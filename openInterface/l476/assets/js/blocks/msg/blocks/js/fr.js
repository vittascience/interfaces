/**
 * @fileoverview English messages for L476. (EN)
 */
'use strict';
// Display - L476
Blockly.Msg['DISPLAY_L476_CONTROL_COLOR_LED_TITLE'] = 'contrôler la LED (verte) état %1';
Blockly.Msg['DISPLAY_L476_CONTROL_COLOR_LED_TOOLTIP'] = 'Contrôler l\'état de la LED de couleur verte de la carte L476.';
Blockly.Msg['DISPLAY_L476_TOGGLE_LED_STATE_TITLE'] = 'inverser l\'état de la LED (verte)';
Blockly.Msg['DISPLAY_L476_TOGGLE_LED_STATE_TOOLTIP'] = 'Inverser l\'état des LED de couleur de la carte L476.';
Blockly.Msg['LED_GREEN'] = 'LED2 (verte)';
// Display - LCD
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD] afficher le texte %1 sur la ligne %2 position %3';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Affiche du texte sur l\'une des deux lignes de l\'écran LCD1602 grove. Brancher le module sur un port I2C';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD] nettoyer l\'écran';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Permet d\'effacer tous les caractères de l\'écran LCD. Brancher le module sur un port I2C.';
Blockly.Msg['DISPLAY_LCD_SETRGBCOLOR_TITLE'] = '[LCD RGB] éclairer l’écran LCD de couleur R %1 G %2 B %3';
Blockly.Msg['DISPLAY_LCD_SETRGBCOLOR_TOOLTIP'] = IMG_MODULE_LCD_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant le rétroéclairage du module Grove LCD 16x2. Donner une valeur entre 0 et 255 pour rouge, vert et bleu. Brancher le module sur un port I2C.';
Blockly.Msg['DISPLAY_LCD_SETPALETTERGBCOLOR_TITLE'] = '[LCD RGB] éclairer l’écran LCD de couleur %1';
Blockly.Msg['DISPLAY_LCD_SETPALETTERGBCOLOR_TOOLTIP'] = IMG_MODULE_LCD_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant le rétroéclairage du module Grove LCD 16x2. Choisir la couleur désirée dans la palette. Brancher le module sur un port I2C.';
// Display - OLED
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[OLED] afficher le texte %1 à la position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'écrire du texte sur un écran OLED de taille 128x64. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TITLE'] = '[OLED] contrôler le pixel x %1 y %2 état %3';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de contrôler chaque pixel de l\'écran OLED de taille 128x64. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TITLE'] = '[OLED] dessiner une ligne de (%1, %2) à (%3, %4)';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de dessiner une ligne entre deux points de l\'écran OLED de taille 128x64. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TITLE'] = '[OLED] définir le fond en %1';
Blockly.Msg['DISPLAY_OLED_WHITE'] = 'blanc';
Blockly.Msg['DISPLAY_OLED_BLACK'] = 'noir';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'inverser le rétroélcairage de l\'écran. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[OLED] effacer l\'écran';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'effacer le contenu de l\'écran OLED. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[OLED] afficher l\'icône %1 position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'afficher une icône de la librairie Image de L476, à la position (x,y) sur l\'écran grove OLED. Brancher l\'afficheur sur un port I2C.';
//Display - RGB LED MATRIX
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_TITLE'] = '[Matrice de LED RGB] afficher %1 %2';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_TOOLTIP'] = IMG_MODULE_RGB_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Permet d\'afficher un dessin sur la matrice de LED RGB 8x8.';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_STOPDISPLAY_TITLE'] = '[Matrice de LED RGB] effacer la matrice';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_STOPDISPLAY_TOOLTIP'] = IMG_MODULE_RGB_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Éteint toutes les LEDs de la matrice';
Blockly.Msg['DISPLAY_LED_MATRIX_DURATION'] = 'pendant';
Blockly.Msg['DISPLAY_LED_MATRIX_DURATION_UNIT'] = 'ms';
//Display - LED MATRIX
Blockly.Msg['DISPLAY_LED_MATRIX_TITLE'] = '[Matrice de LED] afficher %1 %2';
Blockly.Msg['DISPLAY_LED_MATRIX_TOOLTIP'] = IMG_MODULE_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Permet d\'afficher un dessin sur la matrice de LED monochrome 8x8.';
Blockly.Msg['DISPLAY_LED_MATRIX_CLEAR_TITLE'] = '[Matrice de LED] effacer la matrice';
Blockly.Msg['DISPLAY_LED_MATRIX_CLEAR_TOOLTIP'] = IMG_MODULE_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Éteint toutes les LEDs de la matrice';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] contrôler la LED %1 sur la broche  %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Permet d\'activer ou désactiver la LED Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] régler la luminosité à %1 (%) sur la broche %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 100% sur les broches PWM.';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[Variable Color LED] régler la luminosité à %1 (%) sur la broche %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 100 % sur les broches PWM. A la premièe utilisation, les valeurs RGB sont fixées à 0. Utiliser un tournevis pour régler les couleurs R, G et B derrière le module.';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[Afficheur 4-digit] afficher %1 %2 sur les broches CLK %3 DIO %4';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher un nombre, une température ou l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales.';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[Afficheur 4-digit] l\'horloge sur les broches CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales. Attention, l\'heure réelle est récupérée seulement la carte microbit reste allumée.';
Blockly.Msg['DISPLAY_4DIGIT_NUMBER'] = 'le nombre entier';
Blockly.Msg['DISPLAY_4DIGIT_TEMPERATURE'] = 'la température';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[Module LED Bar] afficher le niveau de %1 sur les broches DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permet d\'afficher le niveau de la valeur en entrée sur le module LED Bar (MY9221) avec les broches digitales.';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TITLE'] = '[Module LED Bar] inverser l\'afficheur %1 les broches DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permet d\'inverser les 10 LED du module LED Bar (MY9221) avec les broches digitales.';
// Display - Neopixel
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] définir %1 LED sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de définir le nombre de LED du neopixel. Ce bloc doit être utilisé dans le bloc \'Au démarrage\'.';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] contrôler la LED %1 à R %2 G %3 B %4 sur la broche %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED tel que (R,G,B) de 0 à 255 du module neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] contrôler la LED %1 à %2 sur la broche %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du module neopixel. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] contrôler toutes les LED à R %1 G %2 B %3 sur la broche %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie telle que (R,G,B) soit de 0 à 255.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] contrôler toutes les LED à %1 sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] Arc-en-ciel sur la broche %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB. Il est possible de modifier la broche et le nombre de LED du module neopixel.';
// Display - Chainable LED RGB
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TITLE'] = '[Chainable LED] definir %1 LED sur les broches CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Permet de paramétrer la chaîne de LED RGB en définissant le nombre de modules en série sur les broches digitales D0 à D13.';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TITLE'] = '[Chainable LED] contrôler la LED %1 à R %2 G %3 B %4 sur les broches CIN %5 DIN %6';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la DEL RGB, donner une valeur entre 0 et 255 pour Rouge, Vert et Bleu.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TITLE'] = '[Chainable LED] contrôler la LED %1 à %2 sur les broches CIN %3 DIN %4';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la DEL RGB, choisir une couleur dans la palette.';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TITLE'] = '[Chainable LED] contrôler toutes les LED à R %1 G %2 B %3 sur les broches CIN %4 DIN %5';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur des DEL RGB, donner une valeur entre 0 et 255 pour Rouge, Vert et Bleu.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE'] = '[Chainable LED] contrôler toutes les LED à %1 sur les broches CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur des DEL RGB, choisir une couleur dans la palette.';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TITLE'] = '[Chainable LED] éteindre sur les broches CIN %1 DIN %2';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc éteignant toutes les DEL RGB.';
// Input/Output - L476
Blockly.Msg['IO_WAIT_TITLE'] = 'attendre %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Effectue une pause dans l\'exécution du code.';
Blockly.Msg['IO_WAIT_SECOND'] = 'seconde(s)';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milliseconde(ms)';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microseconde(µs)';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'attendre jusqu\'à %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Arrête l\'excution du code jusqu\'à ce que la condition soit satisfaite.';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'démarrer le chronomètre';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Initialise un chronomètre à 0 (en secondes).';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'valeur du chronomètre en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Renvoie la valeur du chronomètre à partir de l\'initialisation (en secondes ou millisecondes).';
Blockly.Msg['IO_L476_GETSWITCHSTATE_TITLE'] = 'lire l\'état du bouton (B1)';
Blockly.Msg['IO_L476_GETSWITCHSTATE_TOOLTIP'] = 'Permet de lire l\'état des boutons intégrés à la carte L476 (SW1, SW2, SW3).';
Blockly.Msg['IO_L476_ONSWITCHBUTTONPRESSED_TITLE'] = 'si le bouton (B1) %1 alors';
Blockly.Msg['IO_L476_ONSWITCHBUTTONPRESSED_TOOLTIP'] = 'Permet d\'exécuter des instructions selon l\'état des boutons intégrés à la carte L476 (SW1, SW2, SW3).';
Blockly.Msg['IO_L476_PRESSED'] = 'appuyé';
Blockly.Msg['IO_L476_RELEASED'] = 'relâché';
// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Clavier numérique] chiffre sur le bus UART %1';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Permet d\'obtenir la touche appuyée du clavier numérique grove sur les broches TX et RX. Quand vous connectez le module, s\'assurer que les broches sont \'croisées\' : RX de la carte avec TX du module et inversement.';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Module joytsick] valeur de l\'axe %1 sur les broches X %2 Y %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'axe X ou Y (de 0 à 1023) du joystick Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TITLE'] = '[Module bouton coloré] état sur la broche SIG2 %1 ';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Renvoie l\'état du bouton coloré grove (0 or 1) sur les broches digitales.';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TITLE'] = '[Module bouton coloré] contrôler la LED à l\'état %1 sur la broche SIG1 %2';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Permet d\'allumer ou éteindre la LED (0 or 1) sur les broches digitales.';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Potentiomètre rotatif] valeur sur la broche %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Renvoie l\'angle (de 0 à 1023) du potentiomètre rotatif Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Potentiomètre linéaire] valeur sur la broche %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Renvoie la position (de 0 à 1023) du potentiomètre linéaire Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Capteur tactile] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur tactile Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Module bouton] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Renvoie la valeur du bouton Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Module interrupteur] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'interrupteur Grove (0 ou 1) sur les broches digitales.';
// Input/Output - Pins
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'HAUT (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAS (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Retourne une valeur booléene (1 si HAUT ou 0 si BAS).';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'état de la broche numérique %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée digitale (0 ou 1).';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'écrire l\'état %1 sur la broche numérique %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Permet d\'écrire une valeur sur une entrée digitale (0 ou 1).';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'lire la broche analogique %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée analogique (0-4096), ce qui correspond à une tensio entre 0 et 3.6V.';
Blockly.Msg['IO_WRITEPWMPIN_TITLE'] = 'écrire la valeur %1 sur la broche PWM %2';
Blockly.Msg['IO_WRITEPWMPIN_TOOLTIP'] = 'Permet d\'appliquer un signal PWM avec une fréquence fixée à 500Hz et en changeant le cycle de 0 à 255. La valeur 128 correspondra à 50% du cycle.';
Blockly.Msg['IO_SETPWM_TITLE'] = 'appliquer un signal carré de fréquence %1 (Hz) sur la broche %2';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Permet d\'appliquer un signal carré (PWM) avec un cycle fixé à 50% sur une broche. Ce bloc permet de changer la fréquence du signal.';
Blockly.Msg['IO_STOPPWM_TITLE'] = 'arrêter le signal PWM de la broche %1';
Blockly.Msg['IO_STOPPWM_TOOLTIP'] = 'Permet d\'arrêter le signal PWM appliqué sur une broche.';
Blockly.Msg['IO_GETVOLTAGE_TITLE'] = 'convertir %1 sur %2 en tension';
Blockly.Msg['IO_GETVOLTAGE_TOOLTIP'] = 'Permet de convertir une valeur analogique en tension avec la résolution (12-bit: 4096 ou 16-bit: 65536) et un maximum de 3.3V.';
Blockly.Msg['IO_GETVOLTAGE_12BIT'] = '12 bits';
Blockly.Msg['IO_GETVOLTAGE_16BIT'] = '16 bits';
// Communication - UART Blocks
Blockly.Msg['COMMUNICATION_UART_INIT_TITLE'] = '[uart] initialiser la connexion série sur bus %1 Baudrate %2';
Blockly.Msg['COMMUNICATION_UART_INIT_TOOLTIP'] = 'Initialiser la connexion série sur le port UART.';
Blockly.Msg['COMMUNICATION_UART_WRITE_TITLE'] = '[uart] écrire la donnée %1 sur le bus %2';
Blockly.Msg['COMMUNICATION_UART_WRITE_TOOLTIP'] = 'Permet d\'écrire des données dans le port UART.';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'écrire dans la console %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Permet d\'écrire des données dans le port série.';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'avec';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'saut(s) de ligne';
Blockly.Msg['COMMUNICATION_SERIAL_INIT_TITLE'] = 'rediriger la connexion série vers RX %2 TX %3 Baudrate %1';
Blockly.Msg['COMMUNICATION_SERIAL_INIT_TOOLTIP'] = 'Permet de rediriger la connexion série de la carte L476. Quand vous connecter le module, être assuré que les broches sont \'croisées\' : RX de la carte avec TX du module et inversement.';
Blockly.Msg['COMMUNICATION_SERIAL_REDIRECTTOUSB_TITLE'] = 'rediriger la connexion série vers USB';
Blockly.Msg['COMMUNICATION_SERIAL_REDIRECTTOUSB_TOOLTIP'] = 'Permet de rediriger la connexion série vers l\'USB (ordinateur). Cela peut être utilisé pour faire fonctionner plusieurs modules UART en même temps.';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE then'] = 'on serial data received in %1 then';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si une donnée est reçue par le port série dans la variable \'serialData\'.';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'jouer la note %1 sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Joue la note selectionnée jusqu\'à l\'exécution du bloc "Fin de la note".';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'jouer la fréquence %1 (Hz) sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Ce bloc permet de jouer une fréquence donnée sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'terminer la note sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Arrête la note en cours.';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'tracer le graphe';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Ce bloc permet d\'écrire des données (numériques) qui seront visibles dans le traceur. Il peut être utilisé avec un ou plusieurs blocs au format "Nom" et "Données". Pour visualiser les graphiques, cliquer sur l\'icone \'Mode Graphique\' dans la console.';
Blockly.Msg['COMMUNICATION_DATA'] = 'Donnée';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nom %1 Valeur %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Ce bloc est à utiliser avec le bloc "Tracer le graphique". Il doit lui-même contenir le nom de la valeur à afficher (texte), et la valeur en question (nombre).';
// Communication - L476
Blockly.Msg['COMMUNICATION_L476_RTC_SETTIME_TITLE'] = '[Horloge RTC] initialiser à %1 date %2  heure %3 minute %4 seconde %5';
Blockly.Msg['COMMUNICATION_L476_RTC_SETTIME_TOOLTIP'] = 'Permet d\'initialiser le module horloge RTC intégré à la carte L476, pour pouvoir lire la date et l\'heure précise avec le bloc \'Lire le module horloge\'. Placer dans le bloc \'Au démarrage\'.';
Blockly.Msg['COMMUNICATION_L476_RTC_READTIME_TITLE'] = '[Horloge RTC] lire %1';
Blockly.Msg['COMMUNICATION_L476_RTC_READTIME_TOOLTIP'] = 'Permet de lire la date et l\'heure du module horloge RTC intégré à la carte L476. Pour avoir un résultat correct, utiliser au préalable les deux blocs \'Initialiser le module horloge\'.';
Blockly.Msg['CLOCK_ALL_DATA'] = 'time';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'jour du mois';
Blockly.Msg['CLOCK_MONTH'] = 'mois';
Blockly.Msg['CLOCK_YEAR'] = 'année';
Blockly.Msg['CLOCK_SECOND'] = 'seconde';
Blockly.Msg['CLOCK_MINUTE'] = 'minute';
Blockly.Msg['CLOCK_HOUR'] = 'heure';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'jour de la semaine';
Blockly.Msg['DAY_MONDAY'] = 'lundi';
Blockly.Msg['DAY_TUESDAY'] = 'mardi';
Blockly.Msg['DAY_WEDNESDAY'] = 'mercredi';
Blockly.Msg['DAY_THURSDAY'] = 'jeudi';
Blockly.Msg['DAY_FRIDAY'] = 'vendredi';
Blockly.Msg['DAY_SATURDAY'] = 'samedi';
Blockly.Msg['DAY_SUNDAY'] = 'dimanche';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] écrire dans la carte SD %1 sur les broches RX %2 TX %3 %4 Données %5';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'Permet d\'écrire des données dans la carte micro SD avec le module Openlog. Fonctionnement en transmission UART.';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] envoyer sur les broches RX %1 TX %2 message %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permet d\'envoyer des données via le module BLuetooth HC05 sur les broches RX/TX.';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] si message reçu sur les broches RX %1 TX %2 dans %3 alors';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par un module Bluetooth HC05 dans la variable \'bluetoothData\' sur les broches RX/TX.';
// Communication - GPS
Blockly.Msg['COMMUNICATION_GPS_INFO_TYPE'] = 'le type de la trame';
Blockly.Msg['COMMUNICATION_GPS_INFO_CLOCK'] = 'l\'heure (h, m, s)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LATITUDE'] = 'la latitude (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LONGITUDE'] = 'la longitude (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_SATELLITE'] = 'le nombre de satellites utilisés';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALTITUDE'] = 'l\'altitude (m)';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TITLE'] = '[GPS] trames NMEA sur le port UART %1';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Renvoie la liste des trames NMEA lues avec le module GPS Grove SIM28 ou Air530 sur le port UART 1 (D2/D14) ou le port UART 2 (D0/D1). Sur le shield Grove, le port UART (RX/TX) par défaut correspond au port UART 2.';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TITLE'] = '[GPS] obtenir %2 sur le port UART %1';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Renvoie la donnée sélectionnée parmi (le type de trame, l\'horloge, la latitude, la longitude, l\'altitude) annalysée de la trame NMEA (GNGGA ou GPGGA) lue avec le module GPS Grove SIM28 ou Air530 sur le port UART 1 (D2/D14) ou le port UART 2 (D0/D1). Sur le shield Grove, le port UART (RX/TX) par défaut correspond au port UART 2.';
// Communication - NFC
Blockly.Msg['COMMUNICATION_M24SR64_NFC_READ_TITLE'] = '[NFC M24SR64] lire donnée depuis le tag';
Blockly.Msg['COMMUNICATION_M24SR64_NFC_READ_TOOLTIP'] = IMG_MODULE_NFC + Blockly.Tooltip.SEP + 'Lire donnée depuis le tag NFC via I2C.';
Blockly.Msg['COMMUNICATION_M24SR64_NFC_ERASE_TITLE'] = '[NFC M24SR64] effacer les données sur le tag';
Blockly.Msg['COMMUNICATION_M24SR64_NFC_ERASE_TOOLTIP'] = IMG_MODULE_NFC + Blockly.Tooltip.SEP + 'Effacer les messages présents sur le tag NFC via I2C.';
Blockly.Msg['COMMUNICATION_M24SR64_WRITE_NFC_TITLE'] = '[NFC M24SR64] écrire %1 sur le tag';
Blockly.Msg['COMMUNICATION_M24SR64_WRITE_NFC_TOOLTIP'] = IMG_MODULE_NFC + Blockly.Tooltip.SEP + 'Ecrire des données sur le tag NFC via I2C (capacité maximale 8000 caractères).';
// Communication - LoRa
Blockly.Msg['COMMUNICATION_LORA_INIT_TITLE'] = '[LoRa] initialiser le module avec l\'appEui %1 avec l\'appKey %2';
Blockly.Msg['COMMUNICATION_LORA_INIT_TOOLTIP'] = IMG_MODULE_LORA + Blockly.Tooltip.SEP + 'Permet d\'initialiser et de récupérer les informations d\'identification du module LoRa connecté sur le port UART';
Blockly.Msg['COMMUNICATION_LORA_INIT'] = 'avec la devAddr';
Blockly.Msg['COMMUNICATION_LORA_SEND_TITLE'] = '[LoRa] envoyer des données ';
Blockly.Msg['COMMUNICATION_LORA_SEND_TOOLTIP'] = IMG_MODULE_LORA + Blockly.Tooltip.SEP + 'Permet d\'envoyer des données provenant de capteurs via le module LoRa.';
Blockly.Msg['COMMUNICATION_LORA_RECEIVE_TITLE'] = '[LoRa] recevoir un message';
Blockly.Msg['COMMUNICATION_LORA_RECEIVE_TOOLTIP'] = IMG_MODULE_LORA + Blockly.Tooltip.SEP + 'Permet de des données via le module LoRa.';
// Sensors - Expansion board
Blockly.Msg['SENSORS_ACCELEROMETER_INTEGRATED_LIS2DW12_TITLE'] = '[Accéléromètre LIS2DW12] accélération selon l\'axe %1';
Blockly.Msg['SENSORS_ACCELEROMETER_INTEGRATED_LIS2DW12_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Renvoit l\'accélération selon les axes X, Y ou Z (en mg).';
Blockly.Msg['X_AXIS'] = 'x';
Blockly.Msg['Y_AXIS'] = 'y';
Blockly.Msg['Z_AXIS'] = 'z';
Blockly.Msg['SENSORS_INCLINOMETER_INTEGRATED_LIS2DW12_TITLE'] = '[Inclinomètre LIS2DW12] inclinaison entre l\'axe %1 et le plan horizontal';
Blockly.Msg['SENSORS_INCLINOMETER_INTEGRATED_LIS2DW12_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Renvoie l\'inclinaison entre les axes X, Y or Z et le plan horizontal.';
Blockly.Msg['SENSORS_ACCELEROMETER_INTEGRATED_LSM6DSO_TITLE'] = '[Accélérometre LSM6DSO] accélération selon l\'axe %1';
Blockly.Msg['SENSORS_ACCELEROMETER_INTEGRATED_LSM6DSO_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Renvoit l\'accélération selon les axes X, Y ou Z (en mg).';
Blockly.Msg['SENSORS_GYROSCOPE_INTEGRATED_LSM6DSO_TITLE'] = '[Gyroscope LSM6DSO] vitesse angulaire selon l\'axe %1';
Blockly.Msg['SENSORS_GYROSCOPE_INTEGRATED_LSM6DSO_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Renvoit la vitesse angulaire selon les axes X, Y ou Z (en rad/s).';
Blockly.Msg['SENSORS_MAGNETOSCOPE_INTEGRATED_LIS2MDL_TITLE'] = '[Magnétomètre LIS2MDL] champ magnétique suivant %1';
Blockly.Msg['SENSORS_MAGNETOSCOPE_INTEGRATED_LIS2MDL_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Renvoit le champ magnétique selon les axes X, Y ou Z (en gauss).';
Blockly.Msg['SENSORS_THERMOMETER_INTEGRATED_STTS751_TITLE'] = '[Thermomètre STTS751] température';
Blockly.Msg['SENSORS_THERMOMETER_INTEGRATED_STTS751_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Renvoie la température (en °C).';
Blockly.Msg['SENSORS_HYGROMETER_INTEGRATED_HTS221_TITLE'] = '[Hygromètre HTS221] humidité relative';
Blockly.Msg['SENSORS_HYGROMETER_INTEGRATED_HTS221_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Renvoie l\'humidité.';
Blockly.Msg['SENSORS_BAROMETER_INTEGRATED_LPS22_TITLE'] = '[Baromètre LPS22] pression atmosphérique';
Blockly.Msg['SENSORS_BAROMETER_INTEGRATED_LPS22_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Renvoie la pression atmosphérique. (260 à 1260 hPa)';
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[Capteur SGP30] gaz %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Renvoie la quantité de CO2 (en ppm) ou de TVOC (en ppb) contenu dans l\'air grâce au capteur SGP30. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'Dioxyde de carbone (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'Composés organiques volatiles (TVOC) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Capteur de gaz multicanal] gaz %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Renvoie la quantité du gaz mesuré dans l\'air (en ppm) grâce au capteur de gaz multicanal. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Capteur de gaz multicanal v2] gaz %1 (V)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Renvoie la quantité du gaz mesuré dans l\'air (en V) grâce au capteur de gaz multicanal V2 grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['GAS_CO'] = 'Monoxyde de carbone (CO)';
Blockly.Msg['GAS_NO2'] = 'Dioxyde d\'azote (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'Ethanol (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'Dihydrogène (H2)';
Blockly.Msg['GAS_NH3'] = 'Ammoniac (NH3)';
Blockly.Msg['GAS_CH4'] = 'Méthane (CH4)';
Blockly.Msg['GAS_C3H8'] = 'Propane (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'Iso-propane (C4H10)';
Blockly.Msg['GAS_VOC'] = 'Composés organiques volatiles (COV)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Capteur de dioxygène] O2 (%) sur la broche %1';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Renvoie la concentration de dioxygène (O2) dans l\'air (en %) grâce au capteur de gas O2 grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove)..';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[Capteur SCD30] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Renvoie la concentration de CO2 dans l\'air (en ppm), l\'humidité (en %) ou la température en Celsius (°C), Fahrenheit (°F) ou Kelvin (K) from the grove SCD30 sensor. Bancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'dioxyde de carbone (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = 'température';
Blockly.Msg['SENSORS_SCD30_HUM'] = 'humidité (%)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[Capteur SCD30] forcer la recalibration à %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Forcer la calibration du capteur SCD30 à la valeur donnée (in ppm). Se placer en extérieur (là où la concentration est autour de 420 ppm environ, soit un air pur), redémarrer la carte, puis attendre 2 minutes. Conseil: Utiliser les boutons SW1, SW2 ou SW3 de la carte L476 NUCLEO pour contrôler le lancement de la calibration. Sinon, en rebranchant la carte, le programme se lance et effectue de nouveau une calibration pas forcément souhaitée.';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Capteur de qualité d\'air] valeur sur la broche %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Renvoie la valeur de la qualité de l\'air (de 0 à 1023) sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[Capteur HM330X] concentration de particules fines %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Détecte la densité de particules dans l\'air avec le capteur HM330X. Bancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
// Sensors - Climate
Blockly.Msg['SENSORS_TEMPERATURE'] = 'température';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humidité (%)';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'en';
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[Capteur BMP280 %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), la pression (en Pascal) ou l\'altitude (en m). L\'altitude est calculée avec la pression et est initialisée à 0 au début du programme. Le bloc a besoin du capteur Grove BMP280 (adresse I2C: 0x77, couleur: bleu) ou le capteur HW-611 280 (adresse I2C: 0x76, couleur: violet). Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_BMP280_TEMP'] = 'température';
Blockly.Msg['SENSORS_BMP280_PRESS'] = 'pression (Pa)';
Blockly.Msg['SENSORS_BMP280_ALT'] = 'l\'altitude (m)';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = '[Capteur H.T°] température en %1 sur les broches A0 %2 A1 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température du thermocouple en degré Celsius (50 à 600 °C), Fahrenheit (°F) ou Kelvin (K) grâce au capteur grove de haute température sur .';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Capteur d\'humidité] humidité du sol sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Renvoie l\'humidité (de 0 à 1023) mesurée grâce au capteur d\'humidité grove sur les broches analogiques IO34, IO35, IO36 et IO39.';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Capteur de T°] température en %1 sur la broche %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) du capteur de température Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['SENSORS_DHT11_READDATA_TITLE'] = '[Capteur DHT11] %1 sur la broche %2';
Blockly.Msg['SENSORS_DHT11_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur DHT11 grove sur les broches digitales.';
Blockly.Msg['SENSORS_DHT22_READDATA_TITLE'] = '[Capteur DHT22] %1 sur la broche %2';
Blockly.Msg['SENSORS_DHT22_READDATA_TOOLTIP'] = IMG_MODULE_DHT22 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) avec une grande précision grâce au capteur DHT22 grove sur les broches digitales.';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[Capteur TH02] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur TH02. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Capteur SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur SHT31. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TITLE'] = '[Capteur DS18X20] température en %1 sur la broche %2';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) du capteur étanche DS18X20.';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Capteur d\'eau] quantité d\'eau sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Renvoie la quantité d\'eau (de 0 à 255) mesurée grâce au capteur d\'eau grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Capteur de pluie] état sur la broche %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Renvoie l\'état du capteur de pluie (1 s\'il pleut ou 0 sinon) sur les broches digitales.';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anémomètre] état sur la broche %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Renvoie l\'état de l\'anémomètre (deux fois état HAUT à chaque rotation) sur les broches digitales.';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Capteur de lumière] luminosité sur la broche %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Renvoie la luminosité (de 0 à 1023) du capteur de lumière Grove sur les broches analogiques IO34, IO35, IO36 et IO39.';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[Capteur SI1145] luminosité %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Renvoie l\'indice de lumière ultraviolette, la luminosité visible (en lumen) ou infrarouge (en lumen) grâce au capteur Grove Sunlight ou le capteur GY1145. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SI1145_UV'] = 'indice UV';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visible (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrarouge (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Capteur ultraviolet] indice UV sur la broche %1';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Renvoie l\'indice de la lumière ultraviolette pour des ondes entre 240 et 380 nm du capteur Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Capteur de son] niveau sonore sur la broche %1';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Renvoie le niveau sonore (0 à 1023) avec le capteur de son Grove sur les broches digitales.';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Capteur de couleurs] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Permet de lire le niveau d\'une des trois couleurs primaires avec le capteur de couleur grove, le niveau est compris entre 0 et 255. Brancher le capteur sur un port I2C.';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TITLE'] = '[Time Of Flight] Distance en %1';
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TOOLTIP'] = IMG_MODULE_VL53L0X + Blockly.Tooltip.SEP + 'Retourne les mesures de distance à partir du capteur Time Of Flight VL53L0X sur le port I2C.';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Capteur à ultrasons %1] %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Renvoie la distance (in cm) mesurée grâce au capteur grove à ultrasons sur les broches digitales. Attention, si le capteur est un modèle grove, TRIG et ECHO sont sur la même broche SIG.';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distance (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'durée de l\'aller-retour (µs)';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = '[Capteur de gestes] type de geste';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Renvoie le type de geste analysé (\'right\', \'left\', \'up\', \'down\', \'forward\', \'backward\', \'clockwise\', \'anticlockwise\') grâce au capteur de gestes grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Capteur de gestes] si le geste %1 est détecté';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Exécute des instructions si le geste selectionné est détecté par le capteur de gestes grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'droit';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'gauche';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'haut';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'bas';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'avant';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'arrière';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'horaire';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'antihoraire';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'onde';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Capteur de ligne noire] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur de ligne noire grove (0 ou 1) les broches digitales.';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[Capteur de mouvement] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur de mouvement Grove PIR Motion (0 ou 1) les broches digitales.';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Capteur de vibrations] état sur la broche %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Renvoie l\'état de la vibration (0 ou 1) grâce au capteur de vibration piezoélectrique les broches digitales.';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Module inclinaison] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'inclinaison du module Grove (0 ou 1) les broches digitales.';
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TITLE'] = '[Time Of Flight] Distance en %1';
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TOOLTIP'] = IMG_MODULE_VL53L0X + Blockly.Tooltip.SEP + 'Retour les mesures de distance à partir du capteur Time Of Flight sur le port I2C.';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TITLE'] = '[Module bouton] %1 sur la broche %2';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Renvoie la valeur numérique du bouton Grove (0/1 ou 0V/3.3V) les broches digitales.';
Blockly.Msg['SENSORS_GETGROVEBUTTON_VOLTAGE'] = 'tension';
Blockly.Msg['SENSORS_GETGROVEBUTTON_STATE'] = 'état';
// Actuators - Motors
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servomoteur] contrôler l\'angle à %1 sur la broche %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler l\'angle d\'un servomoteur (de 0 à 180) sur les broches digitales. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au servomoteur.';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Servomoteur continu] contrôler la vitesse à %1 (%) direction %2 sur la broche %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler la vitesse (de 0 à 100 %) d\'un servomoteur continu sur les broches PWM.';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Moteur] contrôler la puissance à %1 (%) sur la broche %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permet de contrôler la puissance d\'un moteur (de 0 à 100 %) sur une broche PWM. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au moteur.';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Moteur à vibration] contrôler le moteur à l\'état %1 sur la broche  %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver le moteur à vibration grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Module relais] contrôler le relais à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Permet de contrôler la valeur du relais (0 ou 1) sur les broches digitales.';
// Actuators - MOSFET
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TITLE'] = '[MOSFET] contrôler à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permet de contrôler l\'état du transitor MOSFET (0 ou 1) sur une broche PWM.';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TITLE'] = '[MOSFET] contrôler la puissance à %1 (%) sur la broche %2';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permet de contrôler la puissance de sortie du transitor MOSFET (de 0 à 100 %) sur une broche PWM.';
Blockly.Msg['ACTUATORS_MOSFET_SETFREQUENCY_TITLE'] = '[MOSFET] contrôler la fréquence du cycle à %1 (Hz) sur la broche %2';
Blockly.Msg['ACTUATORS_MOSFET_SETFREQUENCY_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permet de contrôler la fréquence cyclique (Hz) du transistor MOSFET sur une broche PWM.';
Blockly.Msg['ACTUATORS_MOSFET_PULL'] = 'pull';
// Actuators - Music
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TITLE'] = '[Buzzer/Speaker] jouer la musique %1 sur %2';
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une musique avec un module Grove buzzer (ou speaker) sur les broches digitales.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TITLE'] = '[Buzzer/Speaker] jouer les notes sur';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer des notes avec un module Grove buzzer (ou speaker) sur les broches digitales.';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TITLE'] = 'note %1 à l\'octave %2 durée %3';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de définir une note à une certaine octave pendant une durée déterminée.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TITLE'] = '[Buzzer/Speaker] jouer la fréquence %1 pendant %2 (ms) sur %3';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une fréquence avec un module Grove buzzer (ou speaker) sur les broches digitales.';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TITLE'] = '[Buzzer/Speaker] arrêter la musique sur %1';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet d\'arrêter la musique en cours du module Grove buzzer (ou speaker) sur les broches digitales.';
// Notes
Blockly.Msg['NOTE_C'] = 'Do';
Blockly.Msg['NOTE_C_SHARP'] = 'Do#';
Blockly.Msg['NOTE_D'] = 'Ré';
Blockly.Msg['NOTE_D_SHARP'] = 'Ré#';
Blockly.Msg['NOTE_E'] = 'Mi';
Blockly.Msg['NOTE_F'] = 'Fa';
Blockly.Msg['NOTE_F_SHARP'] = 'Fa#';
Blockly.Msg['NOTE_G'] = 'Sol';
Blockly.Msg['NOTE_G_SHARP'] = 'Sol#';
Blockly.Msg['NOTE_A'] = 'La';
Blockly.Msg['NOTE_A_SHARP'] = 'La#';
Blockly.Msg['NOTE_B'] = 'Si';
Blockly.Msg['MUSIC_SILENCE'] = 'Silence';
// Robots - Alphabot
Blockly.Msg['ROBOTS_ALPHABOT_RIGHT'] = 'droit';
Blockly.Msg['ROBOTS_ALPHABOT_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_ALPHABOT_ULTRASONICRANGER_TITLE'] = '[Alphabot - Capteur à ultrasons] distance (cm)';
Blockly.Msg['ROBOTS_ALPHABOT_ULTRASONICRANGER_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Renvoie la distance (en cm) entre un object et le robot Alphabot grâce au capteur de distance à ultrasons.';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_CALIBRATE_TITLE'] = '[Alphabot] calibrer le suiveur de ligne';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_CALIBRATE_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet de calibrer le suiveur de ligne du robot Alphabot v2. Fait tourner le robot à gauche et à droite pour calibrer les capteurs de ligne infrarouge.';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_READSENSORS_TITLE'] = '[Alphabot] valeurs des capteurs de ligne noire %1';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_READSENSORS_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet de lire les valeurs des capteurs de suiveur de ligne de l\'ordre de 0-500 (noir) à 500-1000 (blanc) pour une calibration normale du robot Alphabot v2. L\'option \'tous\' du bloc permet de retourner le tableau avec les valeurs des 5 capteurs.';
Blockly.Msg['ROBOTS_ALPHABOT_ALL_SENSORS'] = 'tous';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_GETSENSORABOVELINE_TITLE'] = '[Alphabot] capteur au-dessus de la ligne noire';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_GETSENSORABOVELINE_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet d\'obtenir le nom du capteur qui se trouve le plus proche de la ligne noire. (IR1/IR2/IR3/IR4/IR5 de gauche à droite)';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ISSENSORABOVELINE_TITLE'] = '[Alphabot] capteur %1 au-dessus de la ligne noire';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ISSENSORABOVELINE_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Retourne \'Vrai\' si le capteur choisit est au-dessus de la ligne noire, sinon le bloc retourne \'Faux\'. (IR1/IR2/IR3/IR4/IR5 de gauche à droite)';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_LIMIT_VALUE'] = 'valeur limite';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_TITLE'] = '[Alphabot] si capteur %1';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_SENSOR_THEN'] = 'au-dessus de la ligne';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_ELSEIF'] = 'sinon si capteur';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_THEN'] = Blockly.Msg['CONTROLS_IF_MSG_THEN'];
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si le capteur sélectionné (IR1/IR2/IR3/IR4/IR5 de gauche à droite) du robot Alphabot v2 se trouve au-dessus de la ligne noire.';
Blockly.Msg['ROBOTS_ALPHABOT_READOBSTACLEDETECTOR_TITLE'] = '[Alphabot - IR frontaux] obstacle détecté par IR';
Blockly.Msg['ROBOTS_ALPHABOT_READOBSTACLEDETECTOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet de lire l\'obstacle détecté (capteurs IR sur LEDL & LEDR) avec le robot Alphabot v2. Valeurs: [\'R\', \'L\', \'B\', \'N\']';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_TITLE'] = '[Alphabot - IR frontaux] si obstacle détecté %1';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_BY_IR_THEN'] = 'par IR alors';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_ELSEIF'] = 'sinon si détecté';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_THEN'] = 'alors';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si un obstacle est détecté à l\'avant du robot par les capteurs IR sur LEDL & LEDR du robot Alphabot.';
Blockly.Msg['ROBOTS_ALPHABOT_BY_RIGHT'] = 'à droite (LEDR)';
Blockly.Msg['ROBOTS_ALPHABOT_BY_LEFT'] = 'à gauche (LEDL)';
Blockly.Msg['ROBOTS_ALPHABOT_BOTH_SIDES'] = 'des deux côtés (LEDL & LEDR)';
Blockly.Msg['ROBOTS_ALPHABOT_GO_TITLE'] = '[Alphabot] contrôler le robot %1 vitesse %2 (%)';
Blockly.Msg['ROBOTS_ALPHABOT_GO_FORWARD'] = 'avancer';
Blockly.Msg['ROBOTS_ALPHABOT_GO_REVERSE'] = 'reculer';
Blockly.Msg['ROBOTS_ALPHABOT_GO_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet de contrôler la marche (AVANT/ARRIERE) ainsi que la vitesse (de 0 à 100 %) du robot Alphabot v2.';
Blockly.Msg['ROBOTS_ALPHABOT_TURNTO_TITLE'] = '[Alphabot] pivoter vers la %1 vitesse %2 (%)';
Blockly.Msg['ROBOTS_ALPHABOT_TURNTO_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet de pivoter à droite ou à gauche à une certaine vitesse (de 0 à 100 %) avec le robot Alphabot v2.';
Blockly.Msg['ROBOTS_ALPHABOT_RIGHT_BIS'] = Blockly.Msg['ROBOTS_ALPHABOT_RIGHT'];
Blockly.Msg['ROBOTS_ALPHABOT_CONTROLMOTOR_TITLE'] = '[Alphabot] contrôler le moteur %1 direction %2 vitesse %3 (%)';
Blockly.Msg['ROBOTS_ALPHABOT_CONTROLMOTOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit et gauche en changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 100 %) du robot Alphabot v2.';
Blockly.Msg['ROBOTS_ALPHABOT_STOPMOTORS_TITLE'] = '[Alphabot] arrêter le moteur %1';
Blockly.Msg['ROBOTS_ALPHABOT_STOPMOTORS_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet d\'arrêter le moteur droit ou gauche du robot Alphabot v2.';
Blockly.Msg['ROBOTS_ALPHABOT_RIGHT&LEFT'] = 'droit & gauche';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_TITLE'] = '[Alphabot] si la commande %1';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_RECEIVED_THEN'] = 'est reçue alors';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_DETECTED_THEN'] = 'est reçue par télécommande noire NEC alors';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_TOOLTIP'] = IMG_MODULE_BASIC_BLACK_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une des commandes est reçue d\'une télécommande NEC noire basique par transmission infrarouge.';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_CAR_MP3_GRAY_DETECTED_THEN'] = 'est reçue par télécommande grise Car mp3 NEC alors';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_CAR_MP3_GRAY_TOOLTIP'] = IMG_MODULE_CAR_MP3_GRAY_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une des commandes est reçue d\'une télécommande NEC grise de type C_ar mp3 par transmission infrarouge.';
Blockly.Msg['REMOTE_NEC_BUTTON'] = 'touche ';
Blockly.Msg['REMOTE_NEC_BUTTON_UP'] = 'haut';
Blockly.Msg['REMOTE_NEC_BUTTON_DOWN'] = 'bas';
Blockly.Msg['REMOTE_NEC_BUTTON_LEFT'] = 'gauche';
Blockly.Msg['REMOTE_NEC_BUTTON_RIGHT'] = 'droit';
Blockly.Msg['REMOTE_NEC_BUTTON_BACK'] = 'Retour';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_ADDTEXT_TITLE'] = '[Alphabot] afficher le texte %1 à la position x %2 y %3 sur l\'écran';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet d\'écrire du texte sur un écran OLED de taille 128x64.';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_SETBACKGROUND_TITLE'] = '[Alphabot] définir le fond de l\'écran en %1';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_SETBACKGROUND_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet d\'inverser le rétroélcairage de l\'écran.';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_YELLOW_BLUE'] = 'jaune & bleu';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_BLACK'] = 'noir';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_CLEARSCREEN_TITLE'] = '[Alphabot] effacer l\'écran';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet d\'effacer le contenu de l\'écran OLED.';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETCOLOR_TITLE'] = '[Alphabot] contrôler la LED %1 à R %2 G %3 B %4';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETCOLOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du neopixel du robot Alphabot (pin15) tel que les valeurs R,G,B soient comprises entre 0 et 255. Le neopixel est connecté à la broche P15 sur le robot.';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Alphabot] contrôler la LED %1 à %2';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du module neopixel. Utiliser la palette pour changer la couleur.';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETRAINBOW_TITLE'] = '[Alphabot] Arc-en-ciel';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETRAINBOW_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB (pin15).';
Blockly.Msg['ROBOTS_ALPHABOT_BUZZER_CONTROLSTATE_TITLE'] = '[Alphabot] contrôler le buzzer à l\'état %1';
Blockly.Msg['ROBOTS_ALPHABOT_BUZZER_CONTROLSTATE_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet de contrôler l\'état du buzzer du robot Alphabot. (0 ou 1)';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_TITLE'] = '[Alphabot] si le bouton %1';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_DETECTED_THEN'] = 'du joystick est appuyé alors';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_ELSEIF'] = 'sinon si bouton';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_RECEIVED_THEN'] = 'appuyé alors';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permet d\'exécuter des insructions si une commande est reçue du joystick du robot Alphabot.';
Blockly.Msg['JOYSTICK_BUTTON_UP'] = 'haut';
Blockly.Msg['JOYSTICK_BUTTON_DOWN'] = 'bas';
Blockly.Msg['JOYSTICK_BUTTON_LEFT'] = 'gauche';
Blockly.Msg['JOYSTICK_BUTTON_RIGHT'] = 'droit';
Blockly.Msg['JOYSTICK_BUTTON_CENTER'] = 'central';
//Robots - Donutbot
Blockly.Msg['ROBOTS_DONUTBOT_TURN_RIGHT'] = 'droite';
Blockly.Msg['ROBOTS_DONUTBOT_RIGHT'] = 'droit';
Blockly.Msg['ROBOTS_DONUTBOT_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_DONUTBOT_ULTRASONICRANGER_TITLE'] = '[Donutbot - Capteur à ultrasons] distance (cm)';
Blockly.Msg['ROBOTS_DONUTBOT_ULTRASONICRANGER_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Renvoie la distance (en cm) entre un object et le robot Donutbot grâce au capteur de distance à ultrasons.';
Blockly.Msg['ROBOTS_DONUTBOT_LINE_DETECTOR_TITLE'] = '[Donutbot] état du capteur de ligne %1';
Blockly.Msg['ROBOTS_DONUTBOT_LINE_DETECTOR_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Renvoie l\'état du capteur de ligne (droit/gauche/central) du robot Donutbot.';
Blockly.Msg['ROBOTS_DONUTBOT_LINE_DETECTOR_THRESHOLD_TITLE'] = '[Donutbot] seuil du capteur de ligne %1';
Blockly.Msg['ROBOTS_DONUTBOT_LINE_DETECTOR_THRESHOLD_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Permet de définir le seuil du capteur de ligne (droit/gauche/central) du robot Donutbot.';
Blockly.Msg['ROBOTS_DONUTBOT_LINE_DETECTOR_FUNCTION_TITLE'] = '[Donutbot] suivre la ligne';
Blockly.Msg['ROBOTS_DONUTBOT_LINE_DETECTOR_FUNCTION_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Permet au robot Donutbot de suivre une ligne noire.';
Blockly.Msg['ROBOTS_DONUTBOT_COLOR_DETECTOR_TITLE'] = '[Donutbot] état du capteur de couleur %1';
Blockly.Msg['ROBOTS_DONUTBOT_COLOR_DETECTOR_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Renvoie l\'état (couleur au format (r,g,b)) du capteur de ligne (droit/gauche/central) du robot Donutbot.';
Blockly.Msg['ROBOTS_DONUTBOT_DETECTOR_RIGHT'] = 'droit';
Blockly.Msg['ROBOTS_DONUTBOT_DETECTOR_MIDDLE'] = 'central';
Blockly.Msg['ROBOTS_DONUTBOT_DETECTOR_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_DONUTBOT_COLOR_DETECTOR_AVERAGE_TITLE'] = '[Donutbot] couleur moyenne des capteurs de couleur';
Blockly.Msg['ROBOTS_DONUTBOT_COLOR_DETECTOR_AVERAGE_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Renvoie la couleur moyenne (r,g,b) des capteurs de couleur du robot Donutbot.';
Blockly.Msg['ROBOTS_DONUTBOT_COLOR_DETECTOR_NAME_TITLE'] = '[Donutbot] nom de la couleur sous le capteur %1';
Blockly.Msg['ROBOTS_DONUTBOT_COLOR_DETECTOR_NAME_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Renvoie le nom de couleur ("white", "orange", "purple", "pink", "brown", "yellow", "green", "blue", "red") détectée par le robot Donutbot.';
Blockly.Msg['ROBOTS_DONUTBOT_DISTANCE_TITLE'] = '[Donutbot - ToF] distance (cm)';
Blockly.Msg['ROBOTS_DONUTBOT_DISTANCE_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Retourne les mesures de distance à partir du capteur Time Of Flight VL53L0X sur le port I2C.';
Blockly.Msg['ROBOTS_DONUTBOT_GO_TITLE'] = '[Donutbot] contrôler le robot %1 vitesse %2 (%)';
Blockly.Msg['ROBOTS_DONUTBOT_GO_FORWARD'] = 'avancer';
Blockly.Msg['ROBOTS_DONUTBOT_GO_REVERSE'] = 'reculer';
Blockly.Msg['ROBOTS_DONUTBOT_GO_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la marche (AVANT/ARRIERE) ainsi que la vitesse (de 0 à 100 %) du robot Donutbot.';
Blockly.Msg['ROBOTS_DONUTBOT_TURNTO_TITLE'] = '[Donutbot] pivoter vers la %1 vitesse %2 (%)';
Blockly.Msg['ROBOTS_DONUTBOT_TURNTO_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Permet de pivoter à droite ou à gauche à une certaine vitesse (de 0 à 100 %) avec le robot Donutbot.';
Blockly.Msg['ROBOTS_DONUTBOT_CONTROLMOTOR_TITLE'] = '[Donutbot] contrôler le moteur %1 direction %2 vitesse %3 (%)';
Blockly.Msg['ROBOTS_DONUTBOT_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit et gauche en changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 100 %) du robot Donutbot.';
Blockly.Msg['ROBOTS_DONUTBOT_MOVE_ONE_SQUARE_FORWARD_TITLE'] = '[Donutbot] avancer d\'une case';
Blockly.Msg['ROBOTS_DONUTBOT_MOVE_ONE_SQUARE_FORWARD_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Avance le robot Donutbot d\'une case.';
Blockly.Msg['ROBOTS_DONUTBOT_MOVE_ONE_SQUARE_BACKWARD_TITLE'] = '[Donutbot] reculer d\'une case';
Blockly.Msg['ROBOTS_DONUTBOT_MOVE_ONE_SQUARE_BACKWARD_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Recule le robot Donutbot d\'une case.';
Blockly.Msg['ROBOTS_DONUTBOT_TURN_LEFT_TITLE'] = '[Donutbot] pivoter à gauche';
Blockly.Msg['ROBOTS_DONUTBOT_TURN_LEFT_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Pivote le robot Donutbot de 90° vers la gauche.';
Blockly.Msg['ROBOTS_DONUTBOT_TURN_RIGHT_TITLE'] = '[Donutbot] pivoter à droite';
Blockly.Msg['ROBOTS_DONUTBOT_TURN_RIGHT_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Pivote le robot Donutbot de 90° vers la droite.';
Blockly.Msg['ROBOTS_DONUTBOT_STOPMOTORS_TITLE'] = '[Donutbot] arrêter le moteur %1';
Blockly.Msg['ROBOTS_DONUTBOT_STOPMOTORS_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Permet d\'arrêter le moteur droit ou gauche du robot Donutbot.';
Blockly.Msg['ROBOTS_DONUTBOT_RELEASEMOTORS_TITLE'] = '[Donutbot] relâcher le moteur %1';
Blockly.Msg['ROBOTS_DONUTBOT_RELEASEMOTORS_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Permet d\'arrêter le moteur droit ou gauche du robot Donutbot et de le libérer de tout asservissement. Une fois désactivé, le moteur devient totalement libre et peut se mouvoir sans contrainte.';
Blockly.Msg['ROBOTS_DONUTBOT_RIGHT&LEFT'] = 'droit & gauche';
Blockly.Msg['ROBOTS_DONUTBOT_NEOPIXEL_SETCOLOR_TITLE'] = '[Donutbot] contrôler la LED %1 à R %2 G %3 B %4';
Blockly.Msg['ROBOTS_DONUTBOT_NEOPIXEL_SETCOLOR_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du neopixel du robot Donutbot (pin15) tel que les valeurs R,G,B soient comprises entre 0 et 255. Le neopixel est connecté à la broche P15 sur le robot.';
Blockly.Msg['ROBOTS_DONUTBOT_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Donutbot] contrôler la LED %1 à %2';
Blockly.Msg['ROBOTS_DONUTBOT_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du module neopixel. Utiliser la palette pour changer la couleur.';
Blockly.Msg['ROBOTS_DONUTBOT_BLINK_ROBOT_TITLE'] = '[Donutbot] clignoter le robot en %1';
Blockly.Msg['ROBOTS_DONUTBOT_BLINK_ROBOT_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Fait clignoter le robot Donutbot.';
Blockly.Msg['ROBOTS_DONUTBOT_NEOPIXEL_SETRAINBOW_TITLE'] = '[Donutbot] Arc-en-ciel';
Blockly.Msg['ROBOTS_DONUTBOT_NEOPIXEL_SETRAINBOW_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB (pin15).';
Blockly.Msg['ROBOTS_DONUTBOT_BUTTONS_ONPRESSED_TITLE'] = '[Donutbot] le bouton %1 est %2';
Blockly.Msg['ROBOTS_DONUTBOT_BUTTONS_ONPRESSED_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si un bouton du robot Donutbot est appuyé.';
Blockly.Msg['ROBOTS_DONUTBOT_BUTTONS_PRESSED'] = 'appuyé';
Blockly.Msg['ROBOTS_DONUTBOT_BUTTONS_RELEASED'] = 'relâché';
Blockly.Msg['ROBOTS_DONUTBOT_BUTTON_FRONT'] = 'haut';
Blockly.Msg['ROBOTS_DONUTBOT_BUTTON_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_DONUTBOT_BUTTON_RIGHT'] = 'droit';
Blockly.Msg['ROBOTS_DONUTBOT_BUTTON_BACK'] = 'bas';
Blockly.Msg['ROBOTS_DONUTBOT_BUTTON_CENTER'] = 'central';
Blockly.Msg['ROBOTS_DONUTBOT_BLE_SEND_DATA_TITLE'] = '[Donutbot] envoyer des données %1 ';
Blockly.Msg['ROBOTS_DONUTBOT_BLE_SEND_DATA_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Envoyer des données via Bluetooth (BLE).';
Blockly.Msg['ROBOTS_DONUTBOT_BLE_READ_DATA_TITLE'] = '[Donutbot] si message reçu dans %1 alors';
Blockly.Msg['ROBOTS_DONUTBOT_BLE_READ_DATA_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par Bluetooth (BLE).';
Blockly.Msg['ROBOTS_DONUTBOT_TURNTO_ANGLE_TITLE'] = '[Donutbot] pivoter vers la %1 de %2 ° vitesse %3 (%)';
Blockly.Msg['ROBOTS_DONUTBOT_TURNTO_ANGLE_TOOLTIP'] = IMG_ROBOT_DONUTBOT + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit et gauche en changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 100 %) du robot Donutbot pour le faire pivoter d\'un certain angle.';
// Camera - Wio lite AI
Blockly.Msg['WIO_MAKE_PREDICTION_TITLE'] = '[Wio lite] lancer une prédiction';
Blockly.Msg['WIO_MAKE_PREDICTION_TOOLTIP'] = IMG_WIO_LITE_AI + Blockly.Tooltip.SEP + 'Lance une prédiction en utilisant l\'image de la caméra de la Wio lite.';
Blockly.Msg['WIO_GET_DATA_TITLE'] = '[Wio lite] récupérer toutes les données';
Blockly.Msg['WIO_GET_DATA_TOOLTIP'] = IMG_WIO_LITE_AI + Blockly.Tooltip.SEP +  'Retourne l\'ensemble des données de la Wio lite (probabiltés associées aux classes du modèle).';
Blockly.Msg['WIO_GET_CLASS_DATA_BY_ID_TITLE'] = '[Wio lite] probabilité de la classe n°%1';
Blockly.Msg['WIO_GET_CLASS_DATA_BY_ID_TOOLTIP'] = IMG_WIO_LITE_AI + Blockly.Tooltip.SEP + 'Retourne la probabilité associée à la classe dont l\'id est indiqué.';
Blockly.Msg['WIO_GET_CLASS_MAX_ID_TITLE'] = '[Wio lite] id de la classe détectée';
Blockly.Msg['WIO_GET_CLASS_MAX_ID_TOOLTIP'] = IMG_WIO_LITE_AI + Blockly.Tooltip.SEP + 'Retourne l\'id de la classe détectée (celle avec la plus haute probabilité).';
Blockly.Msg['WIO_GET_STATUS_TITLE'] = '[Wio lite] obtenir %1';
Blockly.Msg['WIO_GET_STATUS'] = 'le statut';
Blockly.Msg['WIO_GET_VERSION'] = 'la version';
Blockly.Msg['WIO_GET_STATUS_TOOLTIP'] = IMG_WIO_LITE_AI + Blockly.Tooltip.SEP + 'Retourne la version ou le statut de la Wio lite (0: occupé, 1: prêt, 2: résultat disponible).';