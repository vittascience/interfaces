/**
 * @fileoverview English messages for L476. (EN)
 */
'use strict';
// Display - L476
Blockly.Msg['DISPLAY_L476_CONTROL_COLOR_LED_TITLE'] = 'controla %1 LED al estado %2';
Blockly.Msg['DISPLAY_L476_CONTROL_COLOR_LED_TOOLTIP'] = 'Controla el LED de color de la placa L476';
Blockly.Msg['DISPLAY_L476_TOGGLE_LED_STATE_TITLE'] = 'conmutar el estado de %1';
Blockly.Msg['DISPLAY_L476_TOGGLE_LED_STATE_TOOLTIP'] = 'Conmutar el estado del LED de color de la placa L476';
Blockly.Msg['LED_GREEN'] = 'LED2 (verde)';
// Display - LCD
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD] mostrar texto %1 en la línea %2 posición %3';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Mostrar texto en la pantalla lcd 1602 de Grove. Conecte el lcd en el puerto I2C';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD] limpiar pantalla';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Habilitar para borrar todo el texto del lcd. Conecte el lcd en el puerto I2C';
Blockly.Msg['DISPLAY_LCD_SETRGBCOLOR_TITLE'] = '[LCD RGB] iluminar la pantalla LCD en R %1 G %2 B %3';
Blockly.Msg['DISPLAY_LCD_SETRGBCOLOR_TOOLTIP'] = IMG_MODULE_LCD_RGB + Blockly.Tooltip.SEP + 'Bloque que controla la luz de fondo del módulo Grove LCD 16x2 caracteres. Dar un valor entre 0 y 255 para iluminar la pantalla en rojo, verde y azul. Conecte el LCD en un puerto I2C';
Blockly.Msg['DISPLAY_LCD_SETPALETTERGBCOLOR_TITLE'] = '[LCD RGB] iluminar la pantalla LCD en %1';
Blockly.Msg['DISPLAY_LCD_SETPALETTERGBCOLOR_TOOLTIP'] = IMG_MODULE_LCD_RGB + Blockly.Tooltip.SEP + 'Bloque que controla la luz de fondo del módulo Grove LCD 16x2 caracteres. Elección del color en la paleta para iluminar la pantalla. Conecte el LCD en un puerto I2C';
// Display - OLED
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[OLED] mostrar texto %1 en la posición x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Activar la escritura de texto en la pantalla OLED (128x64 px). Conecte la pantalla OLED en el puerto I2C';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TITLE'] = '[OLED] controla el píxel x %1 y %2 al estado %3';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Habilitar para controlar cada píxel de la pantalla OLED (128x64 px). Conecte la pantalla OLED en el puerto I2C';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TITLE'] = '[OLED] dibuja una línea desde (%1, %2) hasta (%3, %4)';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permite dibujar una línea entre dos puntos en la pantalla OLED de Grove (128x64 px). Conecte la pantalla OLED en el puerto I2C';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TITLE'] = '[OLED] establecer fondo a %1';
Blockly.Msg['DISPLAY_OLED_WHITE'] = 'blanco';
Blockly.Msg['DISPLAY_OLED_BLACK'] = 'negro';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Habilitar para invertir la pantalla OLED de Grove. Conecte la pantalla OLED en el puerto I2C';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[OLED] limpiar pantalla';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Habilitar para borrar toda la pantalla OLED de Grove. Conecte la pantalla OLED en el puerto I2C';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[OLED] mostrar icono %1 en x %2 y %3 ';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Habilitar el icono Micro:bit de la biblioteca de imágenes. Conectar la pantalla OLED en el puerto I2C';
//Display - RGB LED MATRIX
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_TITLE'] = '[Matriz LED RGB] display %1 %2';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_TOOLTIP'] = IMG_MODULE_RGB_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Permite mostrar un dibujo en la matriz LED RGB de 8x8';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_STOPDISPLAY_TITLE'] = '[Matriz de LEDs RGB] borra la matriz';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_STOPDISPLAY_TOOLTIP'] = IMG_MODULE_RGB_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Apaga todos los LEDs de la matriz';
Blockly.Msg['DISPLAY_LED_MATRIX_DURATION'] = 'durante';
Blockly.Msg['DISPLAY_LED_MATRIX_DURATION_UNIT'] = 'ms';
//Display - LED MATRIX
Blockly.Msg['DISPLAY_LED_MATRIX_TITLE'] = '[Matriz LED] display %1 %2';
Blockly.Msg['DISPLAY_LED_MATRIX_TOOLTIP'] = IMG_MODULE_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Permite mostrar un dibujo en la matriz LED monocromática de 8x8';
Blockly.Msg['DISPLAY_LED_MATRIX_CLEAR_TITLE'] = '[Matriz LED] borrar la matriz';
Blockly.Msg['DISPLAY_LED_MATRIX_CLEAR_TOOLTIP'] = IMG_MODULE_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Apaga todos los LEDs de la matriz';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] controla el LED al estado %1 en el pin %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Habilitar para encender o apagar el kit de LED Grove (0 o 1) en los pines digitales';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] establece la intensidad del LED a %1 (%) en el pin %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Habilitar para establecer la intensidad del LED de 0 a 100% en los pines PWM';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[LED de color variable] establece la intensidad a %1 (%) en el pin %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Habilitar para establecer la intensidad del LED de 0 a 100 (%) en los pines PWM. Cuando se utiliza el módulo por primera vez, RGB se establecen en 0. Utilice un destornillador en R, G o B detrás del módulo para controlar el color del LED.';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[Módulo de 4 dígitos] muestra %1 %2 en los pines CLK %3 DIO %4';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Habilitar para mostrar los números o la temperatura en la pantalla de 4 dígitos del módulo (TM1637) en los pines digitales';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[Módulo de 4 dígitos] mostrar reloj en los pines CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Habilitar para mostrar el reloj en la pantalla de 4 dígitos de Grove (TM1637) en los pines digitales. Atención, obtener el reloj real sólo es posible si el L476 permanece en modo de encendido';
Blockly.Msg['DISPLAY_4DIGIT_NUMBER'] = 'número';
Blockly.Msg['DISPLAY_4DIGIT_TEMPERATURE'] = 'temperatura';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[Módulo de barra de LEDs] establece el nivel de %1 en los pines DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Habilitar para mostrar el nivel del valor de entrada en la pantalla de la barra de LEDs de la arboleda (MY9221) en los pines digitales';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TITLE'] = '[Módulo de barra de LEDs] invierte la pantalla %1 DI pins %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permite invertir los 10 LEDs del módulo MY9221 con los pines digitales.';
// Display - Neopixel
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] define %1 LED en el pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite definir el número de LED del neopixel. Este bloque debe utilizarse en la configuración';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] establece el LED %1 en R %2 G %3 B %4 en el pin %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar cada color de LED de los neopíxeles como (R,G,B) de 0 a 255. Utilice P15 para configurar el neopixel Alphabot';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] establece el LED %1 a %2 en el pin %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Habilitar para controlar cada color del LED del neopixel. Utilizar P15 para ajustar el neopixel Alphabot';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] establece todos los LED al color R %1 G %2 B %3 en el pin %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar todos los LED del neopixel al valor de color elegido como (R,G,B) de 0 a 255. Utilice P15 para configurar el neopixel Alphabot';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] establece todos los LED al color %1 en el pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Habilitar para controlar todos los LED del neopixel al valor de color elegido. Utilice P15 para ajustar el neopixel Alphabot';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] establece un arco iris en el pin %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Habilitar para mostrar un arco iris en el módulo neopixel, establecer el pin y el número de LED';
// Display - Chainable LED RGB
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TITLE'] = '[LED Encadenable] definir %1 LED en pines CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Habilitar para definir el LED RGB encadenable con el número de LED en los pines digitales D0 hasta D13';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TITLE'] = '[LED encadenable] establece el LED %1 en R %2 G %3 B %4 en los pines CIN %5 DIN %6';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color del LED RGB, da un valor entre 0 y 255 para el rojo, el verde y el azul';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TITLE'] = '[Chainable LED] contrôler la LED %1 à %2 sur les broches CIN %3 DIN %4';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color del LED RGB, elige un color de la paleta';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TITLE'] = '[Chainable LED] controlar todos los LEDs a R %1 G %2 B %3 en los folletos CIN %4 DIN %5';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color de los LEDs RGB, da un valor entre 0 y 255 para el rojo, el verde y el azul';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE'] = '[Chainable LED] controlar todos los LED de %1 en las brochas CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color de los LEDs RGB, elige un color de la paleta';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TITLE'] = '[Chainable LED] éteindre sur les broches CIN %1 DIN %2';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Apagar todos los LEDs RGB';
// Input/Output - L476
Blockly.Msg['IO_WAIT_TITLE'] = 'espera %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Detener la ejecución del código (duración en segundos o milisegundos)';
Blockly.Msg['IO_WAIT_SECOND'] = 'segundo(s)';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milisegundo(ms)';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microsegundo(µs)';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'espera hasta %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Detener la ejecución del código hasta que se cumpla la condición';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'inicializar el cronómetro';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Permite inicializar el cronómetro (en segundos)';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'Obtener cronómetro en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Devuelve el valor del cronómetro desde la inicialización en segundos o milisegundos';
Blockly.Msg['IO_L476_GETSWITCHSTATE_TITLE'] = 'Lee el estado del interruptor %1';
Blockly.Msg['IO_L476_GETSWITCHSTATE_TOOLTIP'] = 'Habilita la lectura del valor digital del interruptor integrado de la placa L476 (SW1, SW2, SW3)';
Blockly.Msg['IO_L476_ONSWITCHBUTTONPRESSED_TITLE'] = 'en el botón del interruptor %1 %2 entonces';
Blockly.Msg['IO_L476_ONSWITCHBUTTONPRESSED_TOOLTIP'] = 'Ejecuta las instrucciones leyendo el valor digital del interruptor integrado de la placa L476 (SW1, SW2, SW3)';
Blockly.Msg['IO_L476_PRESSED'] = 'presionado';
Blockly.Msg['IO_L476_RELEASED'] = 'liberado';
// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Teclado numérico táctil] obtener número en el bus UART %1';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Habilitar para obtener el número tocado del módulo de teclado numérico en los pines RX y TX. Cuando conecte el dispositivo, asegúrese de "cruzar" los cables. El pin TX de L476 tiene que estar conectado con el pin RX del dispositivo, y el pin RX con el pin TX del dispositivo';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Joystick Module] joystick axis %1 value on pins A0 %2 A1 %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Devuelve el valor del eje del joystick de Grove (de 0 a 4095) en los pines analógicos p34 a p36, o p39 (como A2 a A4 en shield Grove)..';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TITLE'] = '[Módulo de botones de colores] estado en el pin SIG2 %1';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el estado del botón de color Grove (0 o 1) en los pines digitales';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TITLE'] = '[Módulo de botones de color] controla el LED al estado %1 en el pin SIG1 %2';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Habilitar para encender o apagar el LED Button Grove (0 o 1) en los pines digitales';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Rotary Angle Module] angle on pin %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Devuelve la posición del ángulo rotativo del Grove (de 0 a 4095) en los pines analógicos p34 a p36, o p39 (como A2 a A4 en el Grove del escudo)';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Potenciómetro de deslizamiento] valor de posición en el pin %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Devuelve el valor de la posición del potenciómetro de deslizamiento de la ranura (de 0 a 4095) en los pines analógicos p34 a p36, o p39 (como A2 a A4 en el escudo Grove)..';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Sensor táctil] estado táctil en el pin %1 ';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Devuelve el estado del sensor táctil de Grove (0 o 1) en los pines digitales';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Módulo de botones] estado del botón en el pin %1 ';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el estado del botón Grove (0 o 1) en los pines digitales';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Módulo de conmutación] estado de conmutación en el pin %1 ';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Devuelve el estado del interruptor de la ranura (0 o 1) en los pines digitales';
// Input/Output - Pins
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'ALTO (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAJO (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Devuelve un valor booleano (1 si es HIGH o 0 si es LOW)';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'leer pin digital %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Habilitar para leer el valor digital de los pines (0 o 1)';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'Escribe el estado %1 en el pin digital %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Habilitar para escribir el valor (0 o 1) en el pin digital';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'leer pin analógico %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Habilita la lectura del valor analógico de los pines (0-4095) entre 0 y 3,6V';
Blockly.Msg['IO_WRITEPWMPIN_TITLE'] = 'escribe el valor %1 en el pin PWM %2';
Blockly.Msg['IO_WRITEPWMPIN_TOOLTIP'] = 'Permite aplicar la señal PWM con una frecuencia fija de 500Hz. Puede cambiar el valor de 0 a 255. 128 será el 50% del ciclo de trabajo';
Blockly.Msg['IO_SETPWM_TITLE'] = 'Aplicar una señal cuadrada de frecuencia %1 (Hz) en el pin %2';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Habilitar para aplicar una señal cuadrada PWM con un 50% de ciclo de trabajo. Se puede cambiar la frecuencia de la señal';
Blockly.Msg['IO_STOPPWM_TITLE'] = 'Detener la señal PWM del pin %1';
Blockly.Msg['IO_STOPPWM_TOOLTIP'] = 'Habilitar para detener la señal PWM aplicada de un pin';
Blockly.Msg['IO_GETVOLTAGE_TITLE'] = 'Convertir %1 en tensión con resolución %2';
Blockly.Msg['IO_GETVOLTAGE_TOOLTIP'] = 'Permite convertir el valor analógico en tensión con resoluciones (12 bits: 4096 o 16 bits: 65536) y un máximo de 3,3V';
Blockly.Msg['IO_GETVOLTAGE_12BIT'] = '12 bits';
Blockly.Msg['IO_GETVOLTAGE_16BIT'] = '16-bit';
// Communication - UART Blocks
Blockly.Msg['COMMUNICATION_UART_INIT_TITLE'] = '[uart] initialize serial connectin on bus %1 Baudrate %2';
Blockly.Msg['COMMUNICATION_UART_INIT_TOOLTIP'] = 'Inicializar conexión serie en el puerto UART';
Blockly.Msg['COMMUNICATION_UART_WRITE_TITLE'] = '[uart] escribir datos %1 en el bus %2';
Blockly.Msg['COMMUNICATION_UART_WRITE_TOOLTIP'] = 'Enviar datos en el puerto UART';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'escribir en el puerto serie %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Escribe una cadena en el puerto serie';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'con';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'newline(s)';
Blockly.Msg['COMMUNICATION_SERIAL_INIT_TITLE'] = 'redirigir serie a RX %2 TX %3 Baudrate %1';
Blockly.Msg['COMMUNICATION_SERIAL_INIT_TOOLTIP'] = 'Habilitar para redirigir la conexión serie con RX y TX. Cuando conecte el dispositivo, asegúrese de "cruzar" los cables. El pin TX de L476 necesita ser conectado con el pin RX del dispositivo, y el pin RX con el pin TX del dispositivo';
Blockly.Msg['COMMUNICATION_SERIAL_REDIRECTTOUSB_TITLE'] = 'redirigir el puerto serie al puerto USB';
Blockly.Msg['COMMUNICATION_SERIAL_REDIRECTTOUSB_TOOLTIP'] = 'Habilitar para redirigir la conexión serie a USB. Se utiliza si se conectan algunos dispositivos UART al mismo tiempo';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE then'] = 'sobre los datos serie recibidos en %1 entonces';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones si se reciben datos por el puerto serie en la variable \'serialData\'';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'Reproduce música %1 en el puerto serie';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Reproducir la nota seleccionada hasta la ejecución del bloque "Detener la música" ';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'Reproducir la frecuencia %1 (Hz) en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Este bloque permite reproducir una frecuencia determinada en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'Detener la música del puerto serie';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Detener la nota actual del puerto serie';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'escribir gráfico';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Este bloque permite escribir datos (digitales) que serán visibles en el trazador. Se puede utilizar con uno o más bloques en formato  "Nombre" y  "Datos". Haga clic en el icono \'Modo gráfico\' para mostrar los gráficos';
Blockly.Msg['COMMUNICATION_DATA'] = 'Datos';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nombre %1 Datos %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Este bloque se utilizará en el bloque "Escribir gráfico". Debe contener el nombre del valor (de texto) a mostrar y el valor en cuestión';
// Communication - L476
Blockly.Msg['COMMUNICATION_L476_RTC_SETTIME_TITLE'] = '[Reloj RTC] inicializar en %1 fecha %2 hora %3 minuto %4 segundo %5';
Blockly.Msg['COMMUNICATION_L476_RTC_SETTIME_TOOLTIP'] = 'Permite inicializar la fecha con el módulo de reloj RTC integrado del L476 para poder leer la fecha y la hora exactas mediante el bloque \'Leer módulo de reloj\'. Colocar en el bloque \'on start\'';
Blockly.Msg['COMMUNICATION_L476_RTC_READTIME_TITLE'] = '[Reloj RTC] leído %1';
Blockly.Msg['COMMUNICATION_L476_RTC_READTIME_TOOLTIP'] = 'Lea la fecha y la hora (elija en el menú desplegable) del módulo de reloj RTC integrado. Para obtener un resultado correcto, utilice primero los dos bloques \'Inicializar el módulo de reloj\'';
Blockly.Msg['CLOCK_ALL_DATA'] = 'l\'horloge';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'día del mes';
Blockly.Msg['CLOCK_MONTH'] = 'mes';
Blockly.Msg['CLOCK_YEAR'] = 'año';
Blockly.Msg['CLOCK_SECOND'] = 'segundo';
Blockly.Msg['CLOCK_MINUTE'] = 'minuto';
Blockly.Msg['CLOCK_HOUR'] = 'hora';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'día de la semana';
Blockly.Msg['DAY_MONDAY'] = 'lunes';
Blockly.Msg['DAY_TUESDAY'] = 'martes';
Blockly.Msg['DAY_WEDNESDAY'] = 'miércoles';
Blockly.Msg['DAY_THURSDAY'] = 'thursday';
Blockly.Msg['DAY_FRIDAY'] = 'viernes';
Blockly.Msg['DAY_SATURDAY'] = 'sábado';
Blockly.Msg['DAY_SUNDAY'] = 'sunday';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] escribe en la tarjeta SD %1 en los pines RX %2 TX %3 %4 Datas %5';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'El bloque permite escribir datos en la tarjeta SD del módulo Openlog';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] enviar en los pines RX %1 TX %2 mensaje %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Habilitar el envío de cualquier dato por el módulo bluetooth HC05 en los pines RX/TX';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] sobre mensaje recibido RX %1 TX %2 en %3 entonces';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones sobre los datos recibidos por el módulo Bluetooth HC05 en la variable \'bluetoothData\' en los pines TX/RX';
// Communication - GPS
Blockly.Msg['COMMUNICATION_GPS_INFO_TYPE'] = 'tipo de trama';
Blockly.Msg['COMMUNICATION_GPS_INFO_CLOCK'] = 'reloj (h, m, s)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LATITUDE'] = 'latitud (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LONGITUDE'] = 'longitud (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_SATELLITE'] = 'número de satélites utilizados';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALTITUDE'] = 'altitud (m)';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TITLE'] = 'tramas NMEA [GPS] en el puerto UART %1';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Devuelve la lista de tramas NMEA leídas con el módulo GPS Grove SIM28 o Air530 en el puerto UART 1 (D2/D14) o en el puerto UART 2 (D0/D1). En el Grove shield, el puerto UART (RX/TX) por defecto corresponde al puerto UART 2';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TITLE'] = '[GPS] obtiene %2 en el puerto UART %1';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Devuelve los datos seleccionados de (tipo de trama, reloj, latitud, longitud, altitud) analizados de la trama NMEA (GNGGA o GPGGA) leídos con el módulo GPS Grove SIM28 o Air530 en el puerto UART 1 (D2/D14) o en el puerto UART 2 (D0/D1). En el Grove shield, el puerto UART (RX/TX) por defecto es el puerto UART 2';
// Communication - NFC
Blockly.Msg['COMMUNICATION_M24SR64_NFC_READ_TITLE'] = '[NFC M24SR64] leer datos de la etiqueta';
Blockly.Msg['COMMUNICATION_M24SR64_NFC_READ_TOOLTIP'] = IMG_MODULE_NFC + Blockly.Tooltip.SEP + 'Leer datos de la etiqueta NFC vía I2C';
Blockly.Msg['COMMUNICATION_M24SR64_NFC_ERASE_TITLE'] = '[NFC M24SR64] borrar datos en la etiqueta';
Blockly.Msg['COMMUNICATION_M24SR64_NFC_ERASE_TOOLTIP'] = IMG_MODULE_NFC + Blockly.Tooltip.SEP + 'Borrar toda la memoria de la etiqueta NFC';
Blockly.Msg['COMMUNICATION_M24SR64_WRITE_NFC_TITLE'] = '[NFC M24SR64] escribir %1 en la etiqueta';
Blockly.Msg['COMMUNICATION_M24SR64_WRITE_NFC_TOOLTIP'] = IMG_MODULE_NFC + Blockly.Tooltip.SEP + 'Escribir datos en la etiqueta NFC (capacidad máxima de 8000 caracteres)';
// Communication - LoRa
Blockly.Msg['COMMUNICATION_LORA_INIT_TITLE'] = '[LoRa] inicializa el módulo con la appEui %1 con la appKey : %2';
Blockly.Msg['COMMUNICATION_LORA_INIT_TOOLTIP'] = IMG_MODULE_LORA + Blockly.Tooltip.SEP + 'Inicializa y obtiene la información de identificación del módulo LoRa conectado en el puerto UART.';
Blockly.Msg['COMMUNICATION_LORA_INIT'] = 'con el devAddr :';
Blockly.Msg['COMMUNICATION_LORA_SEND_TITLE'] = '[LoRa] envía datos ';
Blockly.Msg['COMMUNICATION_LORA_SEND_TOOLTIP'] = IMG_MODULE_LORA + Blockly.Tooltip.SEP + 'Envía datos de sensores a través del módulo LoRa.';
Blockly.Msg['COMMUNICATION_LORA_RECEIVE_TITLE'] = '[LoRa] Recibir un mensaje';
Blockly.Msg['COMMUNICATION_LORA_RECEIVE_TOOLTIP'] = IMG_MODULE_LORA + Blockly.Tooltip.SEP + 'Permite recibir datos a través del módulo LoRa.';
// Sensors - Expansion board
Blockly.Msg['SENSORS_ACCELEROMETER_INTEGRATED_LIS2DW12_TITLE'] = '[Acelerómetro LIS2DW12] aceleración siguiendo el eje %1';
Blockly.Msg['SENSORS_ACCELEROMETER_INTEGRATED_LIS2DW12_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Devuelve la aceleración siguiendo el eje X, Y o Z (en mg)';
Blockly.Msg['X_AXIS'] = 'x';
Blockly.Msg['Y_AXIS'] = 'y';
Blockly.Msg['Z_AXIS'] = 'z';
Blockly.Msg['SENSORS_INCLINOMETER_INTEGRATED_LIS2DW12_TITLE'] = '[Inclinómetro LIS2DW12] inclinación %1 eje y plano horizontal';
Blockly.Msg['SENSORS_INCLINOMETER_INTEGRATED_LIS2DW12_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Devuelve la inclinación entre los ejes X, Y o Z y el plano horizontal';
Blockly.Msg['SENSORS_ACCELEROMETER_INTEGRATED_LSM6DSO_TITLE'] = '[Acelerómetro LSM6DSO] aceleración siguiendo el eje %1';
Blockly.Msg['SENSORS_ACCELEROMETER_INTEGRATED_LSM6DSO_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Devuelve la aceleración siguiendo el eje X, Y o Z (en mg)';
Blockly.Msg['SENSORS_GYROSCOPE_INTEGRATED_LSM6DSO_TITLE'] = '[Giroscopio LSM6DSO] velocidad angular siguiendo el eje %1';
Blockly.Msg['SENSORS_GYROSCOPE_INTEGRATED_LSM6DSO_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Devuelve la velocidad angular siguiendo X, Y o Z (en rad/s)';
Blockly.Msg['SENSORS_MAGNETOSCOPE_INTEGRATED_LIS2MDL_TITLE'] = '[Magnetómetro LIS2MDL] campo magnético siguiendo el eje %1';
Blockly.Msg['SENSORS_MAGNETOSCOPE_INTEGRATED_LIS2MDL_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Devuelve el campo magnético siguiendo X, Y o Z (en gauss)';
Blockly.Msg['SENSORS_THERMOMETER_INTEGRATED_STTS751_TITLE'] = '[Termómetro STTS751] temperatura';
Blockly.Msg['SENSORS_THERMOMETER_INTEGRATED_STTS751_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Devuelve la temperatura (en °C)';
Blockly.Msg['SENSORS_HYGROMETER_INTEGRATED_HTS221_TITLE'] = '[Higrómetro HTS221] humedad relativa';
Blockly.Msg['SENSORS_HYGROMETER_INTEGRATED_HTS221_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Devuelve la humedad';
Blockly.Msg['SENSORS_BAROMETER_INTEGRATED_LPS22_TITLE'] = '[Barómetro LPS22] presión atmosférica';
Blockly.Msg['SENSORS_BAROMETER_INTEGRATED_LPS22_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Devuelve la presión atmosférica. (260 a 1260 hPa)';
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[Sensor SGP30] gas %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Devuelve la cantidad de CO2 (en ppm) o TVOC (en ppb) en el aire del sensor sgp30. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'dióxido de carbono (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'compuestos orgánicos volátiles (TVOC) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Sensor de gas multicanal] gas %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Devuelve la cantidad de gas elegida en el aire (en ppm) del sensor de gas multicanal de Grove. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Sensor de gas multicanal v2] gas %1 (V)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Devuelve la cantidad de gas elegida en el aire (en V) del sensor multicanal de gas V2. Conecte el sensor en el puerto I2C';
Blockly.Msg['GAS_CO'] = 'monóxido de carbono (CO)';
Blockly.Msg['GAS_NO2'] = 'dióxido de nitrógeno (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'etanol (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'dihidrógeno (H2)';
Blockly.Msg['GAS_NH3'] = 'amoníaco (NH3)';
Blockly.Msg['GAS_CH4'] = 'metano (CH4)';
Blockly.Msg['GAS_C3H8'] = 'propano (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'isopropano (C4H10)';
Blockly.Msg['GAS_VOC'] = 'compuestos orgánicos volátiles (COV)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Sensor de gas oxígeno] O2 (%) en el pin %1';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Devuelve la concentración de O2 (en %) del sensor de O2 del Grove en los pines analógicos p34 a p36, o p39 (como A2 a A4 en el Grove del escudo)';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[Sensor SCD30] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Devuelve la concentración de CO2 (en ppm), la humedad (en %) o la temperatura en Celsius (°C), Fahrenheit (°F) o Kelvin (K) del sensor SCD30 de Grove. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'dióxido de carbono (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = 'temperatura';
Blockly.Msg['SENSORS_SCD30_HUM'] = 'humedad (%)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[Sensor SCD30] forzar recalibración a %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Forzar la calibración del sensor SCD30 al valor dado (en ppm). Salga al exterior (donde la concentración sea de aproximadamente 420 ppm, es decir, aire limpio), reinicie la placa y espere 2 minutos. Consejo: Utilice los botones SW1, SW2 o SW3 de la tarjeta L476 NUCLEO para controlar el inicio de la calibración. De lo contrario, al volver a conectar la placa, el programa se lanza y vuelve a realizar una calibración no solicitada';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Sensor de calidad del aire] valor en el pin %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Devuelve el valor de la calidad del aire (de 0 a 4095) en los pines analógicos p34 a p36, o p39 (como A2 a A4 en el escudo Grove)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[Sensor HM330X] concentración de partículas %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Detecta la densidad de partículas en el aire con el sensor HM330X. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
// Sensors - Climate
Blockly.Msg['SENSORS_TEMPERATURE'] = 'temperature';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humedad (%)';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'Temperatura';
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[Sensor BMP280 %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grados Celius (°C), Fahrenheit (°F) o Kelvin (K), presión (en Pa). La altitud se inicializa en 0 cuando el programa se pone en marcha. Utiliza el sensor de barómetro Grove (dirección: 0x77, color: azul) o el sensor HW-611 280 (dirección: 0x76, color: púrpura). Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_BMP280_TEMP'] = 'temperatura';
Blockly.Msg['SENSORS_BMP280_PRESS'] = 'presión (Pa)';
Blockly.Msg['SENSORS_BMP280_ALT'] = 'altitud (m)';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = 'temperatura del sensor H.T° en %1 en los pines A0 %2 A1 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Devuelve la temperatura del termopar entre 50 y 600 °C con el sensor de alta temperatura de Grove. Conecte el sensor en los pines analógicos';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Sensor de humedad] humedad en el pin %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Devuelve la medición de la humedad (de 0 a 4095) del sensor de humedad de la arboleda en los pines IO34, 35 , 36 y 39';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Sensor de temperatura] temperatura en %1 en el pin %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de temperatura del Grove en grados Celius (°C), Fahrenheit (°F) o Kelvin (K) en los pines analógicos p34 a p36, o p39 (como A2 a A4 en el shield Grove)';
Blockly.Msg['SENSORS_DHT11_READDATA_TITLE'] = '[Sensor DHT11] %1 en el pin %2';
Blockly.Msg['SENSORS_DHT11_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad del aire (en %) del sensor DHT11 en los pines digitales';
Blockly.Msg['SENSORS_DHT22_READDATA_TITLE'] = '[Sensor DHT22] %1 en el pin %2';
Blockly.Msg['SENSORS_DHT22_READDATA_TOOLTIP'] = IMG_MODULE_DHT22 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad del aire (en %) con buena precisión del sensor DHT22 en los pines digitales';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[Sensor TH02] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad del aire (en %) del sensor TH02. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Sensor SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad del aire (en %) del sensor SHT31. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TITLE'] = '[Sensor DS18X20] temperatura en %1 en el pin %2';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en Celsius (°C), Fahrenheit (°F) o Kelvin (K) del sensor impermeable DS18X20.';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Sensor de agua] cantidad de agua en el pin %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Devuelve la cantidad de agua (de 0 a 255) del sensor de agua de la arboleda en los pines analógicos p34 a p36, o p39 (como A2 a A4 en la arboleda del escudo).';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Sensor de pluviómetro] valor de estado en el pin %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Devuelve el estado del pluviómetro (1 si está lloviendo o 0 en caso contrario) en los pines digitales';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anemómetro] valor del estado en el pin %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Devuelve el estado del anemómetro de la arboleda (dos veces el estado HIGH en cada rotación) en los pines digitales';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Sensor de luz] nivel de luz en el pin %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de luz de Grove (de 0 a 4095) en los pines analógicos p34 a p36, o p39 (como A2 a A4 en el shield Grove)';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[Sensor SI1145] obtener luz %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Devuelve el índice de luz ultravioleta, luz IR (en lumen) o luz visible (en lumen) del sensor si1145. Funciona con el sensor de luz solar Grove o el sensor GY1145. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_SI1145_UV'] = 'Índice UV';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visible (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrarrojo (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Sensor Ultravioleta] Índice UV en el pin %1';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Devuelve el índice UV, para ondas entre 240 nm y 380 nm, con el sensor UV Grove en los pines analógicos p34 a p36, o p39 (como A2 a A4 en el escudo Grove)';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Sensor de sonido] nivel de sonido (dB) en el pin %1 ';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de sonido de Grove (de 0 a 1023 convertido en dB) en los pines analógicos p34 a p36, o p39 (como A2 a A4 en el escudo Grove)..';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Sensor de color] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Permite leer el nivel de uno de los tres colores primarios con el sensor de color Grove, devuelve un nivel entre 0 y 255';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TITLE'] = '[Time Of Flight] Distance in %1';
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TOOLTIP'] = IMG_MODULE_VL53L0X + Blockly.Tooltip.SEP + 'Devuelve las mediciones de distancia del sensor TOF en el puerto I2C.';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Sensor Ultrasónico %1] obtiene %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Devuelve la medida de la distancia (en centímetros) del sensor ultrasónico del ranger en los pines digitales. Atención, si es un sensor de ranger, TRIG y ECHO están conectados a SIG';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distancia (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'duración del viaje de ida y vuelta (µs)';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = 'tipo de gesto del sensor';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Devuelve el tipo de gesto (\'derecha\', \'izquierda\', \'arriba\', \'abajo\', \'hacia delante\', \'hacia atrás\', \'en el sentido de las agujas del reloj\', \'en sentido contrario\') del sensor de gestos Grove. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Sensor de gestos] en el gesto %1 detectado entonces';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Ejecuta las instrucciones si el sensor de gestos de Grove detecta el gesto seleccionado. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'derecho';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'izquierda';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'arriba';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'abajo';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'hacia adelante';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'hacia atrás';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'en el sentido de las agujas del reloj';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'en sentido contrario a las agujas del reloj';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'onda';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Sensor del buscador de líneas] estado del buscador de líneas en el pin %1';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Devuelve el estado del sensor táctil de ranura (0 o 1) en los pines digitales';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[Sensor de movimiento PIR] valor del estado de movimiento en el pin %1';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Devuelve el estado de movimiento del PIR (0 si hay movimiento o 1 en caso contrario) en los pines digitales';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Sensor de vibración piezoeléctrico] valor del estado en el pin %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Devuelve el estado de vibración (0 o 1) del sensor piezoeléctrico de vibración en los pines digitales';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Módulo de inclinación] estado de inclinación en el pin %1';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Devuelve el estado de inclinación de la arboleda (0 o 1) en los pines digitales';
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TITLE'] = '[Time Of Flight] Distance in %1';
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TOOLTIP'] = IMG_MODULE_VL53L0X + Blockly.Tooltip.SEP + 'Devuelve las mediciones de distancia del sensor TOF en el puerto I2C.';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TITLE'] = '[Módulo de botones] botón %1 en el pin %2';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el valor numérico del botón grove (0/1 o 0V/3.3V) en los pines digitales';
Blockly.Msg['SENSORS_GETGROVEBUTTON_VOLTAGE'] = 'voltaje';
Blockly.Msg['SENSORS_GETGROVEBUTTON_STATE'] = 'estado';
// Actuators - Motors
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servomotor] ajustar ángulo a %1 en el pin %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permite controlar el ángulo del servo (de 0 a 180) en los pines digitales. Atención, L476 tiene que ser alimentado por una batería externa para proporcionar suficiente energía al servomotor';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Servomotor continuo] establece la velocidad en %1 (%) dirección %2 en el pin %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Habilitar para controlar la velocidad del servomotor continuo (de 0 a 100 %) en los pines PWM';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Motor] establece la potencia a %1 en el pin %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permite controlar la potencia del motor de CC (de 0 a 100 %) en los pines digitales. Atención, L476 tiene que ser alimentado por una batería externa para proporcionar suficiente energía al motor de CC';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Motor de vibración] controla el motor al estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Habilitar para controlar el estado del motor de vibración de la ranura (0 o 1) en los pines digitales';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Módulo de relés] controla el relé al estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Habilitar para controlar el módulo de relé de ranura de estado (0 o 1) en los pines digitales';
// Actuators - MOSFET
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TITLE'] = '[MOSFET] set state to %1 on pin %2';
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Habilitar para establecer el estado del transistor MOSFET a HIGH o LOW en los pines PWM';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TITLE'] = '[MOSFET] establece el valor a %1 (%) en el pin %2';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Habilitar para controlar el tiempo de ciclo del transistor MOSFET (de 0 a 100 %) en los pines PWM';
Blockly.Msg['ACTUATORS_MOSFET_SETFREQUENCY_TITLE'] = '[MOSFET] establece la frecuencia de ciclo a %1 (Hz) en el pin %2';
Blockly.Msg['ACTUATORS_MOSFET_SETFREQUENCY_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Habilitar para controlar la frecuencia de ciclo del MOSFET (en Hz) en los pines PWM';
Blockly.Msg['ACTUATORS_MOSFET_PULL'] = 'pull';
// Actuators - Music
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TITLE'] = '[Zumbador/altavoz] reproducir música %1 en %2';
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Activar la reproducción de la música elegida en el módulo zumbador Grove (o altavoz) en los pines digitales';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TITLE'] = '[Buzzer/Speaker] reproducir notas en';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Activar la reproducción de notas en el módulo Grove buzzer (o altavoz) en los pines digitales';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TITLE'] = 'nota %1 en la octava %2 con duración %3';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Define una nota con octava y duración';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TITLE'] = '[Zumbador/Parlante] reproducir frecuencia %1 durante %2 (ms) en %3';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Activar la reproducción de la frecuencia entera en el módulo zumbador (o altavoz) Grove en los pines digitales';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TITLE'] = '[Zumbador/Parlante] detener la música en %1';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Activar para detener la música del módulo zumbador (o altavoz) Grove en los pines digitales';
// Notes
Blockly.Msg['NOTE_C'] = 'C';
Blockly.Msg['NOTE_C_SHARP'] = 'C#';
Blockly.Msg['NOTE_D'] = 'D';
Blockly.Msg['NOTE_D_SHARP'] = 'D#';
Blockly.Msg['NOTE_E'] = 'E';
Blockly.Msg['NOTE_F'] = 'F';
Blockly.Msg['NOTE_F_SHARP'] = 'F#';
Blockly.Msg['NOTE_G'] = 'G';
Blockly.Msg['NOTE_G_SHARP'] = 'G#';
Blockly.Msg['NOTE_A'] = 'A';
Blockly.Msg['NOTE_A_SHARP'] = 'A#';
Blockly.Msg['NOTE_B'] = 'B';
Blockly.Msg['MUSIC_SILENCE'] = 'Silencio';
// Robots - Alphabot
Blockly.Msg['ROBOTS_ALPHABOT_RIGHT'] = 'derecha';
Blockly.Msg['ROBOTS_ALPHABOT_LEFT'] = 'izquierda';
Blockly.Msg['ROBOTS_ALPHABOT_ULTRASONICRANGER_TITLE'] = '[Alphabot - Sensor ultrasónico] distancia (cm)';
Blockly.Msg['ROBOTS_ALPHABOT_ULTRASONICRANGER_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Devuelve el valor de la distancia (en cm) o la duración del viaje de ida y vuelta de la onda (en μs) desde cualquier objeto hasta el robot alphabot con sensor de alcance ultrasónico';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_CALIBRATE_TITLE'] = '[Alphabot] calibra el buscador de líneas';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_CALIBRATE_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Habilitar para calibrar el buscador de líneas del robot alfabeto';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_READSENSORS_TITLE'] = '[Alphabot] valores del sensor del buscador de líneas %1';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_READSENSORS_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permite leer los valores de los sensores del buscador de líneas de alrededor de 0-500 (negro) a 500-1000 (blanco) con una calibración normal del robot alphabot v2. La opción \'all\' del bloque permite obtener un array de 5 valores de sensores';
Blockly.Msg['ROBOTS_ALPHABOT_ALL_SENSORS'] = 'todos los sensores';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_GETSENSORABOVELINE_TITLE'] = '[Alphabot] sensor sobre la línea';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_GETSENSORABOVELINE_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Habilitar para devolver el nombre del sensor sobre la línea. (IR1/IR2/IR3/IR4/IR5 de izquierda a derecha)';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ISSENSORABOVELINE_TITLE'] = '[Alphabot] es el sensor %1 sobre la línea';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ISSENSORABOVELINE_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Habilitar para devolver True si el sensor seleccionado está por encima de la línea, en caso contrario devolver False. (IR1/IR2/IR3/IR4/IR5 de izquierda a derecha)';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_LIMIT_VALUE'] = 'valor límite';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_TITLE'] = '[Alphabot] si sensor %1';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_SENSOR_THEN'] = 'línea superior entonces';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_ELSEIF'] = 'si no, si su sensor';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_THEN'] = Blockly.Msg['CONTROLS_IF_MSG_THEN'];
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones encendiendo los sensores IR del robot alfabeto';
Blockly.Msg['ROBOTS_ALPHABOT_READOBSTACLEDETECTOR_TITLE'] = '[Alphabot - sensores frontales IR] obstáculo detectado por IR';
Blockly.Msg['ROBOTS_ALPHABOT_READOBSTACLEDETECTOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permite leer el estado de los detectores de obstáculos (sensores IR en LEDL y LEDR) del robot alfabeto. El bloque devuelve True si el sensor está delante del obstáculo';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_TITLE'] = '[Alphabot - sensores IR frontales] si obstáculo %1';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_BY_IR_THEN'] = 'detectado por IR entonces';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_ELSEIF'] = 'si no';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_THEN'] = 'detectado entonces';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones sobre el obstáculo detectado por los detectores de obstáculos (sensores IR en LEDL y LEDR) del robot alfabeto';
Blockly.Msg['ROBOTS_ALPHABOT_BY_RIGHT'] = 'por la derecha (LEDR)';
Blockly.Msg['ROBOTS_ALPHABOT_BY_LEFT'] = 'por la izquierda (LEDL)';
Blockly.Msg['ROBOTS_ALPHABOT_BOTH_SIDES'] = 'por ambos lados (LEDR & LEDL)';
Blockly.Msg['ROBOTS_ALPHABOT_GO_TITLE'] = '[Alphabot] controlar robot %1 velocidad %2 (%)';
Blockly.Msg['ROBOTS_ALPHABOT_GO_FORWARD'] = 'hacia adelante';
Blockly.Msg['ROBOTS_ALPHABOT_GO_REVERSE'] = 'hacia atrás';
Blockly.Msg['ROBOTS_ALPHABOT_GO_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permite controlar la marcha del coche (ADELANTE/ATRÁS) y la velocidad (de 0 a 100 %) del robot alfabeto';
Blockly.Msg['ROBOTS_ALPHABOT_TURNTO_TITLE'] = '[Alphabot] girar a %1 velocidad %2';
Blockly.Msg['ROBOTS_ALPHABOT_TURNTO_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Activar el giro a la derecha o a la izquierda con el robot alfabeto. Establecer la velocidad (de 0 a 100 %)';
Blockly.Msg['ROBOTS_ALPHABOT_RIGHT_BIS'] = Blockly.Msg['ROBOTS_ALPHABOT_RIGHT'];
Blockly.Msg['ROBOTS_ALPHABOT_CONTROLMOTOR_TITLE'] = '[Alphabot] controlar motor %1 dirección %2 velocidad %3 (%)';
Blockly.Msg['ROBOTS_ALPHABOT_CONTROLMOTOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permite controlar el motor derecho y el motor izquierdo cambiando la dirección (↻ : FOWARD, ↺ : REVERSE) o la velocidad (de 0 a 100 %) del robot alfabeto';
Blockly.Msg['ROBOTS_ALPHABOT_STOPMOTORS_TITLE'] = '[Alphabot] parar motor %1';
Blockly.Msg['ROBOTS_ALPHABOT_STOPMOTORS_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Habilitar para detener el motor derecho, el izquierdo o ambos del robot alfabeto';
Blockly.Msg['ROBOTS_ALPHABOT_RIGHT&LEFT'] = 'derecha e izquierda';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_TITLE'] = '[Alphabot] si comando %1';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_RECEIVED_THEN'] = 'received then';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_DETECTED_THEN'] = 'received by NEC basic black remote control then';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_TOOLTIP'] = IMG_MODULE_BASIC_BLACK_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Allows you to execute instructions on command received by IR transmission from NEC basic black remote control.';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_CAR_MP3_GRAY_DETECTED_THEN'] = 'received by NEC <br>Car mp3 gray remote control<br> then';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_CAR_MP3_GRAY_TOOLTIP'] = IMG_MODULE_CAR_MP3_GRAY_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Allows you to execute instructions on command received by IR transmission from NEC Car mp3 gray remote control.';
Blockly.Msg['REMOTE_NEC_BUTTON'] = 'pad ';
Blockly.Msg['REMOTE_NEC_BUTTON_UP'] = 'arriba';
Blockly.Msg['REMOTE_NEC_BUTTON_DOWN'] = 'abajo';
Blockly.Msg['REMOTE_NEC_BUTTON_LEFT'] = 'izquierda';
Blockly.Msg['REMOTE_NEC_BUTTON_RIGHT'] = 'derecha';
Blockly.Msg['REMOTE_NEC_BUTTON_BACK'] = 'back';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_ADDTEXT_TITLE'] = '[Alphabot] mostrar texto %1 en pantalla en la posición x %2 y %3';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Activar la escritura de texto en la pantalla OLED (128x64 px)';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_SETBACKGROUND_TITLE'] = '[Alphabot] establece el fondo de la pantalla en %1';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_SETBACKGROUND_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Habilitar para invertir la pantalla OLED de Grove';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_YELLOW_BLUE'] = 'amarillo y azul';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_BLACK'] = 'negro';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_CLEARSCREEN_TITLE'] = '[Alphabot] clear screen';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Habilitar para limpiar toda la pantalla OLED de Grove';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETCOLOR_TITLE'] = '[Alphabot] set color R %2 G %3 B %4 on LED %1';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETCOLOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permite controlar cada color del LED del neopixel del alfabeto como (R,G,B) de 0 a 255. El neopixel está conectado en D7 en el alfabeto';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Alphabot] establece el color %2 en el LED %1';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permite controlar cada color del LED del neopixel alfabeto. Elección del color en la paleta. Utilice D7 para establecer neopixel alfabeto';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETRAINBOW_TITLE'] = '[Alphabot] Rainbow';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETRAINBOW_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Activar para mostrar un arco iris en el LED RGB del alfabeto. El neopixel está conectado a D7 en el alfabeto';
Blockly.Msg['ROBOTS_ALPHABOT_BUZZER_CONTROLSTATE_TITLE'] = '[Alphabot] poner el zumbador en estado %1';
Blockly.Msg['ROBOTS_ALPHABOT_BUZZER_CONTROLSTATE_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Activar para controlar el estado del zumbador del alfabeto';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_TITLE'] = '[Alphabot] si botón %1';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_DETECTED_THEN'] = 'pulsado en el joystick entonces';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_ELSEIF'] = 'si no se pulsa el botón';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_RECEIVED_THEN'] = 'pulsado entonces';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones a la orden recibida por el joystick del robot alfabeto';
Blockly.Msg['JOYSTICK_BUTTON_UP'] = 'arriba';
Blockly.Msg['JOYSTICK_BUTTON_DOWN'] = 'abajo';
Blockly.Msg['JOYSTICK_BUTTON_LEFT'] = 'izquierda';
Blockly.Msg['JOYSTICK_BUTTON_RIGHT'] = 'derecha';
Blockly.Msg['JOYSTICK_BUTTON_CENTER'] = 'centro';