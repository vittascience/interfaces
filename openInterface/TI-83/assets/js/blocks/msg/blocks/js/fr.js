/**
 * @fileoverview Italian messages for TI-83 Premium CE. (EN)
 */
'use strict';
// Common messages
Blockly.Msg['SECOND'] = 'seconde.s';
Blockly.Msg['MILLISECOND'] = 'milliseconde.s';
Blockly.Msg['MICROSECOND'] = 'microseconde.s';
// TI System
Blockly.Msg['TI_SYSTEM_RECALL_LIST_TITLE'] = '[system] liste conservée avec l\'indice %1';
Blockly.Msg['TI_SYSTEM_RECALL_LIST_TOOLTIP'] = 'Renvoie la liste conservée avec les indices (\'1\'-\'6\'). Ce bloc doit fonnctionne s\'il y a déjà eu un appel de la fonction store_list().';
Blockly.Msg['TI_SYSTEM_STORE_LIST_TITLE'] = '[system] conserver la liste %1 avec l\'indice %2';
Blockly.Msg['TI_SYSTEM_STORE_LIST_TOOLTIP'] = 'Permet de conserver une liste avec les indices (\'1\'-\'6\'). Cette liste peut être récupérée plus tard en appelant la fonction recall_list().';
Blockly.Msg['TI_SYSTEM_RECALL_REGEQ_TITLE'] = '[system] obtenir la RegEQ';
Blockly.Msg['TI_SYSTEM_RECALL_REGEQ_TOOLTIP'] = 'Renvoie la RegEQ.';
Blockly.Msg['TI_SYSTEM_WHILE_CONDITION_TITLE'] = '[system] répéter tant que %1';
Blockly.Msg['TI_SYSTEM_WHILE_CONDITION_TOOLTIP'] = 'Répéter la boucle tant que la condition est vérifiée.';
Blockly.Msg['TI_SYSTEM_IF_CONDITION_TITLE'] = '[system] si %1 alors';
Blockly.Msg['TI_SYSTEM_IF_CONDITION_TOOLTIP'] = 'Exécute des instructions si la condition est vérifiée.';
Blockly.Msg['TI_SYSTEM_ESCAPE_TITLE'] = '[system] exécution arrêtée ?';
Blockly.Msg['TI_SYSTEM_ESCAPE_TOOLTIP'] = 'Renvoie \'True\' si le bouton \'annul\' a été appuyé.';
Blockly.Msg['TI_SYSTEM_DISP_AT_TITLE'] = '[system] écrire le texte %1 à la ligne %2 position %3';
Blockly.Msg['TI_SYSTEM_DISP_AT_TOOLTIP'] = 'Ecrit du texte dans la fenêtre graphique de la calculatrice TI-83.';
Blockly.Msg['TI_SYSTEM_DISP_AT_LEFT'] = 'à gauche';
Blockly.Msg['TI_SYSTEM_DISP_AT_CENTER'] = 'centré';
Blockly.Msg['TI_SYSTEM_DISP_AT_RIGHT'] = 'à droite';
Blockly.Msg['TI_SYSTEM_DISP_CLR_TITLE'] = '[system] effacer le texte';
Blockly.Msg['TI_SYSTEM_DISP_CLR_TOOLTIP'] = 'Efface le texte de l\'écran de la calculatrice TI-83.';
Blockly.Msg['TI_SYSTEM_DISP_WAIT_TITLE'] = '[system] attendre que \'annul\' soit appuyé';
Blockly.Msg['TI_SYSTEM_DISP_WAIT_TOOLTIP'] = 'Affiche l\'écran de la calculatrice TI-83 tant que le bouton [annul] n\'est pas appuyé.';
Blockly.Msg['TI_SYSTEM_DISP_CURSOR_TITLE'] = '[system] contrôler le curseur à l\'état %1';
Blockly.Msg['TI_SYSTEM_DISP_CURSOR_TOOLTIP'] = 'Permet d\'afficher ou non le curseur de l\'écran de la calculatrice TI-83.';
Blockly.Msg['TI_SYSTEM_SLEEP_TITLE'] = '[system] attendre %1 %2';
Blockly.Msg['TI_SYSTEM_SLEEP_TOOLTIP'] = 'Effectue une pause dans l\'exécution du code. La fonction ti_system.sleep() prend en argument des secondes.';
Blockly.Msg['TI_SYSTEM_SLEEP_SECOND'] = Blockly.Msg['SECOND'];
Blockly.Msg['TI_SYSTEM_SLEEP_MILLISECOND'] = Blockly.Msg['MILLISECOND'];
Blockly.Msg['TI_SYSTEM_SLEEP_MICROSECOND'] = Blockly.Msg['MICROSECOND'];
Blockly.Msg['TI_SYSTEM_WAIT_KEY_TITLE'] = '[system] attendre la clé';
Blockly.Msg['TI_SYSTEM_WAIT_KEY_TOOLTIP'] = 'Permet d\'attendre la clé.';
// TI Input/Output - Console
Blockly.Msg['TI_IO_PRINT_TITLE'] = 'écrire dans la console %1';
Blockly.Msg['TI_IO_PRINT_TOOLTIP'] = 'Permet d\'écrire des données dans la console.';
Blockly.Msg['TI_IO_CLEAR_SHELL_TITLE'] = 'nettoyer la console';
Blockly.Msg['TI_IO_CLEAR_SHELL_TOOLTIP'] = 'Efface le texte du shell MicroPython de la calculatrice TI-83.';
Blockly.Msg['TI_IO_INPUT_TEXT_TITLE'] = 'demander un texte à l\'utilisateur %1';
Blockly.Msg['TI_IO_INPUT_TEXT_TOOLTIP'] = 'Demande à l\'utilisateur d\'entrer du texte dans la console python.';
Blockly.Msg['TI_IO_INPUT_NUMBER_TITLE'] = 'demander un nombre à l\'utilisateur %1';
Blockly.Msg['TI_IO_INPUT_NUMBER_TOOLTIP'] = 'Demande à l\'utilisateur d\'entrer un nombre dans la console python.';
// TI Input/Output - Time
Blockly.Msg['IO_WAIT_TITLE'] = '[time] attendre %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Effectue une pause dans l\'exécution du code. La fonction time.sleep() prend en argument des secondes.';
Blockly.Msg['IO_WAIT_SECOND'] = Blockly.Msg['SECOND'];
Blockly.Msg['IO_WAIT_MILLISECOND'] = Blockly.Msg['MILLISECOND'];
Blockly.Msg['IO_WAIT_MICROSECOND'] = Blockly.Msg['MICROSECOND'];
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = '[time] attendre jusqu\'à %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Arrête l\'excution du code jusqu\'à ce que la condition soit satisfaite.';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = '[time] démarrer le chronomètre';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Initialise un chronomètre à 0 (en secondes).';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = '[time] valeur du chronomètre en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Renvoie la valeur du chronomètre à partir de l\'initialisation (en secondes ou millisecondes).';
// TI - Random
Blockly.Msg['RANDOM_RANDOM_TITLE'] = 'nombre aléatoire entre 0 et 1';
Blockly.Msg['RANDOM_RANDOM_TOOLTIP'] = 'Renvoie un nombre aléatoire entre 0.0 (inclus) et 1.0 (exclus), soit [0, 1[ en mathématiques.';
Blockly.Msg['RANDOM_RANDINT_TITLE'] = 'entier aléatoire entre %1 et %2';
Blockly.Msg['RANDOM_RANDINT_TOOLTIP'] = 'Renvoie un entier aléatoire entre les deux limites spécifiées, incluses.';
Blockly.Msg['RANDOM_UNIFORM_TITLE'] = 'nombre uniforme entre %1 et %2';
Blockly.Msg['RANDOM_UNIFORM_TOOLTIP'] = 'Renvoie un nombre entre les deux limites spécifiées, incluses.';
Blockly.Msg['RANDOM_RANDRANGE_TITLE'] = 'nombre aléatoire entre %1 et %2 avec un pas de %3';
Blockly.Msg['RANDOM_RANDRANGE_TOOLTIP'] = 'Renvoie un nombre aléatoire entre les deux limites spécifiées, incluses, avec un certain écrat.';
Blockly.Msg['RANDOM_CHOICE_TITLE'] = 'élément aléatoire dans la liste %1';
Blockly.Msg['RANDOM_CHOICE_TOOLTIP'] = 'Renvoie un des éléments de la liste de manière aléatoire.';
Blockly.Msg['RANDOM_SEED_TITLE'] = 'nombre nul';
Blockly.Msg['RANDOM_SEED_TOOLTIP'] = 'Renvoie un nombre nul: None.';
// Sensors - common messages
Blockly.Msg['SENSORS_TEMPERATURE'] = 'temperature';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'in';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humidity (%)';
Blockly.Msg['SENSORS_PRESSURE'] = 'pression (hPa)';
// Devices - Built-in Hub Innovator
Blockly.Msg['DEVICES_BUILTIN_SETRGBLED_TITLE'] = '[DEL RVB] contrôler la LED à R %1 G %2 B %3';
Blockly.Msg['DEVICES_BUILTIN_SETRGBLED_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la LED RGB intégrée au Innovator Hub, donner une valeur entre 0 et 255 pour Rouge, Vert et Bleu.';
Blockly.Msg['DEVICES_BUILTIN_SETRGBLEDPALETTE_TITLE'] = '[DEL RVB] contrôler la LED à %1';
Blockly.Msg['DEVICES_BUILTIN_SETRGBLEDPALETTE_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la LED RGB intégrée au Innovator Hub, choisir une couleur dans la palette.';
Blockly.Msg['DEVICES_BUILTIN_BLINKRGBLED_TITLE'] = '[DEL RVB] faire clignoter la LED';
Blockly.Msg['DEVICES_BUILTIN_BLINKRGBLED_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Fait clignoter la LED RGB intégrée au Innovator Hub.';
Blockly.Msg['DEVICES_BUILTIN_SETREDLED_TITLE'] = '[DEL Rouge] contrôler la LED à l\'état %1';
Blockly.Msg['DEVICES_BUILTIN_SETREDLED_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Contrôle la LED rouge intégrée au Innovator Hub.';
Blockly.Msg['DEVICES_BUILTIN_PLAYMUSICBUZZER_TITLE'] = '[Sortie son] jouer la musique %1';
Blockly.Msg['DEVICES_BUILTIN_PLAYMUSICBUZZER_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Permet de jouer une musique avec le haut-parleur intégré au Innovator Hub.';
Blockly.Msg['DEVICES_BUILTIN_SPEAKER_PLAY_NOTES_TITLE'] = '[Sortie son] jouer les notes sur';
Blockly.Msg['DEVICES_BUILTIN_SPEAKER_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Permet de jouer des notes avec le haut-parleur intégré au Innovator Hub.';
Blockly.Msg['DEVICES_BUILTIN_SPEAKER_NOTE_TITLE'] = 'note %1 à l\'octave %2 durée %3';
Blockly.Msg['DEVICES_BUILTIN_SPEAKER_NOTE_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Permet de définir une note à une certaine octave pendant une durée déterminée.';
Blockly.Msg['DEVICES_BUILTIN_SPEAKER_PLAY_FREQUENCY_TITLE'] = '[Sortie son] jouer la fréquence %1 pendant %2 (s)';
Blockly.Msg['DEVICES_BUILTIN_SPEAKER_PLAY_FREQUENCY_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Permet de jouer une fréquence avec le haut-parleur intégré au Innovator Hub. La durée doit être définie en secondes.';
Blockly.Msg['DEVICES_BUILTIN_GETLIGHT_TITLE'] = '[Entrée de lumière] luminosité';
Blockly.Msg['DEVICES_BUILTIN_GETLIGHT_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Renvoie la luminosité (de 0 à 1023) du capteur de lumière intégré au Innovator Hub.';
// Devices - External Grove Inputs
Blockly.Msg['DEVICES_GROVE_GETPOTENTIOMETER_TITLE'] = '[Potentiomètre] valeur sur la broche %1';
Blockly.Msg['DEVICES_GROVE_GETPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Renvoie la valeur (de 0 à 1023) du potentiomètre grove sur les broches IN1/IN2/IN3 ou BB4/BB8/BB9/BB10.';
Blockly.Msg['DEVICES_GROVE_GETULTRASONIC_TITLE'] = '[Capteur à ultrasons] distance (cm) sur la broche %1';
Blockly.Msg['DEVICES_GROVE_GETULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Renvoie la distance (in cm) mesurée grâce au capteur grove à ultrasons sur les broches digitales. Attention, si le capteur est un modèle grove, TRIG et ECHO sont sur la même broche SIG.';
Blockly.Msg['DEVICES_GROVE_GETMOISTURE_TITLE'] = '[Capteur d\'humidité] humidité du sol sur la broche %1';
Blockly.Msg['DEVICES_GROVE_GETMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Renvoie l\'humidité (de 0 à 1023) mesurée grâce au capteur d\'humidité grove sur les broches IN1/IN2/IN3 ou BB4/BB8/BB9/BB10.';
Blockly.Msg['DEVICES_GROVE_GETTEMPERATURE_TITLE'] = '[Capteur de T°] température en %1 sur la broche %2';
Blockly.Msg['DEVICES_GROVE_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) du capteur de température Grove sur les broches IN1/IN2/IN3 ou BB4/BB8/BB9/BB10.';
Blockly.Msg['DEVICES_GROVE_DHT_READDATA_TITLE'] = '[Capteur DHT11] %1 sur la broche %2';
Blockly.Msg['DEVICES_GROVE_DHT_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur dht11 grove sur les broches digitales de.';
Blockly.Msg['DEVICES_GROVE_GETLOUDNESS_TITLE'] = '[Capteur de son] intensité sur la broche %1';
Blockly.Msg['DEVICES_GROVE_GETLOUDNESS_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Renvoie l\'intensité du son (de 0 à 1023) mesurée grâce au capteur de son grove sur les broches IN1/IN2/IN3 ou BB4/BB8/BB9/BB10.';
Blockly.Msg['DEVICES_GROVE_GETLIGHT_TITLE'] = '[Capteur de lumière] luminosité sur la broche %1';
Blockly.Msg['DEVICES_GROVE_GETLIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Renvoie la luminosité (de 0 à 1023) du capteur de lumière Grove sur les broches IN1/IN2/IN3 ou BB4/BB8/BB9/BB10.';
// Devices - External grove Outputs
Blockly.Msg['DEVICES_GROVE_SETLED_TITLE'] = '[LED] contrôler la LED %1 sur la broche  %2';
Blockly.Msg['DEVICES_GROVE_SETLED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Permet d\'activer ou désactiver la LED Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['DEVICES_GROVE_SETLEDINTENSITY_TITLE'] = '[LED] régler la luminosité à %1 sur la broche %2';
Blockly.Msg['DEVICES_GROVE_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 255 sur les broches PWM.';
Blockly.Msg['DEVICES_GROVE_SERVO_SETANGLE_TITLE'] = '[Servomoteur] contrôler l\'angle à %1 sur la broche %2';
Blockly.Msg['DEVICES_GROVE_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler l\'angle d\'un servomoteur (de -90 à 90) sur les broches digitales de. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au servomoteur.';
Blockly.Msg['DEVICES_GROVE_RELAY_CONTROL_TITLE'] = '[Module relais] contrôler le relais à l\'état %1 sur la broche %2';
Blockly.Msg['DEVICES_GROVE_RELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Permet de contrôler la valeur du relais (0 ou 1) sur les broches digitales.';
Blockly.Msg['DEVICES_GROVE_VIBRATIONMOTOR_CONTROL_TITLE'] = '[Moteur à vibration] contrôler le moteur à l\'état %1 sur la broche  %2';
Blockly.Msg['DEVICES_GROVE_VIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver le moteur à vibration grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['DEVICES_GROVE_VIBRATIONMOTOR_SET_TITLE'] = '[Moteur à vibration] contrôler à la valeur %1 sur la broche  %2';
Blockly.Msg['DEVICES_GROVE_VIBRATIONMOTOR_SET_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Permet de contrôler la valeur du moteur à vibration grove (0-255) sur les broches PWM.';
Blockly.Msg['DEVICES_GROVE_MOTOR_SETPOWERSTATE_TITLE'] = '[Motor] contrôler l\'état à %1 sur la broche %2';
Blockly.Msg['DEVICES_GROVE_MOTOR_SETPOWERSTATE_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permet de contrôler l\'état du moteur (0 ou 1) sur les broches digitales. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au moteur.';
Blockly.Msg['DEVICES_GROVE_MOTOR_SETPOWERVALUE_TITLE'] = '[Motor] contrôler la puissance à %1 (%) sur la broche %2';
Blockly.Msg['DEVICES_GROVE_MOTOR_SETPOWERVALUE_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permet de contrôler la puissance d\'un moteur (0-100) sur les broches pwm. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au moteur.';
// Devices - Pins
Blockly.Msg['IO_HUB_DIGITALSIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_HUB_DIGITALSIGNAL_HIGH'] = 'HAUT (1)';
Blockly.Msg['IO_HUB_DIGITALSIGNAL_LOW'] = 'BAS (0)';
Blockly.Msg['IO_HUB_DIGITALSIGNAL_TOOLTIP'] = 'Renvoie une valeur booléene (1 si HAUT ou 0 si BAS).';
Blockly.Msg['IO_HUB_READDIGITALPIN_TITLE'] = 'état de la broche numérique %1';
Blockly.Msg['IO_HUB_READDIGITALPIN_TOOLTIP'] = IMG_MODULE_PINS + Blockly.Tooltip.SEP + 'Permet de lire la valeur d\'une entrée digitale (0 ou 1).';
Blockly.Msg['IO_HUB_WRITEDIGITALPIN_TITLE'] = 'écrire sur la broche numérique %1 l\'état %2';
Blockly.Msg['IO_HUB_WRITEDIGITALPIN_TOOLTIP'] = IMG_MODULE_PINS + Blockly.Tooltip.SEP + 'Permet d\'écrire une valeur sur une entrée digitale (0 ou 1).';
Blockly.Msg['IO_HUB_READANALOGPIN_TITLE'] = 'lire la broche analogique %1';
Blockly.Msg['IO_HUB_READANALOGPIN_TOOLTIP'] = IMG_MODULE_PINS + Blockly.Tooltip.SEP + 'Permet de lire la valeur d\'une entrée analogique (0-1023).';
Blockly.Msg['IO_HUB_WRITEANALOGPIN_TITLE'] = 'écrire sur la broche analogique %1 la valeur %2';
Blockly.Msg['IO_HUB_WRITEANALOGPIN_TOOLTIP'] = IMG_MODULE_PINS + Blockly.Tooltip.SEP + 'Permet d\'écrire une valeur sur une entrée analogique (0-255).';
Blockly.Msg['IO_HUB_SETPWM_TITLE'] = 'appliquer un signal de fréquence %1 (Hz) cycle %2 (%) sur la broche %3';
Blockly.Msg['IO_HUB_SETPWM_TOOLTIP'] = IMG_MODULE_PINS + Blockly.Tooltip.SEP + 'Permet d\'appliquer un signal PWM de fréquence comprise entre 1 et 500 Hz et un cycle de 0 à 100 %.';
// TI Plotlib - Configure
Blockly.Msg['TI_PLOTLIB_CLS_TITLE'] = 'effacer l\'écran';
Blockly.Msg['TI_PLOTLIB_CLS_TOOLTIP'] = 'Efface l\'écran de la calculatrice TI-83.';
Blockly.Msg['TI_PLOTLIB_WINDOW_TITLE'] = 'définir taille de la fenêtre xmin %1 xmax %2 ymin %3 ymax %4';
Blockly.Msg['TI_PLOTLIB_WINDOW_TOOLTIP'] = 'Définit la taille de la fenêtre graphique de la calculatrice TI-83.';
Blockly.Msg['TI_PLOTLIB_AUTO_WINDOW_TITLE'] = 'définir taille de la fenêtre automatiquement avec %1 abscisses %2 ordonnées %3';
Blockly.Msg['TI_PLOTLIB_AUTO_WINDOW_TOOLTIP'] = 'Définit la taille de la fenêtre graphique de la calculatrice TI-83 avec les minimum et maximum des abscisses et ordonnées.';
Blockly.Msg['TI_PLOTLIB_GRID_TITLE'] = 'afficher la grille à l\'échelle x %1 y %2 type %3';
Blockly.Msg['TI_PLOTLIB_GRID_TOOLTIP'] = 'Affiche une grille avec des traits pleins, hachurés, ou en pointillés sur la calculatrice TI-83. Attention, la taille de la fenêtre doit être définie avant la grille pour avoir une grille à la bonne échelle.';
Blockly.Msg['TI_PLOTLIB_AXES_TITLE'] = 'définir les axes à %1';
Blockly.Msg['TI_PLOTLIB_AXES_TOOLTIP'] = 'Configure les axes de la fenêtre graphique de la calculatrice TI-83.';
Blockly.Msg['TI_PLOTLIB_LABELS_TITLE'] = 'ajouter étiquette x %1 position %2 et y %3 position %4';
Blockly.Msg['TI_PLOTLIB_LABELS_TOOLTIP'] = 'Ajoute two étiquettes dans fenêtre graphique de la calculatrice TI-83. Les étiquettes x et y se trouvent respectivement à gauche et à droite de la fenêtre. La position définit la position sur l\'axe vertical.';
Blockly.Msg['TI_PLOTLIB_TITLE_TITLE'] = 'ajouter le titre %1';
Blockly.Msg['TI_PLOTLIB_TITLE_TOOLTIP'] = 'Ajoute un titre au centre de la fenêtre graphique de la calculatrice TI-83.';
Blockly.Msg['TI_PLOTLIB_SHOWPLOT_TITLE'] = 'afficher le graphe';
Blockly.Msg['TI_PLOTLIB_SHOWPLOT_TOOLTIP'] = 'Permet d\'afficher le graphe dans la fenêtre de la calculatrice TI-83.';
// TI Plotlib - Draw
Blockly.Msg['TI_PLOTLIB_DEFINE_COLOR_TITLE'] = 'changer la couleur à R %1 V %2 B %3';
Blockly.Msg['TI_PLOTLIB_DEFINE_COLOR_TOOLTIP'] = 'Permet de changer la couleur du pinceau de la fenêtre graphique de la calculatrice TI-83 en changeant R,V et B (de 0 à 255).';
Blockly.Msg['TI_PLOTLIB_DEFINE_PALETTE_COLOR_TITLE'] = 'changer la couleur à %1';
Blockly.Msg['TI_PLOTLIB_DEFINE_PALETTE_COLOR_TOOLTIP'] = 'Permet de changer la couleur du pinceau sélectionnée dans la palette de la fenêtre graphique de la calculatrice TI-83.';
Blockly.Msg['TI_PLOTLIB_SCATTER_TITLE'] = 'tracer le nuage de points %1 %2 abscisses %3 ordonnées %4';
Blockly.Msg['TI_PLOTLIB_SCATTER_TOOLTIP'] = 'Trace un nuage de points avec la liste des abscisses et la liste des ordonnées sur la fenêtre graphique de la calculatrice TI-83.';
Blockly.Msg['TI_PLOTLIB_LIN_REG_TITLE'] = 'tracer la droite de régression linéaire %1 (list des X) et %2 (list des Y) en position %3 et sur la ligne %4';
Blockly.Msg['TI_PLOTLIB_LIN_REG_TOOLTIP'] = 'Trace la droite de régression linéaire avec la liste des abscisses et la liste des ordonnées sur la fenêtre graphique de la calculatrice TI-83.';
Blockly.Msg['TI_PLOTLIB_PLOT_TITLE'] = 'tracer le graphe %1 %2 abscisses %3 ordonnées %4';
Blockly.Msg['TI_PLOTLIB_PLOT_TOOLTIP'] = 'Trace le graphe avec la liste des abscisses et la liste des ordonnées sur la fenêtre graphique de la calculatrice TI-83.';
Blockly.Msg['TI_PLOTLIB_LINE_TITLE'] = 'dessiner une %1 entre A (%2,%3) et B (%4,%5)';
Blockly.Msg['TI_PLOTLIB_LINE'] = 'ligne';
Blockly.Msg['TI_PLOTLIB_ARROW'] = 'flèche';
Blockly.Msg['TI_PLOTLIB_LINE_TOOLTIP'] = 'Permet de dessiner une ligne ou une flèche entre les points A et B points sur la fenêtre graphique de la calculatrice TI-83.';
Blockly.Msg['TI_PLOTLIB_PEN_TITLE'] = 'utiliser un pinceau %1 type %2';
Blockly.Msg['TI_PLOTLIB_PEN_THIN'] = 'fin';
Blockly.Msg['TI_PLOTLIB_PEN_MEDIUM'] = 'moyen';
Blockly.Msg['TI_PLOTLIB_PEN_THICK'] = 'épais';
Blockly.Msg['TI_PLOTLIB_PEN_SOLID'] = 'trait plein';
Blockly.Msg['TI_PLOTLIB_PEN_DOT'] = 'pointillé';
Blockly.Msg['TI_PLOTLIB_PEN_DASH'] = 'long pointillé';
Blockly.Msg['TI_PLOTLIB_PEN_TOOLTIP'] = 'Permet de changer le type de pinceau de la fenêtre graphique de la calculatrice TI-83.';
Blockly.Msg['TI_PLOTLIB_TEXT_AT_TITLE'] = 'écrire le texte %1 à la ligne %2 position %3';
Blockly.Msg['TI_PLOTLIB_TEXT_AT_LEFT'] = 'à gauche';
Blockly.Msg['TI_PLOTLIB_TEXT_AT_CENTER'] = 'centré';
Blockly.Msg['TI_PLOTLIB_TEXT_AT_RIGHT'] = 'à droite';
Blockly.Msg['TI_PLOTLIB_TEXT_AT_TOOLTIP'] = 'Ecrit du texte dans la fenêtre graphique de la calculatrice TI-83.';
// Robots - Rover
Blockly.Msg['TI_ROVER_RIGHT'] = 'droit';
Blockly.Msg['TI_ROVER_LEFT'] = 'gauche';
Blockly.Msg['TI_ROVER_BY_RIGHT'] = Blockly.Msg['TI_ROVER_RIGHT'];
Blockly.Msg['TI_ROVER_BY_LEFT'] = Blockly.Msg['TI_ROVER_LEFT'];
Blockly.Msg['TI_ROVER_BOTH_SIDES'] = 'des deux côtés';
Blockly.Msg['TI_ROVER_GO_FORWARD'] = 'avancer';
Blockly.Msg['TI_ROVER_GO_REVERSE'] = 'reculer';
Blockly.Msg['TI_ROVER_GO_TITLE'] = '[Rover] %1 de %2 unité.s à la vitesse %3 (m.s-1)';
Blockly.Msg['TI_ROVER_GO_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permet de contrôler la marche (AVANT/ARRIERE) ainsi que le nombre d\'unités que doit parcourir le robot Rover (1 unité = 10 cm). Vous pouvez également changer la vitesse du robot Rover [0.14-0.23] en mètres par seconde.';
Blockly.Msg['TI_ROVER_GO_TIME_TITLE'] = '[Rover] %1 pendant %2 (s) à la vitesse %3 (m.s-1)';
Blockly.Msg['TI_ROVER_GO_TIME_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permet de contrôler la marche (AVANT/ARRIERE) pendant une durée définie en seconde du robot Rover. Vous pouvez également changer la vitesse du robot Rover [0.14-0.23] en mètres par seconde.';
Blockly.Msg['TI_ROVER_TURNTO_TITLE'] = '[Rover] pivoter vers la %1 angle %2 (°)';
Blockly.Msg['TI_ROVER_TURNTO_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permet de pivoter à droite ou à gauche d\'un certain angle (en °) avec le robot Rover.';
Blockly.Msg['TI_ROVER_RIGHT_BIS'] = Blockly.Msg['TI_ROVER_RIGHT'];
Blockly.Msg['TI_ROVER_CONTROLMOTOR_TITLE'] = '[Rover] contrôler le moteur %1 direction %2 vitesse %3 pendant %4 (s)';
Blockly.Msg['TI_ROVER_CONTROLMOTOR_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit et gauche en changeant la direction (↻ : AVANT, ↺ : ARRIERE), le nombre d\'unités et la durée (en s) du robot Rover.';
Blockly.Msg['TI_ROVER_MOVETOXY_TITLE'] = '[Rover] se déplacer à la position x %1 y %2';
Blockly.Msg['TI_ROVER_MOVETOXY_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permet de bouger le robot Rover à une certaine position dans le repère cartésien.';
Blockly.Msg['TI_ROVER_MOVETOPOLAR_TITLE'] = '[Rover] se déplacer dans le repère polaire r %1 θ %2';
Blockly.Msg['TI_ROVER_MOVETOPOLAR_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permet de bouger le robot Rover à une certaine position dans le repère polaire.';
Blockly.Msg['TI_ROVER_STAY_TITLE'] = '[Rover] arrêter le robot pendant %1 (s)';
Blockly.Msg['TI_ROVER_STAY_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permet d\'arrêter le robot Rover pendant une durée déterminée en seconde.';
Blockly.Msg['TI_ROVER_STOP_TITLE'] = '[Rover] arrêter la course';
Blockly.Msg['TI_ROVER_STOP_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permet d\'arrêter la course du robot Rover.';
Blockly.Msg['TI_ROVER_RESUME_TITLE'] = '[Rover] reprendre la course';
Blockly.Msg['TI_ROVER_RESUME_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permet de reprendre l\'exécution des commandes du robot Rover.';
// Rover - Inputs
Blockly.Msg['TI_ROVER_ULTRASONICRANGER_TITLE'] = '[Rover - Capteur à ultrasons] distance (m)';
Blockly.Msg['TI_ROVER_ULTRASONICRANGER_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Renvoie la distance (en m) entre un object et le robot Rover grâce au capteur de distance à ultrasons.';
Blockly.Msg['TI_ROVER_COLORSENSOR_GETLEVEL_TITLE'] = '[Rover - Capteur de couleur] niveau de %1 sous le robot';
Blockly.Msg['TI_ROVER_COLORSENSOR_GETLEVEL_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Renvoie le niveau de (gris/rouge/vert/bleu) avec le capteur de couleur situé sous le robot Rover.';
Blockly.Msg['TI_ROVER_COLOR_GRAY'] = 'gris';
Blockly.Msg['TI_ROVER_COLOR_RED'] = 'rouge';
Blockly.Msg['TI_ROVER_COLOR_GREEN'] = 'vert';
Blockly.Msg['TI_ROVER_COLOR_BLUE'] = 'bleu';
Blockly.Msg['TI_ROVER_COLORSENSOR_GETCOLOR_TITLE'] = '[Rover - Capteur de couleur] couleur mesurée';
Blockly.Msg['TI_ROVER_COLORSENSOR_GETCOLOR_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Returns the color measurement from color sensor placed under the rover robot as (1:rouge, 2:vert, 3:bleu, 4:cyan, 5:magenta, 6:jaune, 7:noir, 8:blanc, 9:gris).';
Blockly.Msg['TI_ROVER_GYROSCOPE_GETANGULARSPEED_TITLE'] = '[Rover - Gyroscope] vitesse angulaire (rad/s)';
Blockly.Msg['TI_ROVER_GYROSCOPE_GETANGULARSPEED_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Renvoie la vitesse angulaire (en rad/s) mesurée avec le gyroscope du robot Rover.';
Blockly.Msg['TI_ROVER_GYROSCOPE_GETANGLE_TITLE'] = '[Rover - Gyroscope] position angulaire (°)';
Blockly.Msg['TI_ROVER_GYROSCOPE_GETANGLE_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Renvoie la position angulaire (en °) mesurée avec le gyroscope du robot Rover.';
// Rover - Outputs
Blockly.Msg['TI_ROVER_SETRGBLED_TITLE'] = '[Rover - RGB] contrôler la LED à R %1 G %2 B %3';
Blockly.Msg['TI_ROVER_SETRGBLED_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la LED RGB du robot Rover, donner une valeur entre 0 et 255 pour Rouge, Vert et Bleu.';
Blockly.Msg['TI_ROVER_SETRGBLEDPALETTE_TITLE'] = '[Rover - RGB] contrôler la LED à %1';
Blockly.Msg['TI_ROVER_SETRGBLEDPALETTE_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la LED RGB du robot Rover, choisir une couleur dans la palette.';
Blockly.Msg['TI_ROVER_BLINKRGBLED_TITLE'] = '[Rover - RGB] faire clignoter à la fréquence %1 (Hz) pendant %2 (s)';
Blockly.Msg['TI_ROVER_BLINKRGBLED_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Fait clignoter la LED RGB du robot Rover à une certaine fréquence et pendant une certaine durée définie en seconde.';
Blockly.Msg['TI_ROVER_STOPRGBLED_TITLE'] = '[Rover - RGB] éteindre la LED';
Blockly.Msg['TI_ROVER_STOPRGBLED_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Eteindre la LED RGB du robot Rover.';
// Micro:bit - Commandes
Blockly.Msg['MICROBIT_TYPE_IS'] = 'est';
Blockly.Msg['MICROBIT_TYPE_WAS'] = 'a été';
Blockly.Msg['MICROBIT_SLEEP_TITLE'] = '[micro:bit] attendre %1 %2';
Blockly.Msg['MICROBIT_SLEEP_TOOLTIP'] = 'Effectue une pause dans l\'exécution du code. La fonction micro:bit.sleep() prend en argument des millisecondes.';
Blockly.Msg['MICROBIT_SLEEP_SECOND'] = Blockly.Msg['SECOND'];
Blockly.Msg['MICROBIT_SLEEP_MILLISECOND'] = Blockly.Msg['MILLISECOND'];
Blockly.Msg['MICROBIT_SLEEP_MICROSECOND'] = Blockly.Msg['MICROSECOND'];
Blockly.Msg['MICROBIT_WHILE_CONDITION_TITLE'] = '[micro:bit] répéter tant que %1';
Blockly.Msg['MICROBIT_WHILE_CONDITION_TOOLTIP'] = 'Répéter la boucle tant que la condition est vérifiée.';
Blockly.Msg['MICROBIT_ESCAPE_TITLE'] = '[micro:bit] exécution arrêtée ?';
Blockly.Msg['MICROBIT_ESCAPE_TOOLTIP'] = 'Renvoie \'True\' si le bouton \'annul\' a été appuyé.';
Blockly.Msg['MICROBIT_DISP_CLR_TITLE'] = '[micro:bit] effacer le texte';
Blockly.Msg['MICROBIT_DISP_CLR_TOOLTIP'] = 'Permet d\'effacer le texte sur l\'écran de la calculatrice TI-83.';
Blockly.Msg['MICROBIT_STORE_LIST_TITLE'] = '[micro:bit] conserver la liste %1 avec l\'indice %2';
Blockly.Msg['MICROBIT_STORE_LIST_TOOLTIP'] = 'Permet de conserver un maximum de 6 listes avec les indices (\'1\'-\'6\').';
Blockly.Msg['MICROBIT_TEMPERATURE_TITLE'] = '[micro:bit] température en %1';
Blockly.Msg['MICROBIT_TEMPERATURE_TOOLTIP'] = 'Renvoie la température en degré Celius (°C), Fahrenheit (°F) ou Kelvin (K) du processeur de la carte micro:bit.';
// Micro:bit - Screen 
Blockly.Msg['SHOW_STRING_TITLE'] = '[Écran] faire défiler %1';
Blockly.Msg['SHOW_NUMBER_TITLE'] = '[Écran] afficher %1';
Blockly.Msg['SHOW_LEDS_TITLE'] = '[Écran] afficher l\'image';
Blockly.Msg['SHOW_ICON_TITLE'] = '[Écran] afficher l\'icone %1';
Blockly.Msg['SHOW_GAUGE_TITLE'] = '[Écran] afficher la jauge de %1 Maximum %2';
Blockly.Msg['SHOW_GAUGE_TOOLTIP'] = 'Affiche la gauge d\'une mesure d\'un capteur (ou d\'un nombre) sur l\'écran de la carte micro:bit en définissant la valeur maximale correspondant à la jauge remplie.';
Blockly.Msg['SHOW_CLOCK_TITLE'] = '[Écran] afficher l\'horloge %1';
Blockly.Msg['SHOW_ARROW_TITLE'] = '[Écran] afficher la flèche %1';
Blockly.Msg['SHOW_ARROW_TOOLTIP'] = 'Permet d\'afficher les flèches de 8 directions (N,NE,E,SE,S...) sur l\'écran de la carte micro:bit.';
Blockly.Msg['SENSORS_GETLIGHT_TITLE'] = '[Écran] luminosité';
Blockly.Msg['SENSORS_GETLIGHT_TOOLTIP'] = 'Renvoie la luminosité (de 0 à 255) grâce aux LEDs de l\'écran de la carte micro:bit.';
Blockly.Msg['CLEAR_TITLE'] = '[Écran] éteindre les leds';
Blockly.Msg['SET_PIXEL_TITLE'] = '[Écran] contrôler la led x %1 y %2 état %3';
Blockly.Msg['SET_PIXEL_TOOLTIP'] = 'Permet de contrôler l\'état (ON/OFF) de chaque LED de l\'écran de la carte micro:bit.';
Blockly.Msg['SET_LIGHT_PIXEL_TITLE'] = '[Écran] contrôler la led x %1 y %2 luminosité %3';
Blockly.Msg['SET_LIGHT_PIXEL_TOOLTIP'] = 'Permet de choisir la luminosité (de 0 à 9) des LED de l\'écran de la carte micro:bit.';
// Micro:bit - Music
Blockly.Msg['MICROBIT_MUSIC_PLAYMUSIC_TITLE'] = '[Music] jouer la musique %1';
Blockly.Msg['MICROBIT_MUSIC_PLAYMUSIC_TOOLTIP'] = 'Permet de jouer une musique avec le haut-parleur intégré à la micro:bit v2.';
Blockly.Msg['MICROBIT_MUSIC_PLAYSONG_TITLE'] = '[Music] jouer la mélodie %1';
Blockly.Msg['MICROBIT_MUSIC_PLAYSONG_TOOLTIP'] = 'Permet de jouer une musique avec le haut-parleur intégré à la micro:bit v2.';
Blockly.Msg['MICROBIT_MUSIC_PLAYNOTES_TITLE'] = '[Music] jouer les notes';
Blockly.Msg['MICROBIT_MUSIC_PLAYNOTES_TOOLTIP'] = 'Permet de jouer des notes avec le haut-parleur intégré à la micro:bit v2.';
Blockly.Msg['MICROBIT_MUSIC_NOTE_TITLE'] = 'note %1 à l\'octave %2 durée %3';
Blockly.Msg['MICROBIT_MUSIC_NOTE_TOOLTIP'] = 'Permet de définir une note à une certaine octave pendant une durée déterminée.';
Blockly.Msg['NOTE_C'] = 'Do';
Blockly.Msg['NOTE_C_SHARP'] = 'Do#';
Blockly.Msg['NOTE_D'] = 'Ré';
Blockly.Msg['NOTE_D_SHARP'] = 'Ré#';
Blockly.Msg['NOTE_E'] = 'Mi';
Blockly.Msg['NOTE_F'] = 'Fa';
Blockly.Msg['NOTE_F_SHARP'] = 'Fa#';
Blockly.Msg['NOTE_G'] = 'Sol';
Blockly.Msg['NOTE_G_SHARP'] = 'Sol#';
Blockly.Msg['NOTE_A'] = 'La';
Blockly.Msg['NOTE_A_SHARP'] = 'La#';
Blockly.Msg['NOTE_B'] = 'Si';
Blockly.Msg['MUSIC_SILENCE'] = 'Silence';
Blockly.Msg['MICROBIT_MUSIC_PLAYFREQUENCY_TITLE'] = '[Music] jouer la fréquence %1 pendant %2 (ms)';
Blockly.Msg['MICROBIT_MUSIC_PLAYFREQUENCY_TOOLTIP'] = 'Permet de jouer une fréquence sur le haut-parleur intégré à la micro:bit v2.';
Blockly.Msg['MICROBIT_MUSIC_SETTEMPO_TITLE'] = '[Music] définir la pulsation %1 et le tempo %2';
Blockly.Msg['MICROBIT_MUSIC_SETTEMPO_TOOLTIP'] = 'Permet de définir le nombre de pulsations par mesure et le tempo de la musique jouée avec la micro:bit v2.';
Blockly.Msg['MICROBIT_MUSIC_SETVOLUME_TITLE'] = '[Music] définir le volume à %1';
Blockly.Msg['MICROBIT_MUSIC_SETVOLUME_TOOLTIP'] = 'Permet de changer le volume du haut-parleur intégré à la micro:bit v2 de 0 à 255.';
// Micro:bit - Audio
Blockly.Msg['MICROBIT_AUDIO_PLAY_TITLE'] = '[Audio] jouer la musique %1';
Blockly.Msg['MICROBIT_AUDIO_PLAY_TOOLTIP'] = 'Permet de jouer une musique avec le haut-parleur intégré à la micro:bit v2.';
Blockly.Msg['MICROBIT_AUDIO_STOP_TITLE'] = '[Audio] arrêter la musique';
Blockly.Msg['MICROBIT_AUDIO_STOP_TOOLTIP'] = 'Permet d\'arrêter la musique du haut-parleur intégré à la micro:bit v2.';
// Micro:bit - Microphone
Blockly.Msg['IO_MICRO_LOUD'] = 'fort';
Blockly.Msg['IO_MICRO_QUIET'] = 'faible';
Blockly.Msg['IO_MICRO_IS'] = Blockly.Msg['MICROBIT_TYPE_IS'];
Blockly.Msg['IO_MICRO_WAS'] = Blockly.Msg['MICROBIT_TYPE_WAS'];
Blockly.Msg['IO_MICRO_ONSOUNDDETECTED_TITLE'] = '[Micro] si un son %1 %2 détecté alors';
Blockly.Msg['IO_MICRO_ONSOUNDDETECTED_TOOLTIP'] = 'Exécute des instructions si un son (fort/faible) est détecté avec \'is\'. Si l\'option est \'was\': Exécute des instructions si un son (fort/faible) s\'est produit depuis le dernier appel de la fonction \'was_sound()\'.';
Blockly.Msg['IO_MICRO_GETCURRENTSOUND_TITLE'] = '[Micro] état du son';
Blockly.Msg['IO_MICRO_GETCURRENTSOUND_TOOLTIP'] = 'Renvoie l\'état du son (fort/faible).';
Blockly.Msg['IO_MICRO_SOUNDDETECTED_TITLE'] = '[Micro] son %1 %2 détecté';
Blockly.Msg['IO_MICRO_SOUNDDETECTED_TOOLTIP'] = 'Renvoie \'True\' si un son (fort/faible) s\'est produit depuis le dernier appel de la fonction \'was_event()\' ou bien si le son est fort avec l\'appel \'is_event()\'.';
Blockly.Msg['IO_MICRO_GETSOUNDLEVEL_TITLE'] = '[Micro] intensité du son';
Blockly.Msg['IO_MICRO_GETSOUNDLEVEL_TOOLTIP'] = 'Permet d\'obtenir l\'intensité du son.';
Blockly.Msg['IO_MICRO_SETSOUNDTHRESHOLD_TITLE'] = '[Micro] définir le seuil des sons %1 à %2';
Blockly.Msg['IO_MICRO_SETSOUNDTHRESHOLD_TOOLTIP'] = 'Permet de définir un seuil du niveau sonore des sons forts/faibles de 0 à 255.';
Blockly.Msg['IO_MICRO_SOUNDCONDITION_TITLE'] = '[Micro] %1';
Blockly.Msg['IO_MICRO_SOUNDCONDITION_TOOLTIP'] = 'Permet d\'utiliser les constantes (LOUD/QUIET) de la librairie microphone dans les blocs de la catégorie \'Logique\'';
// Micro:bit - Buttons
Blockly.Msg['IO_ONBUTTONPRESSED_TITLE'] = '[boutons] si le bouton %1 %2 appuyé alors';
Blockly.Msg['IO_ONBUTTONPRESSED_TOOLTIP'] = 'Exécute des instructions si les boutons A ou B sont préssés.';
Blockly.Msg['IO_ISPRESSED'] = Blockly.Msg['MICROBIT_TYPE_IS'];
Blockly.Msg['IO_WASPRESSED'] = Blockly.Msg['MICROBIT_TYPE_WAS'];
Blockly.Msg['IO_ISBUTTONPRESSED_TITLE'] = '[boutons] bouton %1 %2 appuyé';
Blockly.Msg['IO_ISBUTTONPRESSED_TOOLTIP'] = 'Renvoie \'True\' si le bouton A ou B est pressé, et \'False\' sinon.';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TITLE'] = '[boutons] nombre de clics du bouton %1';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TOOLTIP'] = 'Retourne le nombre de fois qu\'a été appuyé le bouton A ou B.';
Blockly.Msg['IO_IS_LOGO_TOUCHED_TITLE'] = '[boutons] logo est touché';
Blockly.Msg['IO_IS_LOGO_TOUCHED_TOOLTIP'] = 'Renvoie \'True\' si le logo de la carte micro:bit (v2) est touché.';
// Micro:bit - Sensors
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_BY_AXIS_TITLE'] = '[Accéléromètre] accélération (mg) selon l\'axe %1';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_BY_AXIS_TOOLTIP'] = 'Renvoie l\'accélération (en mg) selon un axe particulier grâce à l\'accéléromètre intégré de la carte micro:bit.';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_VALUES_TITLE'] = '[Accéléromètre] accélérations (mg) sur les 3 axes';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_VALUES_TOOLTIP'] = 'Renvoie les accélérations (en mg) suivant les 3 axes sous forme de tuple (x, y, z) grâce à l\'accéléromètre intégré de la carte micro:bit.';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_MAGNITUDE_TITLE'] = '[Accéléromètre] magnitude (m.s-2)';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_MAGNITUDE_TOOLTIP'] = 'Renvoie la magnitude (en m.s-2) grâce à l\'accéléromètre intégré de la carte micro:bit.';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_ROTATION_TITLE'] = '[Accéléromètre] rotation (°) %1';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_ROTATION_PITCH'] = 'tangage';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_ROTATION_ROLL'] = 'roulis';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_ROTATION_TOOLTIP'] = 'Renvoie la rotation (de -180° à 180°) mesurée avec l\'accéléromètre de la carte micro:bit.';
Blockly.Msg['MICROBIT_COMPASS_HEADING_TITLE'] = '[Boussole] orientation (°)';
Blockly.Msg['MICROBIT_COMPASS_HEADING_TOOLTIP'] = 'Renvoie le cap de la boussole, sous la forme d\'un entier compris entre 0 et 360, représentant l\'angle en degrés, dans le sens des aiguilles d\'une montre, avec le nord à 0°.';
Blockly.Msg['MICROBIT_COMPASS_GET_MAGNETIC_STRENGTH_BY_AXIS_TITLE'] = '[Boussole] intensité du champ magnétique suivant %1 (nT)';
Blockly.Msg['MICROBIT_COMPASS_GET_MAGNETIC_STRENGTH_BY_AXIS_TOOLTIP'] = 'Renvoie la lecture de l\'intensité du champ magnétique sur n\'importe quel axe (en nT), sous forme d\'entier positif ou négatif, selon la direction du champ.';
Blockly.Msg['MICROBIT_COMPASS_IS_CALIBRATED_TITLE'] = '[Boussole] est calibrée';
Blockly.Msg['MICROBIT_COMPASS_IS_CALIBRATED_TOOLTIP'] = 'Renvoie \'True\' si la boussole est calibrée, sinon renvoie \'False\'.';
Blockly.Msg['MICROBIT_COMPASS_GET_FIELD_STRENGTH_TITLE'] = '[Boussole] intensité du champ magnétique (nT)';
Blockly.Msg['MICROBIT_COMPASS_GET_FIELD_STRENGTH_TOOLTIP'] = 'Renvoie une indication entière de l\'amplitude du champ magnétique (en nT) autour de la carte micro:bit.';
Blockly.Msg['MICROBIT_COMPASS_CALIBRATE_TITLE'] = '[Boussole] %1';
Blockly.Msg['MICROBIT_COMPASS_CALIBRATE_TOOLTIP'] = 'Démarre le processus de calibration. Un message instructif sera présenté à l\'utilisateur, après quoi il devra faire pivoter l\'appareil afin de dessiner un cercle sur l\'écran à LED. La 2nde option permet d\'annuler la calibration.';
Blockly.Msg['MICROBIT_COMPASS_CALIBRATE'] = 'calibrer';
Blockly.Msg['MICROBIT_COMPASS_CLEAR_CALIBRATION'] = 'annuler la calibration';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_UP'] = 'logo vers le haut';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_DOWN'] = 'logo vers le bas';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_LEFT'] = 'penché à gauche';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_RIGHT'] = 'penché à droite';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_FACE_UP'] = 'écran vers le haut';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_FACE_DOWN'] = 'écran vers le bas';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_SHAKE'] = 'secoué';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_IS'] = Blockly.Msg['MICROBIT_TYPE_IS'];
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_WAS'] = Blockly.Msg['MICROBIT_TYPE_WAS'];
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_CURRENT_GESTURE_TITLE'] = '[Gestes] geste en cours';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_CURRENT_GESTURE_TOOLTIP'] = 'Renvoie le geste en cours de la carte micro:bit: \'up\', \'down\', \'left\', \'right\', \'face up\', \'face down\' ou \'shake\'.';
Blockly.Msg['MICROBIT_ACCELEROMETER_ON_GESTURE_TYPE_TITLE'] = '[Gestes] si %1 %2 réalisé alors';
Blockly.Msg['MICROBIT_ACCELEROMETER_ON_GESTURE_TYPE_TOOLTIP'] = 'Exécute des instructions si le geste sélectionné est ou a été réalisé avec la carte micro:bit.';
Blockly.Msg['MICROBIT_ACCELEROMETER_IS_GESTURE_TITLE'] = '[Gestes] geste %1 %2';
Blockly.Msg['MICROBIT_ACCELEROMETER_IS_GESTURE_TOOLTIP'] = 'Renvoie \'True\' si le geste sélectionné est ou a été réalisé avec la carte micro:bit, sinon renvoie \'False\'.';
// Micro:bit - Radio
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TITLE'] = '[Radio] envoyer la chaîne %1';
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TOOLTIP'] = 'Permet d\'envoyer uen chaîne de caractères via la radio de la carte micro:bit.';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TITLE'] = '[Radio] envoyer le nombre ou la liste %1';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TOOLTIP'] = 'Permet d\'envoyer des nombres ou une liste via la radio de la carte micro:bit.';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TITLE'] = '[Radio] envoyer la valeur %1 = %2';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TOOLTIP'] = 'Permet d\'envoyer des données avec un nom et sa valeur via la radio de la carte micro:bit.';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TITLE'] = '[Radio] si une chaîne est reçue dans %1 alors';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si une chaîne de caractères est reçue par radio dans la variable \'stringData\'.';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TITLE'] = '[Radio] si un nombre est reçu dans %1 alors';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si un nombre est reçu par radio dans la variable \'numberData\'.';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TITLE'] = '[Radio] si une valeur est reçue dans %1 %2 alors';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si un nom et sa valeur sont reçus par radio dans les variables \'name\' et \'value\'.';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TITLE'] = '[Radio] configurer Canal %1 Puissance %2 Taille des données %3 Groupe %4';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TOOLTIP'] = 'Permet de configurer le canal de la radio (de 0 to 83), la taille des données transmises (en octets), la puissance de transmission (de 0 à 7)  ainsi que le group (de 0 à 255).';
// Micro:bit - Pins
Blockly.Msg['IO_MB_DIGITALSIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_MB_DIGITALSIGNAL_HIGH'] = 'HAUT (1)';
Blockly.Msg['IO_MB_DIGITALSIGNAL_LOW'] = 'BAS (0)';
Blockly.Msg['IO_MB_DIGITALSIGNAL_TOOLTIP'] = 'Renvoie une valeur booléene (1 si HAUT ou 0 si BAS).';
Blockly.Msg['IO_MB_READDIGITALPIN_TITLE'] = 'état de la broche numérique %1';
Blockly.Msg['IO_MB_READDIGITALPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée digitale (0 ou 1).';
Blockly.Msg['IO_MB_WRITEDIGITALPIN_TITLE'] = 'écrire sur la broche numérique %1 l\'état %2';
Blockly.Msg['IO_MB_WRITEDIGITALPIN_TOOLTIP'] = 'Permet d\'écrire une valeur sur une entrée digitale (0 ou 1).';
Blockly.Msg['IO_MB_READANALOGPIN_TITLE'] = 'lire la broche analogique %1';
Blockly.Msg['IO_MB_READANALOGPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée analogique (0-1023).';
Blockly.Msg['IO_MB_WRITEANALOGPIN_TITLE'] = 'écrire sur la broche analogique %1 la valeur %2';
Blockly.Msg['IO_MB_WRITEANALOGPIN_TOOLTIP'] = 'Permet d\'écrire une valeur sur une entrée analogique (0-1023). Cette fonction n\'écris pas réellement une valeur analogique. Elle utilise la PWM (Pulse-Width Modulation). Par exemple, écrire 511 fournit un signal ayant 50% du cycle, la tension moyenne est donc 1,65V.';
Blockly.Msg['IO_MB_SETPWM_TITLE'] = 'appliquer un signal de période %1 %2 sur la broche %3';
Blockly.Msg['IO_MB_SETPWM_TOOLTIP'] = 'Permet d\'appliquer un signal PWM avec une période en ms ou en sur une broche de période minimale 256 μs.';
// Micro:bit - Inputs
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Capteur SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur SHT31. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_MPX5700AP_GETPRESSURE_TITLE'] = '[Capteur MPX5700AP] pression (kPa) sur la broche %1';
Blockly.Msg['SENSORS_MPX5700AP_GETPRESSURE_TOOLTIP'] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + 'Permet de lire la pression du capteur Grove avec la calculatrice TI-83.';
Blockly.Msg['SENSORS_MPX5700AP_CALIBRATE_TITLE'] = '[Capteur MPX5700AP] calibrer le capteur m %1 b %2';
Blockly.Msg['SENSORS_MPX5700AP_CALIBRATE_TOOLTIP'] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + 'Permet de calibrer le capteur de pression grove avec la calculatrice TI-83.';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Capteur d\'humidité] humidité du sol sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Renvoie l\'humidité (de 0 à 1023) mesurée grâce au capteur d\'humidité grove sur les broches P0/P14, P1/P15 ou P2/P16.';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Capteur de T°] température en %1 sur la broche %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) du capteur de température Grove sur les broches P0 à P4, ou P10.';
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Capteur de lumière] luminosité sur la broche %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Renvoie la luminosité (de 0 à 1023) du capteur de lumière Grove sur les broches P0 à P4, ou P10.';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Capteur à ultrasons %1] %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Renvoie la distance (in cm) mesurée grâce au capteur grove à ultrasons sur les broches digitales P0 à P20. Attention, si le capteur est un modèle grove, TRIG et ECHO sont sur la même broche SIG.';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distance (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'durée de l\'aller-retour (µs)';
Blockly.Msg['SENSORS_ULTRASONIC_1PIN'] = 'sur la broche ';
Blockly.Msg['SENSORS_ULTRASONIC_2PINS'] = 'sur les broches ';
Blockly.Msg['MICROBIT_GROVE_READ_BME280_TITLE'] = '[Capteur BME280] %1';
Blockly.Msg['MICROBIT_GROVE_READ_BME280_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), la pression (en Pascal) ou l\'humidité (en %).';
Blockly.Msg['MICROBIT_GROVE_READ_BME280_TEMP'] = Blockly.Msg['SENSORS_TEMPERATURE'];
Blockly.Msg['MICROBIT_GROVE_READ_BME280_PRESS'] = Blockly.Msg['SENSORS_PRESSURE'];
Blockly.Msg['MICROBIT_GROVE_READ_BME280_HUM'] = Blockly.Msg['SENSORS_HUMIDITY'];
// Micro:bit - Outpus
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] contrôler la LED %1 sur la broche  %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Permet d\'activer ou désactiver la LED Grove (0 ou 1) sur les broches digitales P0 à P20.';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Moteur] contrôler la puissance à %1 sur la broche %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permet de contrôler la puissance d\'un moteur (de 0 à 1023) sur les broches digitales P0 à P20. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au moteur.';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Module relais] contrôler le relais à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Permet de contrôler la valeur du relais (0 ou 1) sur les broches digitales P0 à P20.';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servomoteur] contrôler l\'angle à %1 sur la broche %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler l\'angle d\'un servomoteur (de 0 à 180) sur les broches digitales P0 à P20. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au servomoteur.';
// Micro:bit - Neopixel
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] définir %1 LED sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de définir le nombre de LED du neopixel. Ce bloc doit être utilisé dans le bloc \'Au démarrage\'.';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] contrôler la LED %1 à R %2 G %3 B %4 sur la broche %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED tel que (R,G,B) de 0 à 255 du module neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] contrôler la LED %1 à %2 sur la broche %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du module neopixel. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] contrôler toutes les LED à R %1 G %2 B %3 sur la broche %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie telle que (R,G,B) soit de 0 à 255.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] contrôler toutes les LED à %1 sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] Arc-en-ciel sur la broche %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB. Il est possible de modifier la broche et le nombre de LED du module neopixel.';
Blockly.Msg['MICROBIT_NEOPIXEL_SWITCH_OFF_TITLE'] = '[Neopixel] éteindre toutes les LED sur la broche %1';
Blockly.Msg['MICROBIT_NEOPIXEL_SWITCH_OFF_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet d\'éteindre toutes les LED du module neopixel.';
Blockly.Msg['MICROBIT_NEOPIXEL_COLOR_TITLE'] = '[Neopixel - Color] definir la LED à R %1 G %2 B %3 sur la broche %4';
Blockly.Msg['MICROBIT_NEOPIXEL_COLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Permet de définir la couleur d'une LED RGB neopixel avec la classe Color";


// CE
Blockly.Msg['CE_BOX_DEFINE_BOX_TITLE'] = '[ce_box] définir la boîte statistique %1 données %2';
Blockly.Msg['CE_BOX_DEFINE_BOX_TOOLTIP'] = 'Définit une boîte avec les données statistiques de la liste fournie.';
Blockly.Msg['CE_BOX_TITLE_TITLE'] = '[ce_box] ajouter le titre %1';
Blockly.Msg['CE_BOX_TITLE_TOOLTIP'] = 'Ajoute un titre sur le graphique des statistiques.';
Blockly.Msg['CE_BOX_SHOW_TITLE'] = '[ce_box] afficher la boîte';
Blockly.Msg['CE_BOX_SHOW_TOOLTIP'] = 'Affiche les données statistiques sur l\'écran de la calculatrice TI-83.';
Blockly.Msg['CE_CHART_DATA_TITLE'] = 'nom %1 valeur %2';
Blockly.Msg['CE_CHART_DEFINE_CHART_TITLE'] = '[ce_chart] définir l\'histogramme %1 données %2';
Blockly.Msg['CE_CHART_DEFINE_CHART_TOOLTIP'] = 'Définit l\'histogramme avec les données de la liste fournie.';
Blockly.Msg['CE_CHART_TITLE_TITLE'] = '[ce_chart] ajouter le titre %1';
Blockly.Msg['CE_CHART_TITLE_TOOLTIP'] = 'Ajoute un titre sur l\'histogramme.';
Blockly.Msg['CE_CHART_FREQUENCIES_TITLE'] = '[ce_chart] appliquer la fréquence %1';
Blockly.Msg['CE_CHART_FREQUENCIES_TOOLTIP'] = 'Applique une fréquence à l\'histogramme.';
Blockly.Msg['CE_CHART_SHOW_TITLE'] = '[ce_chart] afficher l\'histogramme';
Blockly.Msg['CE_CHART_SHOW_TOOLTIP'] = 'Affiche l\'histogramme sur l\'écran de la calculatrice TI-83.';
Blockly.Msg['CE_QUIVR_ADD_LINE_PORTION_TITLE'] = '[ce_quivr] ajouter une portion de droite entre A (%1,%2) et B (%3,%4) couleur %5';
Blockly.Msg['CE_QUIVR_ADD_LINE_PORTION_TOOLTIP'] = 'Ajoute une portion de droite entre 2 points. Exemple: A (t, y(t)) et B (t+dt, y(t+dt)). Ce bloc peut être utilisé combiné avec la librairie ti_plotlib.';
Blockly.Msg['CE_QUIVR_ADD_VECTOR_TITLE'] = '[ce_quivr] ajouter un vecteur au point (%1,%2) dx %3 dy %4 couleur %5';
Blockly.Msg['CE_QUIVR_ADD_VECTOR_TOOLTIP'] = 'Ajoute un vecteur sur le point définit. dx et dy sont respectivements les longueurs du vecteur selon l\'axe x et l\'axe y. L\'option \'taille\' à la fin du bloc permet de réduire ou augmenter la taille du vecteur d\'un certain pourcentage. Ce bloc peut être utilisé combiné avec la librairie ti_plotlib.';
Blockly.Msg['CE_QUIVR_ADD_VECTOR_SIZE'] = 'taille';
// Turtle - Move
Blockly.Msg['TURTLE_MOVE_TITLE'] = '%1 de %2';
Blockly.Msg['TURTLE_MOVE_FORWARD'] = 'avancer';
Blockly.Msg['TURTLE_MOVE_BACKWARD'] = 'reculer';
Blockly.Msg['TURTLE_MOVE_TOOLTIP'] = 'Déplacer en spécifiant la distance à parcourir. Le dessin est compris dans une fenêtre de taille 300 en largeur et 200 en hauteur.';
Blockly.Msg['TURTLE_TURN_TITLE'] = 'tourner à %1 de %2°';
Blockly.Msg['TURTLE_TURN_RIGHT'] = 'droite ↻';
Blockly.Msg['TURTLE_TURN_LEFT'] = 'gauche ↺';
Blockly.Msg['TURTLE_TURN_TOOLTIP'] = 'Tourner en précisant la valeur de l\'angle (en °).';
Blockly.Msg['TURTLE_GOTO_TITLE'] = 'aller à la position x %1 y %2';
Blockly.Msg['TURTLE_GOTO_TOOLTIP'] = 'Aller à une postition à partir de l\'abscisse et l\'ordonnée.';
Blockly.Msg['TURTLE_DONE_TITLE'] = 'afficher le dessin';
Blockly.Msg['TURTLE_DONE_TOOLTIP'] = 'Permet de garder le dessin affiché sur l\'écran à la fin du programme.';
// Turtle - Draw
Blockly.Msg['TURTLE_FILLCOLOR_TITLE'] = 'définir la couleur de remplissage à R %1 G %2 B %3';
Blockly.Msg['TURTLE_FILLCOLOR_TOOLTIP'] = 'Définir la couleur de remplissage des formes avec R, G et B (de 0 à 255).';
Blockly.Msg['TURTLE_FILLCOLOR_PALETTE_TITLE'] = 'définir la couleur de remplissage à %1';
Blockly.Msg['TURTLE_FILLCOLOR_PALETTE_TOOLTIP'] = 'Définir la couleur de remplissage des formes en sélectionnant une couleur dans la palette.';
Blockly.Msg['TURTLE_SET_FILL_TITLE'] = '%1 le chemin de remplissage de la couleur';
Blockly.Msg['TURTLE_SET_FILL_TOOLTIP'] = 'Permet de contrôler le début et la fin du chemin pour définir la forme où on va remplir avec la couleur.';
Blockly.Msg['TURTLE_SET_FILL_BEGIN'] = 'démarrer';
Blockly.Msg['TURTLE_SET_FILL_END'] = 'terminer';
Blockly.Msg['TURTLE_DOT_TITLE'] = 'dessiner un disque de diamètre %1';
Blockly.Msg['TURTLE_DOT_TOOLTIP'] = 'Permet de dessiner un disque en renseignant le diamètre (0-300).';
Blockly.Msg['TURTLE_WRITE_TITLE'] = 'écrire le texte %1';
Blockly.Msg['TURTLE_WRITE_TOOLTIP'] = 'Permet d\'ajouter du texte à l\'endroit où se trouve la tortue.';
// Turtle - Pen
Blockly.Msg['TURTLE_CONTROL_PEN_TITLE'] = '%1 le crayon';
Blockly.Msg['TURTLE_CONTROL_PEN_TOOLTIP'] = 'Permet d\'activer/désactiver le dessin au crayon.';
Blockly.Msg['TURTLE_CONTROL_PEN_UP'] = 'lever';
Blockly.Msg['TURTLE_CONTROL_PEN_DOWN'] = 'activer';
Blockly.Msg['TURTLE_PENCOLOR_TITLE'] = 'définir la couleur du crayon à R %1 G %2 B %3';
Blockly.Msg['TURTLE_PENCOLOR_TOOLTIP'] = 'Définir la couleur du crayon avec R, G et B (de 0 à 255).';
Blockly.Msg['TURTLE_PENCOLOR_PALETTE_TITLE'] = 'définir la couleur du crayon à %1';
Blockly.Msg['TURTLE_PENCOLOR_PALETTE_TOOLTIP'] = 'Définir la couleur du crayon en sélectionnant une couleur dans la palette.';
Blockly.Msg['TURTLE_PENSIZE_TITLE'] = 'définir la largeur du crayon à %1';
Blockly.Msg['TURTLE_PENSIZE_TOOLTIP'] = 'Définir la largeur du crayon (1-4).';
// TUrtle - Settings
Blockly.Msg['TURTLE_CLEAR_TITLE'] = 'nettoyer le dessin';
Blockly.Msg['TURTLE_CLEAR_TOOLTIP'] = 'Permet de nettoyer le dessin sur l\'écran de la calculatrice TI-83.';
Blockly.Msg['TURTLE_CONTROL_TURTLE_TITLE'] = '%1 la tortue';
Blockly.Msg['TURTLE_CONTROL_TURTLE_TOOLTIP'] = 'Permet d\'activer/désactiver la tortue.';
Blockly.Msg['TURTLE_CONTROL_TURTLE_HIDE'] = 'hide';
Blockly.Msg['TURTLE_CONTROL_TURTLE_SHOW'] = 'show';
Blockly.Msg['TURTLE_HIDEGRID_TITLE'] = 'masquer la grille';
Blockly.Msg['TURTLE_HIDEGRID_TOOLTIP'] = 'Permet de masquer la grille.';
Blockly.Msg['TURTLE_SPEED_TITLE'] = 'changer la vitesse de dessin à %1';
Blockly.Msg['TURTLE_SPEED_TOOLTIP'] = 'Permet de changer la vitesse de la tortue, donc la vitesse de dessin sur l\'écran (0-10).';
// Turtle - State
Blockly.Msg['TURTLE_HOME_TITLE'] = 'replacer la tortue au centre du dessin';
Blockly.Msg['TURTLE_HOME_TOOLTIP'] = 'Permet de replacer la tortue au centre du dessin.';
Blockly.Msg['TURTLE_SET_HEADING_TITLE'] = 'orienter la tortue selon l\'angle %1 (°)';
Blockly.Msg['TURTLE_SET_HEADING_TOOLTIP'] = 'Permet d\'orienter la tortue (en °) sachant que la direction vers la droite correspond à 0°. Les angles positifs correspondant à un angle dans le sens horaire. Les angles négatifs sont dans le sens antihoraires.';
Blockly.Msg['TURTLE_GET_COORDINATES_TITLE'] = 'obtenir %1 coordinate';
Blockly.Msg['TURTLE_GET_COORDINATES_TOOLTIP'] = 'Renvoie la position de la tortue (en pixel) sachant que les dimensions du canvas sont x [-155;155] et y [-105;105].';
Blockly.Msg['TURTLE_GET_COORDINATES_XCOR'] = 'x';
Blockly.Msg['TURTLE_GET_COORDINATES_YCOR'] = 'y';
Blockly.Msg['TURTLE_HEADING_TITLE'] = 'direction de la tortue (°)';
Blockly.Msg['TURTLE_HEADING_TOOLTIP'] = 'Renvoie la direction de la tortue (en °) sachant que la direction vers la droite correspond à 0°.';
// Tello
Blockly.Msg['TELLO_LEFT'] = 'gauche';
Blockly.Msg['TELLO_RIGHT'] = 'droite';
Blockly.Msg['TELLO_TAKEOFF_TITLE'] = '[tello] décoler du sol';
Blockly.Msg['TELLO_TAKEOFF_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de faire décoller le drone Tello. Attention: vous avez besoin d\'un module Grove Wifi UART v2 pour piloter le drone avec une micro:bit v2.';
Blockly.Msg['TELLO_LAND_TITLE'] = '[tello] atterir au sol';
Blockly.Msg['TELLO_LAND_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de faire atterrir le drone Tello. Attention: vous avez besoin d\'un module Grove Wifi UART v2 pour piloter le drone avec une micro:bit v2.';
Blockly.Msg['TELLO_FLY_TITLE'] = '[tello] %1 de %2 (cm)';
Blockly.Msg['TELLO_FLY_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet d\'avancer ou de reculer (20-500 cm) avec le drone Tello. Attention: vous avez besoin d\'un module Grove Wifi UART v2 pour piloter le drone avec une micro:bit v2.';
Blockly.Msg['TELLO_FLY_FORWARD'] = 'avancer';
Blockly.Msg['TELLO_FLY_BACKWARD'] = 'reculer';
Blockly.Msg['TELLO_TURN_TITLE'] = '[tello] pivoter vers la %1 angle %2 (°)';
Blockly.Msg['TELLO_TURN_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de pivoter à gauche ou à droite d\'un angle (0-360 °) avec le drone Tello. Attention: vous avez besoin d\'un module Grove Wifi UART v2 pour piloter le drone avec une micro:bit v2.';
Blockly.Msg['TELLO_FLY_IN_HEIGHT_TITLE'] = '[tello] voler vers le %1 hauteur %2 (cm)';
Blockly.Msg['TELLO_FLY_IN_HEIGHT_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de voler vers le haut ou vers le bas (20-500 cm) avec le drone Tello. Attention: vous avez besoin d\'un module Grove Wifi UART v2 pour piloter le drone avec une micro:bit v2.';
Blockly.Msg['TELLO_FLY_UP'] = 'haut';
Blockly.Msg['TELLO_FLY_DOWN'] = 'bas';
Blockly.Msg['TELLO_FLY_DIRECTION_TITLE'] = '[tello] voler vers la %1 distance %2 (cm)';
Blockly.Msg['TELLO_FLY_DIRECTION_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de voler vers la droite ou vers la gauche (20-500 cm) avec le drone Tello. Attention: vous avez besoin d\'un module Grove Wifi UART v2 pour piloter le drone avec une micro:bit v2.';
Blockly.Msg['TELLO_GET_ALTITUDE_TITLE'] = '[tello] altitude (m)';
Blockly.Msg['TELLO_GET_ALTITUDE_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Retourne l\'altitude (en m) à laquelle se trouve le drone Tello. Attention: vous avez besoin d\'un module Grove Wifi UART v2 pour piloter le drone avec une micro:bit v2.';
// TI - Draw
Blockly.Msg['TI_DRAW_SET_WINDOW_TITLE'] = 'définir la fenêtre de dessin %1 (largeur) et %2 (hauteur)';
Blockly.Msg['TI_DRAW_SET_WINDOW_TOOLTIP'] = 'Définir la fenêtre de dessin (largeur, hauteur).';
Blockly.Msg['TI_DRAW_GET_WINDOW_TITLE'] = 'dimensions de la fenêtre de dessin';
Blockly.Msg['TI_DRAW_GET_WINDOW_TOOLTIP'] = 'Renvoie les dimensions de la fenêtre de dessin.';
Blockly.Msg['TI_DRAW_DRAW_LINE_TITLE'] = 'dessiner une ligne de %1 (x1) %2 (y1) à %3 (x2) %4 (y2)';
Blockly.Msg['TI_DRAW_DRAW_LINE_TOOLTIP'] = 'Dessine une ligne entre les points (x1, y1) et (x2, y2).';
Blockly.Msg['TI_DRAW_DRAW_CIRCLE_TITLE'] = 'dessiner un cercle de centre %1 (x) %2 (y) et de rayon %3 (r)';
Blockly.Msg['TI_DRAW_DRAW_CIRCLE_TOOLTIP'] = 'Dessine un cercle de centre (x, y) et de rayon r.';
Blockly.Msg['TI_DRAW_FILL_CIRCLE_TITLE'] = 'dessiner un cercle plein de centre %1 (x) %2 (y) et de rayon %3 (r)';
Blockly.Msg['TI_DRAW_FILL_CIRCLE_TOOLTIP'] = 'Dessine un cercle plein de centre (x, y) et de rayon r.';
Blockly.Msg['TI_DRAW_DRAW_RECT_TITLE'] = 'dessiner un rectangle de coin supérieur gauche %1 (x) %2 (y) et de largeur %3 (w) et de hauteur %4 (h)';
Blockly.Msg['TI_DRAW_DRAW_RECT_TOOLTIP'] = 'Dessine un rectangle de coin supérieur gauche (x, y) et de largeur w et de hauteur h.';
Blockly.Msg['TI_DRAW_FILL_RECT_TITLE'] = 'dessiner un rectangle plein de coin supérieur gauche %1 (x) %2 (y) et de largeur %3 (w) et de hauteur %4 (h)';
Blockly.Msg['TI_DRAW_FILL_RECT_TOOLTIP'] = 'Dessine un rectangle plein de coin supérieur gauche (x, y) et de largeur w et de hauteur h.';
Blockly.Msg['TI_DRAW_DRAW_TEXT_TITLE'] = 'écrire à la position %1 (x) et %2 (y) le text %3';
Blockly.Msg['TI_DRAW_DRAW_TEXT_TOOLTIP'] = 'Ecrire du text à la position (x, y).';
Blockly.Msg['TI_DRAW_DRAW_POLY_TITLE'] = 'dessiner un polygone avec une list de X %1 et de Y %2';
Blockly.Msg['TI_DRAW_DRAW_POLY_TOOLTIP'] = 'Dessine un polygone à partir de deux listes de coordonnées X et Y.';
Blockly.Msg['TI_DRAW_FILL_POLY_TITLE'] = 'dessiner un polygone plein avec une list de X %1 et de Y %2';
Blockly.Msg['TI_DRAW_FILL_POLY_TOOLTIP'] = 'Dessine un polygone plein à partir de deux listes de coordonnées X et Y.';
Blockly.Msg['TI_DRAW_SET_COLOR_TITLE'] = 'définir la couleur de dessin %1 (rouge) %2 (vert) %3 (bleu)';
Blockly.Msg['TI_DRAW_SET_COLOR_TOOLTIP'] = 'Définir la couleur de dessin (rouge, vert, bleu).';
Blockly.Msg['TI_DRAW_SET_PEN_TITLE'] = 'définir la taille %1 et le style du trait %2';
Blockly.Msg['TI_DRAW_SET_PEN_TOOLTIP'] = 'Définir la taille (petit, moyen, épais) et le style du trait (plein, tirets, pointillets).';
Blockly.Msg['TI_DRAW_SET_PEN_STYLE_SOLID'] = 'trait plein';
Blockly.Msg['TI_DRAW_SET_PEN_STYLE_DASH'] = 'long pointillé';
Blockly.Msg['TI_DRAW_SET_PEN_STYLE_DOT'] = 'pointillé';
Blockly.Msg['TI_DRAW_SET_PEN_THICKNESS_SMALL'] = 'small';
Blockly.Msg['TI_DRAW_SET_PEN_THICKNESS_MEDIUM'] = 'moyen';
Blockly.Msg['TI_DRAW_SET_PEN_THICKNESS_THICK'] = 'large';
Blockly.Msg['TI_DRAW_PLOT_XY_TITLE'] = 'plot en %1 (x) et en %2 (y) avec la forme %3';
Blockly.Msg['TI_DRAW_PLOT_XY_TOOLTIP'] = 'plot en fonction de x et y avec la forme spécifiée.';
Blockly.Msg['TI_DRAW_SHOW_TITLE'] = 'afficher le dessin';
Blockly.Msg['TI_DRAW_SHOW_TOOLTIP'] = 'Afficher le dessin sur l\'écran. Cliquer sur \'annul\' pour effacer le dessin.';