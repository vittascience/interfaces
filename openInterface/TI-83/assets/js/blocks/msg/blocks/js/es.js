/**
 * @fileoverview Italian messages for TI-83 Premium CE. (EN)
 */
'use strict';
// Common messages
Blockly.Msg['SECOND'] = 'segundo.s';
Blockly.Msg['MILLISECOND'] = 'millisecond.s';
Blockly.Msg['MICROSECOND'] = 'microsegundo.s';
// TI System
Blockly.Msg['TI_SYSTEM_RECALL_LIST_TITLE'] = '[system] lista de recuperación con índice %1';
Blockly.Msg['TI_SYSTEM_RECALL_LIST_TOOLTIP'] = 'Devuelve la lista almacenada con el índice (\'1\'-\'6\'). Este bloque debería funcionar si ya ha habido una llamada a la función store_list()';
Blockly.Msg['TI_SYSTEM_STORE_LIST_TITLE'] = '[system] almacenar lista %1 con índice %2';
Blockly.Msg['TI_SYSTEM_STORE_LIST_TOOLTIP'] = 'Permite guardar una lista con el índice (\'1\'-\'6\'). Esta lista puede ser recuperada posteriormente llamando a la función recall_list()';
Blockly.Msg['TI_SYSTEM_RECALL_REGEQ_TITLE'] = '[system] Obtenga RegEQ';
Blockly.Msg['TI_SYSTEM_RECALL_REGEQ_TOOLTIP'] = 'Devuelve el RegEQ';
Blockly.Msg['TI_SYSTEM_WHILE_CONDITION_TITLE'] = '[system] repetir mientras %1';
Blockly.Msg['TI_SYSTEM_WHILE_CONDITION_TOOLTIP'] = 'Repite el bucle mientras la condición es verdadera';
Blockly.Msg['TI_SYSTEM_IF_CONDITION_TITLE'] = '[system] si %1 entonces';
Blockly.Msg['TI_SYSTEM_IF_CONDITION_TOOLTIP'] = 'Ejecuta instrucciones si la condición es verdadera';
Blockly.Msg['TI_SYSTEM_ESCAPE_TITLE'] = 'Ejecución detenida';
Blockly.Msg['TI_SYSTEM_ESCAPE_TOOLTIP'] = 'Devuelve \'True\' si se ha pulsado el botón \'anular\'';
Blockly.Msg['TI_SYSTEM_DISP_AT_TITLE'] = '[system] mostrar texto %1 en la línea %2 posición %3';
Blockly.Msg['TI_SYSTEM_DISP_AT_TOOLTIP'] = 'Habilitar para mostrar texto en la ventana gráfica de la calculadora TI-83';
Blockly.Msg['TI_SYSTEM_DISP_AT_LEFT'] = 'izquierda';
Blockly.Msg['TI_SYSTEM_DISP_AT_CENTER'] = 'centrado';
Blockly.Msg['TI_SYSTEM_DISP_AT_RIGHT'] = 'derecha';
Blockly.Msg['TI_SYSTEM_DISP_CLR_TITLE'] = '[sistema] texto claro';
Blockly.Msg['TI_SYSTEM_DISP_CLR_TOOLTIP'] = 'Habilitar para borrar texto de la pantalla de la calculadora TI-83';
Blockly.Msg['TI_SYSTEM_DISP_WAIT_TITLE'] = '[sistema] espera a que se pulse el botón \'anular\'';
Blockly.Msg['TI_SYSTEM_DISP_WAIT_TOOLTIP'] = 'Mostrar la pantalla de la calculadora TI-83 hasta que se pulse el botón [annul]';
Blockly.Msg['TI_SYSTEM_DISP_CURSOR_TITLE'] = '[sistema] controlar el cursor al estado %1';
Blockly.Msg['TI_SYSTEM_DISP_CURSOR_TOOLTIP'] = 'Permite mostrar o no el cursor de la pantalla de la calculadora TI-83';
Blockly.Msg['TI_SYSTEM_SLEEP_TITLE'] = '[system] wait %1 %2';
Blockly.Msg['TI_SYSTEM_SLEEP_TOOLTIP'] = 'Pausa la ejecución del código. La función ti_system.sleep() toma segundos como argumentos';
Blockly.Msg['TI_SYSTEM_SLEEP_SECOND'] = Blockly.Msg['SECOND'];
Blockly.Msg['TI_SYSTEM_SLEEP_MILLISECOND'] = Blockly.Msg['MILLISECOND'];
Blockly.Msg['TI_SYSTEM_SLEEP_MICROSECOND'] = Blockly.Msg['MICROSECOND'];
Blockly.Msg['TI_SYSTEM_WAIT_KEY_TITLE'] = '[system] tecla de espera';
Blockly.Msg['TI_SYSTEM_WAIT_KEY_TOOLTIP'] = 'Habilitar para esperar tecla';
// TI Input/Output - Console
Blockly.Msg['TI_IO_PRINT_TITLE'] = 'imprimir %1';
Blockly.Msg['TI_IO_PRINT_TOOLTIP'] = 'Escribir una cadena en la consola de TI-83 python';
Blockly.Msg['TI_IO_CLEAR_SHELL_TITLE'] = 'borrar shell';
Blockly.Msg['TI_IO_CLEAR_SHELL_TOOLTIP'] = 'Borrar shell de la calculadora TI-83';
Blockly.Msg['TI_IO_INPUT_TEXT_TITLE'] = 'solicitar al usuario un texto con %1';
Blockly.Msg['TI_IO_INPUT_TEXT_TOOLTIP'] = 'Solicitar al usuario la introducción de un valor como texto en la consola de python';
Blockly.Msg['TI_IO_INPUT_NUMBER_TITLE'] = 'Solicitar al usuario un número con %1';
Blockly.Msg['TI_IO_INPUT_NUMBER_TOOLTIP'] = 'Solicitar al usuario que introduzca un valor como número flotante en la consola de python';
// TI Input/Output - Time
Blockly.Msg['IO_WAIT_TITLE'] = '[tiempo] espera %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Pausa la ejecución del código. La función time.sleep() toma segundos como argumentos';
Blockly.Msg['IO_WAIT_SECOND'] = Blockly.Msg['SECOND'];
Blockly.Msg['IO_WAIT_MILLISECOND'] = Blockly.Msg['MILLISECOND'];
Blockly.Msg['IO_WAIT_MICROSECOND'] = Blockly.Msg['MICROSECOND'];
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = '[tiempo] espera hasta %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Detener la ejecución del código hasta que se cumpla la condición';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = '[tiempo] inicializar el cronómetro';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Permite inicializar el cronómetro (en segundos)';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = '[tiempo] obtener cronómetro en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Devuelve el valor del cronómetro desde la inicialización en segundos o milisegundos';
// TI - Random
Blockly.Msg['RANDOM_RANDOM_TITLE'] = 'flotador aleatorio de 0 a 1';
Blockly.Msg['RANDOM_RANDOM_TOOLTIP'] = 'Devuelve un número aleatorio entre 0,0 (inclusive) y 1,0 (exclusive), como [0, 1[ en matemáticas';
Blockly.Msg['RANDOM_RANDINT_TITLE'] = 'número entero aleatorio de %1 a %2';
Blockly.Msg['RANDOM_RANDINT_TOOLTIP'] = 'Devuelve un entero aleatorio entre los dos límites especificados, ambos inclusive';
Blockly.Msg['RANDOM_UNIFORM_TITLE'] = 'número uniforme de %1 a %2';
Blockly.Msg['RANDOM_UNIFORM_TOOLTIP'] = 'Devuelve un número uniforme entre los dos límites especificados, ambos inclusive';
Blockly.Msg['RANDOM_RANDRANGE_TITLE'] = 'flotador aleatorio de %1 a %2 con paso %3';
Blockly.Msg['RANDOM_RANDRANGE_TOOLTIP'] = 'Devuelve un número aleatorio entre los dos límites especificados, inclusive, con el paso especificado';
Blockly.Msg['RANDOM_CHOICE_TITLE'] = 'elemento aleatorio en la lista %1';
Blockly.Msg['RANDOM_CHOICE_TOOLTIP'] = 'Devuelve un elemento aleatorio de la lista especificada';
Blockly.Msg['RANDOM_SEED_TITLE'] = 'número nulo';
Blockly.Msg['RANDOM_SEED_TOOLTIP'] = 'Devuelve un número nulo: Ninguno';
// Sensors - common messages
Blockly.Msg['SENSORS_TEMPERATURE'] = 'temperatura';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'en';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humedad (%)';
Blockly.Msg['SENSORS_PRESSURE'] = 'presión (hPa)';
// Devices - Built-in Hub Innovator
Blockly.Msg['DEVICES_BUILTIN_SETRGBLED_TITLE'] = '[LED RGB] establece los colores en R %1 G %2 B %3';
Blockly.Msg['DEVICES_BUILTIN_SETRGBLED_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Bloque que controla el color del LED RGB incorporado en el Innovator Hub, dé un valor entre 0 y 255 para el rojo, el verde y el azul';
Blockly.Msg['DEVICES_BUILTIN_SETRGBLEDPALETTE_TITLE'] = '[LED RGB] establece el color en %1';
Blockly.Msg['DEVICES_BUILTIN_SETRGBLEDPALETTE_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Bloque que controla el color del LED RGB incorporado en el Innovator Hub, elija un color de la paleta dada';
Blockly.Msg['DEVICES_BUILTIN_BLINKRGBLED_TITLE'] = '[LED RGB] blink led';
Blockly.Msg['DEVICES_BUILTIN_BLINKRGBLED_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Blink the Innovator Hub built-in RGB LED';
Blockly.Msg['DEVICES_BUILTIN_SETREDLED_TITLE'] = '[LED rojo] controla el LED al estado %1';
Blockly.Msg['DEVICES_BUILTIN_SETREDLED_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Control del LED rojo incorporado';
Blockly.Msg['DEVICES_BUILTIN_PLAYMUSICBUZZER_TITLE'] = '[Salida de sonido] reproducir música %1';
Blockly.Msg['DEVICES_BUILTIN_PLAYMUSICBUZZER_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Activar la reproducción de música en el altavoz incorporado del Innovator Hub';
Blockly.Msg['DEVICES_BUILTIN_SPEAKER_PLAY_NOTES_TITLE'] = '[Salida de sonido] reproducir notas en';
Blockly.Msg['DEVICES_BUILTIN_SPEAKER_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Activar la reproducción de notas en el altavoz incorporado del Innovator Hub';
Blockly.Msg['DEVICES_BUILTIN_SPEAKER_NOTE_TITLE'] = 'nota %1 en la octava %2 con duración %3';
Blockly.Msg['DEVICES_BUILTIN_SPEAKER_NOTE_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Define una nota con octava y duración';
Blockly.Msg['DEVICES_BUILTIN_SPEAKER_PLAY_FREQUENCY_TITLE'] = '[Salida de sonido] reproducir frecuencia %1 durante %2 (s)';
Blockly.Msg['DEVICES_BUILTIN_SPEAKER_PLAY_FREQUENCY_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Activar la reproducción de una frecuencia entera en el altavoz incorporado del Innovator Hub. La duración debe definirse en segundos';
Blockly.Msg['DEVICES_BUILTIN_GETLIGHT_TITLE'] = '[Entrada de luz] nivel de luz';
Blockly.Msg['DEVICES_BUILTIN_GETLIGHT_TOOLTIP'] = IMG_MODULE_BUILTIN + Blockly.Tooltip.SEP + 'Devuelve el nivel de luz (de 0 a 100) del sensor incorporado del Innovator Hub';
// Devices - External Grove Inputs
Blockly.Msg['DEVICES_GROVE_GETPOTENTIOMETER_TITLE'] = '[Potenciómetro] valor en el pin %1';
Blockly.Msg['DEVICES_GROVE_GETPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Devuelve la medición del valor (de 0 a 1023) del potenciómetro Grove en los pines IN1/IN2/IN3 o BB4/BB8/BB9/BB10';
Blockly.Msg['DEVICES_GROVE_GETULTRASONIC_TITLE'] = '[Sensor Ultrasónico] distancia (cm) en el pin %1';
Blockly.Msg['DEVICES_GROVE_GETULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Devuelve la medida de la distancia (en cm) del sensor ultrasónico del ranger en los pines digitales. Atención, si es un sensor de ranger, TRIG y ECHO están conectados a SIG';
Blockly.Msg['DEVICES_GROVE_GETMOISTURE_TITLE'] = '[Sensor de humedad] humedad en el pin %1';
Blockly.Msg['DEVICES_GROVE_GETMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Devuelve la medición de humedad (de 0 a 1023) del sensor de humedad de la arboleda en los pines IN1/IN2/IN3 o BB4/BB8/BB9/BB10';
Blockly.Msg['DEVICES_GROVE_GETTEMPERATURE_TITLE'] = '[Sensor de temperatura] temperatura en %1 en el pin %2';
Blockly.Msg['DEVICES_GROVE_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de temperatura de Grove en grados Celius (°C), Fahrenheit (°F) o Kelvin (K) en los pines analógicos IN1/IN2/IN3 o BB4/BB8/BB9/BB10';
Blockly.Msg['DEVICES_GROVE_DHT_READDATA_TITLE'] = '[Sensor DHT11] %1 en el pin %2';
Blockly.Msg['DEVICES_GROVE_DHT_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad del aire (en %) del sensor dht11 en los pines digitales';
Blockly.Msg['DEVICES_GROVE_GETLOUDNESS_TITLE'] = '[Sensor de sonoridad] sonoridad en el pin %1';
Blockly.Msg['DEVICES_GROVE_GETLOUDNESS_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Devuelve la medida de sonoridad (de 0 a 1023) del sensor de sonoridad de Grove en los pines IN1/IN2/IN3 o BB4/BB8/BB9/BB10';
Blockly.Msg['DEVICES_GROVE_GETLIGHT_TITLE'] = '[Sensor de luz] nivel de luz en el pin %1';
Blockly.Msg['DEVICES_GROVE_GETLIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de luz de la arboleda (de 0 a 1023) en los pines analógicos IN1/IN2/IN3 o BB4/BB8/BB9/BB10';
// Devices - External grove Outputs
Blockly.Msg['DEVICES_GROVE_SETLED_TITLE'] = '[Módulo LED] controla el LED al estado %1 en el pin %2';
Blockly.Msg['DEVICES_GROVE_SETLED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Permite encender o apagar el kit de zócalos LED Grove (0 o 1) en los pines digitales';
Blockly.Msg['DEVICES_GROVE_SETLEDINTENSITY_TITLE'] = '[LED] establece la intensidad del LED a %1 en el pin %2';
Blockly.Msg['DEVICES_GROVE_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Habilitar para establecer la intensidad del LED de 0 a 255 en los pines PWM';
Blockly.Msg['DEVICES_GROVE_SERVO_SETANGLE_TITLE'] = '[Servomotor] establece el ángulo a %1 en el pin %2';
Blockly.Msg['DEVICES_GROVE_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Habilitar para controlar el ángulo del servomotor (de -90 a 90) en los pines pwm. Atención, el Innovator Hub debe ser alimentado por una batería externa para proporcionar suficiente energía al servomotor';
Blockly.Msg['DEVICES_GROVE_RELAY_CONTROL_TITLE'] = '[Módulo de relés] controla el relé al estado %1 en el pin %2';
Blockly.Msg['DEVICES_GROVE_RELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Habilitar para controlar el estado del módulo de relé Grove (0 o 1) en los pines digitales';
Blockly.Msg['DEVICES_GROVE_VIBRATIONMOTOR_CONTROL_TITLE'] = '[Motor de vibración] controlar el motor al estado %1 en el pin %2';
Blockly.Msg['DEVICES_GROVE_VIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Habilitar para controlar el estado del motor de vibración de Grove (0 o 1) en los pines digitales';
Blockly.Msg['DEVICES_GROVE_VIBRATIONMOTOR_SET_TITLE'] = '[Motor de vibración] controlar el motor al valor %1 en el pin %2';
Blockly.Msg['DEVICES_GROVE_VIBRATIONMOTOR_SET_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Habilitar para controlar el valor del motor de vibración de Grove (0-255) en los pines PWM';
Blockly.Msg['DEVICES_GROVE_MOTOR_SETPOWERSTATE_TITLE'] = '[Motor] establecer la potencia al estado %1 en el pin %2';
Blockly.Msg['DEVICES_GROVE_MOTOR_SETPOWERSTATE_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Habilitar para controlar el estado de alimentación del motor de CC (0 o 1) en los pines digitales. Atención, el Innovator Hub debe ser alimentado por una batería externa para proporcionar suficiente energía al motor de corriente continua';
Blockly.Msg['DEVICES_GROVE_MOTOR_SETPOWERVALUE_TITLE'] = '[Motor] establece la potencia al valor %1 en el pin %2';
Blockly.Msg['DEVICES_GROVE_MOTOR_SETPOWERVALUE_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permite controlar el valor de la potencia del motor de CC (0-100) % en los pines pwm. Atención, el Innovator Hub debe ser alimentado por una batería externa para proporcionar suficiente energía al motor de CC';
// Devices - Pins
Blockly.Msg['IO_HUB_DIGITALSIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_HUB_DIGITALSIGNAL_HIGH'] = 'HIGH (1)';
Blockly.Msg['IO_HUB_DIGITALSIGNAL_LOW'] = 'LOW (0)';
Blockly.Msg['IO_HUB_DIGITALSIGNAL_TOOLTIP'] = 'Devuelve un valor booleano (1 si es HIGH o 0 si es LOW)';
Blockly.Msg['IO_HUB_READDIGITALPIN_TITLE'] = 'leer pin digital %1';
Blockly.Msg['IO_HUB_READDIGITALPIN_TOOLTIP'] = IMG_MODULE_PINS + Blockly.Tooltip.SEP + 'Habilitar para leer el valor digital de los pines (0 o 1)';
Blockly.Msg['IO_HUB_WRITEDIGITALPIN_TITLE'] = 'escribir en el pin digital %1 estado %2';
Blockly.Msg['IO_HUB_WRITEDIGITALPIN_TOOLTIP'] = IMG_MODULE_PINS + Blockly.Tooltip.SEP + 'Habilitar para escribir el valor (0 o 1) en el pin digital';
Blockly.Msg['IO_HUB_READANALOGPIN_TITLE'] = 'leer pin analógico %1';
Blockly.Msg['IO_HUB_READANALOGPIN_TOOLTIP'] = IMG_MODULE_PINS + Blockly.Tooltip.SEP + 'Permite leer el valor analógico de los pines (0-1023)';
Blockly.Msg['IO_HUB_WRITEANALOGPIN_TITLE'] = 'escribir en el pin analógico %1 valor %2';
Blockly.Msg['IO_HUB_WRITEANALOGPIN_TOOLTIP'] = IMG_MODULE_PINS + Blockly.Tooltip.SEP + 'Permite escribir en el pin analógico el valor (0-255)';
Blockly.Msg['IO_HUB_SETPWM_TITLE'] = 'aplicar una señal de frecuencia %1 (Hz) duty %2 (%) en el pin %3';
Blockly.Msg['IO_HUB_SETPWM_TOOLTIP'] = IMG_MODULE_PINS + Blockly.Tooltip.SEP + 'Habilitar para aplicar una señal PWM de frecuencia (de 0 a 500 Hz) y duty (de 0 a 100 %)';
// TI Plotlib - Configure
Blockly.Msg['TI_PLOTLIB_CLS_TITLE'] = 'limpiar pantalla';
Blockly.Msg['TI_PLOTLIB_CLS_TOOLTIP'] = 'Borrar pantalla de la calculadora TI-83';
Blockly.Msg['TI_PLOTLIB_WINDOW_TITLE'] = 'definir tamaño de ventana xmin %1 xmax %2 ymin %3 ymax %4';
Blockly.Msg['TI_PLOTLIB_WINDOW_TOOLTIP'] = 'Define el tamaño de la ventana gráfica de la calculadora TI-83';
Blockly.Msg['TI_PLOTLIB_AUTO_WINDOW_TITLE'] = 'definir ventana automáticamente %1 eje x %2 eje y %3';
Blockly.Msg['TI_PLOTLIB_AUTO_WINDOW_TOOLTIP'] = 'Define el tamaño de la ventana gráfica de la calculadora TI-83 obteniendo el mínimo y el máximo de los ejes x y y';
Blockly.Msg['TI_PLOTLIB_GRID_TITLE'] = 'mostrar cuadrícula con escala x %1 y %2 tipo %3';
Blockly.Msg['TI_PLOTLIB_GRID_TOOLTIP'] = 'Mostrar cuadrícula con líneas sólidas, sombreadas o punteadas en la calculadora TI-83. Atención, el tamaño de la ventana debe ser definido antes de la rejilla para tener una rejilla a la escala correcta';
Blockly.Msg['TI_PLOTLIB_AXES_TITLE'] = 'definir ejes a %1';
Blockly.Msg['TI_PLOTLIB_AXES_TOOLTIP'] = 'Configurar ejes de la ventana gráfica de la calculadora TI-83';
Blockly.Msg['TI_PLOTLIB_LABELS_TITLE'] = 'añadir etiquetas x %1 posición %2 y y %3 posición %4';
Blockly.Msg['TI_PLOTLIB_LABELS_TOOLTIP'] = 'Añadir dos etiquetas en la ventana gráfica de la calculadora TI-83. Las etiquetas x e y están a la izquierda y a la derecha de la ventana respectivamente. La posición define la posición en el eje vertical';
Blockly.Msg['TI_PLOTLIB_TITLE_TITLE'] = 'añadir título %1';
Blockly.Msg['TI_PLOTLIB_TITLE_TOOLTIP'] = 'Añade un título al centro de la ventana gráfica de la calculadora TI-83';
Blockly.Msg['TI_PLOTLIB_SHOWPLOT_TITLE'] = 'mostrar gráfico';
Blockly.Msg['TI_PLOTLIB_SHOWPLOT_TOOLTIP'] = 'Habilitar para mantener la ventana de trazado en la pantalla de la calculadora TI-83';
// TI Plotlib - Draw
Blockly.Msg['TI_PLOTLIB_DEFINE_COLOR_TITLE'] = 'cambiar el color a R %1 G %2 B %3';
Blockly.Msg['TI_PLOTLIB_DEFINE_COLOR_TOOLTIP'] = 'Permite cambiar el color de la pluma de la ventana de gráficos cambiando R,G o B (de 0 a 255)';
Blockly.Msg['TI_PLOTLIB_DEFINE_PALETTE_COLOR_TITLE'] = 'cambiar el color a %1';
Blockly.Msg['TI_PLOTLIB_DEFINE_PALETTE_COLOR_TOOLTIP'] = 'Habilitar para cambiar el color de la pluma de la ventana gráfica seleccionada en la paleta';
Blockly.Msg['TI_PLOTLIB_SCATTER_TITLE'] = 'plot scatter %1 %2 xaxis %3 yaxis %4';
Blockly.Msg['TI_PLOTLIB_SCATTER_TOOLTIP'] = 'Trazar dispersión en la ventana de gráficos de la calculadora TI-83';
Blockly.Msg['TI_PLOTLIB_LIN_REG_TITLE'] = 'trazar la línea de regresión lineal %1 (lista de X) y %2 (lista de Y) en la posición %3 y en la línea %4';
Blockly.Msg['TI_PLOTLIB_LIN_REG_TOOLTIP'] = 'Traza la línea de regresión lineal con la lista de coordenadas X y la lista de coordenadas Y en la ventana de gráficos de la calculadora TI-83.';
Blockly.Msg['TI_PLOTLIB_PLOT_TITLE'] = 'plot %1 %2 xaxis %3 yaxis %4';
Blockly.Msg['TI_PLOTLIB_PLOT_TOOLTIP'] = 'Trazar gráfico en la ventana de gráficos de la calculadora TI-83';
Blockly.Msg['TI_PLOTLIB_LINE_TITLE'] = 'dibujar %1 entre A (%2,%3) y B (%4,%5)';
Blockly.Msg['TI_PLOTLIB_LINE'] = 'una línea';
Blockly.Msg['TI_PLOTLIB_ARROW'] = 'una flecha';
Blockly.Msg['TI_PLOTLIB_LINE_TOOLTIP'] = 'Permite dibujar una línea o una flecha entre los puntos A y B en la ventana de gráficos de la calculadora TI-83';
Blockly.Msg['TI_PLOTLIB_PEN_TITLE'] = 'Utilizar un bolígrafo de tipo %1 %2';
Blockly.Msg['TI_PLOTLIB_PEN_THIN'] = 'fino';
Blockly.Msg['TI_PLOTLIB_PEN_MEDIUM'] = 'mediano';
Blockly.Msg['TI_PLOTLIB_PEN_THICK'] = 'grueso';
Blockly.Msg['TI_PLOTLIB_PEN_SOLID'] = 'sólido';
Blockly.Msg['TI_PLOTLIB_PEN_DOT'] = 'punto';
Blockly.Msg['TI_PLOTLIB_PEN_DASH'] = 'guión';
Blockly.Msg['TI_PLOTLIB_PEN_TOOLTIP'] = 'Habilitar para cambiar el tipo de lápiz del cajón en la ventana de gráficos de la calculadora TI-83';
Blockly.Msg['TI_PLOTLIB_TEXT_AT_TITLE'] = 'escribir texto %1 en la línea %2 posición %3';
Blockly.Msg['TI_PLOTLIB_TEXT_AT_LEFT'] = 'izquierda';
Blockly.Msg['TI_PLOTLIB_TEXT_AT_CENTER'] = 'centro';
Blockly.Msg['TI_PLOTLIB_TEXT_AT_RIGHT'] = 'derecha';
Blockly.Msg['TI_PLOTLIB_TEXT_AT_TOOLTIP'] = 'Escribir texto en la ventana de gráficos de la calculadora TI-83';
// Robots - Rover
Blockly.Msg['TI_ROVER_RIGHT'] = 'derecha';
Blockly.Msg['TI_ROVER_LEFT'] = 'izquierda';
Blockly.Msg['TI_ROVER_BY_RIGHT'] = Blockly.Msg['TI_ROVER_RIGHT'];
Blockly.Msg['TI_ROVER_BY_LEFT'] = Blockly.Msg['TI_ROVER_LEFT'];
Blockly.Msg['TI_ROVER_BOTH_SIDES'] = 'ambos lados';
Blockly.Msg['TI_ROVER_GO_FORWARD'] = 'hacia adelante';
Blockly.Msg['TI_ROVER_GO_REVERSE'] = 'hacia atrás';
Blockly.Msg['TI_ROVER_GO_TITLE'] = '[Rover] se mueve %1 en %2 unidad.s con velocidad %3 (m/s)';
Blockly.Msg['TI_ROVER_GO_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permite controlar la marcha del coche (ADELANTE/ATRÁS) y el número de unidades de distancia del robot rover (1 unidad = 10 cm). Se puede ajustar la velocidad del Rover [0,14-0,23] en metros por segundo';
Blockly.Msg['TI_ROVER_GO_TIME_TITLE'] = '[Rover] se mueve %1 durante %2 (s) con velocidad %3 (m/s)';
Blockly.Msg['TI_ROVER_GO_TIME_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permite controlar la marcha del coche (HACIA ADELANTE/HACIA ATRÁS) durante el tiempo definido en segundos del robot rover. Se puede establecer la velocidad del Rover [0,14-0,23] en metros por segundo';
Blockly.Msg['TI_ROVER_TURNTO_TITLE'] = '[Rover] gira a %1 ángulo %2 (°)';
Blockly.Msg['TI_ROVER_TURNTO_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Activar el giro a la derecha o a la izquierda con el robot rover. Establecer el ángulo (en °)';
Blockly.Msg['TI_ROVER_RIGHT_BIS'] = Blockly.Msg['TI_ROVER_RIGHT'];
Blockly.Msg['TI_ROVER_CONTROLMOTOR_TITLE'] = '[Rover] controlar motor %1 dirección %2 velocidad %3 duración %4 (s)';
Blockly.Msg['TI_ROVER_CONTROLMOTOR_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permite controlar el motor derecho y el motor izquierdo cambiando la dirección (↻ : FOWARD, ↺ : REVERSE), la velocidad (de 0 a 255) o la duración (en s) del robot rover';
Blockly.Msg['TI_ROVER_MOVETOXY_TITLE'] = '[Rover] se mueve a la posición x %1 y %2';
Blockly.Msg['TI_ROVER_MOVETOXY_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permite mover el robot rover a una posición especificada de forma cartesiana';
Blockly.Msg['TI_ROVER_MOVETOPOLAR_TITLE'] = '[Rover] mover en posición polar r %1 θ %2';
Blockly.Msg['TI_ROVER_MOVETOPOLAR_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Permite mover el robot rover en una posición especificada de forma polar';
Blockly.Msg['TI_ROVER_STAY_TITLE'] = '[Rover] deja de funcionar durante %1 (s)';
Blockly.Msg['TI_ROVER_STAY_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Habilitar para detener la marcha del robot rover durante la duración especificada en segundos';
Blockly.Msg['TI_ROVER_STOP_TITLE'] = '[Rover] deja de funcionar';
Blockly.Msg['TI_ROVER_STOP_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Habilitar para detener el funcionamiento del robot rover';
Blockly.Msg['TI_ROVER_RESUME_TITLE'] = '[Rover] reanudar la marcha';
Blockly.Msg['TI_ROVER_RESUME_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Habilitar para reanudar el funcionamiento del robot rover';
// Rover - Inputs
Blockly.Msg['TI_ROVER_ULTRASONICRANGER_TITLE'] = '[Rover - Capteur à ultrasons] distancia (m)';
Blockly.Msg['TI_ROVER_ULTRASONICRANGER_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Devuelve el valor de la distancia (en m) desde cualquier objeto al robot rover con sensor de alcance ultrasónico';
Blockly.Msg['TI_ROVER_COLORSENSOR_GETLEVEL_TITLE'] = '[Rover - Sensor de color] nivel de %1 bajo el robot';
Blockly.Msg['TI_ROVER_COLORSENSOR_GETLEVEL_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Devuelve el nivel (gris/rojo/verde/azul) del sensor de color colocado bajo el robot rover';
Blockly.Msg['TI_ROVER_COLOR_GRAY'] = 'gris';
Blockly.Msg['TI_ROVER_COLOR_RED'] = 'rojo';
Blockly.Msg['TI_ROVER_COLOR_GREEN'] = 'verde';
Blockly.Msg['TI_ROVER_COLOR_BLUE'] = 'azul';
Blockly.Msg['TI_ROVER_COLORSENSOR_GETCOLOR_TITLE'] = '[Rover - Sensor de color] medición del color';
Blockly.Msg['TI_ROVER_COLORSENSOR_GETCOLOR_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Devuelve la medición del color del sensor de color colocado bajo el robot rover como (1:rojo, 2:verde, 3:azul, 4:cian, 5:magenta, 6:amarillo, 7:negro, 8:blanco, 9:gris)';
Blockly.Msg['TI_ROVER_GYROSCOPE_GETANGULARSPEED_TITLE'] = '[Rover - Giroscopio] velocidad angular (rad/s)';
Blockly.Msg['TI_ROVER_GYROSCOPE_GETANGULARSPEED_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Devuelve la velocidad angular (en rad/s) del robot rover';
Blockly.Msg['TI_ROVER_GYROSCOPE_GETANGLE_TITLE'] = '[Rover - Giroscopio] posición angular (°)';
Blockly.Msg['TI_ROVER_GYROSCOPE_GETANGLE_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Devuelve la posición angular (en °) del robot rover';
// Rover - Outputs
Blockly.Msg['TI_ROVER_SETRGBLED_TITLE'] = '[Rover - RGB] establece los colores a R %1 G %2 B %3';
Blockly.Msg['TI_ROVER_SETRGBLED_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Bloque que controla el color del LED RGB del robot rover, da un valor entre 0 y 255 para el Rojo, el Verde y el Azul';
Blockly.Msg['TI_ROVER_SETRGBLEDPALETTE_TITLE'] = '[Rover - RGB] establece el color a %1';
Blockly.Msg['TI_ROVER_SETRGBLEDPALETTE_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Bloque que controla el color del LED RGB del robot rover, elige un color de la paleta dada';
Blockly.Msg['TI_ROVER_BLINKRGBLED_TITLE'] = '[Rover - RGB] parpadea el led a la frecuencia %1 (Hz) durante %2 (s)';
Blockly.Msg['TI_ROVER_BLINKRGBLED_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Parpadeo del LED RGB del robot rover';
Blockly.Msg['TI_ROVER_STOPRGBLED_TITLE'] = '[Rover - RGB] apaga el LED';
Blockly.Msg['TI_ROVER_STOPRGBLED_TOOLTIP'] = IMG_MODULE_ROVER + Blockly.Tooltip.SEP + 'Apagar el LED RGB del robot rover';
// Micro:bit - Commandes
Blockly.Msg['MICROBIT_TYPE_IS'] = 'is';
Blockly.Msg['MICROBIT_TYPE_WAS'] = 'era';
Blockly.Msg['MICROBIT_SLEEP_TITLE'] = '[micro:bit] wait %1 %2';
Blockly.Msg['MICROBIT_SLEEP_TOOLTIP'] = 'Pausa la ejecución del código. La función micro:bit.sleep() toma los segundos como milisegundos';
Blockly.Msg['MICROBIT_SLEEP_SECOND'] = Blockly.Msg['SECOND'];
Blockly.Msg['MICROBIT_SLEEP_MILLISECOND'] = Blockly.Msg['MILLISECOND'];
Blockly.Msg['MICROBIT_SLEEP_MICROSECOND'] = Blockly.Msg['MICROSECOND'];
Blockly.Msg['MICROBIT_WHILE_CONDITION_TITLE'] = '[micro:bit] repetir mientras %1';
Blockly.Msg['MICROBIT_WHILE_CONDITION_TOOLTIP'] = 'Repetir bucle mientras se verifica la condición';
Blockly.Msg['MICROBIT_ESCAPE_TITLE'] = '[micro:bit] ejecución detenida';
Blockly.Msg['MICROBIT_ESCAPE_TOOLTIP'] = 'Devuelve \'True\' si se ha pulsado el botón \'annul\'';
Blockly.Msg['MICROBIT_DISP_CLR_TITLE'] = '[micro:bit] clear text';
Blockly.Msg['MICROBIT_DISP_CLR_TOOLTIP'] = 'Habilitar para borrar texto de la pantalla de la calculadora TI-83';
Blockly.Msg['MICROBIT_STORE_LIST_TITLE'] = '[micro:bit] almacenar la lista %1 con índice %2';
Blockly.Msg['MICROBIT_STORE_LIST_TOOLTIP'] = 'Habilitar para almacenar un máximo de 6 listas con índice (\'1\'-\'6\')';
Blockly.Msg['MICROBIT_TEMPERATURE_TITLE'] = '[micro:bit] temperatura en %1';
Blockly.Msg['MICROBIT_TEMPERATURE_TOOLTIP'] = 'Devuelve la temperatura en grados Celius (°C), Fahrenheit (°F) o Kelvin (K) del procesador micro:bit';
// Micro:bit - Screen 
Blockly.Msg['SHOW_STRING_TITLE'] = '[Pantalla] scroll %1';
Blockly.Msg['SHOW_NUMBER_TITLE'] = '[Pantalla] mostrar %1';
Blockly.Msg['SHOW_LEDS_TITLE'] = '[Pantalla] mostrar leds';
Blockly.Msg['SHOW_ICON_TITLE'] = '[Pantalla] mostrar icono %1';
Blockly.Msg['SHOW_GAUGE_TITLE'] = '[Pantalla] mostrar medidor de %1 Máximo %2';
Blockly.Msg['SHOW_GAUGE_TOOLTIP'] = 'Mostrar la varilla de un sensor (o número) en la pantalla de la tarjeta de microbits fijando el valor máximo correspondiente a la varilla llena';
Blockly.Msg['SHOW_CLOCK_TITLE'] = '[Pantalla] mostrar reloj %1';
Blockly.Msg['SHOW_ARROW_TITLE'] = '[Pantalla] mostrar flecha %1';
Blockly.Msg['SHOW_ARROW_TOOLTIP'] = 'Habilitar para mostrar flechas de 8 direcciones (N,NE,E,SE,S...) en la pantalla de micro:bit';
Blockly.Msg['SENSORS_GETLIGHT_TITLE'] = 'Nivel de luz [de la pantalla]';
Blockly.Msg['SENSORS_GETLIGHT_TOOLTIP'] = 'Devuelve el nivel de luz (de 0 a 255) con algún LED de la pantalla de micro:bit.';
Blockly.Msg['CLEAR_TITLE'] = '[Pantalla] apaga los leds';
Blockly.Msg['SET_PIXEL_TITLE'] = '[Pantalla] controla el led x %1 y %2 al estado %3';
Blockly.Msg['SET_PIXEL_TOOLTIP'] = 'Habilitar para controlar el estado (ON/OFF) de cada LED de la pantalla de micro:bit';
Blockly.Msg['SET_LIGHT_PIXEL_TITLE'] = '[Pantalla] control led x %1 y %2 luz %3';
Blockly.Msg['SET_LIGHT_PIXEL_TOOLTIP'] = 'Habilitar para controlar la luz (de 0 a 9) de cada LED de la pantalla micro:bit';
// Micro:bit - Music
Blockly.Msg['MICROBIT_MUSIC_PLAYMUSIC_TITLE'] = '[Música] reproducir música %1';
Blockly.Msg['MICROBIT_MUSIC_PLAYMUSIC_TOOLTIP'] = 'Activar la reproducción de la música elegida en el altavoz incorporado de micro:bit v2';
Blockly.Msg['MICROBIT_MUSIC_PLAYSONG_TITLE'] = '[Música] reproducir canción %1';
Blockly.Msg['MICROBIT_MUSIC_PLAYSONG_TOOLTIP'] = 'Activar la reproducción de la canción elegida en el altavoz incorporado de micro:bit v2';
Blockly.Msg['MICROBIT_MUSIC_PLAYNOTES_TITLE'] = '[Música] reproducir notas';
Blockly.Msg['MICROBIT_MUSIC_PLAYNOTES_TOOLTIP'] = 'Activar la reproducción de notas en el altavoz micro:bit v2 incorporado';
Blockly.Msg['MICROBIT_MUSIC_NOTE_TITLE'] = 'nota %1 en la octava %2 con duración %3';
Blockly.Msg['MICROBIT_MUSIC_NOTE_TOOLTIP'] = 'Definir una nota con octava y duración';
Blockly.Msg['NOTE_C'] = 'C';
Blockly.Msg['NOTE_C_SHARP'] = 'C#';
Blockly.Msg['NOTE_D'] = 'D';
Blockly.Msg['NOTE_D_SHARP'] = 'D#';
Blockly.Msg['NOTE_E'] = 'E';
Blockly.Msg['NOTE_F'] = 'F';
Blockly.Msg['NOTE_F_SHARP'] = 'F#';
Blockly.Msg['NOTE_G'] = 'G';
Blockly.Msg['NOTE_G_SHARP'] = 'G#';
Blockly.Msg['NOTE_A'] = 'A';
Blockly.Msg['NOTE_A_SHARP'] = 'A#';
Blockly.Msg['NOTE_B'] = 'B';
Blockly.Msg['MUSIC_SILENCE'] = 'Silencio';
Blockly.Msg['MICROBIT_MUSIC_PLAYFREQUENCY_TITLE'] = '[Música] frecuencia de reproducción %1 durante %2 (ms)';
Blockly.Msg['MICROBIT_MUSIC_PLAYFREQUENCY_TOOLTIP'] = 'Activar la reproducción de una frecuencia entera en el altavoz micro:bit incorporado';
Blockly.Msg['MICROBIT_MUSIC_SETTEMPO_TITLE'] = '[Música] establecer ticks %1 y tempo %2';
Blockly.Msg['MICROBIT_MUSIC_SETTEMPO_TOOLTIP'] = 'Habilitar para establecer música ticks y beats por minuto';
Blockly.Msg['MICROBIT_MUSIC_SETVOLUME_TITLE'] = '[Música] establecer el volumen a %1';
Blockly.Msg['MICROBIT_MUSIC_SETVOLUME_TOOLTIP'] = 'Habilitar para cambiar el volumen del altavoz incorporado de micro:bit v2 (0-255)';
// Micro:bit - Audio
Blockly.Msg['MICROBIT_AUDIO_PLAY_TITLE'] = '[Audio] reproducir canción %1';
Blockly.Msg['MICROBIT_AUDIO_PLAY_TOOLTIP'] = 'Activar la reproducción de la canción elegida en el altavoz incorporado de micro:bit v2';
Blockly.Msg['MICROBIT_AUDIO_STOP_TITLE'] = '[Audio] detener el sonido';
Blockly.Msg['MICROBIT_AUDIO_STOP_TOOLTIP'] = 'Habilitar para detener el sonido del altavoz incorporado de micro:bit v2';
// Micro:bit - Microphone
Blockly.Msg['IO_MICRO_LOUD'] = 'fuerte';
Blockly.Msg['IO_MICRO_QUIET'] = 'silencioso';
Blockly.Msg['IO_MICRO_IS'] = Blockly.Msg['MICROBIT_TYPE_IS'];
Blockly.Msg['IO_MICRO_WAS'] = Blockly.Msg['MICROBIT_TYPE_WAS'];
Blockly.Msg['IO_MICRO_ONSOUNDDETECTED_TITLE'] = '[Micro] si %1 sonido %2 detectado entonces';
Blockly.Msg['IO_MICRO_ONSOUNDDETECTED_TOOLTIP'] = 'Ejecutar instrucciones si se detecta la condición de sonido (fuerte/silencioso). Opción \'era\': Ejecutar instrucciones si se ha producido un sonido (fuerte/silencioso) desde la última llamada a \'was_sound()\'';
Blockly.Msg['IO_MICRO_GETCURRENTSOUND_TITLE'] = '[Micro] condición de sonido';
Blockly.Msg['IO_MICRO_GETCURRENTSOUND_TOOLTIP'] = 'Devuelve la condición de sonido (fuerte/silencioso)';
Blockly.Msg['IO_MICRO_SOUNDDETECTED_TITLE'] = '[Micro] %1 sonido %2 detectado';
Blockly.Msg['IO_MICRO_SOUNDDETECTED_TOOLTIP'] = 'Devuelve True si se ha producido un sonido (fuerte/silencioso) desde la última llamada a \'was_sound()\'';
Blockly.Msg['IO_MICRO_GETSOUNDLEVEL_TITLE'] = '[Micro] nivel de sonido';
Blockly.Msg['IO_MICRO_GETSOUNDLEVEL_TOOLTIP'] = 'Habilitar du obtener el nivel de sonido de 0 a 255';
Blockly.Msg['IO_MICRO_SETSOUNDTHRESHOLD_TITLE'] = '[Micro] establecer %1 umbral de sonido a %2';
Blockly.Msg['IO_MICRO_SETSOUNDTHRESHOLD_TOOLTIP'] = 'Habilitar para establecer el umbral de sonido alto/silencioso (0-255)';
Blockly.Msg['IO_MICRO_SOUNDCONDITION_TITLE'] = '[Micro] %1';
Blockly.Msg['IO_MICRO_SOUNDCONDITION_TOOLTIP'] = 'Habilita el uso de las constantes (LOUD/QUIET) del módulo de micrófono en la categoría \'Logic\'';
// Micro:bit - Buttons
Blockly.Msg['IO_ONBUTTONPRESSED_TITLE'] = '[botones] en el botón %1 %2 pulsado entonces';
Blockly.Msg['IO_ONBUTTONPRESSED_TOOLTIP'] = 'Ejecutar instrucciones si se pulsa el botón elegido (A o B)';
Blockly.Msg['IO_ISPRESSED'] = Blockly.Msg['MICROBIT_TYPE_IS'];
Blockly.Msg['IO_WASPRESSED'] = Blockly.Msg['MICROBIT_TYPE_WAS'];
Blockly.Msg['IO_ISBUTTONPRESSED_TITLE'] = '[botones] botón %1 %2 pulsado';
Blockly.Msg['IO_ISBUTTONPRESSED_TOOLTIP'] = 'Devuelve \'True\' si el botón A o B está pulsado, en caso contrario devuelve \'False\'';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TITLE'] = '[botones] obtiene las pulsaciones del botón %1';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TOOLTIP'] = 'Devuelve el número de pulsaciones del botón A o B';
Blockly.Msg['IO_IS_LOGO_TOUCHED_TITLE'] = 'Se ha tocado el logotipo de [los botones]';
Blockly.Msg['IO_IS_LOGO_TOUCHED_TOOLTIP'] = 'Devuelve \'True\' si se toca el logo de micro:bit (v2), de lo contrario devuelve \'False\'';
// Micro:bit - Sensors
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_BY_AXIS_TITLE'] = '[Acelerómetro] aceleración (mg) en el eje %1';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_BY_AXIS_TOOLTIP'] = 'Devuelve la aceleración (en mg) a lo largo de cualquier eje con el acelerómetro interno de micro:bit';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_VALUES_TITLE'] = '[Acelerómetro] aceleraciones (en mg) a lo largo de los ejes';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_VALUES_TOOLTIP'] = 'Devuelve las aceleraciones (en mg) según los 3 ejes en forma de tupla (x, y, z) con el acelerómetro interno de la placa micro:bit';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_MAGNITUDE_TITLE'] = '[Acelerómetro] magnitud (m.s-2)';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_MAGNITUDE_TOOLTIP'] = 'Devuelve la magnitud (en m.s-2) con el acelerómetro interno de micro:bit';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_ROTATION_TITLE'] = '[Acelerómetro} rotación como %1 (°)';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_ROTATION_PITCH'] = 'pitch';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_ROTATION_ROLL'] = 'roll';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_ROTATION_TOOLTIP'] = 'Devuelve la rotación (de -180° a 180°) con el acelerómetro interno de micro:bit';
Blockly.Msg['MICROBIT_COMPASS_HEADING_TITLE'] = '[Brújula] rumbo (°)';
Blockly.Msg['MICROBIT_COMPASS_HEADING_TOOLTIP'] = 'Devuelve el rumbo de la brújula, como un entero en el rango de 0 a 360, que representa el ángulo en grados, en el sentido de las agujas del reloj, con el norte como 0°';
Blockly.Msg['MICROBIT_COMPASS_GET_MAGNETIC_STRENGTH_BY_AXIS_TITLE'] = '[Brújula] intensidad del campo magnético %1 (nT)';
Blockly.Msg['MICROBIT_COMPASS_GET_MAGNETIC_STRENGTH_BY_AXIS_TOOLTIP'] = 'Devuelve la lectura de la intensidad del campo magnético en cualquier eje (en nT), como un número entero positivo o negativo, dependiendo de la dirección del campo';
Blockly.Msg['MICROBIT_COMPASS_IS_CALIBRATED_TITLE'] = '[Brújula] está calibrada';
Blockly.Msg['MICROBIT_COMPASS_IS_CALIBRATED_TOOLTIP'] = 'Devuelve \'True\' si la brújula está calibrada, en caso contrario devuelve \'False\'';
Blockly.Msg['MICROBIT_COMPASS_GET_FIELD_STRENGTH_TITLE'] = '[Brújula] intensidad de campo magnético (nT)';
Blockly.Msg['MICROBIT_COMPASS_GET_FIELD_STRENGTH_TOOLTIP'] = 'Devuelve una indicación entera de la magnitud del campo magnético (en nT) alrededor del dispositivo';
Blockly.Msg['MICROBIT_COMPASS_CALIBRATE_TITLE'] = '[Brújula] %1';
Blockly.Msg['MICROBIT_COMPASS_CALIBRATE_TOOLTIP'] = 'Inicia el proceso de calibración. Se mostrará un mensaje instructivo al usuario, tras el cual tendrá que girar el dispositivo para dibujar un círculo en la pantalla LED. La 2ª opción deshace la calibración, haciendo que la brújula vuelva a estar descalibrada';
Blockly.Msg['MICROBIT_COMPASS_CALIBRATE'] = 'calibrar';
Blockly.Msg['MICROBIT_COMPASS_CLEAR_CALIBRATION'] = 'restablecer la calibración';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_UP'] = 'logo arriba';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_DOWN'] = 'logo abajo';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_LEFT'] = 'inclinación hacia la izquierda';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_RIGHT'] = 'inclinación hacia la derecha';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_FACE_UP'] = 'pantalla arriba';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_FACE_DOWN'] = 'pantalla abajo';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_TYPE_SHAKE'] = 'agitar';
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_IS'] = Blockly.Msg['MICROBIT_TYPE_IS'];
Blockly.Msg['MICROBIT_ACCELEROMETER_GESTURE_WAS'] = Blockly.Msg['MICROBIT_TYPE_WAS'];
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_CURRENT_GESTURE_TITLE'] = '[Gesto] obtener gesto actual';
Blockly.Msg['MICROBIT_ACCELEROMETER_GET_CURRENT_GESTURE_TOOLTIP'] = 'Devuelve el gesto actual de la placa micro:bit: \'arriba\', \'abajo\', \'izquierda\', \'derecha\', \'cara arriba\', \'cara abajo\' o \'agitar\'';
Blockly.Msg['MICROBIT_ACCELEROMETER_ON_GESTURE_TYPE_TITLE'] = '[Gesture] if gesture %2 %1 then';
Blockly.Msg['MICROBIT_ACCELEROMETER_ON_GESTURE_TYPE_TOOLTIP'] = 'Ejecuta las instrucciones si el gesto seleccionado es o fue realizado con la tarjeta micro:bit';
Blockly.Msg['MICROBIT_ACCELEROMETER_IS_GESTURE_TITLE'] = 'Gesto %1 %2';
Blockly.Msg['MICROBIT_ACCELEROMETER_IS_GESTURE_TOOLTIP'] = 'Devuelve \'True\' si el gesto seleccionado es o fue realizado con la tarjeta micro:bit, en caso contrario devuelve \'False\'';
// Micro:bit - Radio
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TITLE'] = '[Radio] enviar cadena %1';
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TOOLTIP'] = 'Habilitar para enviar cadena por módulo de radio micro:bit';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TITLE'] = '[Radio] enviar número o lista %1';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TOOLTIP'] = 'Habilitar el envío de números o listas por el módulo de radio';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TITLE'] = '[Radio] enviar valor %1 como %2';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TOOLTIP'] = 'Habilitar el envío de datos con \'nombre\' y su valor por módulo de radio';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TITLE'] = '[Radio] sobre datos recibidos en %1 entonces';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones sobre la cadena recibida por la radio en la variable \'stringData\'';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TITLE'] = '[Radio] sobre los datos recibidos en %1 entonces';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones sobre el número recibido por la radio en la variable \'numberData\'';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TITLE'] = '[Radio] sobre datos recibidos en %1 %2 entonces';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones sobre el nombre como cadena y el valor como número recibidos por la radio en las variables \'nombre\' y \'valor\'';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TITLE'] = '[Radio] set Channel %1 Power %2 Data size %3 Group %4';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TOOLTIP'] = 'Permite configurar el canal de frecuencia (de 0 a 83), el tamaño de los datos (bytes), la potencia de transmisión (de 0 a 7) y el grupo (de 0 a 255)';
// Micro:bit - Pins
Blockly.Msg['IO_MB_DIGITALSIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_MB_DIGITALSIGNAL_HIGH'] = 'HIGH (1)';
Blockly.Msg['IO_MB_DIGITALSIGNAL_LOW'] = 'LOW (0)';
Blockly.Msg['IO_MB_DIGITALSIGNAL_TOOLTIP'] = 'Devuelve un valor booleano (1 si es HIGH o 0 si es LOW)';
Blockly.Msg['IO_MB_READDIGITALPIN_TITLE'] = 'leer pin digital %1';
Blockly.Msg['IO_MB_READDIGITALPIN_TOOLTIP'] = 'Habilitar para leer el valor digital de los pines (0 o 1)';
Blockly.Msg['IO_MB_WRITEDIGITALPIN_TITLE'] = 'escribir en el pin digital %1 estado %2';
Blockly.Msg['IO_MB_WRITEDIGITALPIN_TOOLTIP'] = 'Habilitar para escribir el valor (0 o 1) en el pin digital';
Blockly.Msg['IO_MB_READANALOGPIN_TITLE'] = 'leer pin analógico %1';
Blockly.Msg['IO_MB_READANALOGPIN_TOOLTIP'] = 'Habilitar para leer el valor analógico de los pines (0-1023)';
Blockly.Msg['IO_MB_WRITEANALOGPIN_TITLE'] = 'escribir en el pin analógico %1 el valor %2';
Blockly.Msg['IO_MB_WRITEANALOGPIN_TOOLTIP'] = 'Permite escribir en el pin analógico el valor (0-1023). Esta función no escribe realmente el valor analógico, escribe la señal PWM. Por ejemplo, escribiendo 511 tiene un ciclo de trabajo del 50%, la tensión media es de 1,65V';
Blockly.Msg['IO_MB_SETPWM_TITLE'] = 'aplicar una señal de periodo %1 %2 en el pin %3';
Blockly.Msg['IO_MB_SETPWM_TOOLTIP'] = 'Habilitar para aplicar una señal PWM en un pin';
// Micro:bit - Inputs
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Sensor SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad del aire (en %) del sensor SHT31. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_MPX5700AP_GETPRESSURE_TITLE'] = '[Sensor MPX5700AP] presión (kPa) en el pin %1';
Blockly.Msg['SENSORS_MPX5700AP_GETPRESSURE_TOOLTIP'] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + 'Permite leer la presión del sensor de ranura con la calculadora TI-83';
Blockly.Msg['SENSORS_MPX5700AP_CALIBRATE_TITLE'] = '[Sensor MPX5700AP] calibrar sensor de presión m %1 b %2';
Blockly.Msg['SENSORS_MPX5700AP_CALIBRATE_TOOLTIP'] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + 'Habilitar para calibrar el sensor de presión con la calculadora TI-83';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Sensor de humedad] humedad en el pin %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Devuelve la medición de humedad (de 0 a 1023) del sensor de humedad de la arboleda en los pines P0 a P4, o P10';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Sensor de temperatura] temperatura en %1 en el pin %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de temperatura de la arboleda en grados Celius (°C), Fahrenheit (°F) o Kelvin (K) en los pines analógicos P0 a P4, o P10';
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Sensor de luz] nivel de luz en el pin %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de luz de la arboleda (de 0 a 1023) en los pines analógicos P0 a P4, o P10';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Sensor ultrasónico %1] obtiene %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Devuelve la medida de la distancia (en cm) o la duración del viaje de ida y vuelta (en µs) del sensor ultrasónico del guardabosques en los pines digitales. Atención, si es un sensor de ranger, TRIG y ECHO están conectados a SIG';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distancia (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'duración del viaje de ida y vuelta (µs)';
Blockly.Msg['SENSORS_ULTRASONIC_1PIN'] = 'en el pin';
Blockly.Msg['SENSORS_ULTRASONIC_2PINS'] = 'en pines';
Blockly.Msg['MICROBIT_GROVE_READ_BME280_TITLE'] = '[Sensor BME280] %1';
Blockly.Msg['MICROBIT_GROVE_READ_BME280_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grados Celius (°C), Fahrenheit (°F) o Kelvin (K), la presión (en hPa) y la humedad (en %)';
Blockly.Msg['MICROBIT_GROVE_READ_BME280_TEMP'] = Blockly.Msg['SENSORS_TEMPERATURE'];
Blockly.Msg['MICROBIT_GROVE_READ_BME280_PRESS'] = Blockly.Msg['SENSORS_PRESSURE'];
Blockly.Msg['MICROBIT_GROVE_READ_BME280_HUM'] = Blockly.Msg['SENSORS_HUMIDITY'];
// Micro:bit - Outpus
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] controla el LED al estado %1 en el pin %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Permite encender o apagar el kit de LEDs Grove (0 o 1) en los pines digitales';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Motor] establece la potencia a %1 en el pin %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permite controlar la potencia del motor de CC (de 0 a 1023) en los pines digitales. Atención, el micro:bit debe ser alimentado por una batería externa para proporcionar suficiente energía al motor de corriente continua';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Módulo de relés] controla el relé al estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Habilitar para controlar el estado del módulo de relé (0 o 1) en los pines digitales';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servomotor] establece el ángulo a %1 en el pin %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permite controlar el ángulo del servomotor (de 0 a 180) en los pines digitales. Atención, el micro:bit tiene que ser alimentado por una batería externa para proporcionar suficiente energía al servomotor';
// Micro:bit - Neopixel
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] define %1 LED en el pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite definir el número de LED del neopixel. Este bloque debe utilizarse en la configuración';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] establece el LED %1 en R %2 G %3 B %4 en el pin %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar cada color de LED de los neopixels como (R,G,B) de 0 a 255. Utilizar P15 para ajustar el neopixel Maqueen';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] establece el LED %1 a %2 en el pin %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Habilitar para controlar cada color del LED del neopixel. Utilizar P15 para ajustar el neopixel Maqueen';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] establece todos los LED al color R %1 G %2 B %3 en el pin %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar todos los LED del neopixel al valor de color elegido como (R,G,B) de 0 a 255. Utilice P15 para ajustar el neopixel Maqueen';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] establece todos los LED al color %1 en el pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Habilitar para controlar todos los LED del neopixel al valor de color elegido. Utilizar P15 para ajustar el neopixel Maqueen';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] establece un arco iris en el pin %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Habilitar para mostrar un arco iris en el módulo neopixel, establecer el pin y el número de LED';
Blockly.Msg['MICROBIT_NEOPIXEL_SWITCH_OFF_TITLE'] = '[Neopixel] apaga todos los LEDs en el pin %1';
Blockly.Msg['MICROBIT_NEOPIXEL_SWITCH_OFF_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Habilitar para apagar todos los LEDs del módulo neopixel';
// CE
Blockly.Msg['CE_BOX_DEFINE_BOX_TITLE'] = '[ce_box] mostrar caja de estadísticas %1 datos %2';
Blockly.Msg['CE_BOX_DEFINE_BOX_TOOLTIP'] = 'Muestra un cuadro en la pantalla de la calculadora con datos estadísticos de la lista proporcionada';
Blockly.Msg['CE_BOX_TITLE_TITLE'] = '[ce_box] añade el título %1';
Blockly.Msg['CE_BOX_TITLE_TOOLTIP'] = 'Añadir título en el gráfico de las estadísticas';
Blockly.Msg['CE_BOX_SHOW_TITLE'] = '[ce_box] mostrar caja';
Blockly.Msg['CE_BOX_SHOW_TOOLTIP'] = 'Mostrar cuadro de estadísticas en la pantalla de la calculadora TI-83';
Blockly.Msg['CE_CHART_DATA_TITLE'] = 'etiqueta %1 valor %2';
Blockly.Msg['CE_CHART_DEFINE_CHART_TITLE'] = '[ce_chart] definir histograma %1 données %2';
Blockly.Msg['CE_CHART_DEFINE_CHART_TOOLTIP'] = 'Definir histograma con datos de la lista proporcionada';
Blockly.Msg['CE_CHART_TITLE_TITLE'] = '[ce_chart] añadir título %1';
Blockly.Msg['CE_CHART_TITLE_TOOLTIP'] = 'Añadir título en el histograma';
Blockly.Msg['CE_CHART_FREQUENCIES_TITLE'] = '[ce_chart] aplicar frecuencias %1';
Blockly.Msg['CE_CHART_FREQUENCIES_TOOLTIP'] = 'Aplicar frecuencias para el histograma';
Blockly.Msg['CE_CHART_SHOW_TITLE'] = '[ce_chart] mostrar histograma';
Blockly.Msg['CE_CHART_SHOW_TOOLTIP'] = 'Mostrar histograma en la pantalla de la calculadora TI-83';
Blockly.Msg['CE_QUIVR_ADD_LINE_PORTION_TITLE'] = '[ce_quivr] añadir porción de línea entre A (%1,%2) y B (%3,%4) color %5';
Blockly.Msg['CE_QUIVR_ADD_LINE_PORTION_TOOLTIP'] = 'Añadir porción de línea entre 2 puntos. Ejemplo: A (t, y(t)) y B (t+dt, y(t+dt)). Este bloque debe utilizarse con los bloques ti_plotlib';
Blockly.Msg['CE_QUIVR_ADD_VECTOR_TITLE'] = '[ce_quivr] añadir vector en el punto (%1,%2) dx %3 dy %4 color %5';
Blockly.Msg['CE_QUIVR_ADD_VECTOR_TOOLTIP'] = 'Añade un vector al punto definido. dx y dy son, respectivamente, las longitudes del vector a lo largo del eje x y del eje y. La opción "tamaño" al final del bloque permite reducir o aumentar el tamaño del vector en un determinado porcentaje. Este bloque debe utilizarse con los bloques ti_plotlib';
Blockly.Msg['CE_QUIVR_ADD_VECTOR_SIZE'] = 'size';
// Turtle - Move
Blockly.Msg['TURTLE_MOVE_TITLE'] = 'mover %1 por %2';
Blockly.Msg['TURTLE_MOVE_FORWARD'] = 'hacia adelante';
Blockly.Msg['TURTLE_MOVE_BACKWARD'] = 'hacia atrás';
Blockly.Msg['TURTLE_MOVE_TOOLTIP'] = 'Muévete especificando la dirección y la distancia';
Blockly.Msg['TURTLE_TURN_TITLE'] = 'gira %1 en %2°';
Blockly.Msg['TURTLE_TURN_RIGHT'] = 'derecha ↻';
Blockly.Msg['TURTLE_TURN_LEFT'] = 'izquierda ↺';
Blockly.Msg['TURTLE_TURN_TOOLTIP'] = 'Gira especificando el valor del ángulo (en °)';
Blockly.Msg['TURTLE_GOTO_TITLE'] = 'ir a la posición x %1 y %2';
Blockly.Msg['TURTLE_GOTO_TOOLTIP'] = 'Ir a la abscisa y ordenada especificadas';
Blockly.Msg['TURTLE_DONE_TITLE'] = 'Mostrar dibujo';
Blockly.Msg['TURTLE_DONE_TOOLTIP'] = 'Habilitar para mantener el dibujo en la pantalla de TI al final del programa';
// Turtle - Draw
Blockly.Msg['TURTLE_FILLCOLOR_TITLE'] = 'definir color de relleno a R %1 G %2 B %3';
Blockly.Msg['TURTLE_FILLCOLOR_TOOLTIP'] = 'Definir el color de relleno por R, G y B (de 0 a 255)';
Blockly.Msg['TURTLE_FILLCOLOR_PALETTE_TITLE'] = 'Definir el color de relleno a %1';
Blockly.Msg['TURTLE_FILLCOLOR_PALETTE_TOOLTIP'] = 'Define el color de relleno usando el color de la paleta';
Blockly.Msg['TURTLE_SET_FILL_TITLE'] = '%1 la ruta de relleno de color';
Blockly.Msg['TURTLE_SET_FILL_TOOLTIP'] = 'Iniciemos o finalicemos un camino para definir la forma donde rellenaremos con color';
Blockly.Msg['TURTLE_SET_FILL_BEGIN'] = 'Comienza';
Blockly.Msg['TURTLE_SET_FILL_END'] = 'termina';
Blockly.Msg['TURTLE_DOT_TITLE'] = 'dibujar disco con diámetro %1';
Blockly.Msg['TURTLE_DOT_TOOLTIP'] = 'Habilitar para dibujar el disco con el diámetro especificado (0-300)';
Blockly.Msg['TURTLE_WRITE_TITLE'] = 'escribir texto %1';
Blockly.Msg['TURTLE_WRITE_TOOLTIP'] = 'Habilitar para añadir texto donde está la tortuga';
// Turtle - Pen
Blockly.Msg['TURTLE_CONTROL_PEN_TITLE'] = '%1 el lápiz';
Blockly.Msg['TURTLE_CONTROL_PEN_TOOLTIP'] = 'Activar o desactivar el dibujo del lápiz';
Blockly.Msg['TURTLE_CONTROL_PEN_UP'] = 'levantar';
Blockly.Msg['TURTLE_CONTROL_PEN_DOWN'] = 'activar';
Blockly.Msg['TURTLE_PENCOLOR_TITLE'] = 'definir el color del lápiz a R %1 G %2 B %3';
Blockly.Msg['TURTLE_PENCOLOR_TOOLTIP'] = 'Definir el color del lápiz en R, G y B (de 0 a 255)';
Blockly.Msg['TURTLE_PENCOLOR_PALETTE_TITLE'] = 'Definir el color del lápiz a %1';
Blockly.Msg['TURTLE_PENCOLOR_PALETTE_TOOLTIP'] = 'Define el color del lápiz usando el color de la paleta';
Blockly.Msg['TURTLE_PENSIZE_TITLE'] = 'Definir el ancho del lápiz a %1';
Blockly.Msg['TURTLE_PENSIZE_TOOLTIP'] = 'Defina el ancho del lápiz (1-4)';
// TUrtle - Settings
Blockly.Msg['TURTLE_CLEAR_TITLE'] = 'borrar el dibujo';
Blockly.Msg['TURTLE_CLEAR_TOOLTIP'] = 'Permite limpiar el dibujo de la pantalla de la calculadora TI-83';
Blockly.Msg['TURTLE_CONTROL_TURTLE_TITLE'] = '%1 tortuga';
Blockly.Msg['TURTLE_CONTROl_TURTLE_TOOLTIP'] = 'Habilitar para mostrar/ocultar la tortuga';
Blockly.Msg['TURTLE_CONTROL_TURTLE_HIDE'] = 'masquer';
Blockly.Msg['TURTLE_CONTROL_TURTLE_SHOW'] = 'afficher';
Blockly.Msg['TURTLE_HIDEGRID_TITLE'] = 'ocultar rejilla';
Blockly.Msg['TURTLE_HIDEGRID_TOOLTIP'] = 'Habilitar para ocultar rejilla';
Blockly.Msg['TURTLE_SPEED_TITLE'] = 'cambiar la velocidad de la tortuga a %1';
Blockly.Msg['TURTLE_SPEED_TOOLTIP'] = 'Permite cambiar la velocidad de la tortuga, por lo que la velocidad de dibujo en la pantalla (0-10)';
// Turtle - State
Blockly.Msg['TURTLE_HOME_TITLE'] = 'reemplazar la tortuga en el centro del dibujo';
Blockly.Msg['TURTLE_HOME_TOOLTIP'] = 'Habilitar para reemplazar la tortuga en el centro del dibujo';
Blockly.Msg['TURTLE_SET_HEADING_TITLE'] = 'Establecer el rumbo de la tortuga %1 (°)';
Blockly.Msg['TURTLE_SET_HEADING_TOOLTIP'] = 'Permite establecer el rumbo de la tortuga (en °) sabiendo que la dirección hacia la derecha corresponde a 0°. Los ángulos positivos corresponden a un ángulo en el sentido de las agujas del reloj. Los ángulos negativos corresponden a un ángulo en sentido contrario a las agujas del reloj';
Blockly.Msg['TURTLE_GET_COORDINATES_TITLE'] = 'obtener coordenadas %1';
Blockly.Msg['TURTLE_GET_COORDINATES_TOOLTIP'] = 'Devuelve las coordenadas x o y (en píxeles) sabiendo que la forma del lienzo son x [-155;155] y y [-105;105]';
Blockly.Msg['TURTLE_GET_COORDINATES_XCOR'] = 'x';
Blockly.Msg['TURTLE_GET_COORDINATES_YCOR'] = 'y';
Blockly.Msg['TURTLE_HEADING_TITLE'] = 'rumbo de la tortuga (°)';
Blockly.Msg['TURTLE_HEADING_TOOLTIP'] = 'Devuelve el rumbo de la tortuga (en °) sabiendo que la dirección a la derecha corresponde a 0°';
// Tello
Blockly.Msg['TELLO_LEFT'] = 'izquierda';
Blockly.Msg['TELLO_RIGHT'] = 'derecha';
Blockly.Msg['TELLO_TAKEOFF_TITLE'] = '[tello] take off';
Blockly.Msg['TELLO_TAKEOFF_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite que el dron Tello despegue. Por favor, ten en cuenta: necesitas un módulo Grove Wifi UART v2 para controlar el dron con un micro:bit v2';
Blockly.Msg['TELLO_LAND_TITLE'] = '[tello] land';
Blockly.Msg['TELLO_LAND_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite aterrizar el dron Tello. Por favor, ten en cuenta: necesitas un módulo Grove Wifi UART v2 para controlar el dron con un micro:bit v2.';
Blockly.Msg['TELLO_FLY_TITLE'] = '[tello] mover %1 %2 (cm)';
Blockly.Msg['TELLO_FLY_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite avanzar o retroceder (20-500 cm) con el dron Tello. Atención: necesitas un módulo Grove Wifi UART v2 para controlar el dron con un micro:bit v2';
Blockly.Msg['TELLO_FLY_FORWARD'] = 'hacia adelante';
Blockly.Msg['TELLO_FLY_BACKWARD'] = 'hacia atrás';
Blockly.Msg['TELLO_TURN_TITLE'] = '[tello] giro %1 ángulo %2 (°)';
Blockly.Msg['TELLO_TURN_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Esto le permite girar a la izquierda o a la derecha en un ángulo (0-360°) con el dron Tello. Por favor, ten en cuenta: necesitas un módulo Grove Wifi UART v2 para controlar el dron con un micro:bit v2.';
Blockly.Msg['TELLO_FLY_IN_HEIGHT_TITLE'] = '[tello] fly %1 height %2 (cm)';
Blockly.Msg['TELLO_FLY_IN_HEIGHT_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite volar hacia arriba o hacia abajo (20-500 cm) con el dron Tello. Por favor, ten en cuenta: necesitas un módulo Grove Wifi UART v2 para controlar el dron con un micro:bit v2.';
Blockly.Msg['TELLO_FLY_UP'] = 'hacia arriba';
Blockly.Msg['TELLO_FLY_DOWN'] = 'hacia atrás';
Blockly.Msg['TELLO_FLY_DIRECTION_TITLE'] = '[tello] fly %1 distance %2 (cm)';
Blockly.Msg['TELLO_FLY_DIRECTION_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite volar hacia la derecha o la izquierda (20-500 cm) con el dron Tello. Por favor, ten en cuenta: necesitas un módulo Grove Wifi UART v2 para controlar el dron con un micro:bit v2.';
Blockly.Msg['TELLO_GET_ALTITUDE_TITLE'] = '[tello] altitud (m)';
Blockly.Msg['TELLO_GET_ALTITUDE_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Devuelve la altitud (en m) a la que se encuentra el dron Tello. Nota: se necesita un módulo Grove Wifi UART v2 para controlar el dron con un micro:bit v2.';
// TI - Draw
Blockly.Msg['TI_DRAW_SET_WINDOW_TITLE'] = 'definir ventana de dibujo a %1 (ancho) y %2 (alto)';
Blockly.Msg['TI_DRAW_SET_WINDOW_TOOLTIP'] = 'Definir el tamaño de la ventana de dibujo a (ancho, alto).';
Blockly.Msg['TI_DRAW_GET_WINDOW_TITLE'] = 'obtener tamaño de ventana de dibujo';
Blockly.Msg['TI_DRAW_GET_WINDOW_TOOLTIP'] = 'Devolver el tamaño actual de la ventana de dibujo.';
Blockly.Msg['TI_DRAW_DRAW_LINE_TITLE'] = 'dibujar una línea desde %1 (x1), %2 (y1) hasta %3 (x2), %4 (y2)';
Blockly.Msg['TI_DRAW_DRAW_LINE_TOOLTIP'] = 'Dibujar una línea entre los puntos (x1, y1) y (x2, y2).';
Blockly.Msg['TI_DRAW_DRAW_CIRCLE_TITLE'] = 'dibujar un círculo de centro %1 (x), %2 (y) y radio %3 (r)';
Blockly.Msg['TI_DRAW_DRAW_CIRCLE_TOOLTIP'] = 'Dibujar un círculo de centro (x, y) y radio r.';
Blockly.Msg['TI_DRAW_FILL_CIRCLE_TITLE'] = 'dibujar un círculo relleno de centro %1 (x), %2 (y) y radio %3 (r)';
Blockly.Msg['TI_DRAW_FILL_CIRCLE_TOOLTIP'] = 'Dibujar un círculo relleno de centro (x, y) y radio r.';
Blockly.Msg['TI_DRAW_DRAW_RECT_TITLE'] = 'dibujar un rectángulo de esquina superior izquierda %1 (x), %2 (y), ancho %3 (w) y altura %4 (h)';
Blockly.Msg['TI_DRAW_DRAW_RECT_TOOLTIP'] = 'Dibujar un rectángulo de esquina superior izquierda (x, y), ancho w y altura h.';
Blockly.Msg['TI_DRAW_FILL_RECT_TITLE'] = 'dibujar un rectángulo relleno de esquina superior izquierda %1 (x), %2 (y), ancho %3 (w) y altura %4 (h)';
Blockly.Msg['TI_DRAW_FILL_RECT_TOOLTIP'] = 'Dibujar un rectángulo relleno de esquina superior izquierda (x, y), ancho w y altura h.';
Blockly.Msg['TI_DRAW_DRAW_TEXT_TITLE'] = 'escribir texto en la posición %1(x) y %2(y) con %3';
Blockly.Msg['TI_DRAW_DRAW_TEXT_TOOLTIP'] = 'Escribir texto en la posición (x, y).';
Blockly.Msg['TI_DRAW_DRAW_POLY_TITLE'] = 'dibujar un polígono con lista de X %1 y lista de Y %2';
Blockly.Msg['TI_DRAW_DRAW_POLY_TOOLTIP'] = 'Dibujar un polígono a partir de dos listas de coordenadas X e Y.';
Blockly.Msg['TI_DRAW_FILL_POLY_TITLE'] = 'dibujar un polígono relleno con lista de X %1 y lista de Y %2';
Blockly.Msg['TI_DRAW_FILL_POLY_TOOLTIP'] = 'Dibujar un polígono relleno a partir de dos listas de coordenadas X e Y.';
Blockly.Msg['TI_DRAW_SET_COLOR_TITLE'] = 'definir color de dibujo a %1 (rojo), %2 (verde), %3 (azul)';
Blockly.Msg['TI_DRAW_SET_COLOR_TOOLTIP'] = 'Definir el color de dibujo (rojo, verde, azul).';
Blockly.Msg['TI_DRAW_SET_PEN_TITLE'] = 'definir el grosor %1 y el estilo del trazo %2';
Blockly.Msg['TI_DRAW_SET_PEN_TOOLTIP'] = 'Definir el grosor (pequeño, mediano, grueso) y el estilo del trazo (sólido, guiones, puntos).';
Blockly.Msg['TI_DRAW_SET_PEN_STYLE_SOLID'] = 'sólido';
Blockly.Msg['TI_DRAW_SET_PEN_STYLE_DASH'] = 'guiones';
Blockly.Msg['TI_DRAW_SET_PEN_STYLE_DOT'] = 'puntos';
Blockly.Msg['TI_DRAW_SET_PEN_THICKNESS_SMALL'] = 'pequeño';
Blockly.Msg['TI_DRAW_SET_PEN_THICKNESS_MEDIUM'] = 'mediano';
Blockly.Msg['TI_DRAW_SET_PEN_THICKNESS_THICK'] = 'grueso';
Blockly.Msg['TI_DRAW_PLOT_XY_TITLE'] = 'graficar con x %1 e y %2 usando forma %3';
Blockly.Msg['TI_DRAW_PLOT_XY_TOOLTIP'] = 'Graficar utilizando x e y con la forma especificada.';
Blockly.Msg['TI_DRAW_SHOW_TITLE'] = 'mostrar dibujo';
Blockly.Msg['TI_DRAW_SHOW_TOOLTIP'] = 'Mostrar el dibujo en la pantalla. Haga clic en \'annul\' para borrar el dibujo.';