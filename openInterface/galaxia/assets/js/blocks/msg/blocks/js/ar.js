/**
 * @fileoverview English messages for ESP32. (EN)
 */
'use strict';
// Display - Galaxia/Display
Blockly.Msg['DISPLAY_GALAXIA_SCREEN_SET_TEXT_TITLE'] = '[SCREEN] Write text %1';
Blockly.Msg['DISPLAY_GALAXIA_SCREEN_SET_TEXT_TOOLTIP'] = '[SCREEN] Write text on the screen of the Galaxia card.';
Blockly.Msg['DISPLAY_GALAXIA_SCREEN_SET_TEXT_VALUE_TITLE'] = '[SCREEN] Write text %1 with value %2';
Blockly.Msg['DISPLAY_GALAXIA_SCREEN_SET_TEXT_VALUE_TOOLTIP'] = '[SCREEN] Write text on the screen of the Galaxia card with a value.';
// Display - Galaxia/RGB
Blockly.Msg['DISPLAY_GALAXIA_LED_GREEN_CONTROL_TITLE'] = '[RGB LED] set green intensity to %1';
Blockly.Msg['DISPLAY_GALAXIA_LED_GREEN_CONTROL_TOOLTIP'] = 'Adjusts the intensity of the green for the LED integrated in the Galaxia card from 0 to 255.';
Blockly.Msg['DISPLAY_GALAXIA_LED_RED_CONTROL_TITLE'] = '[RGB LED] set red intensity to %1';
Blockly.Msg['DISPLAY_GALAXIA_LED_RED_CONTROL_TOOLTIP'] = 'Adjusts the intensity of the red for the LED integrated in the Galaxia card from 0 to 255.';
Blockly.Msg['DISPLAY_GALAXIA_LED_BLUE_CONTROL_TITLE'] = '[RGB LED] set blue intensity to %1';
Blockly.Msg['DISPLAY_GALAXIA_LED_BLUE_CONTROL_TOOLTIP'] = 'Adjusts the intensity of the blue for the LED integrated in the Galaxia card from 0 to 255.';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_BLUE_TITLE'] = '[RGB LED] blue intensity';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_BLUE_TOOLTIP'] = 'Returns a value between 0 and 255 corresponding to the intensity of blue currently transferred to the LED.';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_GREEN_TITLE'] = '[RGB LED] green intensity';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_GREEN_TOOLTIP'] = 'Returns a value between 0 and 255 corresponding to the intensity of green currently transferred to the LED.';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_RED_TITLE'] = '[RGB LED] red intensity';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_RED_TOOLTIP'] = 'Returns a value between 0 and 255 corresponding to the intensity of red currently transferred to the LED.';
Blockly.Msg['DISPLAY_GALAXIA_SET_LED_COLORS_TITLE'] = '[RGB LED] set LED to R %1 G %2 B %3';
Blockly.Msg['DISPLAY_GALAXIA_SET_LED_COLORS_TOOLTIP'] = 'Allows you to adjust the intensity of the LED integrated in the Galaxia card, from 0 to 255.';
// Display - Galaxia/Graphique
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_TITLE'] = 'set the screen to %1 mode';
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_TOOLTIP'] = 'Change the screen mode.';
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_CONSOLE'] = 'terminal';
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_PLOT'] = 'data';
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_GRAPHICS'] = 'graphics';
Blockly.Msg['DISPLAY_GALAXIA_PLOT_ADD_POINT_TITLE'] = '[Data] add the value %1';
Blockly.Msg['DISPLAY_GALAXIA_PLOT_ADD_POINT_TOOLTIP'] = 'Add a point to the chart.';
Blockly.Msg['DISPLAY_GALAXIA_PLOT_SET_Y_SCALE_TITLE'] = '[Data] set Y-axis scale to min %1 max %2';
Blockly.Msg['DISPLAY_GALAXIA_PLOT_SET_Y_SCALE_TOOLTIP'] = 'Set the Y-axis scale.';
Blockly.Msg['DISPLAY_GALAXIA_ANIMATE_FUNCTION_TITLE'] = '[Data] every %1 second(s) calculate a new value';
Blockly.Msg['DISPLAY_GALAXIA_ANIMATE_FUNCTION_NEW_POINT'] = 'add the result %1 to the chart';
Blockly.Msg['DISPLAY_GALAXIA_ANIMATE_FUNCTION_TOOLTIP'] = 'Add a point to the chart every x seconds.';
Blockly.Msg['DISPLAY_GALAXIA_RAW_PRINT_TITLE'] = '[Graphics] display text %1 at x %2 y %3';
Blockly.Msg['DISPLAY_GALAXIA_RAW_PRINT_TOOLTIP'] = 'Display text on the graphics screen.';
Blockly.Msg['DISPLAY_GALAXIA_RAW_TEXT_TITLE'] = '[Graphics] display text %1 at x %2 y %3 with color %4';
Blockly.Msg['DISPLAY_GALAXIA_RAW_RECT_TITLE'] = '[Graphics] display rectangle at x %1 y %2 width %3 height %4 with color %5';
Blockly.Msg['DISPLAY_GALAXIA_RAW_RECT_TOOLTIP'] = 'Display a rectangle on the graphics screen.';
Blockly.Msg['DISPLAY_GALAXIA_RAW_PRINT_IMG_TITLE'] = '[Graphics] display image %1 at x %2 y %3';
Blockly.Msg['DISPLAY_GALAXIA_RAW_PRINT_IMG_TOOLTIP'] = 'Display an image on the graphics screen (you must first load the image into the memory of the Galaxia board)';
// Display - Screen
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD] show text %1 on line %2 position %3';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Show text on the grove lcd 1602 display. Connect lcd on I2C port.';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD] clear display';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Enable to clear the entire lcd text. Connect lcd on I2C port.';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[OLED] show text %1 at position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Enable write text on OLED display (128x64 px). Connect the OLED display on I2C port.';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TITLE'] = '[OLED] control pixel x %1 y %2 to state %3';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Enable to control each OLED display pixel (128x64 px). Connect the OLED display on I2C port.';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TITLE'] = '[OLED] draw a line from (%1, %2) to (%3, %4)';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Enable to draw a line between two points on the Grove OLED display (128x64 px). Connect the OLED display on I2C port.';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TITLE'] = '[OLED] set background to %1';
Blockly.Msg['DISPLAY_OLED_WHITE'] = 'white';
Blockly.Msg['DISPLAY_OLED_BLACK'] = 'black';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Enable to invert the Grove OLED display. Connect the OLED display on I2C port.';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[OLED] clear screen';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Enable to clear the entire Grove OLED screen. Connect the OLED display on I2C port.';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[OLED] draw icon %1 at position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Enable to display an icon from the ESP32 Image library, at position (x,y) on the grove OLED screen. Connect the OLED display on I2C port.';
// Display - Neopixel
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] define %1 LED on pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Enable to define LED number of neopixel. This block have to be used in setup.';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] set LED %1 to R %2 G %3 B %4 on pin %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Enable to control each LED color of neopixels as (R,G,B) from 0 to 255. Use P15 to set Maqueen neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] set LED %1 to %2 on pin %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Enable to control each LED color of neopixel. Use P15 to set Maqueen neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] set all LED to colour R %1 G %2 B %3 on pin %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Enable to control all LED of neopixel to the choosed colour value as (R,G,B) from 0 to 255. Use P15 to set Maqueen neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] set all LED to colour %1 on pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Enable to control all LED of neopixel to the choosed colour value. Use P15 to set Maqueen neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] set a rainbow on pin %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Enable to show a rainbow on neopixel module, set pin and the number of LED.';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] control LED to state %1 on pin %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Enable to switch on or switch off the LED socket kit Grove (0 or 1) on digital pins.';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] set LED intensity to %1 (%) on pin %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Enable to set the LED intensity from 0 to 100% on PWM pins.';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[Variable Color LED] set intensity to %1 (%) on pin %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Enable to set the LED intensity from 0 to 100 (%) on PWM pins. When using the module for the first time, RGB are set to 0. Use a screwdriver on R, G or B behind module to control LED color.';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[4-Digit module] show %1 %2 on pins CLK %3 DIO %4';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Enable to show numbers or temperature on grove 4-digit display (TM1637) on digital pins.';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[4-Digit module] show clock on pins CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Enable to show clock on grove 4-digit display (TM1637) on digital pins. Warning, getting real clock is possible only if ESP32 stay in power on mode.';
Blockly.Msg['DISPLAY_4DIGIT_NUMBER'] = 'number';
Blockly.Msg['DISPLAY_4DIGIT_TEMPERATURE'] = 'temperature';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[LED Bar module] set level of %1 on pins DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Enable to show level of input value on grove LED bar display (MY9221) on digital pins.';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TITLE'] = '[LED Bar Module] invert display %1 DI pins %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Allows to invert the 10 LEDs of the MY9221 module with the digital pins P0 to P20.';
// Display - Chainable LED
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TITLE'] = '[Chainable LED] define %1 LED on pins CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Enable to define chainable RGB LED with number of LED on digital pins D0 up through D13.';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TITLE'] = '[Chainable LED] set LED %1 at R %2 G %3 B %4 on pins CIN %5 DIN %6';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Block controlling the color of the RGB LED, give a value between 0 and 255 for Red, Green and Blue.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TITLE'] = '[Chainable LED] set LED %1 at %2 on pins CIN %3 DIN %4';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Block controlling the color of the RGB LED, choose a colour in the given palette.';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TITLE'] = '[Chainable LED] set all LED at R %1 G %2 B %3 on pins CIN %4 DIN %5';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Block controlling the color of all the RGB LED, give a value between 0 and 255 for Red, Green and Blue.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE'] = '[Chainable LED] set all the LED at %1 on pins CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Block controlling the color of all the LED, choose a colour in the given palette.';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TITLE'] = '[Chainable LED] Shut off all the LED on pins CIN %1 DIN %2';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Block shutting off all the LED.';
// IO - Galaxia - A & B
Blockly.Msg['IO_ISPRESSED'] = 'is';
Blockly.Msg['IO_WASPRESSED'] = 'was';
Blockly.Msg['IO_ONBUTTONPRESSED_TITLE'] = 'on button %1 %2 pressed then';
Blockly.Msg['IO_ONBUTTONPRESSED_TOOLTIP'] = 'Execute instructions if the choosen button (A or B) is pressed.';
Blockly.Msg['IO_ISBUTTONPRESSED_TITLE'] = 'button %1 %2 pressed';
Blockly.Msg['IO_ISBUTTONPRESSED_TOOLTIP'] = 'Returns \'True\' if button A or B is pressed, else return \'False\'.';
Blockly.Msg['IO_ONBUTTONEVENT_TITLE'] = 'when button %1 is pressed';
Blockly.Msg['IO_ONBUTTONEVENT_TOOLTIP'] = 'Do something when a button (A or B) is pressed down and released again.';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TITLE'] = 'get button %1 presses';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TOOLTIP'] = 'Returns number of presses of button A or B';
// IO - Galaxia - Touch buttons
Blockly.Msg['IO_TOUCH_UP'] = 'up';
Blockly.Msg['IO_TOUCH_DOWN'] = 'down';
Blockly.Msg['IO_TOUCH_RIGHT'] = 'right';
Blockly.Msg['IO_TOUCH_LEFT'] = 'left';
Blockly.Msg['IO_IFTOUCHSENSITIVEBUTTONTOUCHED_TITLE'] = 'if the %1 touch button %2 pressed do';
Blockly.Msg['IO_IFTOUCHSENSITIVEBUTTONTOUCHED_TOOLTIP'] = 'Execute instructions if the choosen touch button (up, down, right or left) is touched.';
Blockly.Msg['IO_ISTOUCHSENSITIVEBUTTONTOUCHED_TITLE'] = 'the %1 touch button %2 touched';
Blockly.Msg['IO_ISTOUCHSENSITIVEBUTTONTOUCHED_TOOLTIP'] = 'Return \'True\' if the selected touch-sensitive button is touched, else return \'False\'.';
Blockly.Msg['IO_ONTOUCHSENSITIVEBUTTONEVENT_TITLE'] = 'when %1 touch button was touched';
Blockly.Msg['IO_ONTOUCHSENSITIVEBUTTONEVENT_TOOLTIP'] = 'Do something when a touch button (up, down, right or left) is touched and released again.';
Blockly.Msg['IO_TOUCHSENSITIVEBUTTON_GET_TOUCHES_TITLE'] = 'number of touches of %1 button';
Blockly.Msg['IO_TOUCHSENSITIVEBUTTON_GET_TOUCHES_TOOLTIP'] = 'Returns the number of times the selected touch button (UP, DOWN, RIGHT or LEFT) has been touched since the last call to the get_presses() function, i.e. this block';
//input/output Galaxia Specific
// Input/Output - Esp32
Blockly.Msg['IO_WAIT_TITLE'] = 'wait %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Stop the code execution (duration in seconds or milliseconds).';
Blockly.Msg['IO_WAIT_SECOND'] = 'second(s)';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'millisecond(s)';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microsecond(s)';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'wait until %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Stop the code execution until the satisfied condition.';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'initialize the chronometer';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Allows you to initialize the chronometer (in seconds).';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'get chronometer in %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Returns the chronometer value from the initialization in seconds or milliseconds.';
// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Numeric Touch Keypad] get number on pins RX %1 TX %2';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Enable to get touched number from keypad grove module on pins RX & TX. When you connect device, make sure you “cross” the wires. ESP32 TX pin needs to be connected with device\'s RX pin, and the RX pin with the device\'s TX pin.';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Joystick Module] joystick axis %1 value on pins A0 %2 A1 %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Returns grove joystick axis value (from 0 to 4095) on analog pins p34 through p36, or p39 (as A2 to A4 on shield Grove)..';
Blockly.Msg['IO_ROTARYENCODER_TITLE'] = '[Rotary Encoder] value on pins CLK %1 DT %2';
Blockly.Msg['IO_ROTARYENCODER_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Return the value of the Grove rotary encoder. Connect the CLK and DT pins to the digital pins on the Galaxia.';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TITLE'] = '[Colored Button Module] state on pin SIG2 %1';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Returns grove colored button state (0 or 1) on digital pins.';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TITLE'] = '[Colored Button Module] control LED to state %1 on pin SIG1 %2';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Enable to switch on or switch off the LED Button Grove (0 or 1) on digital pins.';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Rotary Angle Module] angle on pin %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Returns grove rotary angle position (from 0 to 4095) on analog pins p34 through p36, or p39 (as A2 to A4 on shield Grove)..';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Slide Potentiometer] position value on pin %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Returns grove slide potentiometer position value (from 0 to 4095) on analog pins p34 through p36, or p39 (as A2 to A4 on shield Grove)..';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Touch Sensor] touch state on pin %1 ';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Returns grove touch sensor state (0 or 1) on digital pins.';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Button Module] button state on pin %1 ';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Returns grove button state (0 or 1) on digital pins.';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Switch Module] switch state on pin %1 ';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Returns grove switch state (0 or 1) on digital pins.';
// Input/Output - Pins
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'HIGH (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'LOW (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Returns boolean value (1 if HIGH or 0 if LOW).';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'read digital pin %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Enable to read the digital value of pins (0 or 1).';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'write state %1 on digital pin %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Enable to write the value (0 or 1) on digital pin.';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'read analog pin %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Enable to read the analog value of pins (0-8191) as between 0 and 3.6V.';
Blockly.Msg['IO_WRITEPWMPIN_TITLE'] = 'write value %1 on PWM pin %2';
Blockly.Msg['IO_WRITEPWMPIN_TOOLTIP'] = 'Enable to apply PWM signal with fixed 10kHz-frequency. You can change value from 0 to 8191. 512 will be 50% of duty cycle, as around 1.66V.';
Blockly.Msg['IO_WRITEANALOGPIN_TITLE'] = 'write value %1 on analog pin %2 (DAC)';
Blockly.Msg['IO_WRITEANALOGPIN_TOOLTIP'] = 'Enable to apply an analog voltage to the DAC pins p25 and p26 (from 0 to 255). The Esp32 uses a digital-analog converter (DAC) to apply a voltage between 0 and 3.3V.';
Blockly.Msg['IO_SETPWM_TITLE'] = 'apply a square signal of %1 (Hz) frequency on pin %2';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Enable to apply a PWM square signal with 50% of duty cycle. You can change frequency of the signal.';
Blockly.Msg['IO_STOPPWM_TITLE'] = 'stop PWM signal of pin %1';
Blockly.Msg['IO_STOPPWM_TOOLTIP'] = 'Enable to stop applied PWM signal of a pin.';
Blockly.Msg['IO_GETVOLTAGE_TITLE'] = 'convert %1 in voltage with resolution %2';
Blockly.Msg['IO_GETVOLTAGE_TOOLTIP'] = 'Enable to convert analog value in voltage by resolution (10-bit: 1024, 12-bit: 4096, 9-bit: 512, 11-bit: 2048) and maximum of 3.6V.';

// Communication LOG
Blockly.Msg['COMMUNICATION_LOG_DELETE_TITLE'] = 'clear logs';
Blockly.Msg['COMMUNICATION_LOG_DELETE_TOOLTIP'] = 'Allows clearing the logs from the Galaxia board.';
Blockly.Msg['COMMUNICATION_LOG_SET_LABEL_TITLE'] = 'add a new label';
Blockly.Msg['COMMUNICATION_LOG_SET_LABEL_TOOLTIP'] = 'Allows adding a label to the logs of the Galaxia board.';
Blockly.Msg['COMMUNICATION_LOG_ADDDATA_TITLE'] = 'add data to a label';
Blockly.Msg['COMMUNICATION_LOG_ADDDATA_TOOLTIP'] = 'Allows adding a label to the data column of the log. The label can be text or a number. The data can be text or a number.';
Blockly.Msg['COMMUNICATION_LOG_DATA_TITLE'] = 'label %1 data %2';
Blockly.Msg['COMMUNICATION_LOG_DATA_TOOLTIP'] = 'Allows adding a label to the data column of the log. The label can be text or a number. The data can be text or a number.';

// Communication - Galaxia
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TITLE'] = '[Radio] send string %1';
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TOOLTIP'] = 'Enable to send string by Galaxia radio module.';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TITLE'] = '[Radio] send number or list %1';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TOOLTIP'] = 'Enable to send numbers or lists by radio module.';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TITLE'] = '[Radio] send value %1 as %2';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TOOLTIP'] = 'Enable to send data with \'name\' and its value by radio module.';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TITLE'] = '[Radio] on data received in %1 then';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TOOLTIP'] = 'Allows you to execute instructions on string received by radio in the \'stringData\' variable.';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TITLE'] = '[Radio] on data received in %1 then';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TOOLTIP'] = 'Allows you to execute instructions on number received by radio in the \'numberData\' variable.';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TITLE'] = '[Radio] on data received in %1 %2 then';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TOOLTIP'] = 'Allows you to execute instructions on name as string and value as number received by radio in the \'name\' and \'value\' variables.';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TITLE'] = '[Radio] set Channel %1 Power %2 Data size %3 Group %4';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TOOLTIP'] = 'Allows you to configure the frequence channel (from 0 to 83), data size (bytes), transmission power (from 0 to 7), and group (from 0 to 255).';
//Communication - Internal Bluetooth
Blockly.Msg['COMMUNICATION_START_BT_TITLE'] = '[ESP32 Bluetooth UART] initialize bluetooth %1';
Blockly.Msg['COMMUNICATION_START_BT_TOOLTIP'] = 'Initialize Bluetooth service on the ESP32 with given name.';
Blockly.Msg['COMMUNICATION_SEND_BT_TITLE'] = '[ESP32 Bluetooth UART] send data %1';
Blockly.Msg['COMMUNICATION_SEND_BT_TOOLTIP'] = 'Send data via the ESP32\'s Bluetooth service.';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TITLE'] = '[Bluetooth] on data reception in %1 then ';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TOOLTIP'] = 'Executes instructions on data reception via Bluetooth (BLE).';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TITLE'] = '[Fizziq App] send %1 %2';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TOOLTIP'] = IMG_MODULE_FIZZIQ + Blockly.Tooltip.SEP + 'Send data via the ESP32\'s Bluetooth service to Fizziq App.';
Blockly.Msg['FIZZ_TEMP'] = 'Temperature';
Blockly.Msg['FIZZ_HUM'] = 'Moisture';
Blockly.Msg['FIZZ_VOLTAGE'] = 'Voltage';
Blockly.Msg['FIZZ_WEIGHT'] = 'Weight';
Blockly.Msg['FIZZ_PRESSURE'] = 'Pressure';
Blockly.Msg['FIZZ_CONCENTRATION'] = 'Concentration';
Blockly.Msg['FIZZ_MAGNETIC'] = 'Magnetic field';
Blockly.Msg['FIZZ_BRIGHTNESS'] = 'Brightness';
Blockly.Msg['FIZZ_ACCELERATION'] = 'Acceleration';
Blockly.Msg['FIZZ_COMPASS'] = 'Compass';
// Infrared Communication
Blockly.Msg['COMMUNICATION_IR_EMIT_TITLE'] = '[IR] %1 an IR signal on pin %2';
Blockly.Msg['COMMUNICATION_IR_EMIT_TOOLTIP'] = 'Enable to send an IR signal on the pin indicated.';
Blockly.Msg['COMMUNICATION_IR_EMIT_ACTIVATE'] = 'activate';
Blockly.Msg['COMMUNICATION_IR_EMIT_DEACTIVATE'] = 'deactivate';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'write on serial port %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Write a string on serial port.';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'with';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'newline(s)';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE then'] = 'on serial data received in %1 then';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Allows you to execute instructions if data is received by serial port in the \'serialData\' variable.';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'play music %1 in the serial port';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Play selected note until execution of "Stop music" block.';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'play frequency %1 (Hz) on the computer';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'This block allows to play a given frequency on the computer';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'stop music of serial port';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Stop the current note of serial port.';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'write graph';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'This block makes it possible to write (digital) data that will be visible in the plotter. It can be used with one or more blocks in "Name" and "Data" format. Click on icon \'Graphic mode\' to display graphics.';
Blockly.Msg['COMMUNICATION_DATA'] = 'Data';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Name %1 Data %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'This block is to be used in the "Write in graphic" block. It must contain the name of the (text) value to display and the value in question.';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] write in the SD card %1 baudrate %2 on pins RXI %3 TXO %4 %5 Datas %6';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'Block enables writing data in the SD card of Openlog module.';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] send on pins RX %1 TX %2 message %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Enable to send any data by bluetooth HC05 module on pins RX/TX.';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] on message received RX %1 TX %2 in %3 then';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Allows you to execute instructions on data received by Bluetooth HC05 module in the \'bluetoothData\' variable on pins TX/RX.';
// Communication - Tracking modules
Blockly.Msg['COMMUNICATION_GPS_INFO_TYPE'] = 'frame type';
Blockly.Msg['COMMUNICATION_GPS_INFO_CLOCK'] = 'clock (h, m, s)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LATITUDE'] = 'latitude (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LONGITUDE'] = 'longitude (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_SATELLITE'] = 'number of satellites used';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALTITUDE'] = 'altitude (m)';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALL_FRAME'] = 'all frame';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TITLE'] = '[GPS] NMEA frames on pins RX %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Returns the list of NMEA frames read with the Grove SIM28 or Air530 GPS module on the RX/TX pins. The wires do not need to be reversed between the module pins and those indicated in the block. The inversion is done automatically in the python code.\nWarning: If you use the console to display GPS data, connect your card to the interface before sending the program by clicking on the button [>_ REPL]. Then transfer your program using the button [Download .hex].';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TITLE'] = '[GPS] get %3 on RX %1 TX %2 pins';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Returns the data selected among (frame type, clock, latitude, longitude, altitude) analyzed from the NMEA frame (GNGGA or GPGGA) read with the Grove SIM28 or Air530 GPS module on the RX/TX pins. The wires do not do not need to be reversed between the pins of the module and those indicated in the block. The reversal is done automatically in the python code.\nWarning: If you use the console to display the GPS data, connect your card to the interface before sending the program by clicking on the [>_ REPL] button. Then, transfer your program using the button [Download .hex].';
Blockly.Msg['COMMUNICATION_RTC_MODULE_PCF85063TP'] = 'High Precision (0x51)';
Blockly.Msg['COMMUNICATION_RTC_MODULE_DS1307'] = 'v1.2 (0x68)';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TITLE'] = '[Clock RTC %1] initialize at %2 date %3';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Allows you to initialize the date with the Grove High Precision RTC clock module (PCF85063TP) or RTC v1.2 (DS1307) so that you can read the exact date and time using the \'Read clock module\' block. Place in the \'on start\' block. Connect module on I2C port. Warning: To work, the DS1307 module must have a small flat battery.';
Blockly.Msg['DAY_MONDAY'] = 'monday';
Blockly.Msg['DAY_TUESDAY'] = 'tuesday';
Blockly.Msg['DAY_WEDNESDAY'] = 'wednesday';
Blockly.Msg['DAY_THURSDAY'] = 'thursday';
Blockly.Msg['DAY_FRIDAY'] = 'friday';
Blockly.Msg['DAY_SATURDAY'] = 'saturday';
Blockly.Msg['DAY_SUNDAY'] = 'sunday';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TITLE'] = '[Clock RTC %1] initialize at hour %2 minute %3 second %4';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Allows you to initialize the time the Grove High Precision RTC clock module (PCF85063TP) or RTC v1.2 (DS1307) so that you can read the exact date and time using the \'Read clock module\' block. Place in the \'on start\' block. Connect the module on I2C port. Warning: To work, the DS1307 module must have a small flat battery.';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TITLE'] = '[Clock RTC %1] read %2';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Read the date and time (choose from the drop-down menu) from Grove High Precision RTC clock module (PCF85063TP) or RTC v1.2 (DS1307). To obtain a correct result, first use the two blocks \'Initialize the clock module\'. Connect module on I2C port. Warning: To work, the DS1307 module must have a small flat battery.';
Blockly.Msg['CLOCK_ALL_DATA'] = 'time';
Blockly.Msg['CLOCK_YEAR'] = 'year';
Blockly.Msg['CLOCK_MONTH'] = 'month';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'day of month';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'day of week';
Blockly.Msg['CLOCK_HOUR'] = 'hour';
Blockly.Msg['CLOCK_MINUTE'] = 'minute';
Blockly.Msg['CLOCK_SECOND'] = 'second';
// Communication - UART
Blockly.Msg['COMMUNICATION_UART_INIT_TITLE'] = '[uart] init serial connection to RX %1 TX %2 Baudrate %3';
Blockly.Msg['COMMUNICATION_UART_INIT_TOOLTIP'] = 'Allows you to set the serial connection of the ESP32 board to the UART port (1 or 2). Port 0 is reserved for REPL.';
Blockly.Msg['COMMUNICATION_UART_WRITE_TITLE'] = '[uart] write data %1';
Blockly.Msg['COMMUNICATION_UART_WRITE_TOOLTIP'] = 'Allows writing data to UART port (1 or 2). By default the pins are as: UART 1 (tx=10, rx=9) and UART 2 ( tx=17, rx=16) Otherwise, use the block \'Set serial connection to RX TX Baudrate...\'.';
Blockly.Msg['COMMUNICATION_UART_READ_TITLE'] = '[uart] read data';
Blockly.Msg['COMMUNICATION_UART_READ_TOOLTIP'] = 'Read data from UART port (1 or 2). By default the pins are as: UART 1 (tx=10, rx=9) and UART 2 (tx =17, rx=16).Otherwise, use the block \'Set serial connection to RX TX Baudrate...\'.';
Blockly.Msg['COMMUNICATION_UART_READ_SIZE'] = 'data size';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TITLE'] = '[uart] data available';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TOOLTIP'] = 'Returns the size of data available on the UART port (1 or 2). By default, the pins are as: UART 1 (tx=10, rx=9) and UART 2 ( tx=17, rx=16). Otherwise, use the \'Set serial connection to RX TX Baudrate...\' block.';
// Sensors - Galaxia
Blockly.Msg['SENSORS_GETACCELERATION_TITLE'] = 'acceleration (mg) %1';
Blockly.Msg['SENSORS_GETACCELERATION_TOOLTIP'] = 'Returns the acceleration (in mg) with internal Galaxia accelerometer.';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_TITLE'] = 'on %1 then';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_SHAKE'] = 'shake';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_UP'] = 'logo up';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_DOWN'] = 'logo down';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FACE_UP'] = 'screen up';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FACE_DOWN'] = 'screen down';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_LEFT'] = 'tilt left';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_RIGHT'] = 'tilt right';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FREEFALL'] = 'free fall';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_TOOLTIP'] = 'Execute instructions if the Galaxia board is shaken.';
Blockly.Msg['SENSORS_GETLIGHT_TITLE'] = 'light level';
Blockly.Msg['SENSORS_GETLIGHT_TOOLTIP'] = 'Returns light level (from 0 to 255) with some of Galaxia screen LED.';
Blockly.Msg['SENSORS_CALIBRATECOMPASS_TITLE'] = 'calibrate compass';
Blockly.Msg['SENSORS_CALIBRATECOMPASS_TOOLTIP'] = 'Enable to calibrate the internal Galaxia compass. Just shake the board to calibrate it. A \'happy\' smiley appears when the calibration is completed.';
Blockly.Msg['SENSORS_GETCOMPASS_TITLE'] = 'compass heading (°)';
Blockly.Msg['SENSORS_GETCOMPASS_TOOLTIP'] = 'Returns the compass heading (from 0° to 360°) with the internal Galaxia compass.';
Blockly.Msg['SENSORS_GETTEMPERATURE_TITLE'] = 'temperature in %1';
Blockly.Msg['SENSORS_GETTEMPERATURE_TOOLTIP'] = 'Returns the temperature in Celius degree (°C), Fahrenheit (°F) or Kelvin (K) of Galaxia processor.';
Blockly.Msg['SENSORS_GETROTATION_TITLE'] = 'rotation (°) %1';
Blockly.Msg['SENSORS_GETROTATION_PITCH'] = 'pitch';
Blockly.Msg['SENSORS_GETROTATION_ROLL'] = 'roll';
Blockly.Msg['SENSORS_GETROTATION_TOOLTIP'] = 'Returns the rotation (from -180° to 180°) with the internal Galaxia accelerometer.';
Blockly.Msg['SENSORS_GETMAGNETICFORCE_TITLE'] = 'magnetic field strength %1 (nT)';
Blockly.Msg['SENSORS_GETMAGNETICFORCE_TOOLTIP'] = 'Returns the magnetic field strength (in nT) in the choosen direction from internal Galaxia compass.';
// Sensors - ESP32
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TITLE'] = 'read hall sensor';
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TOOLTIP'] = 'Returns the hall sensor value from board.';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TITLE'] = 'read processor temperature in %1';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TOOLTIP'] = 'Returns the temperature of processor board.';
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[SGP30 Sensor] gas %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Returns the amount of CO2 (in ppm) or TVOC (in ppb) in the air from sgp30 sensor. Connect sensor on I2C port.';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'carbon dioxide (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'volatile organic compounds (TVOC) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Multichannel Gas Sensor] gas %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Returns the amount of choosen gas in the air (in ppm) from grove multichannel gas sensor. Connect sensor on I2C port.';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Multichannel Gas Sensor v2] gas %1 (V)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Returns the amount of choosen gas in the air (in V) from grove multichannel gas V2 sensor. Connect sensor on I2C port.';
Blockly.Msg['GAS_CO'] = 'carbon monoxide (CO)';
Blockly.Msg['GAS_NO2'] = 'nitrogen dioxide (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'ethanol (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'dihydrogen (H2)';
Blockly.Msg['GAS_NH3'] = 'ammonia (NH3)';
Blockly.Msg['GAS_CH4'] = 'methane (CH4)';
Blockly.Msg['GAS_C3H8'] = 'propane (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'iso-propane (C4H10)';
Blockly.Msg['GAS_VOC'] = 'volatile organic compounds (VOC)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Oxygen Gas Sensor] O2 (%) on pin %1';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Returns O2 concentration (in %) from the grove O2 sensor on analog pins p34 through p36, or p39 (as A2 to A4 on shield Grove).';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[SCD30 Sensor] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Returns CO2 concentration (in ppm), humidity (in %) or temperature in Celsius (°C), Fahrenheit (°F) or Kelvin (K) from the grove SCD30 sensor. Connect sensor on I2C port.';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'carbon dioxide (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = 'temperature';
Blockly.Msg['SENSORS_SCD30_HUM'] = 'humidity (%)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[SCD30 Sensor] force recalibration to %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Force the calibration of the SCD30 sensor to the given value (in ppm). Go outside (where the concentration is around approximately 420 ppm, i.e. clean air), reset the board, then wait 2 minutes. Tip: Use the SW1, SW2 or SW3 buttons on the STM32 NUCLEO board to control the start of the calibration. Otherwise, by reconnecting the board, the program launches and again performs an unrequested calibration.';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Air Quality Sensor] value on pin %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Returns value of air quality (from 0 to 4095) on analog pins p34 through p36, or p39 (as A2 to A4 on shield Grove).';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[HM330X Sensor] concentration of particle matter %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Detect the density of particles in the air with the HM330X sensor. Connect sensor on I2C port.';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
// Sensors - Climate
Blockly.Msg['SENSORS_LINKY_TITLE'] = '[Linky Sensor] retrieve the value of %1 on RX pin %2';
Blockly.Msg['SENSORS_LINKY_TOOLTIP'] = 'Returns the apparent electric consumption (in Wh) for off-peak and peak hours of the Linky meter. Connect the sensor to a UART port on the Galaxia board.';
Blockly.Msg['SENSORS_LINKY_PAPP'] = 'instantaneous power';
Blockly.Msg['SENSORS_LINKY_HCHC'] = 'off-peak hours';
Blockly.Msg['SENSORS_LINKY_HCHP'] = 'peak hours';
Blockly.Msg['SENSORS_TEMPERATURE'] = 'temperature';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humidity (%)';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'in';
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[BMP280 Sensor %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Returns the ambient temperature in Celius degree (°C), Fahrenheit (°F) or Kelvin (K), pressure (in Pa). The altitude is initialized at 0 when program is flashed. It use Grove Barometer Sensor (address: 0x77, color: blue) or HW-611 280 sensor (address: 0x76, color: purple). Connect sensor on I2C port.';
Blockly.Msg['SENSORS_BMP280_TEMP'] = 'temperature';
Blockly.Msg['SENSORS_BMP280_PRESS'] = 'pressure (Pa)';
Blockly.Msg['SENSORS_BMP280_ALT'] = 'altitude (m)';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = '[H.T° sensor] temperature in %1 on pins A0 %2 A1 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Returns thermocouple temperature dorm 50 to 600 °C with grove high temperature sensor. Connect sensor on analog pins.';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Moisture Sensor] moisture on pin %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Returns moisture measurement (from 0 to 4095) from the grove moisture sensor on pins IO34, 35 , 36 and 39.';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Temperature Sensor] temperature in %1 on pin %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Returns grove temperature sensor value in Celius degree (°C), Fahrenheit (°F) or Kelvin (K) on analog pins p34 through p36, or p39 (as A2 to A4 on shield Grove).';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TITLE'] = '[DS18B20 Sensor] temperature in %1 on pin %2';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + 'Returns the DS18B20 waterproof temperature sensor value in Celius degree (°C), Fahrenheit (°F) or Kelvin (K) on digital pins.';
Blockly.Msg['SENSORS_DHT11_READDATA_TITLE'] = '[DHT11 Sensor] %1 on pin %2';
Blockly.Msg['SENSORS_DHT11_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Returns temperature in Celius degree (°C), Fahrenheit (°F) or Kelvin (K), or air humidity (in %) from dht11 sensor on digital pins.';
Blockly.Msg['SENSORS_DHT22_READDATA_TITLE'] = '[DHT22 Sensor] %1 on pin %2';
Blockly.Msg['SENSORS_DHT22_READDATA_TOOLTIP'] = IMG_MODULE_DHT22 + Blockly.Tooltip.SEP + 'Returns temperature in Celius degree (°C), Fahrenheit (°F) or Kelvin (K), or air humidity (in %) with good accuracy from dht22 sensor on digital pins.';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[TH02 Sensor] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Returns temperature in Celsius degree (°C), Fahrenheit (°F) or Kelvin (K), or air humidity (in %) from TH02 sensor. Connect sensor on I2C port.';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[SHT31 Sensor] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Returns temperature in Celsius degree (°C), Fahrenheit (°F) or Kelvin (K), or air humidity (in %) from SHT31 sensor. Connect sensor on I2C port.';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Water Sensor] water amount on pin %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Returns water amount (from 0 to 255) from the grove water sensor on analog pins p34 through p36, or p39 (as A2 to A4 on shield Grove)..';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Rain Gauge sensor] state value on pin %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Returns rain gauge grove state (1 if it\'s raining or 0 else) on digital pins.';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anemometer] state value on pin %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Returns grove anemometer state (twice state HIGH on each rotation) on digital pins.';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Light Sensor] light level on pin %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Returns grove light sensor value (from 0 to 4095) on analog pins p34 through p36, or p39 (as A2 to A4 on shield Grove).';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[SI1145 Sensor] get light %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Returns Ultraviolet light index, IR light (in lumen) or Visible light (in lumen) from si1145 sensor. It works with Grove Sunlight Sensor or GY1145 sensor. Connect sensor on I2C port.';
Blockly.Msg['SENSORS_SI1145_UV'] = 'UV index';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visible (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrared (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Ultraviolet Sensor] UV index on pin %1';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Returns UV index, for waves between 240 nm and 380 nm, with UV grove sensor on analog pins p34 through p36, or p39 (as A2 to A4 on shield Grove)..';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Color Sensor] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Lets you read the level of one of the three primary colors with the Grove color sensor, returns a level between 0 and 255.';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Sound Sensor] sound level (dB) on pin %1 ';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Returns grove sound sensor value (from 0 to 8191 converted in dB) on analog pins p34 through p36, or p39 (as A2 to A4 on shield Grove)..';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Ultrasonic Sensor %1] get %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Returns distance measurement (in centimeters) from the ultrasonic ranger sensor on digital pins. Warning, if it\'s a grove sensor, TRIG and ECHO are both connected to SIG.';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distance (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'round-trip duration (µs)';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = '[Gesture Sensor] gesture type';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Returns the gesture type (\'right\', \'left\', \'up\', \'down\', \'forward\', \'backward\', \'clockwise\', \'anticlockwise\') from grove gesture sensor. Connect sensor on I2C port.';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Gesture Sensor] on gesture %1 detected then';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Execute instructions if selected gesture id detected by the grove gesture sensor. Connect sensor on I2C port.';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'right';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'left';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'up';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'down';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'forward';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'backward';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'clockwise';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'anticlockwise';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'wave';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Line Finder Sensor] line finder state on pin %1';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Returns grove touch sensor state (0 or 1) on digital pins.';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[PIR Motion Sensor] movement state value on pin %1';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Returns grove PIR Motion state (0 if there is movement or 1 else) on digital pins.';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Piezo Vibration Sensor] state value on pin %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Returns vibration state (0 or 1) from piezo vibration grove sensor on digital pins.';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Tilt Module] tilt state on pin %1';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Returns grove tilt state (0 or 1) on digital pins.';
// Other sensors
Blockly.Msg['SENSORS_GETGROVEBUTTON_TITLE'] = '[Button Module] button %1 on pin %2';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Returns numeric value of grove button (0/1 or 0V/3.3V) on digital pins.';
Blockly.Msg['SENSORS_GETGROVEBUTTON_VOLTAGE'] = 'voltage';
Blockly.Msg['SENSORS_GETGROVEBUTTON_STATE'] = 'state';
// Actuators
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servomotor] set angle to %1 on pin %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Enable to control servo angle (from 0 to 180) on digital pins. Warning, ESP32 has to be powered by external batterie in order to provide enough energy to servomotor.';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Continuous Servomotor] set speed to %1 (%) direction %2 on pin %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Enable to control continuous servo speed (from 0 to 100 %) on PWM pins.';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Motor] set power to %1 on pin %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Enable to control DC motor power (from 0 to 8191) on digital pins. Warning, ESP32 has to be powered by external batterie in order to provide enough energy to DC motor.';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Relay module] control relay to state %1 on pin %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Enable to control state grove relay module (0 or 1) on digital pins.';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Vibration motor] control motor to state %1 on pin %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Enable to control state of grove vibration motor (0 or 1) on digital pins.';
// Actuators - Music
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TITLE'] = '[Buzzer/Speaker] play music %1 on %2';
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Enable to play the choosen music on Grove buzzer module (or speaker) on digital pins.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TITLE'] = '[Buzzer/Speaker] play notes on';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Enable to play notes on Grove buzzer module (or speaker) on digital pins.';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TITLE'] = 'note %1 at octave %2 with duration %3';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Define a note with octave and duration.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TITLE'] = '[Buzzer/Speaker] play frequency %1 during %2 (ms) on %3';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Enable to play integer frequency on Grove buzzer module (or speaker) on digital pins.';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TITLE'] = '[Buzzer/Speaker] stop music on %1';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Enable to stop music from Grove buzzer module (or speaker) on digital pins.';
// Notes
Blockly.Msg['NOTE_C'] = 'C';
Blockly.Msg['NOTE_C_SHARP'] = 'C#';
Blockly.Msg['NOTE_D'] = 'D';
Blockly.Msg['NOTE_D_SHARP'] = 'D#';
Blockly.Msg['NOTE_E'] = 'E';
Blockly.Msg['NOTE_F'] = 'F';
Blockly.Msg['NOTE_F_SHARP'] = 'F#';
Blockly.Msg['NOTE_G'] = 'G';
Blockly.Msg['NOTE_G_SHARP'] = 'G#';
Blockly.Msg['NOTE_A'] = 'A';
Blockly.Msg['NOTE_A_SHARP'] = 'A#';
Blockly.Msg['NOTE_B'] = 'B';
Blockly.Msg['MUSIC_SILENCE'] = 'Silence';

// AI sensors
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TITLE'] = 'تحميل النموذج المحلي';
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TOOLTIP'] = 'يتيح تحميل نموذج ذكاء اصطناعي مخزن محليًا من متصفح الويب.';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TITLE'] = 'تحميل النموذج من الرابط %1';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TOOLTIP'] = 'يتيح تحميل نموذج ذكاء اصطناعي مخزن في السحابة.';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TITLE'] = 'تنبؤ من بيانات المستشعر';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TOOLTIP'] = 'يتيح إجراء تنبؤ من مستشعر. قم بضبط نافذة الوقت للحصول على التنبؤ إذا لزم الأمر.';
Blockly.Msg['VITTAIA_SENSOR_ACC'] = 'مقياس التسارع';
Blockly.Msg['VITTAIA_DETECT_CLASS_TITLE'] = 'إذا تم الكشف عن الفئة %1 %2 فقم بـ';
Blockly.Msg['VITTAIA_DETECT_CLASS_TOOLTIP'] = 'يتيح اكتشاف فئة كائن.';
Blockly.Msg['VITTAIA_IS'] = 'هو';
Blockly.Msg['VITTAIA_ISNOT'] = 'ليس';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TITLE'] = 'الفئة المكتشفة';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TOOLTIP'] = 'يتيح لك استرجاع الفئة ذات أعلى احتمال.';