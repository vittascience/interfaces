/**
 * @fileoverview English messages for ESP32. (EN)
 */
'use strict';
// Display - Galaxia/Display
Blockly.Msg['DISPLAY_GALAXIA_SCREEN_SET_TEXT_TITLE'] = '[Pantalla] Mostar texto %1 ';
Blockly.Msg['DISPLAY_GALAXIA_SCREEN_SET_TEXT_TOOLTIP'] = '[Pantalla] Muestra texto en la pantalla de la tarjeta Galaxia.';
Blockly.Msg['DISPLAY_GALAXIA_SCREEN_SET_TEXT_VALUE_TITLE'] = '[Pantalla] Mostrar texto %1 con valor %2';
Blockly.Msg['DISPLAY_GALAXIA_SCREEN_SET_TEXT_VALUE_TOOLTIP'] = '[Pantalla] Muestra texto en la pantalla de la tarjeta Galaxia con un valor numérico.';
// Display - Galaxia/RGB
Blockly.Msg['DISPLAY_GALAXIA_LED_GREEN_CONTROL_TITLE'] = '[LED RGB] establece la intensidad del verde en %1';
Blockly.Msg['DISPLAY_GALAXIA_LED_GREEN_CONTROL_TOOLTIP'] = 'Ajusta la intensidad del verde del LED integrado en la tarjeta Galaxia de 0 a 255';
Blockly.Msg['DISPLAY_GALAXIA_LED_RED_CONTROL_TITLE'] = '[LED RGB] ajusta la intensidad del rojo a %1';
Blockly.Msg['DISPLAY_GALAXIA_LED_RED_CONTROL_TOOLTIP'] = 'Ajusta la intensidad del rojo para el LED integrado en la tarjeta Galaxia de 0 a 255';
Blockly.Msg['DISPLAY_GALAXIA_LED_BLUE_CONTROL_TITLE'] = '[LED RGB] ajusta la intensidad del azul a %1';
Blockly.Msg['DISPLAY_GALAXIA_LED_BLUE_CONTROL_TOOLTIP'] = 'Ajusta la intensidad del azul del LED integrado en la tarjeta Galaxia de 0 a 255';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_BLUE_TITLE'] = '[LED RGB] intensidad del azul';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_BLUE_TOOLTIP'] = 'Devuelve un valor entre 0 y 255 correspondiente a la intensidad de azul que se transfiere actualmente al LED';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_GREEN_TITLE'] = '[LED RGB] intensidad verde';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_GREEN_TOOLTIP'] = 'Devuelve un valor entre 0 y 255 correspondiente a la intensidad de verde transferida actualmente al LED';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_RED_TITLE'] = '[LED RGB] intensidad del rojo';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_RED_TOOLTIP'] = 'Devuelve un valor entre 0 y 255 correspondiente a la intensidad de rojo transferida actualmente al LED';
Blockly.Msg['DISPLAY_GALAXIA_SET_LED_COLORS_TITLE'] = '[LED RGB] establece el LED en R %1 G %2 B %3';
Blockly.Msg['DISPLAY_GALAXIA_SET_LED_COLORS_TOOLTIP'] = 'Permite ajustar la intensidad del LED integrado en la tarjeta Galaxia, de 0 a 255';
// Display - Galaxia/Graphique
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_TITLE'] = 'cambiar la pantalla al modo %1';
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_TOOLTIP'] = 'Cambiar el modo de la pantalla.';
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_CONSOLE'] = 'terminal';
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_PLOT'] = 'datos';
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_GRAPHICS'] = 'gráficos';
Blockly.Msg['DISPLAY_GALAXIA_PLOT_ADD_POINT_TITLE'] = '[Datos] añadir el valor %1';
Blockly.Msg['DISPLAY_GALAXIA_PLOT_ADD_POINT_TOOLTIP'] = 'Añadir un punto al gráfico.';
Blockly.Msg['DISPLAY_GALAXIA_PLOT_SET_Y_SCALE_TITLE'] = '[Datos] establecer escala del eje Y a min %1 máx %2';
Blockly.Msg['DISPLAY_GALAXIA_PLOT_SET_Y_SCALE_TOOLTIP'] = 'Establecer la escala del eje Y.';
Blockly.Msg['DISPLAY_GALAXIA_ANIMATE_FUNCTION_TITLE'] = '[Datos] cada %1 segundo(s) calcular un nuevo valor';
Blockly.Msg['DISPLAY_GALAXIA_ANIMATE_FUNCTION_NEW_POINT'] = 'añadir el resultado %1 al gráfico';
Blockly.Msg['DISPLAY_GALAXIA_ANIMATE_FUNCTION_TOOLTIP'] = 'Añadir un punto al gráfico cada x segundos.';
Blockly.Msg['DISPLAY_GALAXIA_RAW_PRINT_TITLE'] = '[Gráficos] mostrar texto %1 en x %2 y %3';
Blockly.Msg['DISPLAY_GALAXIA_RAW_PRINT_TOOLTIP'] = 'Mostrar texto en la pantalla gráfica.';
Blockly.Msg['DISPLAY_GALAXIA_RAW_TEXT_TITLE'] = '[Gráficos] mostrar texto %1 en x %2 y %3 con color %4';
Blockly.Msg['DISPLAY_GALAXIA_RAW_RECT_TITLE'] = '[Gráficos] mostrar rectángulo en x %1 y %2 ancho %3 alto %4 con color %5';
Blockly.Msg['DISPLAY_GALAXIA_RAW_RECT_TOOLTIP'] = 'Mostrar un rectángulo en la pantalla gráfica.';
Blockly.Msg['DISPLAY_GALAXIA_RAW_PRINT_IMG_TITLE'] = '[Gráficos] mostrar imagen %1 en x %2 y %3';
Blockly.Msg['DISPLAY_GALAXIA_RAW_PRINT_IMG_TOOLTIP'] = 'Mostrar una imagen en la pantalla gráfica (debes cargar primero la imagen en la memoria de la placa Galaxia)';

// Display - Screen
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD] mostrar texto %1 en la línea %2 posición %3';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Mostrar texto en una de las dos líneas de la arboleda LCD1602. Conecte el módulo a un puerto I2C';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD] limpiar pantalla';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Permite borrar todos los caracteres de la pantalla LCD. Conecte el módulo a un puerto I2C';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[OLED] mostrar texto %1 en la posición x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permite escribir texto en una pantalla OLED de 128x64. Conecta la pantalla a un puerto I2C';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TITLE'] = '[OLED] control pixel x %1 y %2 state %3';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permite controlar cada pixel de la pantalla OLED de tamaño 128x64. Conecta la pantalla a un puerto I2C';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TITLE'] = '[OLED] dibuja una línea desde (%1, %2) hasta (%3, %4)';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permite dibujar una línea entre dos puntos de la pantalla OLED de tamaño 128x64. Conecta la pantalla a un puerto I2C';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TITLE'] = '[OLED] establece el fondo en %1';
Blockly.Msg['DISPLAY_OLED_WHITE'] = 'blanco';
Blockly.Msg['DISPLAY_OLED_BLACK'] = 'negro';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Invierte la retroiluminación de la pantalla. Conecta la pantalla a un puerto I2C';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[OLED] limpiar pantalla';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permite borrar el contenido de la pantalla OLED. Conecta la pantalla a un puerto I2C';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[OLED] mostrar icono %1 posición x %2 y %3';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Muestra un icono de la biblioteca de imágenes ESP32 en la posición (x,y) de la pantalla OLED de la arboleda. Conecte la pantalla a un puerto I2C';
// Display - Neopixel
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] establece %1 LED en el pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite definir el número de LEDs del neopixel. Este bloque debe utilizarse en el bloque "Al inicio"';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] controla el LED %1 a R %2 G %3 B %4 en el pin %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar el color de cada LED como (R,G,B) de 0 a 255 del módulo neopixel';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] controla el LED %1 a %2 en el pin %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Enable to control each LED color of neopixel. Use P15 to set Maqueen neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] controla todos los LEDs en R %1 G %2 B %3 en el pin %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar todos los LEDs del módulo neopixel al color elegido tal que (R,G,B) esté entre 0 y 255';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] controla todos los LEDs en %1 en el pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar todos los LEDs del módulo neopixel al color elegido. Utilice la paleta para cambiar el color';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] Arco iris en el pin %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Mostrar el espectro de colores en el LED RGB. Es posible cambiar el pin y el número de LEDs del módulo neopixel';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] controla el LED %1 en el pin %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Activar o desactivar el LED Grove (0 o 1) en los pines digitales';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] establece el brillo a %1 (%) en el pin %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Permite ajustar el brillo de un LED de 0 a 100% en los pines PWM';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[LED de color variable] establece el brillo a %1 (%) en el pin %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Permite establecer el brillo de un LED de 0 a 100% en los pines PWM. Cuando se utiliza por primera vez, los valores RGB se establecen en 0. Utilice un destornillador para ajustar los colores R, G y B detrás del módulo';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[Pantalla de 4 dígitos] muestra %1 %2 en los pines CLK %3 DIO %4';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permite mostrar un número, una temperatura o el reloj en la pantalla de 4 dígitos de la arboleda (TM1637) con los pines digitales';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[Pantalla de 4 dígitos] reloj en pines CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permite mostrar el reloj en la pantalla de 4 dígitos de la arboleda (TM1637) con pines digitales. Cuidado, el tiempo real se recupera sólo cuando la tarjeta microbit está encendida';
Blockly.Msg['DISPLAY_4DIGIT_NUMBER'] = 'el número entero';
Blockly.Msg['DISPLAY_4DIGIT_TEMPERATURE'] = 'la temperatura';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[Módulo de barras LED] muestra el nivel de %1 en los pines DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permite mostrar el nivel del valor de entrada en el módulo de la barra de LEDs (MY9221) con los pines digitales';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TITLE'] = '[Módulo de barras LED] invierte la pantalla %1 DI pins %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permite invertir los 10 LEDs del módulo MY9221 con los pines digitales P0 a P20';
// Display - Chainable LED
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TITLE'] = '[LED encadenable] establecer %1 LED en pines CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Permite configurar la cadena de LEDs RGB definiendo el número de módulos en serie en los pines digitales.';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TITLE'] = '[LED encadenable] controla el LED %1 a R %2 G %3 B %4 en los pines CIN %5 DIN %6';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color del LED RGB, da un valor entre 0 y 255 para el Rojo, el Verde y el Azul';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TITLE'] = '[LED encadenable] controla el LED %1 a %2 en los pines CIN %3 DIN %4';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color del LED RGB, elige un color de la paleta';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TITLE'] = '[LED encadenable] controla todos los LEDs en R %1 G %2 B %3 en los pines CIN %4 DIN %5';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color de los LEDs RGB, da un valor entre 0 y 255 para el Rojo, Verde y Azul';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE'] = '[LED encadenable] controla todos los LEDs en %1 en los pines CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color de los LEDs RGB, elige un color de la paleta';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TITLE'] = '[LED encadenable] se apaga en los pines CIN %1 DIN %2';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloquea el apagado de todos los LEDs RGB';
// IO - Galaxia - A & B
Blockly.Msg['IO_ISPRESSED'] = 'es';
Blockly.Msg['IO_WASPRESSED'] = 'fue';
Blockly.Msg['IO_ONBUTTONPRESSED_TITLE'] = 'si se pulsa el botón %1 %2 entonces';
Blockly.Msg['IO_ONBUTTONPRESSED_TOOLTIP'] = 'Ejecuta las instrucciones si se pulsa el botón elegido (A o B)';
Blockly.Msg['IO_ISBUTTONPRESSED_TITLE'] = 'botón %1 %2 pulsado';
Blockly.Msg['IO_ISBUTTONPRESSED_TOOLTIP'] = 'Devuelve \'True\' si el botón A o B está pulsado, en caso contrario devuelve \'False\'';
Blockly.Msg['IO_ONBUTTONEVENT_TITLE'] = 'cuando se pulsa el botón %1';
Blockly.Msg['IO_ONBUTTONEVENT_TOOLTIP'] = 'Hacer algo cuando un botón (A o B) se pulsa y se suelta de nuevo';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TITLE'] = 'Obtener las pulsaciones del botón %1';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TOOLTIP'] = 'Devuelve el número de pulsaciones del botón A o B';
// IO - Galaxia - Touch buttons
Blockly.Msg['IO_TOUCH_UP'] = 'arriba';
Blockly.Msg['IO_TOUCH_DOWN'] = 'abajo';
Blockly.Msg['IO_TOUCH_RIGHT'] = 'derecha';
Blockly.Msg['IO_TOUCH_LEFT'] = 'izquierda';
Blockly.Msg['IO_IFTOUCHSENSITIVEBUTTONTOUCHED_TITLE'] = 'si el botón táctil %1 %2 pulsado hace';
Blockly.Msg['IO_IFTOUCHSENSITIVEBUTTONTOUCHED_TOOLTIP'] = 'Ejecutar instrucciones si se toca el botón táctil elegido (arriba, abajo, derecha o izquierda)';
Blockly.Msg['IO_ISTOUCHSENSITIVEBUTTONTOUCHED_TITLE'] = 'se ha tocado el botón táctil %1 %2';
Blockly.Msg['IO_ISTOUCHSENSITIVEBUTTONTOUCHED_TOOLTIP'] = 'Devuelve \'True\' si se toca el botón táctil seleccionado, en caso contrario devuelve \'False\'';
Blockly.Msg['IO_ONTOUCHSENSITIVEBUTTONEVENT_TITLE'] = 'cuando se tocó el botón táctil %1';
Blockly.Msg['IO_ONTOUCHSENSITIVEBUTTONEVENT_TOOLTIP'] = 'Hacer algo cuando se toca un botón táctil (arriba, abajo, derecha o izquierda) y se suelta de nuevo';
Blockly.Msg['IO_TOUCHSENSITIVEBUTTON_GET_TOUCHES_TITLE'] = 'número de toques del botón %1';
Blockly.Msg['IO_TOUCHSENSITIVEBUTTON_GET_TOUCHES_TOOLTIP'] = 'Devuelve el número de veces que se ha tocado el botón táctil seleccionado (ARRIBA, ABAJO, DERECHA o IZQUIERDA) desde la última llamada a la función get_presses(), es decir, este bloque';
//input/output Galaxia Specific
// Input/Output - Esp32
Blockly.Msg['IO_WAIT_TITLE'] = 'wait %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Pausa en la ejecución del código';
Blockly.Msg['IO_WAIT_SECOND'] = 'segundo(s)';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milisegundo(s)';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microsegundo(s)';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'espera hasta %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Detiene la ejecución del código hasta que se cumpla la condición';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'iniciar el temporizador';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Inicializar un temporizador a 0 (en segundos)';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'Valor del cronómetro en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Devuelve el valor del temporizador de la inicialización (en segundos o milisegundos)';
// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Teclado numérico] dígito en pines RX %1 TX %2';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Permite obtener el teclado numérico de Grove pulsado en los pines TX y RX. Al conectar el módulo, asegúrate de que los pines están cruzados: RX en la placa con TX en el módulo y viceversa';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Módulo joytsick] valor del eje %1 en los pines X %2 Y %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Devuelve el valor del eje X o Y del joystick de Grove (0 a 8191) en los pines analógicos p34 a p36, o p39 (A2 a A4 en la pantalla de Grove)';
Blockly.Msg['IO_ROTARYENCODER_TITLE'] = '[Codificador rotativo] valor en los pines CLK %1 DT %2';
Blockly.Msg['IO_ROTARYENCODER_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Devuelve el valor del codificador rotativo Grove. Conecta los pines CLK y DT en los pines digitales de la Galaxia.';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TITLE'] = '[Módulo de botones de colores] estado en el pin SIG2 %1';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el estado del botón coloreado de Grove (0 o 1) en los pines digitales';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TITLE'] = '[Módulo de botones de colores] controlan el estado del LED %1 en el pin SIG1 %2';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Enciende o apaga el LED (0 o 1) de los pines digitales';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Potenciómetro rotativo] valor en el pin %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Devuelve el ángulo (de 0 a 8191) del potenciómetro rotativo Grove en los pines analógicos p34 a p36, o p39 (A2 a A4 en la pantalla Grove)';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Potenciómetro lineal] valor en el pin %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Devuelve la posición (de 0 a 8191) del potenciómetro lineal Grove en los pines analógicos p34 a p36, o p39 (A2 a A4 en la pantalla Grove)';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Sensor táctil] estado en el pin %1';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor táctil Grove (0 o 1) en los pines digitales';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Módulo de botones] estado en el pin %1';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el valor del botón Grove (0 o 1) en los pines digitales';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Módulo de conmutación] estado en el pin %1';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Devuelve el valor del interruptor Grove (0 o 1) en los pines digitales';
// Input/Output - Pins
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'ALTO (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAJO (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Devuelve un valor booleano (1 si es HIGH o 0 si es LOW)';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'leer pin digital %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Leer el valor de una entrada digital (0 o 1)';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'escribe el estado %1 en el pin digital %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Escribir un valor en una entrada digital (0 o 1)';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'leer pin analógico %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Lee el valor de una entrada analógica (0-8191), que corresponde a una tensión entre 0 y 3,6V';
Blockly.Msg['IO_WRITEPWMPIN_TITLE'] = 'escribe el valor %1 en el pin PWM %2';
Blockly.Msg['IO_WRITEPWMPIN_TOOLTIP'] = 'Permite aplicar una señal PWM con una frecuencia fija de 10kH y cambiando el ciclo de 0 a 8191. El valor 512 corresponderá al 50% del ciclo, es decir, a unos 1,66V';
Blockly.Msg['IO_WRITEANALOGPIN_TITLE'] = 'escribe el valor %1 en el pin analógico %2 (DAC)';
Blockly.Msg['IO_WRITEANALOGPIN_TOOLTIP'] = 'Permite aplicar una tensión analógica a los pines DAC p25 y p26 (de 0 a 255). El Esp32 utiliza un convertidor digital-analógico (DAC) para aplicar una tensión entre 0 y 3,3V';
Blockly.Msg['IO_SETPWM_TITLE'] = 'aplicar una señal de onda cuadrada de frecuencia %1 (Hz) al pin %2';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Aplicar una señal de onda cuadrada (PWM) con un ciclo fijo del 50% a un pin. Este bloque permite cambiar la frecuencia de la señal';
Blockly.Msg['IO_STOPPWM_TITLE'] = 'detener la señal PWM del pin %1';
Blockly.Msg['IO_STOPPWM_TOOLTIP'] = 'Detener la señal PWM aplicada a un pin';
Blockly.Msg['IO_GETVOLTAGE_TITLE'] = 'convertir %1 en %2 en voltaje';
Blockly.Msg['IO_GETVOLTAGE_TOOLTIP'] = 'Convierte un valor analógico a voltaje eligiendo la resolución (10 bits: 1024, 12 bits: 4096, 9 bits: 512, 11 bits: 2048) y un máximo de 3,6V';

// Communication LOG
Blockly.Msg['COMMUNICATION_LOG_DELETE_TITLE'] = 'borrar los registros';
Blockly.Msg['COMMUNICATION_LOG_DELETE_TOOLTIP'] = 'Permite borrar los registros de la placa Galaxia.';
Blockly.Msg['COMMUNICATION_LOG_SET_LABEL_TITLE'] = 'añadir una nueva etiqueta';
Blockly.Msg['COMMUNICATION_LOG_SET_LABEL_TOOLTIP'] = 'Permite añadir una etiqueta a los registros de la placa Galaxia.';
Blockly.Msg['COMMUNICATION_LOG_ADDDATA_TITLE'] = 'añadir datos a una etiqueta';
Blockly.Msg['COMMUNICATION_LOG_ADDDATA_TOOLTIP'] = 'Permite añadir una etiqueta a la columna de datos del registro. La etiqueta puede ser un texto o un número. Los datos pueden ser un texto o un número.';
Blockly.Msg['COMMUNICATION_LOG_DATA_TITLE'] = 'etiqueta %1 dato %2';
Blockly.Msg['COMMUNICATION_LOG_DATA_TOOLTIP'] = 'Permite añadir una etiqueta a la columna de datos del registro. La etiqueta puede ser un texto o un número. Los datos pueden ser un texto o un número.';


// Communication - Galaxia
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TITLE'] = '[Radio] enviar cadena %1';
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TOOLTIP'] = 'Habilitar para enviar cadena por módulo de radio Galaxia';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TITLE'] = '[Radio] enviar número o lista %1';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TOOLTIP'] = 'Activar el envío de números o listas por el módulo de radio';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TITLE'] = '[Radio] enviar valor %1 como %2';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TOOLTIP'] = 'Habilitar el envío de datos con \'nombre\' y su valor por módulo de radio';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TITLE'] = '[Radio] sobre datos recibidos en %1 entonces';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones sobre la cadena recibida por la radio en la variable \'stringData\'';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TITLE'] = '[Radio] sobre los datos recibidos en %1 entonces';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones sobre el número recibido por la radio en la variable \'numberData\'';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TITLE'] = '[Radio] sobre datos recibidos en %1 %2 entonces';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones sobre el nombre como cadena y el valor como número recibidos por la radio en las variables \'nombre\' y \'valor\'';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TITLE'] = '[Radio] set Channel %1 Power %2 Data size %3 Group %4';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TOOLTIP'] = 'Permite configurar el canal de frecuencia (de 0 a 83), el tamaño de los datos (bytes), la potencia de transmisión (de 0 a 7) y el grupo (de 0 a 255)';
//Communication - Internal Bluetooth
Blockly.Msg['COMMUNICATION_START_BT_TITLE'] = '[ESP32 Bluetooth UART] inicializar bluetooth %1';
Blockly.Msg['COMMUNICATION_START_BT_TOOLTIP'] = 'Permite inicializar el servicio Bluetooth de ESP32 con un nombre asignado';
Blockly.Msg['COMMUNICATION_SEND_BT_TITLE'] = '[ESP32 Bluetooth UART] enviar datos %1';
Blockly.Msg['COMMUNICATION_SEND_BT_TOOLTIP'] = 'Permite enviar datos a través del Bluetooth del ESP32';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TITLE'] = '[Bluetooth] si el mensaje se recibe en %1 entonces';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TOOLTIP'] = 'Permite ejecutar instrucciones si se reciben datos por Bluetooth (BLE)';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TITLE'] = '[Bluetooth Fizziq App] send %1 %2';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TOOLTIP'] = IMG_MODULE_FIZZIQ + Blockly.Tooltip.SEP + 'Enviar datos (Temperatura, Humedad, etc) vía Bluetooth a la aplicación Fizziq';
Blockly.Msg['FIZZ_TEMP'] = 'Temperatura';
Blockly.Msg['FIZZ_HUM'] = 'Humedad';
Blockly.Msg['FIZZ_VOLTAGE'] = 'Tensión';
Blockly.Msg['FIZZ_WEIGHT'] = 'Peso';
Blockly.Msg['FIZZ_PRESSURE'] = 'Presión';
Blockly.Msg['FIZZ_CONCENTRATION'] = 'Concentración';
Blockly.Msg['FIZZ_MAGNETIC'] = 'Campo magnético';
Blockly.Msg['FIZZ_BRIGHTNESS'] = 'Brillo';
Blockly.Msg['FIZZ_ACCELERATION'] = 'Aceleración';
Blockly.Msg['FIZZ_COMPASS'] = 'Brújula';
Blockly.Msg['COMMUNICATION_IR_EMIT_TITLE'] = '[IR] %1 una señal IR en el pin %2';
Blockly.Msg['COMMUNICATION_IR_EMIT_TOOLTIP'] = 'Permite enviar una señal IR en los pines digitales';
Blockly.Msg['COMMUNICATION_IR_EMIT_ACTIVATE'] = 'activar';
Blockly.Msg['COMMUNICATION_IR_EMIT_DEACTIVATE'] = 'desactivar';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'escribir en la consola %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Permite escribir datos en el puerto serie';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'con';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'avance de línea(s)';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE then'] = 'on serial data received in %1 then';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones si se reciben datos del puerto serie en la variable \'serialData\'';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'reproduce la nota %1 en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Toca la nota seleccionada hasta que se ejecuta el bloque "Fin de nota".';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'reproduce la frecuencia %1 (Hz) en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Este bloque reproduce una frecuencia determinada en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'terminar la nota en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Detener la nota actual';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'trazar gráfico';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Este bloque permite escribir datos (numéricos) que serán visibles en el trazador. Puede utilizarse con uno o varios bloques con formato "Nom" y "Datos". Para ver los gráficos, haga clic en el icono "Modo gráfico" de la consola';
Blockly.Msg['COMMUNICATION_DATA'] = 'Datos';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nombre %1 Valor %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Este bloque debe utilizarse junto con el bloque "Plot Graph". Debe contener a su vez el nombre del valor a mostrar (texto), y el valor en cuestión (número)';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] escribe en la tarjeta SD %1 baudrate %2 en los pines RXI %3 TXO %4 %5 Data %6';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'Permite escribir datos en la tarjeta micro SD con el módulo Openlog. Funciona con transmisión UART';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] enviar en los pines RX %1 TX %2 mensaje %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permite enviar datos a través del módulo BLuetooth HC05 en los pines RX/TX';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] si el mensaje se recibe en los pines RX %1 TX %2 en %3 entonces';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones si se reciben datos por un módulo Bluetooth HC05 en la variable \'bluetoothData\' en los pines RX/TX';
// Communication - Tracking modules
Blockly.Msg['COMMUNICATION_GPS_INFO_TYPE'] = 'el tipo de marco';
Blockly.Msg['COMMUNICATION_GPS_INFO_CLOCK'] = 'la hora (h, m, s)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LATITUDE'] = 'latitud (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LONGITUDE'] = 'la longitud (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_SATELLITE'] = 'el número de satélites utilizados';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALTITUDE'] = 'altitud (m)';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALL_FRAME'] = 'todo el marco';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TITLE'] = '[GPS] Tramas NMEA en los pines RX %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Devuelve la lista de tramas NMEA leídas con el módulo GPS Grove SIM28 o Air530 en los pines RX/TX. No es necesario invertir los cables entre los pines del módulo y los indicados en el bloque. Nota: Si utiliza la consola para visualizar los datos del GPS, conecte su tarjeta a la interfaz antes de enviar el programa haciendo clic en el botón [>_ REPL]. A continuación, cargue su programa mediante el botón [Descargar .hex]';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TITLE'] = '[GPS] get %3 on RX pins %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Devuelve los datos seleccionados de (tipo de trama, reloj, latitud, longitud, altitud) analizados de la trama NMEA (GNGGA o GPGGA) leída con el módulo GPS Grove SIM28 o Air530 en los pines RX/TX. No es necesario invertir los cables entre los pines del módulo y los indicados en el bloque. Nota: Si utiliza la consola para visualizar los datos del GPS, conecte su tarjeta a la interfaz antes de enviar el programa haciendo clic en el botón [>_ REPL]. A continuación, cargue su programa mediante el botón [Descargar .hex]';
Blockly.Msg['COMMUNICATION_RTC_MODULE_PCF85063TP'] = 'Alta precisión (0x51)';
Blockly.Msg['COMMUNICATION_RTC_MODULE_DS1307'] = 'v1.2 (0x68)';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TITLE'] = '[Reloj RTC %1] ajustado a %2 fecha %3';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Inicialice el módulo de reloj de alta precisión Grove RTC (PCF85063TP) o el módulo RTC v1.2 (DS1307), para poder leer la fecha y la hora precisas con el bloque \'Leer módulo de reloj\'. Colóquelo en el bloque "Al inicio". Conecte el módulo RTC a un puerto I2C. Nota: Para que funcione, el módulo DS1307 debe tener una pila de botón';
Blockly.Msg['DAY_MONDAY'] = 'Lunes';
Blockly.Msg['DAY_TUESDAY'] = 'Martes';
Blockly.Msg['DAY_WEDNESDAY'] = 'Miércoles';
Blockly.Msg['DAY_THURSDAY'] = 'Jueves';
Blockly.Msg['DAY_FRIDAY'] = 'Viernes';
Blockly.Msg['DAY_SATURDAY'] = 'Sábado';
Blockly.Msg['DAY_SUNDAY'] = 'Domingo';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TITLE'] = '[Reloj RTC %1] ajustado a la hora %2 minuto %3 segundo %4';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permite inicializar el módulo de reloj de alta precisión Grove RTC (PCF85063TP) o el módulo RTC v1.2 (DS1307), para poder leer la fecha y la hora precisas con el bloque \'Leer módulo de reloj\'. Colóquelo en el bloque "Al inicio". Conecte el módulo a un puerto I2C. Nota: El módulo DS1307 debe tener una pila de botón para funcionar';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TITLE'] = '[Reloj RTC %1] leído %2';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Lee la fecha y la hora del módulo de reloj Grove RTC de alta precisión (PCF85063TP) o del módulo RTC v1.2 (DS1307). Para obtener el resultado correcto, utilice primero los dos bloques "Inicializar módulo de reloj". Conecte el módulo a un puerto I2C. Nota: Para que funcione, el módulo DS1307 debe tener una pila de botón';
Blockly.Msg['CLOCK_ALL_DATA'] = 'el reloj';
Blockly.Msg['CLOCK_YEAR'] = 'año';
Blockly.Msg['CLOCK_MONTH'] = 'mes';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'día del mes';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'día de la semana';
Blockly.Msg['CLOCK_HOUR'] = 'hora';
Blockly.Msg['CLOCK_MINUTE'] = 'minuto';
Blockly.Msg['CLOCK_SECOND'] = 'segundo';
// Communication - UART
Blockly.Msg['COMMUNICATION_UART_INIT_TITLE'] = '[uart] establece la conexión serie a RX %1 TX %2 Baudrate %3';
Blockly.Msg['COMMUNICATION_UART_INIT_TOOLTIP'] = 'Configurar la conexión serie de la tarjeta ESP32 al puerto UART (1 o 2). El puerto 0 está reservado para REPL';
Blockly.Msg['COMMUNICATION_UART_WRITE_TITLE'] = '[uart] escribe datos %1';
Blockly.Msg['COMMUNICATION_UART_WRITE_TOOLTIP'] = 'Permite escribir datos en el puerto UART (1 o 2). Por defecto, los pines son los siguientes: UART 1 (tx=10, rx=9) y UART 2 (tx=17, rx=16). En caso contrario, utilice el bloque \'Configurar la conexión serie a la velocidad de transmisión RX ...\'';
Blockly.Msg['COMMUNICATION_UART_READ_TITLE'] = '[uart] leer datos';
Blockly.Msg['COMMUNICATION_UART_READ_TOOLTIP'] = 'Permite leer datos del puerto UART (1 o 2). Por defecto, los pines son los siguientes: UART 1 (tx=10, rx=9) y UART 2 (tx=17, rx=16). En caso contrario, utilice el bloque \'Configurar la conexión serie a la velocidad de transmisión RX ...\'';
Blockly.Msg['COMMUNICATION_UART_READ_SIZE'] = 'tamaño de los datos';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TITLE'] = '[uart] datos disponibles';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TOOLTIP'] = 'Devuelve el tamaño de los datos disponibles en el puerto UART (1 o 2). Por defecto, los pines son los siguientes: UART 1 (tx=10, rx=9) y UART 2 (tx=17, rx=16). En caso contrario, utilice el bloque \'Configurar la conexión serie a la velocidad de transmisión RX ...\'.';
// Sensors - Galaxia
Blockly.Msg['SENSORS_GETACCELERATION_TITLE'] = 'aceleración (mg) %1';
Blockly.Msg['SENSORS_GETACCELERATION_TOOLTIP'] = 'Devuelve la aceleración (en mg) con el acelerómetro interno de Galaxia';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_TITLE'] = 'en %1 entonces';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_SHAKE'] = 'shake';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_UP'] = 'logo arriba';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_DOWN'] = 'logo abajo';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FACE_UP'] = 'pantalla arriba';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FACE_DOWN'] = 'pantalla abajo';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_LEFT'] = 'inclinación hacia la izquierda';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_RIGHT'] = 'inclinación hacia la derecha';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FREEFALL'] = 'caída libre';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_TOOLTIP'] = 'ejecutar instrucciones si la placa Galaxia se agita';
Blockly.Msg['SENSORS_GETLIGHT_TITLE'] = 'nivel de luz';
Blockly.Msg['SENSORS_GETLIGHT_TOOLTIP'] = 'Devuelve el nivel de luz (de 0 a 255) con algún LED de la pantalla Galaxia.';
Blockly.Msg['SENSORS_CALIBRATECOMPASS_TITLE'] = 'Calibrar brújula';
Blockly.Msg['SENSORS_CALIBRATECOMPASS_TOOLTIP'] = 'Habilitar para calibrar la brújula interna de Galaxia. Basta con agitar la placa para calibrarla. Un smiley \'feliz\' aparece cuando se completa la calibración';
Blockly.Msg['SENSORS_GETCOMPASS_TITLE'] = 'rumbo de la brújula (°)';
Blockly.Msg['SENSORS_GETCOMPASS_TOOLTIP'] = 'Devuelve el rumbo de la brújula (de 0° a 360°) con la brújula interna de Galaxia';
Blockly.Msg['SENSORS_GETTEMPERATURE_TITLE'] = 'temperatura en %1';
Blockly.Msg['SENSORS_GETTEMPERATURE_TOOLTIP'] = 'Devuelve la temperatura en grados Celius (°C), Fahrenheit (°F) o Kelvin (K) del procesador Galaxia';
Blockly.Msg['SENSORS_GETROTATION_TITLE'] = 'rotación (°) %1';
Blockly.Msg['SENSORS_GETROTATION_PITCH'] = 'tono';
Blockly.Msg['SENSORS_GETROTATION_ROLL'] = 'balanceo';
Blockly.Msg['SENSORS_GETROTATION_TOOLTIP'] = 'Devuelve la rotación (de -180° a 180°) con el acelerómetro interno de Galaxia';
Blockly.Msg['SENSORS_GETMAGNETICFORCE_TITLE'] = 'intensidad del campo magnético %1 (nT)';
Blockly.Msg['SENSORS_GETMAGNETICFORCE_TOOLTIP'] = 'Devuelve la intensidad del campo magnético (en nT) en la dirección elegida con la brújula interna de Galaxia';
// Sensors - ESP32
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TITLE'] = 'leer sensor Hall';
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TOOLTIP'] = 'Devuelve el valor del sensor Hall de la placa';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TITLE'] = 'temperatura del procesador en %1';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TOOLTIP'] = 'Devuelve la temperatura del procesador';
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[sensor SGP30] gas %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Devuelve la cantidad de CO2 (en ppm) o TVOC (en ppb) contenida en el aire por el sensor SGP30. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'Dióxido de carbono (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'Compuestos orgánicos volátiles (TVOC) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Sensor de gas multicanal] gas %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Devuelve la cantidad de gas medida en el aire (en ppm) utilizando el sensor de gas multicanal. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Sensor de gas multicanal v2] gas %1 (V)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Devuelve la cantidad de gas medida en el aire (en V) utilizando el sensor de gas multicanal V2. Conecte el sensor a un puerto I2C';
Blockly.Msg['GAS_CO'] = 'Monóxido de carbono (CO)';
Blockly.Msg['GAS_NO2'] = 'Dióxido de nitrógeno (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'Etanol (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'Dihidrógeno (H2)';
Blockly.Msg['GAS_NH3'] = 'Amoníaco (NH3)';
Blockly.Msg['GAS_CH4'] = 'Metano (CH4)';
Blockly.Msg['GAS_C3H8'] = 'Propano (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'Iso-propane (C4H10)';
Blockly.Msg['GAS_VOC'] = 'Compuestos orgánicos volátiles (COV)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Sensor de oxígeno] O2 (%) en el pin %1';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Devuelve la concentración de oxígeno (O2) en el aire (en %) del sensor de gas O2 del surco en los pines analógicos p34 a p36, o p39 (A2 a A4 en el escudo del surco)';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[Sensor SCD30] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Devuelve la concentración de CO2 en el aire (en ppm), la humedad (en %), o la temperatura en Celsius (°C), Fahrenheit (°F), o Kelvin (K) del sensor SCD30 de Grove. Coloca el sensor en un puerto I2C';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'dióxido de carbono (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = 'temperatura';
Blockly.Msg['SENSORS_SCD30_HUM'] = 'humedad (%)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[Sensor SCD30] forzar recalibración a %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Forzar la calibración del sensor SCD30 al valor dado (en ppm). Salga al exterior (donde la concentración es de unas 420 ppm, es decir, aire limpio), reinicie la placa y espere 2 minutos. Consejo: Utilice los botones SW1, SW2 o SW3 de la placa NUCLEO STM32 para controlar el inicio de la calibración. De lo contrario, al volver a enchufar la placa, el programa se inicia y vuelve a realizar una calibración, lo cual no es necesariamente deseado';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Sensor de calidad del aire] valor en el pin %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Devuelve el valor de la calidad del aire (0 a 8191) en los pines analógicos p34 a p36, o p39 (A2 a A4 en el escudo Grove)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[Sensor HM330X] concentración de partículas finas %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Detecta la densidad de las partículas en el aire con el sensor HM330X. Banquear el sensor en un puerto I2C';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
// Sensors - Climate
Blockly.Msg['SENSORS_LINKY_TITLE'] = '[Sensor Linky] recuperar el valor de %1 en el pin RX %2';
Blockly.Msg['SENSORS_LINKY_TOOLTIP'] = 'Devuelve el consumo eléctrico aparente (en Wh) para las horas valle y las horas pico del contador Linky. Conecte el sensor a un puerto UART en la placa Galaxia.';
Blockly.Msg['SENSORS_LINKY_PAPP'] = 'potencia instantánea';
Blockly.Msg['SENSORS_LINKY_HCHC'] = 'horas valle';
Blockly.Msg['SENSORS_LINKY_HCHP'] = 'horas pico';
Blockly.Msg['SENSORS_TEMPERATURE'] = 'la temperatura';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humedad (%)';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'es';
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[Sensor BMP280 %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), presión (en Pascal) o altitud (en m). La altitud se calcula con la presión y se pone a 0 al principio del programa. El bloque necesita el sensor Grove BMP280 (dirección I2C: 0x77, color: azul) o el sensor HW-611 280 (dirección I2C: 0x76, color: morado). Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_BMP280_TEMP'] = 'temperatura';
Blockly.Msg['SENSORS_BMP280_PRESS'] = 'presión (Pa)';
Blockly.Msg['SENSORS_BMP280_ALT'] = 'altitud (m)';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = '[Sensor H.T°] temperatura en %1 en los pines A0 %2 A1 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Devuelve la temperatura del termopar en grados Celsius (50 a 600 °C), Fahrenheit (°F) o Kelvin (K) utilizando el sensor de alta temperatura de la arboleda en ';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Sensor de humedad] humedad del suelo en el pin %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Devuelve la humedad (de 0 a 8191) medida por el sensor de humedad de la arboleda en los pines analógicos IO34, IO35, IO36 e IO39';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Sensor T°] temperatura en %1 en el pin %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F), o Kelvin (K) del sensor de temperatura Grove en los pines analógicos p34 a p36, o p39 (A2 a A4 en la pantalla Grove)';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TITLE'] = '[Sensor DS18B20] temperatura en %1 en el pin %2';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K) del sensor de temperatura resistente al agua DS18B20 en los pines digitales';
Blockly.Msg['SENSORS_DHT11_READDATA_TITLE'] = '[Sensor DHT11] %1 en pin %2';
Blockly.Msg['SENSORS_DHT11_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad (en %) del sensor dht11 en los pines digitales';
Blockly.Msg['SENSORS_DHT22_READDATA_TITLE'] = '[Sensor DHT22] %1 en pin %2';
Blockly.Msg['SENSORS_DHT22_READDATA_TOOLTIP'] = IMG_MODULE_DHT22 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad (en %) con gran precisión gracias al sensor grove dht22 en los pines digitales';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[Sensor TH02] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad (en %) del sensor TH02. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Sensor SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad (en %) del sensor SHT31. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Sensor de agua] cantidad de agua en el pin %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Devuelve la cantidad de agua (de 0 a 255) medida por el sensor de agua del bosquecillo en los pines analógicos p34 a p36, o p39 (A2 a A4 en el escudo del bosquecillo)';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Sensor de lluvia] estado en el pin %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Devuelve el estado del sensor de lluvia (1 si está lloviendo o 0 si no lo está) en los pines digitales';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anemómetro] estado en el pin %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Devuelve el estado del anemómetro (dos veces el estado HIGH en cada rotación) en los pines digitales';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Sensor de luz] brillo en el pin %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Devuelve el brillo (de 0 a 8191) del sensor de luz Grove en los pines analógicos IO34, IO35, IO36 e IO39';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[Sensor SI1145] brillo %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Devuelve el índice de luz ultravioleta, el brillo visible (en lumen) o el brillo infrarrojo (en lumen) utilizando el sensor Grove Sunlight o el sensor GY1145. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_SI1145_UV'] = 'Índice UV';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visible (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrarrojos (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Sensor ultravioleta] Índice UV en el pin %1';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Devuelve el índice de luz ultravioleta para ondas entre 240 y 380 nm del sensor Grove en los pines analógicos p34 a p36, o p39 (A2 a A4 en el escudo Grove)';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Sensor de color] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Permite leer el nivel de uno de los tres colores primarios con el sensor de color Grove, el nivel está entre 0 y 255. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Sensor de sonido] nivel de sonido en el pin %1';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Devuelve el nivel de sonido (0 a 8191) con el sensor de sonido Grove en los pines digitales';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Sensor ultrasónico %1] %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Devuelve la distancia (en cm) medida con el sensor ultrasónico de ranura en los pines digitales. Tenga en cuenta que si el sensor es un modelo de ranura, TRIG y ECHO están en el mismo pin SIG';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distancia (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'tiempo de ida y vuelta (µs)';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = '[Sensor gestual] tipo de gesto';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Devuelve el tipo de gesto analizado (\'derecha\', \'izquierda\', \'arriba\', \'abajo\', \'hacia delante\', \'hacia atrás\', \'en el sentido de las agujas del reloj\', \'en el sentido contrario\') utilizando el sensor de gestos de Grove. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Sensor de gestos] si se detecta el gesto %1';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Ejecuta las instrucciones si el gesto seleccionado es detectado por el sensor de gestos Grove. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'derecho';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'izquierda';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'top';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'bottom';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'front';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'atrás';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'tiempo';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'en sentido contrario a las agujas del reloj';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'wave';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Sensor de línea negra] estado en el pin %1';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de línea negra grove (0 o 1) los pines digitales';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[Sensor de movimiento] estado en el pin %1';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor Grove PIR Motion (0 o 1) en los pines digitales';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Sensor de vibración] estado en el pin %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Devuelve el estado de vibración (0 o 1) del sensor de vibración piezoeléctrico en los pines digitales';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Módulo de inclinación] estado en el pin %1';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Devuelve el valor de la inclinación del módulo Grove (0 o 1) en los pines digitales';
// Other sensors
Blockly.Msg['SENSORS_GETGROVEBUTTON_TITLE'] = '[Módulo de botones] %1 en el pin %2';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el valor numérico del botón Grove (0/1 o 0V/3.3V) en los pines digitales';
Blockly.Msg['SENSORS_GETGROVEBUTTON_VOLTAGE'] = 'voltaje';
Blockly.Msg['SENSORS_GETGROVEBUTTON_STATE'] = 'state';
// Actuators
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Actuador] ángulo de control en %1 en el husillo %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permite controlar el ángulo de un servomotor (de 0 a 180) en los pines digitales. Tenga en cuenta que el conjunto debe ser alimentado por una batería para proporcionar suficiente corriente al servomotor';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Continuous servo] control speed at %1 (%) direction %2 on spindle %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Permite controlar la velocidad (de 0 a 100%) de un servomotor continuo en los pines PWM';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Motor] controla la potencia en %1 en el pin %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permite controlar la potencia de un motor (de 0 a 8191) en los pines digitales. Tenga cuidado, el conjunto debe ser alimentado por una batería para proporcionar suficiente corriente al motor';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Módulo de relé] controla el relé en estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Permite controlar el valor del relé (0 o 1) en los pines digitales';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Motor de vibración] controla el motor en el estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Activa o desactiva el motor de vibración del surco (0 o 1) en los pines digitales';
// Actuators - Music
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TITLE'] = '[Zumbador/altavoz] reproducir música %1 en %2';
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Activar la reproducción de la música elegida en el módulo zumbador Grove (o altavoz) en los pines digitales';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TITLE'] = '[Buzzer/Speaker] reproducir notas en';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Activar la reproducción de notas en el módulo Grove buzzer (o altavoz) en los pines digitales';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TITLE'] = 'nota %1 en la octava %2 con duración %3';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Define una nota con octava y duración';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TITLE'] = '[Zumbador/Parlante] reproducir frecuencia %1 durante %2 (ms) en %3';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Activar la reproducción de la frecuencia entera en el módulo zumbador (o altavoz) Grove en los pines digitales';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TITLE'] = '[Zumbador/Parlante] detener la música en %1';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Activar para detener la música del módulo zumbador (o altavoz) Grove en los pines digitales';
// Notes
Blockly.Msg['NOTE_C'] = 'C';
Blockly.Msg['NOTE_C_SHARP'] = 'C#';
Blockly.Msg['NOTE_D'] = 'D';
Blockly.Msg['NOTE_D_SHARP'] = 'D#';
Blockly.Msg['NOTE_E'] = 'E';
Blockly.Msg['NOTE_F'] = 'F';
Blockly.Msg['NOTE_F_SHARP'] = 'F#';
Blockly.Msg['NOTE_G'] = 'G';
Blockly.Msg['NOTE_G_SHARP'] = 'G#';
Blockly.Msg['NOTE_A'] = 'A';
Blockly.Msg['NOTE_A_SHARP'] = 'A#';
Blockly.Msg['NOTE_B'] = 'B';
Blockly.Msg['MUSIC_SILENCE'] = 'Silencio';

// IA Sensors
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TITLE'] = 'cargar modelo local';
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TOOLTIP'] = 'Permite cargar un modelo de IA almacenado localmente desde el navegador web.';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TITLE'] = 'cargar el modelo desde la URL %1';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TOOLTIP'] = 'Permite cargar un modelo de IA almacenado en la nube.';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TITLE'] = 'Predicción a partir de datos de sensores';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TIME_WINDOW'] = 'ventana';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TOOLTIP'] = 'Permite realizar una predicción a partir de un sensor. Ajusta la ventana de tiempo si es necesario.';
Blockly.Msg['VITTAIA_SENSOR_ACC'] = 'acelerómetro';
Blockly.Msg['VITTAIA_DETECT_CLASS_TITLE'] = 'si la clase %1 %2 es detectada entonces';
Blockly.Msg['VITTAIA_DETECT_CLASS_TOOLTIP'] = 'Permite detectar la clase de un objeto.';
Blockly.Msg['VITTAIA_IS'] = 'es';
Blockly.Msg['VITTAIA_ISNOT'] = 'no es';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TITLE'] = 'clase detectada';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TOOLTIP'] = 'Permite recuperar la clase con la mayor probabilidad.';
