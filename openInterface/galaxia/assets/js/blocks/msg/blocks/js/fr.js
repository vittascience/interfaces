/**
 * @fileoverview English messages for ESP32. (EN)
 */
'use strict';
// Display - Galaxia/Display
Blockly.Msg['DISPLAY_GALAXIA_SCREEN_SET_TEXT_TITLE'] = '[Ecran] Afficher le texte %1';
Blockly.Msg['DISPLAY_GALAXIA_SCREEN_SET_TEXT_TOOLTIP'] = '[Ecran] Affiche du texte sur l\'écran de la carte Galaxia.';
Blockly.Msg['DISPLAY_GALAXIA_SCREEN_SET_TEXT_VALUE_TITLE'] = '[Ecran] Afficher %1 avec la valeur %2';
Blockly.Msg['DISPLAY_GALAXIA_SCREEN_SET_TEXT_VALUE_TOOLTIP'] = '[Ecran] Affiche du texte sur l\'écran de la carte Galaxia avec une valeur.';
// Display - Galaxia/RGB
Blockly.Msg['DISPLAY_GALAXIA_LED_GREEN_CONTROL_TITLE'] = '[LED RGB] régler l\'intensité du vert à %1';
Blockly.Msg['DISPLAY_GALAXIA_LED_GREEN_CONTROL_TOOLTIP'] = 'Permet de régler l\'intensité du vert, de 0 à 255, pour la LED intégrée à la carte Galaxia.';
Blockly.Msg['DISPLAY_GALAXIA_LED_RED_CONTROL_TITLE'] = '[LED RGB] régler l\'intensité du rouge à %1';
Blockly.Msg['DISPLAY_GALAXIA_LED_RED_CONTROL_TOOLTIP'] = 'Permet de régler l\'intensité du rouge, de 0 à 255, pour la LED intégrée à la carte Galaxia.';
Blockly.Msg['DISPLAY_GALAXIA_LED_BLUE_CONTROL_TITLE'] = '[LED RGB] régler l\'intensité du bleu à %1';
Blockly.Msg['DISPLAY_GALAXIA_LED_BLUE_CONTROL_TOOLTIP'] = 'Permet de régler l\'intensité du bleu, de 0 à 255, pour la LED intégrée à la carte Galaxia.';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_BLUE_TITLE'] = '[LED RGB] intensité du bleu de la LED';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_BLUE_TOOLTIP'] = 'Retourne une valeur entre 0 et 255 correspondant à l\'intensité de bleu actuellement tranférée à la LED.';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_GREEN_TITLE'] = '[LED RGB] intensité du vert de la LED';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_GREEN_TOOLTIP'] = 'Retourne une valeur entre 0 et 255 correspondant à l\'intensité de vert actuellement tranférée à la LED.';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_RED_TITLE'] = '[LED RGB] intensité du rouge de la LED';
Blockly.Msg['DISPLAY_GALAXIA_LED_GET_RED_TOOLTIP'] = 'Retourne une valeur entre 0 et 255 correspondant à l\'intensité de rouge actuellement tranférée à la LED.';
Blockly.Msg['DISPLAY_GALAXIA_SET_LED_COLORS_TITLE'] = '[LED RGB] contrôler la couleur à R %1 G %2 B %3';
Blockly.Msg['DISPLAY_GALAXIA_SET_LED_COLORS_TOOLTIP'] = 'Permet de régler l\'intensité de la LED intégrée à la carte Galaxia, de 0 à 255.';
// Display - Galaxia/Graphique
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_TITLE'] = 'passer l\'écran en mode %1';
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_TOOLTIP'] = 'Changer le mode de l\'écran.';
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_CONSOLE'] = 'terminal';
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_PLOT'] = 'données';
Blockly.Msg['DISPLAY_GALAXIA_SET_MODE_GRAPHICS'] = 'graphique';
Blockly.Msg['DISPLAY_GALAXIA_PLOT_ADD_POINT_TITLE'] = '[Données] ajouter la valeur %1';
Blockly.Msg['DISPLAY_GALAXIA_PLOT_ADD_POINT_TOOLTIP'] = 'Ajouter un point sur le graphique.';
Blockly.Msg['DISPLAY_GALAXIA_PLOT_SET_Y_SCALE_TITLE'] = '[Données] régler l\'échelle de l\'axe Y à min %1 max %2';
Blockly.Msg['DISPLAY_GALAXIA_PLOT_SET_Y_SCALE_TOOLTIP'] = 'Règle l\'échelle de l\'axe y';
Blockly.Msg['DISPLAY_GALAXIA_ANIMATE_FUNCTION_TITLE'] = '[Données] toutes les %1 seconde.s calculer une nouvelle valeur';
Blockly.Msg['DISPLAY_GALAXIA_ANIMATE_FUNCTION_NEW_POINT'] = 'ajouter le résultat %1 dans le graphique';
Blockly.Msg['DISPLAY_GALAXIA_ANIMATE_FUNCTION_TOOLTIP'] = 'Ajouter un point sur le graphique toutes les x secondes.';
Blockly.Msg['DISPLAY_GALAXIA_RAW_PRINT_TITLE'] = '[Graphique] afficher le texte %1 en x %2 y %3';
Blockly.Msg['DISPLAY_GALAXIA_RAW_PRINT_TOOLTIP'] = 'Afficher du texte sur l\'écran graphique.';
Blockly.Msg['DISPLAY_GALAXIA_RAW_TEXT_TITLE'] = '[Graphique] afficher le texte %1 en x %2 y %3 avec la couleur %4';
Blockly.Msg['DISPLAY_GALAXIA_RAW_RECT_TITLE'] = '[Graphique] afficher le rectangle en x %1 y %2 largeur %3 hauteur %4 avec la couleur %5';
Blockly.Msg['DISPLAY_GALAXIA_RAW_RECT_TOOLTIP'] = 'Afficher un rectangle sur l\'écran graphique.';
Blockly.Msg['DISPLAY_GALAXIA_RAW_PRINT_IMG_TITLE'] = '[Graphique] afficher l\'image %1 en x %2 y %3';
Blockly.Msg['DISPLAY_GALAXIA_RAW_PRINT_IMG_TOOLTIP'] = 'Afficher une image sur l\'écran graphique (vous devez d\'abord charger l\'image dans la mémoire de la carte Galaxia)';
// Display - Screen
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD] afficher le texte %1 sur la ligne %2 position %3';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Affiche du texte sur l\'une des deux lignes de l\'écran LCD1602 grove. Brancher le module sur un port I2C';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD] nettoyer l\'écran';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Permet d\'effacer tous les caractères de l\'écran LCD. Brancher le module sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[Ecran OLED] afficher le texte %1 à la position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'écrire du texte sur un écran OLED grove avec 4x11 caractères. Brancher l\'afficheur sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TITLE'] = '[Ecran OLED] contrôler le pixel x %1 y %2 état %3';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de contrôler chaque pixel de l\'écran OLED 16x32 pixels. Brancher l\'afficheur sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TITLE'] = '[OLED] dessiner une ligne de (%1, %2) à (%3, %4)';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de dessiner une ligne entre deux points de l\'écran OLED de taille 128x64. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TITLE'] = '[OLED] définir le fond en %1';
Blockly.Msg['DISPLAY_OLED_WHITE'] = 'blanc';
Blockly.Msg['DISPLAY_OLED_BLACK'] = 'noir';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'inverser le rétroélcairage de l\'écran. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[Ecran OLED] effacer l\'écran';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de nettoyer l\'écran OLED. Brancher le module sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[OLED] afficher l\'icône %1 position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'afficher une icône de la librairie Image de ESP32, à la position (x,y) sur l\'écran grove OLED. Brancher l\'afficheur sur un port I2C.';
// Display - Neopixel
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] définir %1 LED sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de définir le nombre de LED du neopixel. Ce bloc doit être utilisé dans le bloc \'Au démarrage\'.';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] contrôler la LED %1 à R %2 G %3 B %4 sur la broche %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED tel que (R,G,B) de 0 à 255 du module neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] contrôler la LED %1 à %2 sur la broche %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du module neopixel. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] contrôler toutes les LED à R %1 G %2 B %3 sur la broche %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie telle que (R,G,B) soit de 0 à 255.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] contrôler toutes les LED à %1 sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] Arc-en-ciel sur la broche %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB. Il est possible de modifier la broche et le nombre de LED du module neopixel.';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] contrôler la LED %1 sur la broche  %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Permet d\'activer ou désactiver la LED Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] régler la luminosité à %1 sur la broche %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 255 sur les broches PWM.';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[Variable Color LED] régler la luminosité à %1 (%) sur la broche %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 100 % sur les broches PWM. A la premièe utilisation, les valeurs RGB sont fixées à 0. Utiliser un tournevis pour régler les couleurs R, G et B derrière le module.';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[Afficheur 4-digit] afficher %1 %2 sur les broches CLK %3 DIO %4';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher un nombre, une température ou l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales.';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[Afficheur 4-digit] l\'horloge sur les broches CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales. Attention, l\'heure réelle est récupérée seulement la carte Galaxia reste allumée.';
Blockly.Msg['DISPLAY_4DIGIT_NUMBER'] = 'le nombre entier';
Blockly.Msg['DISPLAY_4DIGIT_TEMPERATURE'] = 'la température';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[Module LED Bar] afficher le niveau de %1 sur les broches DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permet d\'afficher le niveau de la valeur en entrée sur le module LED Bar (MY9221) avec les broches digitales P0 à P20.';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TITLE'] = '[Module LED Bar] inverser l\'afficheur %1 les broches DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permet d\'inverser les 10 LED du module LED Bar (MY9221) avec les broches digitales.';
// Display - Chainable LED
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TITLE'] = '[Chainable LED] definir %1 LED sur les broches CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Permet de paramétrer la chaîne de LED RGB en définissant le nombre de modules en série sur les broches digitales D0 à D13.';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TITLE'] = '[Chainable LED] contrôler la LED %1 à R %2 G %3 B %4 sur les broches CIN %5 DIN %6';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la DEL RGB, donner une valeur entre 0 et 255 pour Rouge, Vert et Bleu.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TITLE'] = '[Chainable LED] contrôler la LED %1 à %2 sur les broches CIN %3 DIN %4';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la DEL RGB, choisir une couleur dans la palette.';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TITLE'] = '[Chainable LED] contrôler toutes les LED à R %1 G %2 B %3 sur les broches CIN %4 DIN %5';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur des DEL RGB, donner une valeur entre 0 et 255 pour Rouge, Vert et Bleu.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE'] = '[Chainable LED] contrôler toutes les LED à %1 sur les broches CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur des DEL RGB, choisir une couleur dans la palette.';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TITLE'] = '[Chainable LED] éteindre sur les broches CIN %1 DIN %2';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc éteignant toutes les DEL RGB.';
// IO - Galaxia - A & B
Blockly.Msg['IO_ISPRESSED'] = 'est';
Blockly.Msg['IO_WASPRESSED'] = 'a été';
Blockly.Msg['IO_ONBUTTONPRESSED_TITLE'] = 'si le bouton %1 %2 appuyé alors';
Blockly.Msg['IO_ONBUTTONPRESSED_TOOLTIP'] = 'Exécute des instructions si les boutons A ou B sont préssés.';
Blockly.Msg['IO_ISBUTTONPRESSED_TITLE'] = 'bouton %1 %2 appuyé';
Blockly.Msg['IO_ISBUTTONPRESSED_TOOLTIP'] = 'Retourne \'True\' si le bouton A ou B est pressé, et \'False\' sinon.';
Blockly.Msg['IO_ONBUTTONEVENT_TITLE'] = 'Lorsque le bouton %1 est appuyé';
Blockly.Msg['IO_ONBUTTONEVENT_TOOLTIP'] = 'Faire quelque chose quand un bouton (A ou B) est appuyé et relaché.';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TITLE'] = 'nombre de clics du bouton %1';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TOOLTIP'] = 'Retourne le nombre de fois qu\'a été appuyé le bouton A ou B.';
// IO - Galaxia - Touch buttons
Blockly.Msg['IO_TOUCH_UP'] = 'haut';
Blockly.Msg['IO_TOUCH_DOWN'] = 'bas';
Blockly.Msg['IO_TOUCH_RIGHT'] = 'droit';
Blockly.Msg['IO_TOUCH_LEFT'] = 'gauche';
Blockly.Msg['IO_IFTOUCHSENSITIVEBUTTONTOUCHED_TITLE'] = 'si le bouton tactile %1 %2 appuyé alors';
Blockly.Msg['IO_IFTOUCHSENSITIVEBUTTONTOUCHED_TOOLTIP'] = 'Exécute des instructions si le bouton tactile (haut, bas, droit ou gauche) est touché.';
Blockly.Msg['IO_ISTOUCHSENSITIVEBUTTONTOUCHED_TITLE'] = 'bouton tactile %1 %2 touché';
Blockly.Msg['IO_ISTOUCHSENSITIVEBUTTONTOUCHED_TOOLTIP'] = 'Retourne \'True\' si le bouton tactile selectionné est touché, et \'False\' sinon.';
Blockly.Msg['IO_ONTOUCHSENSITIVEBUTTONEVENT_TITLE'] = 'Lorsque le bouton tactile %1 a été touché';
Blockly.Msg['IO_ONTOUCHSENSITIVEBUTTONEVENT_TOOLTIP'] = 'Faire quelque chose quand un bouton tactile (haut, bas, droit ou gauche) est appuyé et relaché.';
Blockly.Msg['IO_TOUCHSENSITIVEBUTTON_GET_TOUCHES_TITLE'] = 'nombre de clics du bouton tactile %1';
Blockly.Msg['IO_TOUCHSENSITIVEBUTTON_GET_TOUCHES_TOOLTIP'] = 'Retourne le nombre de fois qu\'a été appuyé la touche sélectionnée (HAUT, BAS, DROITE ou GAUCHE) depuis le dernier appel de la fonction get_touches(), soit ce bloc.';
//input/output Galaxia Specific
// Input/Output - Esp32
Blockly.Msg['IO_WAIT_TITLE'] = 'attendre %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Effectue une pause dans l\'exécution du code.';
Blockly.Msg['IO_WAIT_SECOND'] = 'seconde.s';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milliseconde.s';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microseconde.s';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'attendre jusqu\'à %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Arrête l\'excution du code jusqu\'à ce que la condition soit satisfaite.';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'démarrer le chronomètre';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Initialise un chronomètre à 0 (en secondes).';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'valeur du chronomètre en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Renvoie la valeur du chronomètre à partir de l\'initialisation (en secondes ou millisecondes).';
// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Clavier numérique] chiffre sur les broches RX %1 TX %2';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Permet d\'obtenir la touche appuyée du clavier numérique grove sur les broches TX et RX. Quand vous connectez le module, s\'assurer que les broches sont \'croisées\' : RX de la carte avec TX du module et inversement.';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Module joytsick] valeur de l\'axe %1 sur les broches X %2 Y %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'axe X ou Y (de O à 65535) du joystick Grove sur les broches analogiques.';
Blockly.Msg['IO_ROTARYENCODER_TITLE'] = '[Encodeur rotatif] Connecter les broches CLK %1 et DT %2';
Blockly.Msg['IO_ROTARYENCODER_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'encodeur rotatif Grove. Connecter les broches CLK et DT sur les pins digitales de la galaxia.';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TITLE'] = '[Module bouton coloré] état sur la broche SIG2 %1 ';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Renvoie l\'état du bouton coloré grove (0 or 1) sur les broches digitales.';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TITLE'] = '[Module bouton coloré] contrôler la LED à l\'état %1 sur la broche SIG1 %2';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Permet d\'allumer ou éteindre la LED (0 or 1) sur les broches digitales.';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Potentiomètre rotatif] valeur sur la broche %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Renvoie l\'angle (de O à 65535) du potentiomètre rotatif Grove sur les broches analogiques.';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Potentiomètre linéaire] valeur sur la broche %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Renvoie la position (de O à 65535) du potentiomètre linéaire Grove sur les broches analogiques.';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Capteur tactile] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur tactile Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Module bouton] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Renvoie la valeur du bouton Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Module interrupteur] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'interrupteur Grove (0 ou 1) sur les broches digitales.';
// Input/Output - Pins
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'HAUT (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAS (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Retourne une valeur booléene (1 si HAUT ou 0 si BAS).';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'état de la broche numérique %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée digitale (0 ou 1).';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'écrire sur la broche numérique %1 l\'état %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Permet d\'écrire une valeur sur une entrée digitale (0 ou 1).';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'lire la broche analogique %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée analogique (0-65535).';
Blockly.Msg['IO_WRITEPWMPIN_TITLE'] = 'écrire la valeur %1 sur la broche PWM %2';
Blockly.Msg['IO_WRITEPWMPIN_TOOLTIP'] = 'Permet d\'appliquer un signal PWM avec une fréquence fixée à 10 kHz et en changeant le cycle de 0 à 65535. La valeur 32768 correspondra à 50% du cycle, donc environ 1.66V.';
Blockly.Msg['IO_WRITEANALOGPIN_TITLE'] = 'écrire la valeur %1 sur la broche analogique %2 (DAC)';
Blockly.Msg['IO_WRITEANALOGPIN_TOOLTIP'] = 'Enable to apply an analog voltage to the DAC pins p25 and p26 (from 0 to 255). The Esp32 uses a digital-analog converter (DAC) to apply a voltage between 0 and 3.3V.';
Blockly.Msg['IO_SETPWM_TITLE'] = 'appliquer un signal carré de fréquence %1 (Hz) sur la broche %2';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Permet d\'appliquer un signal carré (PWM) avec un cycle fixé à 50% (soit 32768) sur une broche. Ce bloc permet de changer la fréquence du signal de 0 à 4.29 GHz.';
Blockly.Msg['IO_STOPPWM_TITLE'] = 'arrêter le signal PWM de la broche %1';
Blockly.Msg['IO_STOPPWM_TOOLTIP'] = 'Permet d\'arrêter le signal PWM appliqué sur une broche.';
Blockly.Msg['IO_GETVOLTAGE_TITLE'] = 'convertir %1 sur %2 en tension';
Blockly.Msg['IO_GETVOLTAGE_TOOLTIP'] = 'Permet de convertir une valeur analogique en tension en choisissant la résolution (10-bit: 1024, 12-bit: 4096, 9-bit: 512, 11-bit: 2048, 12-bit: 4096, 13-bit: 8191) et un maximum de 3.6V.';

// Communication LOG
Blockly.Msg['COMMUNICATION_LOG_DELETE_TITLE'] = 'effacer les logs';
Blockly.Msg['COMMUNICATION_LOG_DELETE_TOOLTIP'] = 'Permet d\'effacer les logs de la carte Galaxia.';
Blockly.Msg['COMMUNICATION_LOG_SET_LABEL_TITLE'] = 'ajouter un nouveau label';
Blockly.Msg['COMMUNICATION_LOG_SET_LABEL_TOOLTIP'] = 'Permet d\'ajouter un label aux logs de la carte Galaxia.';
Blockly.Msg['COMMUNICATION_LOG_ADDDATA_TITLE'] = 'ajouter les données à un label';
Blockly.Msg['COMMUNICATION_LOG_ADDDATA_TOOLTIP'] = 'Permet d\'ajouter un label à la colonne des données du log. Le label peut être un texte ou un nombre. Les données peuvent être un texte ou un nombre.';
Blockly.Msg['COMMUNICATION_LOG_DATA_TITLE'] = 'label %1 donnée %2';
Blockly.Msg['COMMUNICATION_LOG_DATA_TOOLTIP'] = 'Permet d\'ajouter un label à la colonne des données du log. Le label peut être un texte ou un nombre. Les données peuvent être un texte ou un nombre.';

// Communication - Galaxia
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TITLE'] = '[Radio] envoyer la chaîne %1';
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TOOLTIP'] = 'Permet d\'envoyer uen chaîne de caractères via la radio de la carte Galaxia.';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TITLE'] = '[Radio] envoyer le nombre ou la liste %1';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TOOLTIP'] = 'Permet d\'envoyer des nombres ou une liste via la radio de la carte Galaxia.';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TITLE'] = '[Radio] envoyer la valeur %1 = %2';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TOOLTIP'] = 'Permet d\'envoyer des données avec un nom et sa valeur via la radio de la carte Galaxia.';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TITLE'] = '[Radio] si une chaîne est reçue dans %1 alors';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si une chaîne de caractères est reçue par radio dans la variable \'stringData\'.';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TITLE'] = '[Radio] si un nombre est reçu dans %1 alors';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si un nombre est reçu par radio dans la variable \'numberData\'.';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TITLE'] = '[Radio] si une valeur est reçue dans %1 %2 alors';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si un nom et sa valeur sont reçus par radio dans les variables \'name\' et \'value\'.';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TITLE'] = '[Radio] configurer Canal %1 Puissance %2 Taille des données %3 Groupe %4';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TOOLTIP'] = 'Permet de configurer le canal de la radio (de 0 to 83), la taille des données transmises (en octets), la puissance de transmission (de 0 à 7)  ainsi que le group (de 0 à 255).';
//Communication - Internal Bluetooth
Blockly.Msg['COMMUNICATION_START_BT_TITLE'] = '[ESP32 Bluetooth UART] initialiser le bluetooth %1';
Blockly.Msg['COMMUNICATION_START_BT_TOOLTIP'] = 'Permet d\'intialiser le service Bluetooth de l\'ESP32 avec un nom attribué.';
Blockly.Msg['COMMUNICATION_SEND_BT_TITLE'] = '[ESP32 Bluetooth UART] envoyer donnée %1';
Blockly.Msg['COMMUNICATION_SEND_BT_TOOLTIP'] = 'Permet d\'envoyer des données via le Bluetooth de l\'ESP32.';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TITLE'] = '[Bluetooth] si message reçu dans %1 alors';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TOOLTIP'] = 'Permet d\'exécuter des instructions si une donnée est reçue par Bluetooth (BLE).';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TITLE'] = '[Bluetooth Fizziq App] envoyer %1 %2';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TOOLTIP'] = IMG_MODULE_FIZZIQ + Blockly.Tooltip.SEP + 'Envoyer des données (Température, Humidité, etc) via Bluetooth à Fizziq App.';
Blockly.Msg['FIZZ_TEMP'] = 'Température';
Blockly.Msg['FIZZ_HUM'] = 'Humidité';
Blockly.Msg['FIZZ_VOLTAGE'] = 'Tension';
Blockly.Msg['FIZZ_WEIGHT'] = 'Poids';
Blockly.Msg['FIZZ_PRESSURE'] = 'Pression';
Blockly.Msg['FIZZ_CONCENTRATION'] = 'Concentration';
Blockly.Msg['FIZZ_MAGNETIC'] = 'Champ magnétique';
Blockly.Msg['FIZZ_BRIGHTNESS'] = 'Luminosité';
Blockly.Msg['FIZZ_ACCELERATION'] = 'Accélération';
Blockly.Msg['FIZZ_COMPASS'] = 'Boussole';
// Communication - Infrared
Blockly.Msg['COMMUNICATION_INFRARED_ONDATARECEIVED_TITLE'] = '[IR] si %1 est reçu dans %2 %3broche %4 avec le protocol %5 alors';
Blockly.Msg['COMMUNICATION_INFRARED_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par un module infrarouge dans une variable sur la broche digitale avec un protocol NEC_8 ou NEC_16.';
Blockly.Msg['COMMUNICATION_IR_EMIT_TITLE'] = '[IR] %1 un signal IR sur la broche %2';
Blockly.Msg['COMMUNICATION_IR_EMIT_TOOLTIP'] = 'Permet d\'émettre un signal infrarouge sur la broche digitale';
Blockly.Msg['COMMUNICATION_IR_EMIT_ACTIVATE'] = 'activer';
Blockly.Msg['COMMUNICATION_IR_EMIT_DEACTIVATE'] = 'désactiver';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'écrire dans la console %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Permet d\'écrire des données dans la console.';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'avec';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'saut.s de ligne';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE then'] = 'on serial data received in %1 then';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si une donnée est reçue par le port série dans la variable \'serialData\'.';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'jouer la note %1 sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Joue la note sélectionnée jusqu\'à l\'exécution du bloc "Fin de la note".';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'jouer la fréquence %1 (Hz) sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Ce bloc permet de jouer une fréquence donnée sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'terminer la note sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Arrête la note en cours.';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'tracer le graphe';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Ce bloc permet d\'écrire des données (numériques) qui seront visibles dans le traceur. Il peut être utilisé avec un ou plusieurs blocs au format "Nom" et "Données". Pour visualiser les graphiques, cliquer sur l\'icone \'Mode Graphique\' dans la console.';
Blockly.Msg['COMMUNICATION_DATA'] = 'Donnée';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nom %1 Valeur %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Ce bloc est à utiliser avec le bloc "Tracer le graphique". Il doit lui-même contenir le nom de la valeur à afficher (texte), et la valeur en question (nombre).';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] écrire dans la carte SD %1 avec la carte %2 sur les broches RXI %3 TXO %4 %5 Données %6';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'Permet d\'écrire des données dans la carte micro SD avec le module Openlog. Le baudrate de l\'OpenLog doit être configuré à la moitié du baudrate de la carte. Exemple: Pour la carte v1, si le baudrate est à 9600 (cf config.txt sur la carte SD), le baudrate doit être à 4800.';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] envoyer sur les broches RX %1 TX %2 message %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permet d\'envoyer des données via le module Bluetooth HC05 sur les broches RX/TX.';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] si message reçu sur les broches RX %1 TX %2 dans %3 alors';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par un module Bluetooth HC05 dans la variable \'bluetoothData\' sur les broches RX/TX.';
// Communication - Tracking modules
Blockly.Msg['COMMUNICATION_GPS_INFO_TYPE'] = 'le type de la trame';
Blockly.Msg['COMMUNICATION_GPS_INFO_CLOCK'] = 'l\'heure';
Blockly.Msg['COMMUNICATION_GPS_INFO_LATITUDE'] = 'la latitude °Nord';
Blockly.Msg['COMMUNICATION_GPS_INFO_LONGITUDE'] = 'la longitude °Est';
Blockly.Msg['COMMUNICATION_GPS_INFO_SATELLITE'] = 'le nombre de satellites utilisés';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALTITUDE'] = 'l\'altitude (m)';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALL_FRAME'] = 'toute la trame';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TITLE'] = '[GPS] trames NMEA sur les broches RX %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Renvoie la liste des trames NMEA lues avec le module GPS Grove SIM28 ou Air530 sur les broches RX/TX. Les fils n\'ont pas besoin d\'être inversée entre les broches du module et celles indiquées dans le bloc. L\'inversion se fait automatiquement dans le code python.\nAttention: Si vous utilisez la console pour afficher les données du GPS, connecter votre carte à l\'interface avant d\'envoyer le programme en cliquant sur le bouton [>_ REPL]. Ensuite, transférer votre programme en utilisant le bouton [Télécharger .hex].';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TITLE'] = '[GPS] obtenir %3 sur les broches RX %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Renvoie la donnée sélectionnée parmi (le type de trame, l\'horloge, la latitude, la longitude, l\'altitude) annalysée de la trame NMEA (GNGGA ou GPGGA) lue avec le module GPS Grove SIM28 ou Air530 sur les broches RX/TX. Les fils n\'ont pas besoin d\'être inversée entre les broches du module et celles indiquées dans le bloc. L\'inversion se fait automatiquement dans le code python.\nAttention: Si vous utilisez la console pour afficher les données du GPS, connecter votre carte à l\'interface avant d\'envoyer le programme en cliquant sur le bouton [>_ REPL]. Ensuite, transférer votre programme en utilisant le bouton [Télécharger .hex].';
Blockly.Msg['COMMUNICATION_RTC_MODULE_PCF85063TP'] = 'Haute Précision (0x51)';
Blockly.Msg['COMMUNICATION_RTC_MODULE_DS1307'] = 'v1.2 (0x68)';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TITLE'] = '[Horloge RTC %1] initialiser à %2 date %3';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet d\'initialiser le module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307), pour pouvoir lire la date et l\'heure précise avec le bloc \'Lire le module horloge\'. Placer dans le bloc \'Au démarrage\'. Brancher le module RTC sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['DAY_MONDAY'] = 'lundi';
Blockly.Msg['DAY_TUESDAY'] = 'mardi';
Blockly.Msg['DAY_WEDNESDAY'] = 'mercredi';
Blockly.Msg['DAY_THURSDAY'] = 'jeudi';
Blockly.Msg['DAY_FRIDAY'] = 'vendredi';
Blockly.Msg['DAY_SATURDAY'] = 'samedi';
Blockly.Msg['DAY_SUNDAY'] = 'dimanche';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TITLE'] = '[Horloge RTC %1] initialiser à heure %2 minute %3 seconde %4';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet d\'initialiser le module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307), pour pouvoir lire la date et l\'heure précise avec le bloc \'Lire le module horloge\'. Placer dans le bloc \'Au démarrage\'. Brancher le module sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TITLE'] = '[Horloge RTC %1] lire %2';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet de lire la date et l\'heure du module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307). Pour avoir un résultat correct, utiliser au préalable les deux blocs \'Initialiser le module horloge\'. Brancher le module sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['CLOCK_ALL_DATA'] = 'l\'horloge';
Blockly.Msg['CLOCK_YEAR'] = 'année';
Blockly.Msg['CLOCK_MONTH'] = 'mois';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'jour du mois';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'jour de la semaine';
Blockly.Msg['CLOCK_HOUR'] = 'heure';
Blockly.Msg['CLOCK_MINUTE'] = 'minute';
Blockly.Msg['CLOCK_SECOND'] = 'seconde';
// Communication - UART
Blockly.Msg['COMMUNICATION_UART_INIT_TITLE'] = '[uart] définir la connexion série sur RX %1 TX %2 Baudrate %3';
Blockly.Msg['COMMUNICATION_UART_INIT_TOOLTIP'] = 'Permet de définir la connexion série de la carte ESP32 sur le port UART (1 ou 2). Le port 0 est réservé au REPL.';
Blockly.Msg['COMMUNICATION_UART_WRITE_TITLE'] = '[uart] écrire la donnée %1';
Blockly.Msg['COMMUNICATION_UART_WRITE_TOOLTIP'] = 'Permet d\'écrire des données dans le port UART.';
Blockly.Msg['COMMUNICATION_UART_READ_TITLE'] = '[uart] lire les données';
Blockly.Msg['COMMUNICATION_UART_READ_TOOLTIP'] = 'Permet de lire des données depuis le port UART.';
Blockly.Msg['COMMUNICATION_UART_READ_SIZE'] = 'taille des données';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TITLE'] = '[uart] données disponibles';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TOOLTIP'] = 'Retourne une valeur booléenne (1 si des données sont disponibles à la lecture ou 0 sinon).';
// Sensors - Galaxia
Blockly.Msg['SENSORS_GETACCELERATION_TITLE'] = 'accélération (mg) %1';
Blockly.Msg['SENSORS_GETACCELERATION_TOOLTIP'] = 'Renvoie l\'accélération (en mg) grâce à l\'accéléromètre de la carte Galaxia.';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_TITLE'] = 'si %1 alors';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_SHAKE'] = 'secoué';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_UP'] = 'logo vers le haut';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_DOWN'] = 'logo vers le bas';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FACE_UP'] = 'écran vers le haut';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FACE_DOWN'] = 'écran vers le bas';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_LEFT'] = 'penché à gauche';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_RIGHT'] = 'penché à droite';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FREEFALL'] = 'chute libre';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_TOOLTIP'] = 'Exécute des instructions si la carte Galaxia est secouée.';
Blockly.Msg['SENSORS_GETLIGHT_TITLE'] = 'luminosité';
Blockly.Msg['SENSORS_GETLIGHT_TOOLTIP'] = 'Renvoie la luminosité (de 0 à 255) grâce à quelques LED de l\'écran de la carte Galaxia.';
Blockly.Msg['SENSORS_CALIBRATECOMPASS_TITLE'] = 'calibrer la boussole';
Blockly.Msg['SENSORS_CALIBRATECOMPASS_TOOLTIP'] = 'Permet de calibrer le compas de la carte Galaxia. Il suffit de secouée la carte pour le calibrer. Un smiley \'heureux\' apparaît lorsque la calibration est terminée.';
Blockly.Msg['SENSORS_GETCOMPASS_TITLE'] = 'direction de la boussole (°)';
Blockly.Msg['SENSORS_GETCOMPASS_TOOLTIP'] = 'Renvoie la direction (de 0° à 360°) de la carte Galaxia grâce au compas interne.';
Blockly.Msg['SENSORS_GETTEMPERATURE_TITLE'] = 'température en %1';
Blockly.Msg['SENSORS_GETTEMPERATURE_TOOLTIP'] = 'Renvoie la température en degré Celius (°C), Fahrenheit (°F) ou Kelvin (K) du processeur de la carte Galaxia.';
Blockly.Msg['SENSORS_GETROTATION_TITLE'] = 'rotation (°) %1';
Blockly.Msg['SENSORS_GETROTATION_PITCH'] = 'tangage';
Blockly.Msg['SENSORS_GETROTATION_ROLL'] = 'roulis';
Blockly.Msg['SENSORS_GETROTATION_TOOLTIP'] = 'Renvoie la rotation (de -180° à 180°) grâce à l\'accéléromètre de la carte Galaxia.';
Blockly.Msg['SENSORS_GETMAGNETICFORCE_TITLE'] = 'force du champ magnétique %1 (nT)';
Blockly.Msg['SENSORS_GETMAGNETICFORCE_TOOLTIP'] = 'Renvoie la valeur du champ magnétique (en nT) grâce au compas de la carte Galaxia.';
// Sensors - ESP32
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TITLE'] = 'lire le capteur à effet Hall';
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TOOLTIP'] = 'Renvoie la valeur du capteur à effet Hall de la carte.';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TITLE'] = 'température du processeur en %1';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TOOLTIP'] = 'Retourne la température du processeur.';
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[Capteur SGP30] gaz %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Renvoie la quantité de CO2 (en ppm) ou de TVOC (en ppb) contenu dans l\'air grâce au capteur SGP30. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'Dioxyde de carbone (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'Composés organiques volatiles (TVOC) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Capteur de gaz multicanal] gaz %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Renvoie la quantité du gaz mesuré dans l\'air (en ppm) grâce au capteur de gaz multicanal. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Capteur de gaz multicanal v2] gaz %1 (V)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Renvoie la quantité du gaz mesuré dans l\'air (en V) grâce au capteur de gaz multicanal V2 grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['GAS_CO'] = 'Monoxyde de carbone (CO)';
Blockly.Msg['GAS_NO2'] = 'Dioxyde d\'azote (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'Ethanol (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'Dihydrogène (H2)';
Blockly.Msg['GAS_NH3'] = 'Ammoniac (NH3)';
Blockly.Msg['GAS_CH4'] = 'Méthane (CH4)';
Blockly.Msg['GAS_C3H8'] = 'Propane (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'Iso-propane (C4H10)';
Blockly.Msg['GAS_VOC'] = 'Composés organiques volatiles (COV)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Capteur de dioxygène] O2 (%) sur la broche %1';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Renvoie la concentration de dioxygène (O2) dans l\'air (en %) grâce au capteur de gas O2 grove sur les broches analogiques.';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[Capteur SCD30] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Renvoie la concentration de CO2 dans l\'air (en ppm), l\'humidité (en %) ou la température en Celsius (°C), Fahrenheit (°F) ou Kelvin (K) from the grove SCD30 sensor. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'dioxyde de carbone (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = 'température';
Blockly.Msg['SENSORS_SCD30_HUM'] = 'humidité (%)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[Capteur SCD30] forcer la recalibration à %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Forcer la calibration du capteur SCD30 à la valeur donnée. Se placer en extérieur (là où la concentration est autour de 420 ppm environ, soit un air pur), redémarrer la carte, puis attendre 2 minutes. Conseil: Utiliser le bouton A ou B de la carte BBC Galaxia pour contrôler le lancement de la calibration. Sinon, en rebranchant la carte, le programme se lance et effectue de nouveau une calibration pas forcément souhaitée.';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Capteur de qualité d\'air] valeur sur la broche %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Renvoie la valeur de la qualité de l\'air (de O à 65535) sur les broches analogiques. Le capteur est Air Quality Sensor v1.3 de Seeed.';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[Capteur HM330X] concentration de particules fines %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Détecte la densité de particules dans l\'air avec le capteur HM330X. brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
// Sensors - Climate
Blockly.Msg['SENSORS_LINKY_TITLE'] = '[Capteur Linky] récuppérer la valeur de %1 sur la broche RX %2';
Blockly.Msg['SENSORS_LINKY_TOOLTIP'] = 'Renvoie la consommation électrique (en Wh) apparente, des heures creuses et heures pleines du compteur Linky. Brancher le capteur sur un port UART de la galaxia.';
Blockly.Msg['SENSORS_LINKY_PAPP'] = 'puissance instantanée';
Blockly.Msg['SENSORS_LINKY_HCHC'] = 'heure creuses';
Blockly.Msg['SENSORS_LINKY_HCHP'] = 'heure pleines';
Blockly.Msg['SENSORS_TEMPERATURE'] = 'température';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humidité (%)';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'en';
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[Capteur BMP280 %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), la pression (en Pascal) ou l\'altitude (en m). L\'altitude est calculée avec la pression et est initialisée à 0 au début du programme. Le bloc a besoin du capteur Grove BMP280 (adresse I2C: 0x77, couleur: bleu) ou le capteur HW-611 280 (adresse I2C: 0x76, couleur: violet). Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_BMP280_TEMP'] = 'température';
Blockly.Msg['SENSORS_BMP280_PRESS'] = 'pression (Pa)';
Blockly.Msg['SENSORS_BMP280_ALT'] = 'l\'altitude (m)';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = '[Capteur H.T°] température en %1 sur les broches A0 %2 A1 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température du thermocouple en degré Celsius (50 à 600 °C), Fahrenheit (°F) ou Kelvin (K) grâce au capteur grove de haute température sur les broches analogiques.';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Capteur d\'humidité] humidité du sol sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Renvoie l\'humidité (de O à 65535) mesurée grâce au capteur d\'humidité grove sur les broches analogiques.';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Capteur de T°] température en %1 sur la broche %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) du capteur de température Grove sur les broches analogiques.';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TITLE'] = '[Capteur DS18B20] température en %1 sur la broche %2';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) du capteur de température étanche DS18B20 sur les broches digitales.';
Blockly.Msg['SENSORS_DHT11_READDATA_TITLE'] = '[Capteur DHT11] %1 sur la broche %2';
Blockly.Msg['SENSORS_DHT11_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur dht11 grove sur les broches digitales.';
Blockly.Msg['SENSORS_DHT22_READDATA_TITLE'] = '[Capteur DHT22] %1 sur la broche %2';
Blockly.Msg['SENSORS_DHT22_READDATA_TOOLTIP'] = IMG_MODULE_DHT22 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) avec une grande précision grâce au capteur dht22 grove sur les broches digitales.';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[Capteur TH02] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur TH02. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Capteur SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur SHT31. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Capteur d\'eau] quantité d\'eau sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Renvoie la quantité d\'eau (de 0 à 255) mesurée grâce au capteur d\'eau grove sur les broches analogiques.';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Capteur de pluie] état sur la broche %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Renvoie l\'état du capteur de pluie (1 s\'il pleut ou 0 sinon) sur les broches digitales.';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anémomètre] état sur la broche %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Renvoie l\'état de l\'anémomètre (deux fois état HAUT à chaque rotation) sur les broches digitales.';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Capteur de lumière] luminosité sur la broche %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Renvoie la luminosité (de O à 65535) du capteur de lumière Grove sur les broches analogiques.';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[Capteur SI1145] luminosité %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Renvoie l\'indice de lumière ultraviolette, la luminosité visible (en lumen) ou infrarouge (en lumen) grâce au capteur Grove Sunlight ou le capteur GY1145. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SI1145_UV'] = 'indice UV';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visible (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrarouge (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Capteur ultraviolet] indice UV sur la broche %1';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Renvoie l\'indice de la lumière ultraviolette pour des ondes entre 240 et 380 nm du capteur Grove sur les broches analogiques.';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Capteur de couleurs] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Permet de lire le niveau d\'une des trois couleurs primaires avec le capteur de couleur grove, le niveau est compris entre 0 et 255. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Capteur de son] niveau sonore sur la broche %1';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Renvoie le niveau sonore (O à 65535) avec le capteur de son Grove sur les broches digitales.';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Capteur à ultrasons %1] %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Renvoie la distance (in cm) mesurée grâce au capteur grove à ultrasons sur les broches digitales. Attention, si le capteur est un modèle grove, TRIG et ECHO sont sur la même broche SIG.';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distance (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'durée de l\'aller-retour (µs)';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = '[Capteur de gestes] type de geste';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Renvoie le type de geste analysé (\'right\', \'left\', \'up\', \'down\', \'forward\', \'backward\', \'clockwise\', \'anticlockwise\') grâce au capteur de gestes grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Capteur de gestes] si le geste %1 est détecté';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Exécute des instructions si le geste sélectionné est détecté par le capteur de gestes grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'droit';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'gauche';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'haut';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'bas';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'avant';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'arrière';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'horaire';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'antihoraire';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'onde';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Capteur de ligne noire] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur de ligne noire grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[Capteur de mouvement] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur de mouvement Grove PIR Motion (0 ou 1) sur les broches digitales.';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Capteur de vibrations] état sur la broche %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Renvoie l\'état de la vibration (0 ou 1) grâce au capteur de vibration piezoélectrique sur les broches digitales.';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Module inclinaison] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'inclinaison du module Grove (0 ou 1) sur les broches digitales.';
// Other sensors
Blockly.Msg['SENSORS_GETGROVEBUTTON_TITLE'] = '[Module bouton] %1 sur la broche %2';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Renvoie la valeur numérique du bouton Grove (0/1 ou 0V/3.3V) sur les broches digitales.';
Blockly.Msg['SENSORS_GETGROVEBUTTON_VOLTAGE'] = 'tension';
Blockly.Msg['SENSORS_GETGROVEBUTTON_STATE'] = 'état';
// Actuators
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servomoteur] contrôler l\'angle à %1 sur la broche %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler l\'angle d\'un servomoteur (de 0 à 180) sur les broches digitales.. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au servomoteur.';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Servomoteur continu] contrôler la vitesse à %1 (%) direction %2 sur la broche %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler la vitesse (de 0 à 100 %) d\'un servomoteur continu sur les broches PWM.';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Moteur] contrôler la puissance à %1 sur la broche %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permet de contrôler la puissance d\'un moteur (de 0 à 1023) sur les broches digitales.. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au moteur.';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Module relais] contrôler le relais à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Permet de contrôler la valeur du relais (0 ou 1) sur les broches digitales.';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Moteur à vibration] contrôler le moteur à l\'état %1 sur la broche  %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver le moteur à vibration grove (0 ou 1) sur les broches digitales.';
// Actuators - Music
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TITLE'] = '[Music] jouer la musique %1 sur %2';
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une musique avec le module buzzer ou speaker grove sur les broches digitales.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TITLE'] = '[Buzzer/Speaker] jouer les notes sur';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer des notes avec un module Grove buzzer (ou speaker) sur les broches digitales.';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TITLE'] = 'note %1 à l\'octave %2 durée %3';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de définir une note à une certaine octave pendant une durée déterminée.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TITLE'] = '[Buzzer/Speaker] jouer la fréquence %1 pendant %2 (ms) sur %3';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une fréquence avec un module Grove buzzer (ou speaker) sur les broches digitales.';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TITLE'] = '[Buzzer/Speaker] arrêter la musique sur %1';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet d\'arrêter la musique en cours du module Grove buzzer (ou speaker) sur les broches digitales.';
// Notes
Blockly.Msg['NOTE_C'] = 'Do';
Blockly.Msg['NOTE_C_SHARP'] = 'Do#';
Blockly.Msg['NOTE_D'] = 'Ré';
Blockly.Msg['NOTE_D_SHARP'] = 'Ré#';
Blockly.Msg['NOTE_E'] = 'Mi';
Blockly.Msg['NOTE_F'] = 'Fa';
Blockly.Msg['NOTE_F_SHARP'] = 'Fa#';
Blockly.Msg['NOTE_G'] = 'Sol';
Blockly.Msg['NOTE_G_SHARP'] = 'Sol#';
Blockly.Msg['NOTE_A'] = 'La';
Blockly.Msg['NOTE_A_SHARP'] = 'La#';
Blockly.Msg['NOTE_B'] = 'Si';
Blockly.Msg['MUSIC_SILENCE'] = 'Silence';

// IA SENSORS
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TITLE'] = 'charger le modèle local';
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TOOLTIP'] = 'Permet de charger un modèle IA stocké localement depuis le navigateur web.';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TITLE'] = 'charger le modèle depuis l\'url %1';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TOOLTIP'] = 'Permet de charger un modèle IA stocké depuis le cloud.';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TITLE'] = 'Prédiction à partir des données de capteur';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TIME_WINDOW'] = 'fenêtre';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TOOLTIP'] = 'Permet de lancer une prédiction à partir d\'un capteur. Ajuster la fenêtre de temps pour obtenir une prédiction, si nécessaire.';
Blockly.Msg['VITTAIA_SENSOR_ACC'] = 'accéléromètre';
Blockly.Msg['VITTAIA_DETECT_CLASS_TITLE'] = 'si la classe %1 %2 détectée alors';
Blockly.Msg['VITTAIA_DETECT_CLASS_TOOLTIP'] = 'Permet de détecter la classe d\'un objet.';
Blockly.Msg['VITTAIA_IS'] = 'est';
Blockly.Msg['VITTAIA_ISNOT'] = 'n\'est pas';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TITLE'] = 'classe detectée';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TOOLTIP'] = 'Permet de récupérer la classe avec la plus haute probabilité.';