/**
 * @fileoverview English messages for Raspberry Pi Pico. (EN)
 */

'use strict';

// Display - Pico
Blockly.Msg["DISPLAY_CONTROL_BUILTIN_LED_TITLE"] = "[Pico] control built-in led (GP25) at state %1";
Blockly.Msg["DISPLAY_CONTROL_BUILTIN_LED_TOOLTIP"] = "Enbable to control the built-in led of the Raspberry Pi Pico.";
Blockly.Msg["DISPLAY_CONTROL_BUILTIN_LED_W_TITLE"] = "[Pico] control built-in led (GPI0) at state %1";
Blockly.Msg["DISPLAY_CONTROL_BUILTIN_LED_W_TOOLTIP"] = "Enbable to control the built-in led of the Raspberry Pi Pico W.";
// Display - Screen
Blockly.Msg["DISPLAY_LCD_SETTEXT_TITLE"] = "[LCD] show text %1 on line %2 position %3 on port %4";
Blockly.Msg["DISPLAY_LCD_SETTEXT_TOOLTIP"] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + "Show text on the grove lcd 1602 display. Connect lcd on I2C port.";
Blockly.Msg["DISPLAY_LCD_CLEAR_TITLE"] = "[LCD] clear display on port %1";
Blockly.Msg["DISPLAY_LCD_CLEAR_TOOLTIP"] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + "Enable to clear the entire lcd text. Connect lcd on I2C port.";
Blockly.Msg["DISPLAY_OLED_ADDTEXT_TITLE"] = "[OLED display] show text %1 at position x %2 y %3 on port %4";
Blockly.Msg["DISPLAY_OLED_ADDTEXT_TOOLTIP"] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + "Enable write text on OLED display. Connect the OLED display on I2C port.";
Blockly.Msg["DISPLAY_OLED_SETPIXEL_TITLE"] = "[OLED display] control pixel x %1 y %2 to state %3 on port %4";
Blockly.Msg["DISPLAY_OLED_SETPIXEL_TOOLTIP"] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + "Enable to control each OLED display pixel. Connect the OLED display on I2C port.";
Blockly.Msg["DISPLAY_OLED_CLEARSCREEN_TITLE"] = "[OLED display] clear screen on port %1";
Blockly.Msg["DISPLAY_OLED_CLEARSCREEN_TOOLTIP"] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + "Enable to clear the entire grove oled screen. Connect the OLED display on I2C port.";
Blockly.Msg["DISPLAY_OLED_DRAWICON_TITLE"] = "[OLED] draw icon %1 at position x %2 y %3 on port %4";
Blockly.Msg["DISPLAY_OLED_DRAWICON_TOOLTIP"] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + "Enable to draw an icon from Pico_ssd1306 library, at the position (x,y) on the OLED screen. Connect the OLED display on I2C port.";
// Display - Neopixel
Blockly.Msg["DISPLAY_NEOPIXEL_DEFINE_TITLE"] = "[Neopixel] define %1 LED on pin %2";
Blockly.Msg["DISPLAY_NEOPIXEL_DEFINE_TOOLTIP"] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Enable to define LED number of neopixel. This block have to be used in setup.";
Blockly.Msg["DISPLAY_NEOPIXEL_LEDCONTROL_TITLE"] = "[Neopixel] set LED %1 to R %2 G %3 B %4 on pin %5";
Blockly.Msg["DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP"] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Enable to control each LED color of neopixels as (R,G,B) from 0 to 255. Use P15 to set Maqueen neopixel.";
Blockly.Msg["DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE"] = "[Neopixel] set LED %1 to %2 on pin %3";
Blockly.Msg["DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP"] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Enable to control each LED color of neopixel. Use P15 to set Maqueen neopixel.";
Blockly.Msg["DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE"] = "[Neopixel] set all LED to colour R %1 G %2 B %3 on pin %4";
Blockly.Msg["DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP"] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Enable to control all LED of neopixel to the choosed colour value as (R,G,B) from 0 to 255. Use P15 to set Maqueen neopixel.";
Blockly.Msg["DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE"] = "[Neopixel] set all LED to colour %1 on pin %2";
Blockly.Msg["DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP"] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Enable to control all LED of neopixel to the choosed colour value. Use P15 to set Maqueen neopixel.";
Blockly.Msg["DISPLAY_NEOPIXEL_RAINBOW_TITLE"] = "[Neopixel] set a rainbow on pin %1";
Blockly.Msg["DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP"] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Enable to show a rainbow on neopixel module, set pin and the number of LED.";
// Display - LED modules
Blockly.Msg["DISPLAY_SETGROVELED_TITLE"] = "[LED] control LED to state %1 on pin %2";
Blockly.Msg["DISPLAY_SETGROVELED_TOOLTIP"] = IMG_MODULE_LED + Blockly.Tooltip.SEP + "Enable to switch on or switch off the LED socket kit Grove (0 or 1) on digitals pins P0 up through P20.";
Blockly.Msg["DISPLAY_SETLEDINTENSITY_TITLE"] = "[LED] set LED intensity to %1 on pin %2";
Blockly.Msg["DISPLAY_SETLEDINTENSITY_TOOLTIP"] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + "Enable to set the LED intensity from 0 to 255 on PWM pins.";
Blockly.Msg["DISPLAY_4DIGIT_SETNUMBER_TITLE"] = "[4-Digit module] show %1 %2 on pins CLK %3 DIO %4";
Blockly.Msg["DISPLAY_4DIGIT_SETNUMBER_TOOLTIP"] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + "Enable to show numbers or temperature on grove 4-digit display (TM1637) on digital pins from P0 to P20.";
Blockly.Msg["DISPLAY_4DIGIT_SETCLOCK_TITLE"] = "[4-Digit module] show clock on pins CLK %1 DIO %2";
Blockly.Msg["DISPLAY_4DIGIT_SETCLOCK_TOOLTIP"] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + "Enable to show clock on grove 4-digit display (TM1637) on digital pins from P0 to P20.";
Blockly.Msg["DISPLAY_4DIGIT_NUMBER"] = "number";
Blockly.Msg["DISPLAY_4DIGIT_TEMPERATURE"] = Blockly.Msg["SENSORS_TEMPERATURE"];
Blockly.Msg["DISPLAY_MY9221_SET_LEVEL_TITLE"] = "[LED Bar module] set level of %1 on pins DI %2 DCKI %3";
Blockly.Msg["DISPLAY_MY9221_SET_LEVEL_TOOLTIP"] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + "Enable to show level of input value on grove LED bar display (MY9221) on digital pins from P0 to P20.";
Blockly.Msg["DISPLAY_MY9221_REVERSE_TITLE"] = "[LED Bar Module] invert display %1 DI pins %2 DCKI %3";
Blockly.Msg["DISPLAY_MY9221_REVERSE_TOOLTIP"] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + "Allows to invert the 10 LEDs of the MY9221 module with the digital pins P0 to P20.";
// Display - Chainable LED
Blockly.Msg["DISPLAY_CHAINABLERGBLED_DEFINE_TITLE"] = "[Chainable LED] define %1 LED on pins CIN %2 DIN %3";
Blockly.Msg["DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP"] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + "Enable to define chainable RGB LED with number of LED on digital pins D0 up through D13.";
Blockly.Msg["DISPLAY_CHAINABLE_RGBLED_TITLE"] = "[Chainable LED] set LED %1 at R %2 G %3 B %4 on pins CIN %5 DIN %6";
Blockly.Msg["DISPLAY_CHAINABLE_RGBLED_TOOLTIP"] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + "Block controlling the color of the RGB LED, give a value between 0 and 255 for Red, Green and Blue.";
Blockly.Msg["DISPLAY_CHAINABLE_PALETTERGBLED_TITLE"] = "[Chainable LED] set LED %1 at %2 on pins CIN %3 DIN %4";
Blockly.Msg["DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP"] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + "Block controlling the color of the RGB LED, choose a colour in the given palette.";
Blockly.Msg["DISPLAY_CHAINABLE_ALLRGBLED_TITLE"] = "[Chainable LED] set all LED at R %1 G %2 B %3 on pins CIN %4 DIN %5";
Blockly.Msg["DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP"] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + "Block controlling the color of all the RGB LED, give a value between 0 and 255 for Red, Green and Blue.";
Blockly.Msg["DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE"] = "[Chainable LED] set all the LED at %1 on pins CIN %2 DIN %3";
Blockly.Msg["DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP"] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + "Block controlling the color of all the LED, choose a colour in the given palette.";
Blockly.Msg["DISPLAY_CHAINABLE_RESETALLRGBLED_TITLE"] = "[Chainable LED] Shut off all the LED on pins CIN %1 DIN %2";
Blockly.Msg["DISPLAY_CHAINABLE_RESETALLRGBLED_TOOLTIP"] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + "Block shutting off all the LED.";
// Input/Output - Microphone module
Blockly.Msg["IO_MICRO_LOUD"] = "loud";
Blockly.Msg["IO_MICRO_QUIET"] = "quiet";
Blockly.Msg["IO_MICRO_IS"] = "is";
Blockly.Msg["IO_MICRO_WAS"] = "was";
Blockly.Msg["IO_MICRO_ONSOUNDDETECTED_TITLE"] = "[Micro] if %1 sound %2 detected then";
Blockly.Msg["IO_MICRO_ONSOUNDDETECTED_TOOLTIP"] = "Execute instructions if sound condition (loud/quiet) is detected. 'was' option: Execute instructions if a (loud/quiet) sound occured since the last call to 'was_sound()'.";
Blockly.Msg["IO_MICRO_GETCURRENTSOUND_TITLE"] = "[Micro] sound condition";
Blockly.Msg["IO_MICRO_GETCURRENTSOUND_TOOLTIP"] = "Returns the sound condition (loud/quiet).";
Blockly.Msg["IO_MICRO_WASSOUNDDETECTED_TITLE"] = "[Micro] %1 sound was detected";
Blockly.Msg["IO_MICRO_WASSOUNDDETECTED_TOOLTIP"] = "Returns True if a (loud/quiet) sound occured since the last call to 'was_sound()'.";
Blockly.Msg["IO_MICRO_GETSOUNDLEVEL_TITLE"] = "[Micro] sound level";
Blockly.Msg["IO_MICRO_GETSOUNDLEVEL_TOOLTIP"] = "Enable du get sound level from 0 to 255.";
Blockly.Msg["IO_MICRO_GETHISTORYSOUND_TITLE"] = "[Micro] history of sounds";
Blockly.Msg["IO_MICRO_GETHISTORYSOUND_TOOLTIP"] = "Returns history of sounds since last call to 'get_sounds()'.";
Blockly.Msg["IO_MICRO_SETSOUNDTHRESHOLD_TITLE"] = "[Micro] set %1 sound threshold to %2";
Blockly.Msg["IO_MICRO_SETSOUNDTHRESHOLD_TOOLTIP"] = "Enable to set sound level threshold loud/quiet from 0 to 255.";
Blockly.Msg["IO_MICRO_SOUNDCONDITION_TITLE"] = "[Micro] %1";
Blockly.Msg["IO_MICRO_SOUNDCONDITION_TOOLTIP"] = "Enable to use (LOUD/QUIET) constants from microphone module in 'Logic' category.";
// Input/Output - External modules
Blockly.Msg["IO_GROVEKEYPAD_GETNUMBER_TITLE"] = "[Numeric Touch Keypad] get number on pins RX %1 TX %2";
Blockly.Msg["IO_GROVEKEYPAD_GETNUMBER_TOOLTIP"] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + "Enable to get touched number from keypad grove module on pins RX & TX. When you connect device, make sure you “cross” the wires. Raspberry Pi Pico TX pin needs to be connected with device's RX pin, and the RX pin with the device's TX pin.";
Blockly.Msg["IO_GROVEJOYSTICK_GETAXIS_TITLE"] = "[Joystick Module] joystick axis %1 value on pins A0 %2 A1 %3";
Blockly.Msg["IO_GROVEJOYSTICK_GETAXIS_TOOLTIP"] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + "Returns grove joystick axis value (from 0 to 1023) on analog pins P0 through P4, or P10.";
Blockly.Msg["IO_GROVECOLOREDBUTTON_GET_TITLE"] = "[Colored Button Module] state on pin SIG2 %1";
Blockly.Msg["IO_GROVECOLOREDBUTTON_GET_TOOLTIP"] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + "Returns grove colored button state (0 or 1) on digital pins P0 up through P20.";
Blockly.Msg["IO_GROVECOLOREDBUTTON_SETLED_TITLE"] = "[Colored Button Module] control LED to state %1 on pin SIG1 %2";
Blockly.Msg["IO_GROVECOLOREDBUTTON_SETLED_TOOLTIP"] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + "Enable to switch on or switch off the LED Button Grove (0 or 1) on digitals pins P0 up through P20.";
Blockly.Msg["IO_GETGROVEROTARYANGLE_TITLE"] = "[Rotary Angle Module] angle on pin %1";
Blockly.Msg["IO_GETGROVEROTARYANGLE_TOOLTIP"] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + "Returns grove rotary angle position (from 0 to 1023) on analog pins P0 through P4, or P10.";
Blockly.Msg["IO_GETGROVESLIDEPOTENTIOMETER_TITLE"] = "[Slide Potentiometer] position value on pin %1";
Blockly.Msg["IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP"] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + "Returns grove slide potentiometer position value (from 0 to 1023) on analog pins P0 through P4, or P10.";
Blockly.Msg["IO_GETGROVETACTILE_TITLE"] = "[Touch Sensor] touch state on pin %1 ";
Blockly.Msg["IO_GETGROVETACTILE_TOOLTIP"] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + "Returns grove touch sensor state (0 or 1) on digital pins P0 up through P20.";
Blockly.Msg["IO_GETGROVEBUTTON_TITLE"] = "[Button Module] button state on pin %1 ";
Blockly.Msg["IO_GETGROVEBUTTON_TOOLTIP"] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + "Returns grove button state (0 or 1) on digital pins P0 up through P20.";
Blockly.Msg["IO_GETGROVESWITCH_TITLE"] = "[Switch Module] switch state on pin %1 ";
Blockly.Msg["IO_GETGROVESWITCH_TOOLTIP"] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + "Returns grove switch state (0 or 1) on digital pins P0 up through P20.";
// Input/Output - Pins
Blockly.Msg["IO_DIGITAL_SIGNAL_TITLE"] = "%1";
Blockly.Msg["IO_DIGITAL_SIGNAL_HIGH"] = "HIGH (1)";
Blockly.Msg["IO_DIGITAL_SIGNAL_LOW"] = "LOW (0)";
Blockly.Msg["IO_DIGITAL_SIGNAL_TOOLTIP"] = "Returns boolean value (1 if HIGH or 0 if LOW).";
Blockly.Msg["IO_READDIGITALPIN_TITLE"] = "read digital pin %1";
Blockly.Msg["IO_READDIGITALPIN_TOOLTIP"] = "Enable to read the digital value of pins (0 or 1).";
Blockly.Msg["IO_WRITEDIGITALPIN_TITLE"] = "write on digital pin %1 state %2";
Blockly.Msg["IO_WRITEDIGITALPIN_TOOLTIP"] = "Enable to write the value (0 or 1) on digital pin.";
Blockly.Msg["IO_READANALOGPIN_TITLE"] = "read analog pin %1";
Blockly.Msg["IO_READANALOGPIN_TOOLTIP"] = "Enable to read the analog value of pins (0-1023).";
Blockly.Msg["IO_WRITEANALOGPIN_TITLE"] = "write on analog pin %1 value %2";
Blockly.Msg["IO_WRITEANALOGPIN_TOOLTIP"] = "Enable to write on analog pin the value (0-1023). This function does not really write analog value, it writes PWM signal. For example, writing 511 has 50% duty cycle, the average voltage is 1,65V.";
Blockly.Msg["IO_SETPWM_TITLE"] = "apply a signal of period %1 %2 on pin %3";
Blockly.Msg["IO_SETPWM_TOOLTIP"] = "Enable to apply a PWM signal on a pin";
Blockly.Msg["IO_WRITEPWMPIN_TITLE"] = "write value %1 on PWM pin %2";
Blockly.Msg["IO_WRITEPWMPIN_TOOLTIP"] = "Enable to apply PWM signal with fixed 10kHz-frequency. You can change value from 0 to 1023. 512 will be 50% of duty cycle, as around 1.66V.";
Blockly.Msg["IO_READPULSEIN_TITLE"] = "read pulse in (μs) of state %1 on pin %2";
Blockly.Msg["IO_READPULSEIN_TOOLTIP"] = "Returns the duration of pulse in. Choice state (HIGH or LOW)";
// Input/Output - Time
Blockly.Msg["IO_WAIT_TITLE"] = "wait %1 %2";
Blockly.Msg["IO_WAIT_TOOLTIP"] = "Stop the code execution (duration in seconds or milliseconds).";
Blockly.Msg["IO_WAIT_SECOND"] = "second.s";
Blockly.Msg["IO_WAIT_MILLISECOND"] = "millisecond.s";
Blockly.Msg["IO_WAIT_MICROSECOND"] = "microsecond.s";
Blockly.Msg["IO_WAIT_UNTIL_TITLE"] = "wait until %1";
Blockly.Msg["IO_WAIT_UNTIL_TOOLTIP"] = "Stop the code execution until the satisfied condition.";
Blockly.Msg["IO_INITCHRONOMETER_TITLE"] = "Initialize the chronometer";
Blockly.Msg["IO_INITCHRONOMETER_TOOLTIP"] = "Allows you to initialize the chronometer (in seconds).";
Blockly.Msg["IO_GETCHRONOMETER_TITLE"] = "get chronometer in %1";
Blockly.Msg["IO_GETCHRONOMETER_TOOLTIP"] = "Returns the chronometer value from the initialization in seconds or milliseconds.";
//Communication - Internal Bluetooth
Blockly.Msg["COMMUNICATION_START_BT_TITLE"] = "[Pico Bluetooth] initialize Bluetooth %1";
Blockly.Msg["COMMUNICATION_START_BT_TOOLTIP"] = "Initialize Bluetooth service on the Pico with given name.";
Blockly.Msg["COMMUNICATION_SEND_BT_TITLE"] = "[Pico Bluetooth] send data %1";
Blockly.Msg["COMMUNICATION_SEND_BT_TOOLTIP"] = "Send data via the Pico's Bluetooth service.";
Blockly.Msg["COMMUNICATION_BLE_READ_DATA_TITLE"] = "[Pico Bluetooth] on data reception in %1 then ";
Blockly.Msg["COMMUNICATION_BLE_READ_DATA_TOOLTIP"] = "Executes instructions on data reception via Bluetooth (BLE).";
// Communication - Serial connection
Blockly.Msg["COMMUNICATION_SERIAL_WRITE_TITLE"] = "write on serial port %1";
Blockly.Msg["COMMUNICATION_SERIAL_WRITE_TOOLTIP"] = "Write a string on serial port.";
Blockly.Msg["COMMUNICATION_SERIAL_WRITE_WITH"] = "with";
Blockly.Msg["COMMUNICATION_SERIAL_WRITE_NEWLINES"] = "newline(s)";
Blockly.Msg["COMMUNICATION_WRITEGRAPH_TITLE"] = "write graph";
Blockly.Msg["COMMUNICATION_WRITEGRAPH_TOOLTIP"] = "This block makes it possible to write (digital) data that will be visible in the plotter. It can be used with one or more blocks in \"Name\" and \"Data\" format. Click on icon 'Graphic mode' to display graphics.";
Blockly.Msg["COMMUNICATION_DATA"] = "Data";
Blockly.Msg["COMMUNICATION_PRINT_DATAS_TITLE"] = "Name %1 Data %2";
Blockly.Msg["COMMUNICATION_PRINT_DATAS_TOOLTIP"] = "This block is to be used in the \"Write in graphic\" block. It must contain the name of the (text) value to display and the value in question.";
Blockly.Msg["COMMUNICATION_COMPUTER_PLAYNOTE_TITLE"] = "play music %1 in the serial port";
Blockly.Msg["COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP"] = "Play selected note until execution of \"Stop music\" block.";
Blockly.Msg["COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE"] = "play frequency %1 (Hz) on the computer";
Blockly.Msg["COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP"] = "This block allows to play a given frequency on the computer";
Blockly.Msg["COMMUNICATION_COMPUTER_STOPMUSIC_TITLE"] = "stop music of serial port";
Blockly.Msg["COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP"] = "Stop the current note of serial port.";
Blockly.Msg["COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE"] = "on serial data received in %1 then";
Blockly.Msg["COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP"] = "Allows you to execute instructions if data is received by serial port in the 'serialData' variable.";
// Comunicación - Radio
Blockly.Msg["COMMUNICATION_RADIO_SENDSTRING_TITLE"] = "[Radio] send string %1";
Blockly.Msg["COMMUNICATION_RADIO_SENDSTRING_TOOLTIP"] = "Enable to send string by Raspberry Pi Pico radio module";
Blockly.Msg["COMMUNICATION_RADIO_SEND_TITLE"] = "[Radio] send number or list %1";
Blockly.Msg["COMMUNICATION_RADIO_SEND_TOOLTIP"] = "Enable to send number or list by radio module";
Blockly.Msg["COMMUNICATION_RADIO_SENDVALUE_TITLE"] = "[Radio] send value %1 as %2";
Blockly.Msg["COMMUNICATION_RADIO_SENDVALUE_TOOLTIP"] = "Enable to send data with 'name' and its value by radio module";
Blockly.Msg["COMMUNICATION_RADIO_ONSTRINGRECEIVED_TITLE"] = "[Radio] on data received in %1 then";
Blockly.Msg["COMMUNICATION_RADIO_ONSTRINGRECEIVED_TOOLTIP"] = "Allows you to execute instructions on the string received by the radio in the 'stringData' variable";
Blockly.Msg["COMMUNICATION_RADIO_ONNUMBERRECEIVED_TITLE"] = "[Radio] on data received in %1 then";
Blockly.Msg["COMMUNICATION_RADIO_ONNUMBERRECEIVED_TOOLTIP"] = "Allows you to execute instructions on the number received by the radio in the 'numberData' variable";
Blockly.Msg["COMMUNICATION_RADIO_ONVALUERECEIVED_TITLE"] = "[Radio] on data received in %1 %2 then";
Blockly.Msg["COMMUNICATION_RADIO_ONVALUERECEIVED_TOOLTIP"] = "Allows you to execute instructions on the name as a string and the value as a number received by the radio in the 'name' and 'value' variables";
Blockly.Msg["COMMUNICATION_RADIO_CONFIG_TITLE"] = "[Radio] set Channel %1 Power %2 Data size %3 Group %4";
Blockly.Msg["COMMUNICATION_RADIO_CONFIG_TOOLTIP"] = "Allows you to configure the frequency channel (from 0 to 83), the data size (bytes), the transmission power (from 0 to 7) and the group (from 0 to 255)";
// Communication - Data logging
Blockly.Msg["COMMUNICATION_OPENLOG_WRITE_TITLE"] = "[Openlog] write in the SD card %1 board %2 on pins RXI %3 TXO %4 %5 Datas %6";
Blockly.Msg["COMMUNICATION_OPENLOG_WRITE_TOOLTIP"] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + "Block enables writing data in the SD card of Openlog module. For the openlog, the baudrate has to be defined at the half of Raspberry Pi Pico baudrate. Example: Raspberry Pi Pico v1 (9600 in config.txt file), the baudrate is 4800 in function uart.init().";
// Communication - Wireless
Blockly.Msg["COMMUNICATION_BLUETOOTH_SENDDATA_TITLE"] = "[Bluetooth] send on pins RX %1 TX %2 message %3";
Blockly.Msg["COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP"] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + "Enable to send any data by Bluetooth HC05 module on pins RX/TX.";
Blockly.Msg["COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE"] = "[Bluetooth] on message received RX %1 TX %2 in %3 then";
Blockly.Msg["COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP"] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + "Allows you to execute instructions on data received by Bluetooth HC05 module in the 'bluetoothData' variable on pins TX/RX.";
Blockly.Msg["COMMUNICATION_HM10_BLUETOOTH_SENDDATA_TITLE"] = "[HM10 BT] send on pins RX %1 TX %2 message %3";
Blockly.Msg["COMMUNICATION_HM10_BLUETOOTH_SENDDATA_TOOLTIP"] = IMG_MODULE_HM10_BT + Blockly.Tooltip.SEP + "Enable to send any data by Bluetooth HM10 module on pins RX/TX.";
Blockly.Msg["COMMUNICATION_HM10_BLUETOOTH_ONDATARECEIVED_TITLE"] = "[HM10 BT] on message received RX %1 TX %2 in %3 then";
Blockly.Msg["COMMUNICATION_HM10_BLUETOOTH_ONDATARECEIVED_TOOLTIP"] = IMG_MODULE_HM10_BT + Blockly.Tooltip.SEP + "Allows you to execute instructions on data received by Bluetooth HM10 module in the 'HM10Data' variable on pins TX/RX. As default, the module name is MLT-BT05.";
// Communication - Tracking modules
Blockly.Msg["COMMUNICATION_GPS_INFO_TYPE"] = "frame type";
Blockly.Msg["COMMUNICATION_GPS_INFO_CLOCK"] = "clock (h, m, s)";
Blockly.Msg["COMMUNICATION_GPS_INFO_LATITUDE"] = "latitude (°)";
Blockly.Msg["COMMUNICATION_GPS_INFO_LONGITUDE"] = "longitude (°)";
Blockly.Msg["COMMUNICATION_GPS_INFO_SATELLITE"] = "number of satellites used";
Blockly.Msg["COMMUNICATION_GPS_INFO_ALTITUDE"] = "altitude (m)";
Blockly.Msg["COMMUNICATION_GPS_INFO_ALL_FRAME"] = "all frame";
Blockly.Msg["COMMUNICATION_GPS_GET_NMEA_TITLE"] = "[GPS] NMEA frames on pins RX %1 TX %2";
Blockly.Msg["COMMUNICATION_GPS_GET_NMEA_TOOLTIP"] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + "Returns the list of NMEA frames read with the Grove SIM28 or Air530 GPS module on the RX/TX pins. The wires do not need to be reversed between the module pins and those indicated in the block. The inversion is done automatically in the python code.\nWarning: If you use the console to display GPS data, connect your card to the interface before sending the program by clicking on the button [>_ REPL]. Then transfer your program using the button [Download .hex].";
Blockly.Msg["COMMUNICATION_GPS_GGA_GETINFORMATIONS_TITLE"] = "[GPS] get %3 on RX %1 TX %2 pins";
Blockly.Msg["COMMUNICATION_GPS_GGA_GETINFORMATIONS_TOOLTIP"] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + "Returns the data selected among (frame type, clock, latitude, longitude, altitude) analyzed from the NMEA frame (GNGGA or GPGGA) read with the Grove SIM28 or Air530 GPS module on the RX/TX pins. The wires do not do not need to be reversed between the pins of the module and those indicated in the block. The reversal is done automatically in the python code.\nWarning: If you use the console to display the GPS data, connect your card to the interface before sending the program by clicking on the [>_ REPL] button. Then, transfer your program using the button [Download .hex].";
// 05/22 The 2 following blocks removed from toolbox. We keep the block cause of user projects.
Blockly.Msg["COMMUNICATION_GPS_ONDATARECEIVED_TITLE"] = "[GPS] on data received on pins TX %1 RX %2 in %3 then";
Blockly.Msg["COMMUNICATION_GPS_ONDATARECEIVED_TOOLTIP"] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + "Allows you to execute instructions on data received by GPS grove module in the 'gpsData' variable on pin TX/RX.";
Blockly.Msg["COMMUNICATION_GPS_GETINFORMATIONS_TITLE"] = "[GPS] get %1 with datas %2";
Blockly.Msg["COMMUNICATION_GPS_GETINFORMATIONS_TOOLTIP"] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + "Returns analyzed datas from gps grove module choosen in ('clock','latitude,'longitude')";
// end of the 2 blocks
Blockly.Msg["COMMUNICATION_RTC_MODULE_PCF85063TP"] = "High Precision (0x51)";
Blockly.Msg["COMMUNICATION_RTC_MODULE_DS1307"] = "v1.2 (0x68)";
Blockly.Msg["COMMUNICATION_GROVERTC_SETDATE_TITLE"] = "[Clock RTC %1] initialize at %2 date %3";
Blockly.Msg["COMMUNICATION_GROVERTC_SETDATE_TOOLTIP"] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + "Allows you to initialize the Grove High Precision RTC clock module (PCF85063TP) or RTC v1.2 (DS1307) so that you can read the exact date and time using the 'Read clock module' block. Place in the 'on start' block. Connect module on I2C port. Warning: To work, the DS1307 module must have a small flat battery.";
Blockly.Msg["DAY_MONDAY"] = "monday";
Blockly.Msg["DAY_TUESDAY"] = "tuesday";
Blockly.Msg["DAY_WEDNESDAY"] = "wednesday";
Blockly.Msg["DAY_THURSDAY"] = "thursday";
Blockly.Msg["DAY_FRIDAY"] = "friday";
Blockly.Msg["DAY_SATURDAY"] = "saturday";
Blockly.Msg["DAY_SUNDAY"] = "sunday";
Blockly.Msg["COMMUNICATION_GROVERTC_SETHOUR_TITLE"] = "[Clock RTC %1] initialize at hour %2 minute %3 second %4";
Blockly.Msg["COMMUNICATION_GROVERTC_SETHOUR_TOOLTIP"] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + "Allows you to initialize the Grove High Precision RTC clock module (PCF85063TP) or RTC v1.2 (DS1307) so that you can read the exact date and time using the 'Read clock module' block. Place in the 'on start' block. Connect the module on I2C port. Warning: To work, the DS1307 module must have a small flat battery.";
Blockly.Msg["COMMUNICATION_GROVERTC_READTIME_TITLE"] = "[Clock RTC %1] read %2";
Blockly.Msg["COMMUNICATION_GROVERTC_READTIME_TOOLTIP"] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + "Read the date and time (choose from the drop-down menu) from Grove High Precision RTC clock module (PCF85063TP) or RTC v1.2 (DS1307). To obtain a correct result, first use the two blocks 'Initialize the clock module'. Connect module on I2C port. Warning: To work, the DS1307 module must have a small flat battery.";
Blockly.Msg["CLOCK_ALL_DATA"] = "time";
Blockly.Msg["CLOCK_YEAR"] = "year";
Blockly.Msg["CLOCK_MONTH"] = "month";
Blockly.Msg["CLOCK_MONTH_DAY"] = "day of month";
Blockly.Msg["CLOCK_WEEK_DAY"] = "day of week";
Blockly.Msg["CLOCK_HOUR"] = "hour";
Blockly.Msg["CLOCK_MINUTE"] = "minute";
Blockly.Msg["CLOCK_SECOND"] = "second";
// Communication - UART
Blockly.Msg["COMMUNICATION_SERIAL_INIT_TITLE"] = "[uart] redirect serial to RX %2 TX %3 baudrate %1";
Blockly.Msg["COMMUNICATION_SERIAL_INIT_TOOLTIP"] = "Enable to redirect serial connection with RX & TX. When you connect device, make sure you “cross” the wires. Raspberry Pi Pico TX pin needs to be connected with device's RX pin, and the RX pin with the device's TX pin.";
Blockly.Msg["COMMUNICATION_SERIAL_REDIRECTTOUSB_TITLE"] = "[uart] redirect serial to USB port";
Blockly.Msg["COMMUNICATION_SERIAL_REDIRECTTOUSB_TOOLTIP"] = "Enable to redirect serial connection to USB. It is used if you connect some UART devices in same time.";
Blockly.Msg["COMMUNICATION_UART_WRITE_TITLE"] = "[uart] write data %1";
Blockly.Msg["COMMUNICATION_UART_WRITE_TOOLTIP"] = "Write data on uart port.";
Blockly.Msg["COMMUNICATION_UART_READ_TITLE"] = "[uart] read data";
Blockly.Msg["COMMUNICATION_UART_READ_TOOLTIP"] = "read data from uart port.";
Blockly.Msg["COMMUNICATION_UART_DATA_AVAILABLE_TITLE"] = "[uart] Available data"
Blockly.Msg["COMMUNICATION_UART_DATA_AVAILABLE_TOOLTIP"] = "Returns a boolen (1 if there's data to read 0 else).";
// Sensors - common msg
Blockly.Msg["SENSORS_TEMPERATURE"] = "temperature";
Blockly.Msg["SENSORS_TEMPERATURE_IN"] = "in";
Blockly.Msg["SENSORS_HUMIDITY"] = "humidity (%)";
Blockly.Msg["SENSORS_PRESSURE"] = "pressure (Pa)";
Blockly.Msg["SENSORS_ALTITUDE"] = "altitude (m)";
// Sensors - Gas
Blockly.Msg["SENSORS_SGP30_READDATA_TITLE"] = "[SGP30 Sensor] gas %1 on port %2";
Blockly.Msg["SENSORS_SGP30_READDATA_TOOLTIP"] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + "Returns the amount of CO2 (in ppm) or TVOC (in ppb) in the air from sgp30 sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_SGP30_CO2"] = "carbon dioxide (CO2) (ppm)";
Blockly.Msg["SENSORS_SGP30_TVOC"] = "volatile organic compounds (TVOC) (ppb)";
Blockly.Msg["SENSORS_MULTICHANNEL_GETGAS_TITLE"] = "[Multichannel Gas Sensor] gas %1 (ppm) on port %2";
Blockly.Msg["SENSORS_MULTICHANNEL_GETGAS_TOOLTIP"] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + "Returns the amount of choosen gas in the air (in ppm) from grove multichannel gas sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_MULTICHANNELV2_GETGAS_TITLE"] = "[Multichannel Gas Sensor v2] gas %1 (V)";
Blockly.Msg["SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP"] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + "Returns the amount of choosen gas in the air (in V) from grove multichannel gas V2 sensor. Connect sensor on I2C port.";
Blockly.Msg["GAS_CO"] = "carbon monoxide (CO)";
Blockly.Msg["GAS_NO2"] = "nitrogen dioxide (NO2)";
Blockly.Msg["GAS_C2H5OH"] = "ethanol (C2H5OH)";
Blockly.Msg["GAS_H2"] = "dihydrogen (H2)";
Blockly.Msg["GAS_NH3"] = "ammonia (NH3)";
Blockly.Msg["GAS_CH4"] = "methane (CH4)";
Blockly.Msg["GAS_C3H8"] = "propane (C3H8)";
Blockly.Msg["GAS_C4H10"] = "iso-propane (C4H10)";
Blockly.Msg["GAS_VOC"] = "volatile organic compounds (VOC)";
Blockly.Msg["SENSORS_O2_GAS_READDATA_TITLE"] = "[Oxygen Gas Sensor] O2 (%) on pin %1";
Blockly.Msg["SENSORS_O2_GAS_READDATA_TOOLTIP"] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + "Returns O2 concentration (in %) from the grove O2 sensor on pins P0 through P4, or P10.";
Blockly.Msg["SENSORS_SCD30_READDATA_TITLE"] = "[SCD30 Sensor] %1 on port %2";
Blockly.Msg["SENSORS_SCD30_READDATA_TOOLTIP"] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + "Returns CO2 concentration (in ppm), humidity (in %) or temperature in Celsius (°C), Fahrenheit (°F) or Kelvin (K) from the grove SCD30 sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_SCD30_CO2"] = "carbon dioxide (CO2) (ppm)";
Blockly.Msg["SENSORS_SCD30_TEMP"] = Blockly.Msg["SENSORS_TEMPERATURE"];
Blockly.Msg["SENSORS_SCD30_HUM"] = Blockly.Msg["SENSORS_HUMIDITY"];
Blockly.Msg["SENSORS_SCD30_FORCED_CALIBRATION_TITLE"] = "[Capteur SCD30] force recalibration to %1 (ppm) on port %2";
Blockly.Msg["SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP"] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + "Force the calibration of the SCD30 sensor to the given value (in ppm). Go outside (where the concentration is around approximately 420 ppm, i.e. clean air), reset the board, then wait 2 minutes";
Blockly.Msg["SENSORS_AIR_QUALITY_GETVALUE_TITLE"] = "[Air Quality Sensor] value on pin %1";
Blockly.Msg["SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP"] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + "Returns value of air quality (from 0 to 1023) on pins P0 through P4, or P10.";
Blockly.Msg["SENSORS_HM330X_GETPARTICULE_TITLE"] = "[HM330X Sensor] concentration of particle matter %1 (µg/m3) on port %2";
Blockly.Msg["SENSORS_HM330X_GETPARTICULE_TOOLTIP"] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + "Detect the density of particles in the air with the HM330X sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_HM330X_ATM_PM1"] = "PM1.0";
Blockly.Msg["SENSORS_HM330X_ATM_PM2_5"] = "PM2.5";
Blockly.Msg["SENSORS_HM330X_ATM_PM10"] = "PM10.0";
// Sensors - Climate
Blockly.Msg["SENSORS_BMP280_READDATA_TITLE"] = "[BMP280 Sensor %1] %2 on port %3";
Blockly.Msg["SENSORS_BMP280_READDATA_TOOLTIP"] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + "Returns the ambient temperature in Celius degree (°C), Fahrenheit (°F) or Kelvin (K), pressure (in Pa). The altitude is initialized at 0 when program is flashed. It use Grove Barometer Sensor (address: 0x77, color: blue) or HW-611 280 sensor (address: 0x76, color: purple). Connect sensor on I2C port.";
Blockly.Msg["SENSORS_BMP280_TEMP"] = Blockly.Msg["SENSORS_TEMPERATURE"];
Blockly.Msg["SENSORS_BMP280_PRESS"] = Blockly.Msg["SENSORS_PRESSURE"];
Blockly.Msg["SENSORS_BMP280_ALT"] = Blockly.Msg["SENSORS_ALTITUDE"];
Blockly.Msg["SENSORS_GETGROVEHIGHTEMP_TITLE"] = "[H.T° sensor] temperature in %1 on pins A0 %2 A1 %3";
Blockly.Msg["SENSORS_GETGROVEHIGHTEMP_TOOLTIP"] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + "Returns thermocouple temperature dorm 50 to 600 °C with grove high temperature sensor. Connect sensor on analog pins.";
Blockly.Msg["SENSORS_GETGROVEMOISTURE_TITLE"] = "[Moisture Sensor] moisture on pin %1";
Blockly.Msg["SENSORS_GETGROVEMOISTURE_TOOLTIP"] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + "Returns moisture measurement (from 0 to 1023) from the grove moisture sensor on pins P0 through P4, or P10.";
Blockly.Msg["SENSORS_GETGROVETEMPERATURE_TITLE"] = "[Temperature Sensor] temperature in %1 on pin %2";
Blockly.Msg["SENSORS_GETGROVETEMPERATURE_TOOLTIP"] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + "Returns grove temperature sensor value in Celius degree (°C), Fahrenheit (°F) or Kelvin (K) on analog pins P0 through P4, or P10.";
Blockly.Msg["SENSORS_DHT11_READDATA_TITLE"] = "[DHT11 Sensor] %1 on pin %2";
Blockly.Msg["SENSORS_DHT11_READDATA_TOOLTIP"] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + "Returns temperature in Celius degree (°C), Fahrenheit (°F) or Kelvin (K), or air humidity (in %) from dht11 sensor on digital pins.";
Blockly.Msg["SENSORS_DHT22_READDATA_TITLE"] = "[DHT22 Sensor] %1 on pin %2";
Blockly.Msg["SENSORS_DHT22_READDATA_TOOLTIP"] = IMG_MODULE_DHT22 + Blockly.Tooltip.SEP + "Returns temperature in Celius degree (°C), Fahrenheit (°F) or Kelvin (K), or air humidity (in %) with good accuracy from dht22 sensor on digital pins.";
Blockly.Msg["SENSORS_TH02_READDATA_TITLE"] = "[TH02 Sensor] %1 on port %2";
Blockly.Msg["SENSORS_TH02_READDATA_TOOLTIP"] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + "Returns temperature in Celsius degree (°C), Fahrenheit (°F) or Kelvin (K), or air humidity (in %) from TH02 sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_SHT31_READDATA_TITLE"] = "[SHT31 Sensor] %1 on port %2";
Blockly.Msg["SENSORS_SHT31_READDATA_TOOLTIP"] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + "Returns temperature in Celsius degree (°C), Fahrenheit (°F) or Kelvin (K), or air humidity (in %) from SHT31 sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_MPX5700AP_GETPRESSURE_TITLE"] = "[MPX5700AP Sensor] pressure (kPa) on pin %1";
Blockly.Msg["SENSORS_MPX5700AP_GETPRESSURE_TOOLTIP"] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + "Enable to read pressure of grove sensor with TI-83 calculator.";
Blockly.Msg["SENSORS_MPX5700AP_CALIBRATE_TITLE"] = "[MPX5700AP Sensor] calibrate pressure sensor m %1 b %2";
Blockly.Msg["SENSORS_MPX5700AP_CALIBRATE_TOOLTIP"] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + "Enable to calibrate pressure sensor grove with TI-83 calculator.";
Blockly.Msg["SENSORS_GETGROVEWATER_TITLE"] = "[Water Sensor] water amount on pin %1";
Blockly.Msg["SENSORS_GETGROVEWATER_TOOLTIP"] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + "Returns water amount (from 0 to 255) from the grove water sensor on pins P0 through P4, or P10.";
Blockly.Msg["SENSORS_GETRAINGAUGE_TITLE"] = "[Rain Gauge sensor] state value on pin %1";
Blockly.Msg["SENSORS_GETRAINGAUGE_TOOLTIP"] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + "Returns rain gauge grove state (1 if it's raining or 0 else) on digital pins P0 up through P20.";
Blockly.Msg["SENSORS_GETANEMOMETER_TITLE"] = "[Anemometer] state value on pin %1";
Blockly.Msg["SENSORS_GETANEMOMETER_TOOLTIP"] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + "Returns grove anemometer state (twice state HIGH on each rotation) on digital pins P0 up through P20.";
// Sensors - Sound & Light
Blockly.Msg["SENSORS_GETGROVELIGHT_TITLE"] = "[Light Sensor] light level on pin %1";
Blockly.Msg["SENSORS_GETGROVELIGHT_TOOLTIP"] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + "Returns grove light sensor value (from 0 to 1023) on analog pins P0 through P4, or P10.";
Blockly.Msg["SENSORS_SI1145_GETLIGHT_TITLE"] = "[SI1145 Sensor] get light %1 on port %2";
Blockly.Msg["SENSORS_SI1145_GETLIGHT_TOOLTIP"] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + "Returns Ultraviolet light index, IR light (in lumen) or Visible light (in lumen) from si1145 sensor. It works with Grove Sunlight Sensor or GY1145 sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_SI1145_UV"] = "UV index";
Blockly.Msg["SENSORS_SI1145_VISIBLE"] = "visible (lumen)";
Blockly.Msg["SENSORS_SI1145_IR"] = "infrared (lumen)";
Blockly.Msg["SENSORS_GETUVINDEX_TITLE"] = "[Ultraviolet Sensor] UV index on pin %1";
Blockly.Msg["SENSORS_GETUVINDEX_TOOLTIP"] = IMG_MODULE_UV + Blockly.Tooltip.SEP + "Returns UV index, for waves between 240 nm and 380 nm, with UV grove sensor on analog pins A0 to A5.";
Blockly.Msg["SENSORS_GROVECOLOR_GETDATA_TITLE"] = "[Color Sensor] %1 on port %2";
Blockly.Msg["SENSORS_GROVECOLOR_GETDATA_TOOLTIP"] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + "Lets you read the level of one of the three primary colors with the Grove color sensor, returns a level between 0 and 255. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_GETGROVESOUND_TITLE"] = "[Sound Sensor] sound level (dB) on pin %1 ";
Blockly.Msg["SENSORS_GETGROVESOUND_TOOLTIP"] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + "Returns grove sound sensor value (from 0 to 1023 converted in dB) on analog pins P0 through P4, or P10.";
// Sensors - Distance & Motion
Blockly.Msg["SENSORS_GETGROVEULTRASONIC_TITLE"] = "[Ultrasonic Sensor %1] get %2";
Blockly.Msg["SENSORS_GETGROVEULTRASONIC_TOOLTIP"] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + "Returns distance measurement (in cm) or round-trip duration (in µs) from the ultrasonic ranger sensor on digital pins P0 up through P20. Warning, if it's a grove sensor, TRIG and ECHO are both connected to SIG.";
Blockly.Msg["SENSORS_ULTRASONIC_DISTANCE"] = "distance (cm)";
Blockly.Msg["SENSORS_ULTRASONIC_DURATION"] = "round-trip duration (µs)";
Blockly.Msg["SENSORS_ULTRASONIC_1PIN"] = "on pin";
Blockly.Msg["SENSORS_ULTRASONIC_2PINS"] = "on pins ";
Blockly.Msg["SENSORS_GETGESTURE_TITLE"] = "[Gesture Sensor] gesture type";
Blockly.Msg["SENSORS_GETGESTURE_TOOLTIP"] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + "Returns the gesture type ('right', 'left', 'up', 'down', 'forward', 'backward', 'clockwise', 'anticlockwise') from grove gesture sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_ONGESTUREDETECTED_TITLE"] = "[Gesture Sensor] on gesture %1 detected then";
Blockly.Msg["SENSORS_ONGESTUREDETECTED_TOOLTIP"] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + "Execute instructions if selected gesture id detected by the grove gesture sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_GESTURE_RIGHT"] = "right";
Blockly.Msg["SENSORS_GESTURE_LEFT"] = "left";
Blockly.Msg["SENSORS_GESTURE_UP"] = "up";
Blockly.Msg["SENSORS_GESTURE_DOWN"] = "down";
Blockly.Msg["SENSORS_GESTURE_FORWARD"] = "forward";
Blockly.Msg["SENSORS_GESTURE_BACKWARD"] = "backward";
Blockly.Msg["SENSORS_GESTURE_CLOCKWISE"] = "clockwise";
Blockly.Msg["SENSORS_GESTURE_ANTICLOCKWISE"] = "anticlockwise";
Blockly.Msg["SENSORS_GESTURE_WAVE"] = "wave";
Blockly.Msg["SENSORS_GETGROVELINEFINDER_TITLE"] = "[Line Finder Sensor] line finder state on pin %1";
Blockly.Msg["SENSORS_GETGROVELINEFINDER_TOOLTIP"] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + "Returns grove touch sensor state (0 or 1) on digital pins P0 up through P20.";
Blockly.Msg["SENSORS_GETGROVEMOTION_TITLE"] = "[PIR Motion Sensor] movement state value on pin %1";
Blockly.Msg["SENSORS_GETGROVEMOTION_TOOLTIP"] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + "Returns grove PIR Motion state (0 if there is movement or 1 else) on digital pins P0 up through P20.";
Blockly.Msg["SENSORS_GETPIEZOVIBRATION_TITLE"] = "[Piezo Vibration Sensor] state value on pin %1";
Blockly.Msg["SENSORS_GETPIEZOVIBRATION_TOOLTIP"] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + "Returns vibration state (0 or 1) from piezo vibration grove sensor on digital pins P0 up through P20.";
Blockly.Msg["SENSORS_GETGROVETILT_TITLE"] = "[Tilt Module] tilt state on pin %1";
Blockly.Msg["SENSORS_GETGROVETILT_TOOLTIP"] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + "Returns grove tilt state (0 or 1) on digital pins P0 up through P20.";
// Other sensors
Blockly.Msg["SENSORS_GETGROVEBUTTON_TITLE"] = "[Button Module] button %1 on pin %2";
Blockly.Msg["SENSORS_GETGROVEBUTTON_TOOLTIP"] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + "Returns numeric value of grove button (0/1 or 0V/3.3V) on digital pins P0 up through P20.";
Blockly.Msg["SENSORS_GETGROVEBUTTON_VOLTAGE"] = "voltage";
Blockly.Msg["SENSORS_GETGROVEBUTTON_STATE"] = "state";
Blockly.Msg["SENSORS_DS18B20_GETTEMPERATURE_TITLE"] = "[DS18B20 Sensor] temperature in %1 on pin %2";
Blockly.Msg["SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP"] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + "Returns the DS18B20 waterproof temperature sensor value in Celius degree (°C), Fahrenheit (°F) or Kelvin (K) on digital pins.";

// Actuators
Blockly.Msg["ACTUATORS_SERVO_SETANGLE_TITLE"] = "[Servomotor] set angle to %1 on pin %2";
Blockly.Msg["ACTUATORS_SERVO_SETANGLE_TOOLTIP"] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + "Enable to control servo angle (from 0 to 180) on digital pins. Warning, Pico has to be powered by external batterie in order to provide enough energy to servomotor.";
Blockly.Msg["ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE"] = "[Continuous Servomotor] set speed to %1 (%) direction %2 on pin %3";
Blockly.Msg["ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP"] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + "Enable to control continuous servo speed (from 0 to 100 %) on PWM pins.";
Blockly.Msg["ACTUATORS_MOTOR_SETPOWER_TITLE"] = "[Motor] set power to %1 on pin %2";
Blockly.Msg["ACTUATORS_MOTOR_SETPOWER_TOOLTIP"] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + "Enable to control DC motor power (from 0 to 1023) on digital pins. Warning, Pico has to be powered by external batterie in order to provide enough energy to DC motor.";
Blockly.Msg["ACTUATORS_GROVERELAY_CONTROL_TITLE"] = "[Relay module] control relay to state %1 on pin %2";
Blockly.Msg["ACTUATORS_GROVERELAY_CONTROL_TOOLTIP"] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + "Enable to control state grove relay module (0 or 1) on digital pins.";
Blockly.Msg["ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE"] = "[Vibration motor] control motor to state %1 on pin %2";
Blockly.Msg["ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP"] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + "Enable to control state of grove vibration motor (0 or 1) on digital pins.";

// Actuators - MOSFET
Blockly.Msg["ACTUATORS_MOSFET_SETSTATE_TITLE"] = "[MOSFET] control state to %1 on pin %2";
Blockly.Msg["ACTUATORS_MOSFET_SETSTATE_TOOLTIP"] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + "Allows you to control the state of the MOSFET transistor (0 or 1) on a PWM pin.";
Blockly.Msg["ACTUATORS_MOSFET_SETPERCENTVALUE_TITLE"] = "[MOSFET] control power to %1 (%) on pin %2";
Blockly.Msg["ACTUATORS_MOSFET_SETPERCENTVALUE_TOOLTIP"] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + "Allows you to control the output power of the MOSFET transistor (from 0 to 100%) on a PWM pin.";
Blockly.Msg["ACTUATORS_MOSFET_SETFREQUENCY_TITLE"] = "[MOSFET] control frequency to %1 (Hz) on pin %2";
Blockly.Msg["ACTUATORS_MOSFET_SETFREQUENCY_TOOLTIP"] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + "Allows you to control the cycle frequency (Hz) of the MOSFET transistor on a PWM pin.";
Blockly.Msg["ACTUATORS_MOSFET_PULL"] = "pull";
// Actuators - Music
Blockly.Msg["ACTUATORS_MUSIC_PLAYMUSIC_TITLE"] = "[Buzzer/Speaker] play music %1 on %2";
Blockly.Msg["ACTUATORS_MUSIC_PLAYMUSIC_TOOLTIP"] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + "Enable to play the choosen music on Grove buzzer module (or speaker) on digital pins.";
Blockly.Msg["ACTUATORS_MUSIC_PLAY_NOTES_TITLE"] = "[Buzzer/Speaker] play notes on";
Blockly.Msg["ACTUATORS_MUSIC_PLAY_NOTES_TOOLTIP"] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + "Enable to play notes on Grove buzzer module (or speaker) on digital pins.";
Blockly.Msg["ACTUATORS_MUSIC_NOTE_TITLE"] = "note %1 at octave %2 with duration %3";
Blockly.Msg["ACTUATORS_MUSIC_NOTE_TOOLTIP"] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + "Define a note with octave and duration.";
Blockly.Msg["ACTUATORS_MUSIC_PLAY_FREQUENCY_TITLE"] = "[Buzzer/Speaker] play frequency %1 during %2 (ms) on %3";
Blockly.Msg["ACTUATORS_MUSIC_PLAY_FREQUENCY_TOOLTIP"] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + "Enable to play integer frequency on Grove buzzer module (or speaker) on digital pins.";
Blockly.Msg["ACTUATORS_MUSIC_STOP_TITLE"] = "[Buzzer/Speaker] stop music on %1";
Blockly.Msg["ACTUATORS_MUSIC_STOP_TOOLTIP"] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + "Enable to stop music from Grove buzzer module (or speaker) on digital pins.";
// Notes
Blockly.Msg["NOTE_C"] = "C";
Blockly.Msg["NOTE_C_SHARP"] = "C#";
Blockly.Msg["NOTE_D"] = "D";
Blockly.Msg["NOTE_D_SHARP"] = "D#";
Blockly.Msg["NOTE_E"] = "E";
Blockly.Msg["NOTE_F"] = "F";
Blockly.Msg["NOTE_F_SHARP"] = "F#";
Blockly.Msg["NOTE_G"] = "G";
Blockly.Msg["NOTE_G_SHARP"] = "G#";
Blockly.Msg["NOTE_A"] = "A";
Blockly.Msg["NOTE_A_SHARP"] = "A#";
Blockly.Msg["NOTE_B"] = "B";
Blockly.Msg["MUSIC_SILENCE"] = "Silence";
// Process
Blockly.Msg['ON_START_CORE0_TITLE'] = '[core0] On sart';
Blockly.Msg['ON_START_CORE0_TOOLTIP'] = 'Starts the main execution queue on core0 of the Raspberry Pi Pico.';
Blockly.Msg['FOREVER_CORE0_TITLE'] = '[core0] Forever';
Blockly.Msg['PROCESS_FOREVER_CORE1_TITLE'] = '[core1] Forever';
Blockly.Msg['PROCESS_ON_START_CORE1_TITLE'] = '[core1] On start';
Blockly.Msg['PROCESS_ON_START_CORE1_TOOLTIP'] = 'Used to start a second execution queue on core1 of the Raspberry Pi Pico.';
Blockly.Msg['PROCESS_EXIT_CORE1_TITLE'] = '[core1] exit process';
Blockly.Msg['PROCESS_EXIT_CORE1_TOOLTIP'] = 'Used to exit core1 of the Raspberry Pi Pico.';
Blockly.Msg['PROCESS_GLOBAL_VAR_TITLE'] = 'make %1 a global variable';
Blockly.Msg['PROCESS_GLOBAL_VAR_TOOLTIP'] = 'Transforms a local variable into a global variable so that processes can communicate with each other.';

// Robot
Blockly.Msg["ROBOTS_KITRO_MOVE_TITLE"] = "[Kitronik] control robot %1 speed %2 %";
Blockly.Msg["ROBOTS_KITRO_MOVE_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Allows controlling the direction of the Kitronik robot";
Blockly.Msg["ROBOTS_KITRO_MOVE_FORWARD"] = "move forward";
Blockly.Msg["ROBOTS_KITRO_MOVE_BACKWARD"] = "move backward";
Blockly.Msg["ROBOTS_KITRO_ROTATE_TITLE"] = "[Kitronik] rotate robot towards %1 speed %2 %";
Blockly.Msg["ROBOTS_KITRO_ROTATE_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Allows the Kitronik robot to rotate right or left at a speed between 70% and 100%";
Blockly.Msg["ROBOTS_KITRO_ROTATE_RIGHT"] = "right";
Blockly.Msg["ROBOTS_KITRO_ROTATE_LEFT"] = "left";
Blockly.Msg["ROBOTS_KITRO_STOP_TITLE"] = "[Kitronik] stop the robot";
Blockly.Msg["ROBOTS_KITRO_STOP_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Stops the Kitronik robot";
Blockly.Msg["ROBOTS_KITRO_CONTROL_MOTOR_TITLE"] = "[Kitronik] control the motor %1 direction %2 speed %3 %";
Blockly.Msg["ROBOTS_KITRO_CONTROL_MOTOR_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Controls the right or left motor of the Kitronik robot in the direction (↻: FORWARD, ↺: BACKWARD) and desired speed (from 70% to 100%)";
Blockly.Msg["ROBOTS_KITRO_MOTOR_RIGHT"] = "right";
Blockly.Msg["ROBOTS_KITRO_MOTOR_LEFT"] = "left";
Blockly.Msg["ROBOTS_KITRO_SETANGLE_TITLE"] = "[Kitronik] rotate the robot by %1 °";
Blockly.Msg["ROBOTS_KITRO_SETANGLE_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Controls the direction of the robot (in degrees)";
Blockly.Msg["ROBOTS_KITRO_MOVE_ONE_SQUARE_FORWARD_TITLE"] = "[Kitronik] move one square forward";
Blockly.Msg["ROBOTS_KITRO_MOVE_ONE_SQUARE_FORWARD_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Moves the Kitronik robot forward by one square";
Blockly.Msg["ROBOTS_KITRO_MOVE_ONE_SQUARE_BACKWARD_TITLE"] = "[Kitronik] move one square backward";
Blockly.Msg["ROBOTS_KITRO_MOVE_ONE_SQUARE_BACKWARD_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Moves the Kitronik robot backward by one square";
Blockly.Msg["ROBOTS_KITRO_ROTATE_LEFT_TITLE"] = "[Kitronik] rotate left";
Blockly.Msg["ROBOTS_KITRO_ROTATE_LEFT_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Rotates the Kitronik robot 90° to the left";
Blockly.Msg["ROBOTS_KITRO_ROTATE_RIGHT_TITLE"] = "[Kitronik] rotate right";
Blockly.Msg["ROBOTS_KITRO_ROTATE_RIGHT_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Rotates the Kitronik robot 90° to the right";
Blockly.Msg["ROBOTS_KITRO_ULTRASONICRANGER_TITLE"] = "[Kitronik] %1 on sensor %2";
Blockly.Msg["ROBOTS_KITRO_ULTRASONICRANGER_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Returns the distance (in cm) or duration (in μs) of the wave's round trip between an obstacle and the Kitronik robot thanks to the ultrasonic sensor";
Blockly.Msg["ROBOTS_KITRO_ULTRASONIC_DISTANCE"] = "distance (cm)";
Blockly.Msg["ROBOTS_KITRO_ULTRASONIC_DURATION"] = "round trip duration (μs)";
Blockly.Msg["ROBOTS_KITRO_ULTRASONIC_SENSOR_FRONT"] = "front";
Blockly.Msg["ROBOTS_KITRO_ULTRASONIC_SENSOR_BACK"] = "back";
Blockly.Msg["ROBOTS_KITRO_READ_LINE_FINDER_TITLE"] = "[Kitronik] state of the line sensor %1";
Blockly.Msg["ROBOTS_KITRO_READ_LINE_FINDER_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Reads the state of the left or right line follower sensor of the Kitronik robot. The block returns 1 if the sensor is over the line";
Blockly.Msg["ROBOTS_KITRO_LINE_RIGHT"] = "right";
Blockly.Msg["ROBOTS_KITRO_LINE_LEFT"] = "left";
Blockly.Msg["ROBOTS_KITRO_LINE_CENTER"] = "center";
Blockly.Msg["ROBOTS_KITRO_CONTROL_LED_COLOR_TITLE"] = "[Kitronik] control RGB LED %1 %2";
Blockly.Msg["ROBOTS_KITRO_CONTROL_LED_COLOR_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Reads the state of the left or right line follower sensor of the Kitronik robot. The block returns 1 if the sensor is over the line";
Blockly.Msg["ROBOTS_KITRO_TOP_LEFT"] = "front left (0)";
Blockly.Msg["ROBOTS_KITRO_TOP_RIGHT"] = "front right (1)";
Blockly.Msg["ROBOTS_KITRO_BOT_RIGHT"] = "rear right (2)";
Blockly.Msg["ROBOTS_KITRO_BOT_LEFT"] = "rear left (3)";
Blockly.Msg["ROBOTS_KITRO_CONTROL_RGB_LED_TITLE"] = "[Kitronik] control RGB LED %1 R %2 G %3 B %4";
Blockly.Msg["ROBOTS_KITRO_CONTROL_RGB_LED_TOOLTIP"] = IMG_ROBOT_KITRONIK_PICO + Blockly.Tooltip.SEP + "Reads the state of the left or right line follower sensor of the Kitronik robot. The block returns 1 if the sensor is over the line";
// Camera - Wio lite AI
Blockly.Msg['WIO_GET_DATA_TITLE'] = '[Wio lite] retrieve all data on port %1';
Blockly.Msg['WIO_GET_CLASS_DATA_BY_ID_TITLE'] = '[Wio lite] probability of class no. %1 on port %2';
Blockly.Msg['WIO_GET_CLASS_MAX_ID_TITLE'] = '[Wio lite] ID of the detected class on port %1';
Blockly.Msg['WIO_GET_STATUS_TITLE'] = '[Wio lite] get %1 on port %2';