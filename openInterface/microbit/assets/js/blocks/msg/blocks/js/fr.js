/**
 * @fileoverview French messages for Micro:bit. (FR)
 */
'use strict';
// Display - Micro:bit 
Blockly.Msg['SHOW_LEDS_TITLE'] = 'afficher l\'image';
Blockly.Msg['SHOW_LEDS_TOOLTIP'] = 'Affiche l\'image personnalisé sur l\'écran de la carte micro:bit';
Blockly.Msg['SHOW_STRING_TITLE'] = 'faire défiler %1';
Blockly.Msg['SHOW_STRING_TOOLTIP'] = 'Fait défiler une chaine de caractère sur l\'écran de la carte micro:bit';
Blockly.Msg['DISPLAY_SHOW_STRING_DELAY'] = 'délais (ms)';
Blockly.Msg['SHOW_NUMBER_TITLE'] = 'afficher %1';
Blockly.Msg['SHOW_NUMBER_TOOLTIP'] = 'Affiche un à un les chiffres sur l\'écran de la carte micro:bit';
Blockly.Msg['SHOW_ICON_TITLE'] = 'afficher l\'icone %1';
Blockly.Msg['SHOW_ICON_TOOLTIP'] = 'Affiche l\'icone sélectionnée sur l\'écran de la carte micro:bit';
Blockly.Msg['SHOW_ICON_SIMPLE_TITLE'] = 'afficher l\'icone %1';
Blockly.Msg['SHOW_ICON_SIMPLE_TOOLTIP'] = 'Affiche l\'icone sélectionnée sur l\'écran de la carte micro:bit';
Blockly.Msg['SHOW_GAUGE_TITLE'] = 'afficher la jauge de %1 Maximum %2';
Blockly.Msg['SHOW_GAUGE_TOOLTIP'] = 'Affiche la gauge d\'une mesure d\'un capteur (ou d\'un nombre) sur l\'écran de la carte micro:bit en définissant la valeur maximale correspondant à la jauge remplie.';
Blockly.Msg['PLOT_BAR_GRAPH_TITLE'] = 'tracer le graphe de %1';
Blockly.Msg['PLOT_BAR_GRAPH_TOOLTIP'] = 'Affiche un graphique à barres verticales basé sur les valeurs "value" et "high". Si "high" est égal à 0, le graphique est ajusté automatiquement';
Blockly.Msg['PLOT_BAR_GRAPH_TO'] = 'à';
Blockly.Msg['SET_PIXEL_TITLE'] = 'contrôler la led x %1 y %2 état %3';
Blockly.Msg['SET_PIXEL_TOOLTIP'] = 'Permet de contrôler l\'état (ON/OFF) de chaque LED de l\'écran de la carte micro:bit.';
Blockly.Msg['GET_PIXEL_STATE_TITLE'] = 'état de la led x %1 y %2';
Blockly.Msg['GET_PIXEL_STATE_TOOLTIP'] = 'Permet de vérifier l\'état (ON/OFF) de chaque LED de l\'écran de la carte micro:bit.';
Blockly.Msg['TOGGLE_PIXEL_STATE_TITLE'] = 'inverser l\'état de la led x %1 y %2';
Blockly.Msg['TOGGLE_PIXEL_STATE_TOOLTIP'] = 'Permet d\'inverser l\'état (ON/OFF) de chaque LED de l\'écran de la carte micro:bit.';
Blockly.Msg['SET_LIGHT_PIXEL_TITLE'] = 'contrôler la led x %1 y %2 luminosité %3';
Blockly.Msg['SET_LIGHT_PIXEL_TOOLTIP'] = 'Permet de choisir la luminosité (de 0 à 9) d\'une LED de l\'écran de la carte micro:bit.';
Blockly.Msg['SET_BRIGHTNESS_TITLE'] = 'régler la luminosité %1';
Blockly.Msg['SET_BRIGHTNESS_TOOLTIP'] = 'Permet de choisir la luminosité (de 0 à 9) des LEDs de l\'écran de la carte micro:bit.';
Blockly.Msg['SHOW_CLOCK_TITLE'] = 'afficher l\'horloge %1';
Blockly.Msg['SHOW_CLOCK_TOOLTIP'] = 'Affiche l\'aiguille des heures d\'une horloge sur l\'écran de la carte micro:bit';
Blockly.Msg['SHOW_ARROW_TITLE'] = 'afficher la flèche %1';
Blockly.Msg['SHOW_ARROW_TOOLTIP'] = 'Permet d\'afficher les flèches de 8 directions (N,NE,E,SE,S...) sur l\'écran de la carte micro:bit.';
Blockly.Msg['CLEAR_TITLE'] = 'effacer l\'écran';
Blockly.Msg['CLEAR_TOOLTIP'] = 'Efface l\'écran de la carte micro:bit';
// Display - Screen
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD] afficher le texte %1 sur la ligne %2 position %3';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Affiche du texte sur l\'une des deux lignes de l\'écran LCD1602 grove. Brancher le module sur un port I2C';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD] nettoyer l\'écran';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Permet d\'effacer tous les caractères de l\'écran LCD. Brancher le module sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[Ecran OLED] afficher le texte %1 à la position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'écrire du texte sur un écran OLED grove avec 4x11 caractères. Brancher l\'afficheur sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TITLE'] = '[Ecran OLED] contrôler le pixel x %1 y %2 état %3';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de contrôler chaque pixel de l\'écran OLED 16x32 pixels. Brancher l\'afficheur sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[Ecran OLED] effacer l\'écran';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de nettoyer l\'écran OLED. Brancher le module sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[Ecran OLED] afficher l\'icône %1 position x %2 y %3 état %4';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'afficher une icône de la librairie Image de micro:bit, à la position (x,y) sur l\'écran grove OLED. Brancher l\'afficheur sur un port I2C.';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] contrôler la LED %1 sur la broche  %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Permet d\'activer ou désactiver la LED Grove (0 ou 1) sur les broches digitales P0 à P20.';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] régler la luminosité à %1 sur la broche %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 1023 sur les broches PWM.';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[Variable Color LED] régler la luminosité à %1 (%) sur la broche %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 100 % sur les broches PWM. A la premièe utilisation, les valeurs RGB sont fixées à 0. Utiliser un tournevis pour régler les couleurs R, G et B derrière le module.';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] définir %1 LED sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de définir le nombre de LED du neopixel. Ce bloc doit être utilisé dans le bloc \'Au démarrage\'.';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] contrôler la LED %1 à R %2 G %3 B %4 sur la broche %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED tel que (R,G,B) de 0 à 255 du module neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] contrôler la LED %1 à %2 sur la broche %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du module neopixel. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] contrôler toutes les LED à R %1 G %2 B %3 sur la broche %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie telle que (R,G,B) soit de 0 à 255.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] contrôler toutes les LED à %1 sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] Arc-en-ciel sur la broche %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB. Il est possible de modifier la broche et le nombre de LED du module neopixel.';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_LEDCONTROL_TITLE'] = '[ZIP Halo HD] contrôler la LED %1 à R %2 G %3 B %4';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_LEDCONTROL_TOOLTIP'] = 'Permet de contrôler la couleur de chaque LED telle que (R,G,B) de 0 à 255 du module Zip Halo LED de Kitronik.';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_SETPALETTECOLOR_TITLE'] = '[ZIP Halo HD] contrôler la LED %1 à %2';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_SETPALETTECOLOR_TOOLTIP'] = 'Permet de contrôler la couleur de chaque LED du module Zip Halo LED de Kitronik. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_SETALLLEDRGB_TITLE'] = '[ZIP Halo HD] contrôler toutes les LED à R %1 G %2 B %3';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_SETALLLEDRGB_TOOLTIP'] = 'Permet de contrôler toutes les LED du module Zip Halo LED de Kitronik à la couleur choisie telle que (R,G,B) soit de 0 à 255.';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_SETALLLEDCOLOR_TITLE'] = '[ZIP Halo HD] contrôler toutes les LED à %1';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_SETALLLEDCOLOR_TOOLTIP'] = 'Permet de contrôler toutes les LED du module Zip Halo LED de Kitronik à la couleur choisie. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_RAINBOW_TITLE'] = '[ZIP Halo HD] Arc-en-ciel';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_RAINBOW_TOOLTIP'] = 'Afficher le spectre des couleurs sur les LED RGB du module Zip Halo LED de Kitronik.';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[Afficheur 4-digit] afficher %1 %2 sur les broches CLK %3 DIO %4';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher un nombre, une température ou l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales P0 à P20.';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[Afficheur 4-digit] l\'horloge sur les broches CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales P0 à P20. Attention, l\'heure réelle est récupérée seulement la carte micro:bit reste allumée.';
Blockly.Msg['DISPLAY_4DIGIT_NUMBER'] = 'le nombre entier';
Blockly.Msg['DISPLAY_4DIGIT_TEMPERATURE'] = Blockly.Msg['SENSORS_TEMPERATURE'];
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[Module LED Bar] afficher le niveau de %1 sur les broches DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permet d\'afficher le niveau de la valeur en entrée sur le module LED Bar (MY9221) avec les broches digitales P0 à P20.';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TITLE'] = '[Module LED Bar] inverser l\'afficheur %1 les broches DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permet d\'inverser les 10 LED du module LED Bar (MY9221) avec les broches digitales P0 à P20.';
// display - Kitronic Traffic
Blockly.Msg['DISPLAY_TRAFFICLIGHT_SETLED_TITLE'] = '[Panneau de signalisation] contrôler la LED %1 à l\'état %2';
Blockly.Msg['DISPLAY_TRAFFICLIGHT_SETLED_TOOLTIP'] = IMG_MODULE_TRAFFIC_LIGHT + Blockly.Tooltip.SEP + 'Permet de contrôler le panneau de signalisation de la carte micro:bit.';
Blockly.Msg['DISPLAY_TRAFFICLIGHT_RED'] = 'rouge';
Blockly.Msg['DISPLAY_TRAFFICLIGHT_ORANGE'] = 'orange';
Blockly.Msg['DISPLAY_TRAFFICLIGHT_GREEN'] = 'verte';
Blockly.Msg['DISPLAY_LAMPBIT_SETLED_TITLE'] = "[LAMP:BIT] contrôler la LED à l'état %1";
Blockly.Msg['DISPLAY_LAMPBIT_SETLED_TOOLTIP'] = IMG_MODULE_LAMPBIT + Blockly.Tooltip.SEP + "Contrôle la LED du lampadaire";
//Display - RGB LED MATRIX
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_TITLE'] = '[Matrice de LED RGB] afficher %1 %2';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_TOOLTIP'] = IMG_MODULE_RGB_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Permet d\'afficher un dessin sur la matrice de LED RGB 8x8.';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_STOPDISPLAY_TITLE'] = '[Matrice de LED RGB] effacer la matrice';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_STOPDISPLAY_TOOLTIP'] = IMG_MODULE_RGB_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Éteint toutes les LEDs de la matrice';
Blockly.Msg['DISPLAY_LED_MATRIX_DURATION'] = 'pendant';
Blockly.Msg['DISPLAY_LED_MATRIX_DURATION_UNIT'] = 'ms';
//Display - LED MATRIX
Blockly.Msg['DISPLAY_LED_MATRIX_TITLE'] = '[Matrice de LED] afficher %1 %2';
Blockly.Msg['DISPLAY_LED_MATRIX_TOOLTIP'] = IMG_MODULE_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Permet d\'afficher un dessin sur la matrice de LED monochrome 8x8.';
Blockly.Msg['DISPLAY_LED_MATRIX_CLEAR_TITLE'] = '[Matrice de LED] effacer la matrice';
Blockly.Msg['DISPLAY_LED_MATRIX_CLEAR_TOOLTIP'] = IMG_MODULE_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Éteint toutes les LEDs de la matrice';
// Display - Morpion
Blockly.Msg['DISPLAY_MORPION_NEWGAME_TITLE'] = '[Ecran OLED] Morpion - nouvelle partie';
Blockly.Msg['DISPLAY_MORPION_NEWGAME_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de lancer une nouvelle partie de morpion sur un afficheur OLED. Brancher l\'afficheur sur un port I2C. Attention, le jeu du Morpion utilise toute la mémoire de la micro:bit, vous ne pouvez pas utiliser d\'autres modules pendant le jeu.';
Blockly.Msg['DISPLAY_MORPION_MOVECURSOR_TITLE'] = '[Ecran OLED] Morpion - déplacer le curseur';
Blockly.Msg['DISPLAY_MORPION_MOVECURSOR_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de déplacer le curseur dans la grille du morpion sur un afficheur OLED. Le curseur parcourt toute la grille case par case. Brancher l\'afficheur sur un port I2C. Attention, le jeu du Morpion utilise toute la mémoire de la micro:bit, vous ne pouvez pas utiliser d\'autres modules pendant le jeu.';
Blockly.Msg['DISPLAY_MORPION_SETPLAYERFIGURE_TITLE'] = '[Ecran OLED] Morpion - ajouter %1';
Blockly.Msg['DISPLAY_MORPION_SETPLAYERFIGURE_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'ajouter une figure (croix ou cercle) dans la grille du morpion sur un afficheur OLED. Brancher l\'afficheur sur un port I2C. Attention, le jeu du Morpion utilise toute la mémoire de la micro:bit, vous ne pouvez pas utiliser d\'autres modules pendant le jeu.';
Blockly.Msg['DISPLAY_MORPION_CROSS'] = 'une croix';
Blockly.Msg['DISPLAY_MORPION_CIRCLE'] = 'un cercle';
Blockly.Msg['DISPLAY_MORPION_ISENDGAME_TITLE'] = '[Ecran OLED] Morpion - partie terminée ?';
Blockly.Msg['DISPLAY_MORPION_ISENDGAME_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de retourner l\'état de la partie en cours du morpion. Brancher l\'afficheur sur un port I2C. Attention, le jeu du Morpion utilise toute la mémoire de la micro:bit, vous ne pouvez pas utiliser d\'autres modules pendant le jeu.';
// Display - Games
Blockly.Msg['DISPLAY_GAMES_LEFT'] = 'gauche';
Blockly.Msg['DISPLAY_GAMES_RIGHT'] = 'droite';
Blockly.Msg['DISPLAY_GAMES_UP'] = 'haut';
Blockly.Msg['DISPLAY_GAMES_DOWN'] = 'bas';
Blockly.Msg['DISPLAY_GAMES_CREATESPRITE_TITLE'] = 'créer un sprite à x %1 y %2';
Blockly.Msg['DISPLAY_GAMES_CREATESPRITE_TOOLTIP'] = 'Créer un sprite sur l\'écran de la micro:bit.';
Blockly.Msg['DISPLAY_GAMES_DELETESPRITE_TITLE'] = 'supprimer %1';
Blockly.Msg['DISPLAY_GAMES_DELETESPRITE_TOOLTIP'] = 'Supprime le sprite sélectionné dans les variables.';
Blockly.Msg['DISPLAY_GAMES_ISSPRITEDELETED_TITLE'] = '%1 est supprimé ?';
Blockly.Msg['DISPLAY_GAMES_ISSPRITEDELETED_TOOLTIP'] = 'Retourne \'True\' si le sprite sélectionné est supprimé.';
Blockly.Msg['DISPLAY_GAMES_MOVESPRITE_TITLE'] = 'déplacer %1 de %2 vers %3';
Blockly.Msg['DISPLAY_GAMES_MOVESPRITE_TOOLTIP'] = 'Déplace le sprite sélectionné vers la direction choisie.';
Blockly.Msg['DISPLAY_GAMES_GETSPRITEPOSITION_TITLE'] = 'position %2 de %1';
Blockly.Msg['DISPLAY_GAMES_GETSPRITEPOSITION_TOOLTIP'] = 'Renvoie les coordonnées du sprite sélectionné.';
Blockly.Msg['DISPLAY_GAMES_CHANGESCORE_TITLE'] = 'incrémenter le score de %1';
Blockly.Msg['DISPLAY_GAMES_CHANGESCORE_TOOLTIP'] = 'Augmente le score.';
Blockly.Msg['DISPLAY_GAMES_GETSCORE_TITLE'] = 'score';
Blockly.Msg['DISPLAY_GAMES_GETSCORE_TOOLTIP'] = 'Renvoie le score du jeu.';
Blockly.Msg['DISPLAY_GAMES_STOPGAME_TITLE'] = 'arrêter le jeu';
Blockly.Msg['DISPLAY_GAMES_STOPGAME_TOOLTIP'] = 'Arrêter le jeu en cours.';
Blockly.Msg['DISPLAY_GAMES_ISENDGAME_TITLE'] = 'fin du jeu';
Blockly.Msg['DISPLAY_GAMES_ISENDGAME_TOOLTIP'] = 'Retourne \'True\' si le jeu est arrêté.';
Blockly.Msg['DISPLAY_GAMES_RESTARTGAME_TITLE'] = 'recommencer le jeu';
Blockly.Msg['DISPLAY_GAMES_RESTARTGAME_TOOLTIP'] = 'Permet de démarrer le jeu.';
// Input/Output - Micro:bit
Blockly.Msg['IO_WAIT_TITLE'] = 'attendre %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Effectue une pause dans l\'exécution du code.';
Blockly.Msg['IO_WAIT_SECOND'] = 'seconde.s';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milliseconde.s';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microseconde.s';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'attendre jusqu\'à %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Arrête l\'excution du code jusqu\'à ce que la condition soit satisfaite.';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'démarrer le chronomètre';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Initialise un chronomètre à 0 (en secondes).';
Blockly.Msg['IO_RESETCHRONOMETER_TITLE'] = 'réinitialiser le chronomètre';
Blockly.Msg['IO_RESETCHRONOMETER_TOOLTIP'] = 'Réinitialise un chronomètre à 0 (en secondes).';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'valeur du chronomètre en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Renvoie la valeur du chronomètre à partir de l\'initialisation (en secondes ou millisecondes).';
Blockly.Msg['IO_ONBUTTONPRESSED_TITLE'] = 'si le bouton %1 %2 appuyé alors';
Blockly.Msg['IO_ONBUTTONPRESSED_TOOLTIP'] = 'Exécute des instructions si les boutons A ou B sont préssés.';
Blockly.Msg['IO_ISPRESSED'] = 'est';
Blockly.Msg['IO_WASPRESSED'] = 'a été';
Blockly.Msg['IO_ONPINTOUCHED_TITLE'] = 'si %1 est touché alors';
Blockly.Msg['IO_ONPINTOUCHED_TOOLTIP'] = 'Exécute des instructions si le logo de la carte micro:bit ou si la broche P0, P1 ou P2 est appuyée (ou touchée).';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_TITLE'] = 'si %1 alors';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_SHAKE'] = 'secoué';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_UP'] = 'logo vers le haut';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_DOWN'] = 'logo vers le bas';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FACE_UP'] = 'écran vers le haut';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FACE_DOWN'] = 'écran vers le bas';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_LEFT'] = 'penché à gauche';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_RIGHT'] = 'penché à droite';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FREEFALL'] = 'chute libre';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_TOOLTIP'] = 'Exécute des instructions si la carte micro:bit est secouée.';
Blockly.Msg['IO_ISBUTTONPRESSED_TITLE'] = 'bouton %1 %2 appuyé';
Blockly.Msg['IO_ISBUTTONPRESSED_TOOLTIP'] = 'Retourne \'True\' si le bouton A ou B est pressé, et \'False\' sinon.';
Blockly.Msg['IO_ISPINTOUCHED_TITLE'] = '%1 est touché';
Blockly.Msg['IO_ISPINTOUCHED_TOOLTIP'] = 'Retourne \'True\' si le logo de la carte micro:bit ou si la broche P0, P1 ou P2 est touchée, et \'False\' sinon.';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TITLE'] = 'nombre de clics du bouton %1';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TOOLTIP'] = 'Retourne le nombre de fois qu\'a été appuyé le bouton A ou B.';
Blockly.Msg['IO_RUN_EVERY_TITLE'] = 'répéter toutes les %1 heures.s %2 minutes.s %3 secondes.s %4 millisecondes.s';
Blockly.Msg['IO_RUN_EVERY_TOOLTIP'] = 'Exécute une fonction de manière répétée. Chaque argument est une unité de temps différente et ils s\'additionnent. Par exemple, run_every(min=2, s=30) planifie le rappel toutes les deux minutes et demie . Veuillez noter que cette fonctionnalité n\'est disponible qu\'avec le micro:bit V2.';
Blockly.Msg['IO_MICROBIT_RESET_TITLE'] = '[Micro:bit] réinitialiser la carte';
Blockly.Msg['IO_MICROBIT_RESET_TOOLTIP'] = 'Redémarre la carte micro:bit. Cela peut être utile pour réinitialiser l\'état de la carte ou pour redémarrer le programme en cours d\'exécution.';
// Input/Output - Microphone module
Blockly.Msg['IO_MICRO_LOUD'] = 'fort';
Blockly.Msg['IO_MICRO_QUIET'] = 'faible';
Blockly.Msg['IO_MICRO_IS'] = 'est';
Blockly.Msg['IO_MICRO_WAS'] = 'a été';
Blockly.Msg['IO_MICRO_ONSOUNDDETECTED_TITLE'] = '[Micro] si un son %1 %2 détecté alors';
Blockly.Msg['IO_MICRO_ONSOUNDDETECTED_TOOLTIP'] = 'Exécute des instructions si u1023n son (fort/faible) est détecté. Option \'was: Exécute des instructions si un son (fort/faible) s\'est produit depuis le dernier appel de la fonction \'was_sound()\'.';
Blockly.Msg['IO_MICRO_GETCURRENTSOUND_TITLE'] = '[Micro] état du son';
Blockly.Msg['IO_MICRO_GETCURRENTSOUND_TOOLTIP'] = 'Renvoie l\'état du son (fort/faible).';
Blockly.Msg['IO_MICRO_WASSOUNDDETECTED_TITLE'] = '[Micro] son %1 a été détecté';
Blockly.Msg['IO_MICRO_WASSOUNDDETECTED_TOOLTIP'] = 'Retourne \'True\' si un son (fort/faible) s\'est produit depuis le dernier appel de la fonction \'was_sound()\'.';
Blockly.Msg['IO_MICRO_GETSOUNDLEVEL_TITLE'] = '[Micro] intensité du son';
Blockly.Msg['IO_MICRO_GETSOUNDLEVEL_TOOLTIP'] = 'Permet d\'obtenir l\'intensité du son.';
Blockly.Msg['IO_MICRO_GETHISTORYSOUND_TITLE'] = '[Micro] historique des sons';
Blockly.Msg['IO_MICRO_GETHISTORYSOUND_TOOLTIP'] = 'Renvoie l\'historique des sons depuis le dernier appel de la fonction \'get_sounds()\'.';
Blockly.Msg['IO_MICRO_SETSOUNDTHRESHOLD_TITLE'] = '[Micro] définir le seuil des sons %1 à %2';
Blockly.Msg['IO_MICRO_SETSOUNDTHRESHOLD_TOOLTIP'] = 'Permet de définir un seuil du niveau sonore des sons forts/faibles de 0 à 255.';
Blockly.Msg['IO_MICRO_SOUNDCONDITION_TITLE'] = '[Micro] %1';
Blockly.Msg['IO_MICRO_SOUNDCONDITION_TOOLTIP'] = 'Permet d\'utiliser les constantes (LOUD/QUIET) de la librairie microphone dans les blocs de la catégorie \'Logique\'';
// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Clavier numérique] chiffre sur les broches RX %1 TX %2';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Permet d\'obtenir la touche appuyée du clavier numérique grove sur les broches TX et RX. Quand vous connectez le module, s\'assurer que les broches sont \'croisées\' : RX de la carte avec TX du module et inversement.';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Module joytsick] valeur de l\'axe %1 sur les broches X %2 Y %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'axe X ou Y (de 0 à 1023) du joystick Grove sur les broches P0 à P4, ou P10.';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TITLE'] = '[Module bouton coloré] état sur la broche SIG2 %1 ';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Renvoie l\'état du bouton coloré grove (0 or 1) sur les broches digitales P0 à P20.';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TITLE'] = '[Module bouton coloré] contrôler la LED à l\'état %1 sur la broche SIG1 %2';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Permet d\'allumer ou éteindre la LED (0 or 1) sur les broches digitales P0 à P20.';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Potentiomètre rotatif] valeur sur la broche %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Renvoie l\'angle (de 0 à 1023) du potentiomètre rotatif Grove sur les broches P0 à P4, ou P10.';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Potentiomètre linéaire] valeur sur la broche %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Renvoie la position (de 0 à 1023) du potentiomètre linéaire Grove sur les broches P0 à P4, ou P10.';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Capteur tactile] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur tactile Grove (0 ou 1) sur les broches digitales P0 à P20.';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Module bouton] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Renvoie la valeur du bouton Grove (0 ou 1) sur les broches digitales P0 à P20.';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Module interrupteur] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'interrupteur Grove (0 ou 1) sur les broches digitales P0 à P20.';
Blockly.Msg['IO_GETMAGNETICSWITCH_TITLE'] = '[Module interrupteur mag.] état sur la broche %1 ';
Blockly.Msg['IO_GETMAGNETICSWITCH_TOOLTIP'] = IMG_MODULE_MAGNETIC_SWITCH + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'interrupteur magnétique Grove (0 ou 1) sur les broches digitales P0 à P20.';
// Input/Output - Pins
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'HAUT (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAS (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Retourne une valeur booléene (1 si HAUT ou 0 si BAS).';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'état de la broche numérique %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée digitale (0 ou 1).';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'écrire sur la broche numérique %1 l\'état %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Permet d\'écrire une valeur sur une entrée digitale (0 ou 1).';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'lire la broche analogique %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée analogique (0-1023).';
Blockly.Msg['IO_WRITEANALOGPIN_TITLE'] = 'écrire sur la broche analogique %1 la valeur %2';
Blockly.Msg['IO_WRITEANALOGPIN_TOOLTIP'] = 'Permet d\'écrire une valeur sur une entrée analogique (0-1023). Cette fonction n\'écris pas réellement une valeur analogique. Elle utilise la PWM (Pulse-Width Modulation). Par exemple, écrire 511 fournit un signal ayant 50% du cycle, la tension moyenne est donc 1,65V.';
Blockly.Msg['IO_SETPWM_TITLE'] = 'appliquer un signal de période %1 %2 sur la broche %3';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Permet d\'appliquer un signal PWM avec une période en ms ou en sur une broche de période minimale 256 μs.';
Blockly.Msg['IO_READPULSEIN_TITLE'] = 'lire l\'impulsion (μs) de l\'état %1 sur la broche %2';
Blockly.Msg['IO_READPULSEIN_TOOLTIP'] = 'Renvoie la durée de l\'impulsion entrante à l\'état HAUT ou BAS en (us).';
Blockly.Msg['IO_SET_PULL_TITLE'] = 'régler le levier en broche %1 sur l\'état %2';
Blockly.Msg['IO_SET_PULL_TOOLTIP'] = 'Configure la broche pour qu\'elle soit en mode lecture numérique avec le pull mode donné.';
Blockly.Msg['IO_SET_PULL_UP'] = 'haut';
Blockly.Msg['IO_SET_PULL_DOWN'] = 'bas';
Blockly.Msg['IO_SET_NO_PULL'] = 'aucun';
// Communication - Micro:bit Logs
Blockly.Msg['COMMUNICATION_LOG_DELETE_TITLE'] = 'effacer le log sur la micro:bit';
Blockly.Msg['COMMUNICATION_LOG_DELETE_TOOLTIP'] = 'Efface le log (html) sur la carte micro:bit.';
Blockly.Msg['COMMUNICATION_LOG_SERIAL_TITLE'] = 'obtenir un retour dans la console';
Blockly.Msg['COMMUNICATION_LOG_SERIAL_TOOLTIP'] = 'Permet d\'écrire des données du log dans la console en temps réél.';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TITLE'] = 'ajouter un nouveau label avec un Timer %1';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TOOLTIP'] = 'Permet d\'ajouter un label à la colonne des données du log. Le label peut être un texte ou un nombre. Le timestamp peut être en secondes, millisecondes, minutes, heures ou jours.';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TIMESTAMP_MILLISECONDS'] = 'millisecondes';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TIMESTAMP_SECONDS'] = 'secondes';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TIMESTAMP_MINUTES'] = 'minutes';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TIMESTAMP_HOURS'] = 'heures';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TIMESTAMP_DAYS'] = 'jours';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TIMESTAMP_NONE'] = 'None';
Blockly.Msg['COMMUNICATION_LOG_ADDDATA_TITLE'] = 'ajouter les données à un label';
Blockly.Msg['COMMUNICATION_LOG_ADDDATA_TOOLTIP'] = 'Permet d\'ajouter un label à la colonne des données du log. Le label peut être un texte ou un nombre. Les données peuvent être un texte ou un nombre.';
Blockly.Msg['COMMUNICATION_LOG_DATA_TITLE'] = 'label %1 donnée %2';
Blockly.Msg['COMMUNICATION_LOG_DATA_TOOLTIP'] = 'Permet d\'ajouter un label à la colonne des données du log. Le label peut être un texte ou un nombre. Les données peuvent être un texte ou un nombre.';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'écrire dans la console %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Permet d\'écrire des données dans la console.';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'avec';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'saut.s de ligne';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'tracer le graphe';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Ce bloc permet d\'écrire des données (numériques) qui seront visibles dans le traceur. Il peut être utilisé avec un ou plusieurs blocs au format "Nom" et "Données". Pour visualiser les graphiques, cliquer sur l\'icone \'Mode Graphique\' dans la console.';
Blockly.Msg['COMMUNICATION_DATA'] = 'Donnée';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nom %1 Valeur %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Ce bloc est à utiliser avec le bloc "Tracer le graphique". Il doit lui-même contenir le nom de la valeur à afficher (texte), et la valeur en question (nombre).';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'jouer la note %1 sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Joue la note sélectionnée jusqu\'à l\'exécution du bloc "Fin de la note".';
Blockly.Msg['NOTE_C'] = 'Do';
Blockly.Msg['NOTE_C_SHARP'] = 'Do#';
Blockly.Msg['NOTE_D'] = 'Ré';
Blockly.Msg['NOTE_D_SHARP'] = 'Ré#';
Blockly.Msg['NOTE_E'] = 'Mi';
Blockly.Msg['NOTE_F'] = 'Fa';
Blockly.Msg['NOTE_F_SHARP'] = 'Fa#';
Blockly.Msg['NOTE_G'] = 'Sol';
Blockly.Msg['NOTE_G_SHARP'] = 'Sol#';
Blockly.Msg['NOTE_A'] = 'La';
Blockly.Msg['NOTE_A_SHARP'] = 'La#';
Blockly.Msg['NOTE_B'] = 'Si';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'jouer la fréquence %1 (Hz) sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Ce bloc permet de jouer une fréquence donnée sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'terminer la note sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Arrête la note en cours.';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE'] = 'si une donnée est reçue du port série dans %1 alors';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si une donnée est reçue par le port série dans la variable \'serialData\'.';
// Communication - Radio
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TITLE'] = '[Radio] envoyer la chaîne %1';
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TOOLTIP'] = 'Permet d\'envoyer uen chaîne de caractères via la radio de la carte micro:bit.';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TITLE'] = '[Radio] envoyer le nombre ou la liste %1';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TOOLTIP'] = 'Permet d\'envoyer des nombres ou une liste via la radio de la carte micro:bit.';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TITLE'] = '[Radio] envoyer la valeur %1 = %2';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TOOLTIP'] = 'Permet d\'envoyer des données avec un nom et sa valeur via la radio de la carte micro:bit.';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TITLE'] = '[Radio] si une chaîne est reçue dans %1 alors';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si une chaîne de caractères est reçue par radio dans la variable \'stringData\'.';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TITLE'] = '[Radio] si un nombre est reçu dans %1 alors';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si un nombre est reçu par radio dans la variable \'numberData\'.';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TITLE'] = '[Radio] si une valeur est reçue dans %1 %2 alors';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si un nom et sa valeur sont reçus par radio dans les variables \'name\' et \'value\'.';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TITLE'] = '[Radio] configurer Canal %1 Puissance %2 Taille des données %3 Groupe %4';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TOOLTIP'] = 'Permet de configurer le canal de la radio (de 0 to 83), la taille des données transmises (en octets), la puissance de transmission (de 0 à 7)  ainsi que le group (de 0 à 255).';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] écrire dans la carte SD %1 avec la carte %2 sur les broches RXI %3 TXO %4 %5 Données %6';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'Permet d\'écrire des données dans la carte micro SD avec le module Openlog. Le baudrate de l\'OpenLog doit être configuré à la moitié du baudrate de la carte. Exemple: Pour la carte v1, si le baudrate est à 9600 (cf config.txt sur la carte SD), le baudrate doit être à 4800.';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] envoyer sur les broches RX %1 TX %2 message %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permet d\'envoyer des données via le module Bluetooth HC05 sur les broches RX/TX.';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] si message reçu sur les broches RX %1 TX %2 dans %3 alors';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par un module Bluetooth HC05 dans la variable \'bluetoothData\' sur les broches RX/TX.';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_SENDDATA_TITLE'] = '[HM10 BT] envoyer sur les broches RX %1 TX %2 message %3';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HM10_BT + Blockly.Tooltip.SEP + 'Permet d\'envoyer des données via le module Bluetooth HM10 sur les broches RX/TX.';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[HM10 BT] si message reçu sur les broches RX %1 TX %2 dans %3 alors';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HM10_BT + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par un module Bluetooth HM10 dans la variable \'HM10Data\' sur les broches RX/TX. Par défaut, le module s\'appelle MLT-BT05.';
// Communication - Tracking modules
Blockly.Msg['COMMUNICATION_GPS_INFO_TYPE'] = 'le type de la trame';
Blockly.Msg['COMMUNICATION_GPS_INFO_CLOCK'] = 'l\'heure (h, m, s)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LATITUDE'] = 'la latitude (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LONGITUDE'] = 'la longitude (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_SATELLITE'] = 'le nombre de satellites utilisés';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALTITUDE'] = 'l\'altitude (m)';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALL_FRAME'] = 'toute la trame';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TITLE'] = '[GPS] trames NMEA sur les broches RX %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Renvoie la liste des trames NMEA lues avec le module GPS Grove SIM28 ou Air530 sur les broches RX/TX. Les fils n\'ont pas besoin d\'être inversée entre les broches du module et celles indiquées dans le bloc. L\'inversion se fait automatiquement dans le code python.\nAttention: Si vous utilisez la console pour afficher les données du GPS, connecter votre carte à l\'interface avant d\'envoyer le programme en cliquant sur le bouton [>_ REPL]. Ensuite, transférer votre programme en utilisant le bouton [Télécharger .hex].';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TITLE'] = '[GPS] obtenir %3 sur les broches RX %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Renvoie la donnée sélectionnée parmi (le type de trame, l\'horloge, la latitude, la longitude, l\'altitude) annalysée de la trame NMEA (GNGGA ou GPGGA) lue avec le module GPS Grove SIM28 ou Air530 sur les broches RX/TX. Les fils n\'ont pas besoin d\'être inversée entre les broches du module et celles indiquées dans le bloc. L\'inversion se fait automatiquement dans le code python.\nAttention: Si vous utilisez la console pour afficher les données du GPS, connecter votre carte à l\'interface avant d\'envoyer le programme en cliquant sur le bouton [>_ REPL]. Ensuite, transférer votre programme en utilisant le bouton [Télécharger .hex].';
// 05/22 The 2 following blocks removed from toolbox. We keep the block cause of user projects.
Blockly.Msg['COMMUNICATION_GPS_ONDATARECEIVED_TITLE'] = '[GPS] si une donnée est reçue sur les broches TX %1 RX %2 dans %3 alors';
Blockly.Msg['COMMUNICATION_GPS_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par GPS dans la variable \'gpsData\' sur les broches RX/TX.';
Blockly.Msg['COMMUNICATION_GPS_GETINFORMATIONS_TITLE'] = '[GPS] obtenir %1 avec les données %2';
Blockly.Msg['COMMUNICATION_GPS_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Renvoie les données analysées du GPS parmi (\'horloge\', \'latitude, \'longitude\', \'altitude\', \'toute la trame\')';
// end of the 2 blocks
Blockly.Msg['COMMUNICATION_RTC_MODULE_PCF85063TP'] = 'Haute Précision (0x51)';
Blockly.Msg['COMMUNICATION_RTC_MODULE_DS1307'] = 'v1.2 (0x68)';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TITLE'] = '[Horloge RTC %1] initialiser à %2 date %3';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet d\'initialiser le module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307), pour pouvoir lire la date et l\'heure précise avec le bloc \'Lire le module horloge\'. Placer dans le bloc \'Au démarrage\'. Brancher le module RTC sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['DAY_MONDAY'] = 'lundi';
Blockly.Msg['DAY_TUESDAY'] = 'mardi';
Blockly.Msg['DAY_WEDNESDAY'] = 'mercredi';
Blockly.Msg['DAY_THURSDAY'] = 'jeudi';
Blockly.Msg['DAY_FRIDAY'] = 'vendredi';
Blockly.Msg['DAY_SATURDAY'] = 'samedi';
Blockly.Msg['DAY_SUNDAY'] = 'dimanche';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TITLE'] = '[Horloge RTC %1] initialiser à heure %2 minute %3 seconde %4';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet d\'initialiser le module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307), pour pouvoir lire la date et l\'heure précise avec le bloc \'Lire le module horloge\'. Placer dans le bloc \'Au démarrage\'. Brancher le module sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TITLE'] = '[Horloge RTC %1] lire %2';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet de lire la date et l\'heure du module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307). Pour avoir un résultat correct, utiliser au préalable les deux blocs \'Initialiser le module horloge\'. Brancher le module sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['CLOCK_ALL_DATA'] = 'l\'horloge';
Blockly.Msg['CLOCK_YEAR'] = 'année';
Blockly.Msg['CLOCK_MONTH'] = 'mois';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'jour du mois';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'jour de la semaine';
Blockly.Msg['CLOCK_HOUR'] = 'heure';
Blockly.Msg['CLOCK_MINUTE'] = 'minute';
Blockly.Msg['CLOCK_SECOND'] = 'seconde';
// Communication - UART
Blockly.Msg['COMMUNICATION_SERIAL_INIT_TITLE'] = '[uart] rediriger la connexion série sur RX %2 TX %3 baudrate %1';
Blockly.Msg['COMMUNICATION_SERIAL_INIT_TOOLTIP'] = 'Permet de rediriger la connexion série de la carte micro:bit. Quand vous connecter le module, être assuré que les broches sont \'croisées\' : RX de la carte avec TX du module et inversement.';
Blockly.Msg['COMMUNICATION_SERIAL_REDIRECTTOUSB_TITLE'] = '[uart] rediriger la connexion série vers USB';
Blockly.Msg['COMMUNICATION_SERIAL_REDIRECTTOUSB_TOOLTIP'] = 'Permet de rediriger la connexion série vers l\'USB (ordinateur). Cela peut être utilisé pour faire fonctionner plusieurs modules UART en même temps.';
Blockly.Msg['COMMUNICATION_UART_WRITE_TITLE'] = '[uart] écrire la donnée %1';
Blockly.Msg['COMMUNICATION_UART_WRITE_TOOLTIP'] = 'Permet d\'écrire des données dans le port UART.';
Blockly.Msg['COMMUNICATION_UART_READ_TITLE'] = '[uart] lire les données';
Blockly.Msg['COMMUNICATION_UART_READ_TOOLTIP'] = 'Permet de lire des données depuis le port UART.';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TITLE'] = '[uart] données disponibles';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TOOLTIP'] = 'Retourne une valeur booléenne (1 si des données sont disponibles à la lecture ou 0 sinon).';
// Sensors - common msg
Blockly.Msg['SENSORS_TEMPERATURE'] = 'température';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'en';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humidité (%)';
Blockly.Msg['SENSORS_PRESSURE'] = 'pression (Pa)';
Blockly.Msg['SENSORS_ALTITUDE'] = 'l\'altitude (m)';
// Sensors - Micro:bit
Blockly.Msg['SENSORS_GETACCELERATION_TITLE'] = 'accélération (mg) %1';
Blockly.Msg['SENSORS_GETACCELERATION_TOOLTIP'] = 'Renvoie l\'accélération (en mg) grâce à l\'accéléromètre de la carte micro:bit.';
Blockly.Msg['SENSORS_GETLIGHT_TITLE'] = 'luminosité';
Blockly.Msg['SENSORS_GETLIGHT_TOOLTIP'] = 'Renvoie la luminosité (de 0 à 255) grâce à quelques LED de l\'écran de la carte micro:bit.';
Blockly.Msg['SENSORS_CALIBRATECOMPASS_TITLE'] = 'calibrer la boussole';
Blockly.Msg['SENSORS_CALIBRATECOMPASS_TOOLTIP'] = 'Permet de calibrer le compas de la carte micro:bit. Il suffit de secouée la carte pour le calibrer. Un smiley \'heureux\' apparaît lorsque la calibration est terminée.';
Blockly.Msg['SENSORS_GETCOMPASS_TITLE'] = 'direction de la boussole (°)';
Blockly.Msg['SENSORS_GETCOMPASS_TOOLTIP'] = 'Renvoie la direction (de 0° à 360°) de la carte micro:bit grâce au compas interne.';
Blockly.Msg['SENSORS_ISCOMPASSCALIBRATED_TITLE'] = 'boussole est calibrée ?';
Blockly.Msg['SENSORS_ISCOMPASSCALIBRATED_TOOLTIP'] = 'Retourne \'True\' si la boussole est calibrée, retourne \'False\' sinon.';
Blockly.Msg['SENSORS_GETTEMPERATURE_TITLE'] = Blockly.Msg['SENSORS_TEMPERATURE'] + ' in %1';
Blockly.Msg['SENSORS_GETTEMPERATURE_TOOLTIP'] = 'Renvoie la température en degré Celius (°C), Fahrenheit (°F) ou Kelvin (K) du processeur de la carte micro:bit.';
Blockly.Msg['SENSORS_GETROTATION_TITLE'] = 'rotation (°) %1';
Blockly.Msg['SENSORS_GETROTATION_PITCH'] = 'tangage';
Blockly.Msg['SENSORS_GETROTATION_ROLL'] = 'roulis';
Blockly.Msg['SENSORS_GETROTATION_TOOLTIP'] = 'Renvoie la rotation (de -180° à 180°) grâce à l\'accéléromètre de la carte micro:bit.';
Blockly.Msg['SENSORS_GETMAGNETICFORCE_TITLE'] = 'force du champ magnétique %1 (nT)';
Blockly.Msg['SENSORS_GETMAGNETICFORCE_TOOLTIP'] = 'Renvoie la valeur du champ magnétique (en nT) grâce au compas de la carte micro:bit.';
// Sensors - Enviro:bit
Blockly.Msg['SENSORS_TCS3472_GETRGB_TITLE'] = '[Enviro:bit - TCS3472] %1';
Blockly.Msg['SENSORS_TCS3472_GETRGB_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Permet de lire le niveau d\'une des trois couleurs primaires (de 0 à 255) avec le capteur de couleur TCS3472 intégré au shield Enviro:bit.';
Blockly.Msg['SENSORS_TCS3472_GETBRIGHTNESS_TITLE'] = '[Enviro:bit - TCS3472] luminosité';
Blockly.Msg['SENSORS_TCS3472_GETBRIGHTNESS_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Permet de mesurer la luminosité (de 0 à 1000) avec le capteur de couleur TCS3472 intégré au shield Enviro:bit.';
Blockly.Msg['SENSORS_TCS3472_SETLED_TITLE'] = '[Enviro:bit - TCS3472] contrôler la LED à l\'état %1';
Blockly.Msg['SENSORS_TCS3472_SETLED_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Permet de contrôler la LED intégré au capteur TCS3472 du shield Enviro:bit.';
Blockly.Msg['SENSORS_ENVIROBIT_BME280_GETDATA_TITLE'] = '[Enviro:bit - BME280] %1';
Blockly.Msg['SENSORS_ENVIROBIT_BME280_GETDATA_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C) de -40 à 85 °C, Fahrenheit (°F) ou Kelvin (K), l\'humidité (en %), la pression (en Pascal) ou l\'altitude (en m) grâce au capteur BME280 du shield Enviro:bit.';
Blockly.Msg['SENSORS_BME280_TEMP'] = Blockly.Msg['SENSORS_TEMPERATURE'];
Blockly.Msg['SENSORS_BME280_HUM'] = Blockly.Msg['SENSORS_HUMIDITY'];
Blockly.Msg['SENSORS_BME280_PRESS'] = Blockly.Msg['SENSORS_PRESSURE'];
Blockly.Msg['SENSORS_BME280_ALT'] = Blockly.Msg['SENSORS_ALTITUDE'];
Blockly.Msg['SENSORS_ENVIRO_BIT_GETSOUNDLEVEL_TITLE'] = '[Enviro:bit - micro] intensité du son';
Blockly.Msg['SENSORS_ENVIRO_BIT_GETSOUNDLEVEL_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Effectue une lecture de l\'intensité du son (de 0 à 443) pouvant être utilisée pour comparer différentes intensités de son.';
Blockly.Msg['SENSORS_ENVIRO_BIT_WAIT_CLAP_TITLE'] = '[Enviro:bit - micro] mesure %1 son.s fort.s en %2 seconde.s';
Blockly.Msg['SENSORS_ENVIRO_BIT_WAIT_CLAP_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Mesure un son fort 1 ou 2 fois par seconde, retourne True si c\'est détecté.';
Blockly.Msg['SENSORS_WEATHERBIT_BME280_GETDATA_TITLE'] = '[Weather:bit - BME280] %1';
Blockly.Msg['SENSORS_WEATHERBIT_BME280_GETDATA_TOOLTIP'] = IMG_MODULE_WEATHER_BIT + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C) de -40 à 85 °C, Fahrenheit (°F) ou Kelvin (K), l\'humidité (en %), la pression (en Pascal) ou l\'altitude (en m) grâce au capteur BME280 du shield Weather:bit.';
Blockly.Msg['SENSORS_WEATHERBIT_GETSOILMOISTURE_TITLE'] = '[Weather:bit - soil] humidité du sol';
Blockly.Msg['SENSORS_WEATHERBIT_GETSOILMOISTURE_TOOLTIP'] = IMG_MODULE_WEATHER_BIT_MOSITURE + Blockly.Tooltip.SEP + 'Renvoie l\'humidité (de 0 à 1023) mesurée grâce au capteur d\'humidité (SOIL MOISTURE) sur la broche P0.';
Blockly.Msg['SENSORS_WEATHERBIT_ANEMOMETER_GET_SPEED_TITLE'] = '[Weather:bit - wind] vitesse du vent en %1';
Blockly.Msg['SENSORS_WEATHERBIT_ANEMOMETER_GET_SPEED_TOOLTIP'] = IMG_MODULE_WEATHER_BIT_KIT_MICROBIT + Blockly.Tooltip.SEP + 'Renvoie la vitesse du vent avec l\'anémomètre dans l\'unité choisie (en m/s, km/s, inch/s ou noeud). L\'anémomètre se branche sur le port RJ45 WIND du shield Weather:bit.';
Blockly.Msg['SENSORS_UNIT_M_S'] = '(m/s)';
Blockly.Msg['SENSORS_UNIT_KM_H'] = '(km/h)';
Blockly.Msg['SENSORS_UNIT_INCH_S'] = '(inch/s)';
Blockly.Msg['SENSORS_UNIT_KNOT'] = '(noeud.s)';
Blockly.Msg['SENSORS_WEATHERBIT_WEATHERCOCK_GET_DIRECTION_TITLE'] = '[Weather:bit - wind] direction du vent';
Blockly.Msg['SENSORS_WEATHERBIT_WEATHERCOCK_GET_DIRECTION_TOOLTIP'] = IMG_MODULE_WEATHER_BIT_KIT_MICROBIT + Blockly.Tooltip.SEP + 'Renvoie la direction du vent (N,S,E,O,NE,NO,SE,SO) dans une chaîne de caractères. La girouette se branche avec l\'anémomètre sur le port RJ45 WIND du shield Weather:bit.';
Blockly.Msg['SENSORS_WEATHERBIT_RAIN_GAUGE_GET_DUMPS_TITLE'] = '[Weather:bit - rain] quantité d\'eau (mm)';
Blockly.Msg['SENSORS_WEATHERBIT_RAIN_GAUGE_GET_DUMPS_TOOLTIP'] = IMG_MODULE_WEATHER_BIT_KIT_MICROBIT + Blockly.Tooltip.SEP + 'Renvoie la précipitation d\'eau en hauteur d\'eau tombée au sol rapportée à une unité de surface. La pluviomètre se branche sur le port RJ45 RAIN du shield Weather:bit.';
// Sensors - Kitronik environmental
Blockly.Msg['SENSORS_KITRONIK_BME280_GETDATA_TITLE'] = '[Kitronik env. - BME280] %1';
Blockly.Msg['SENSORS_KITRONIK_BME280_GETDATA_TOOLTIP'] = IMG_SHIELD_KITRONIK_ENV + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C) de -40 à 85 °C, Fahrenheit (°F) ou Kelvin (K), l\'humidité (en %), la pression (en hPa) ou l\'altitude (en m) grâce au capteur BME280 du shield Kitronik.';
Blockly.Msg['SENSORS_KITRONIK_KLIMATE_BME280_GETDATA_TITLE'] = '[Kitronik Klimate - BME280] %1';
Blockly.Msg['SENSORS_KITRONIK_KLIMATE_BME280_GETDATA_TOOLTIP'] = IMG_SHIELD_KITRONIK_KLIMATE + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C) de -40 à 85 °C, Fahrenheit (°F) ou Kelvin (K), l\'humidité (en %), la pression (en hPa) ou l\'altitude (en m) grâce au capteur BME280 du shield Kitronik.';
// Sensors - Kitronic Traffic
Blockly.Msg['SENSORS_LAMPBIT_GETLUMINOSITY_TITLE'] = "[LAMP:BIT] luminosité";
Blockly.Msg['SENSORS_LAMPBIT_GETLUMINOSITY_TOOLTIP'] = IMG_MODULE_LAMPBIT + Blockly.Tooltip.SEP + "Récupère la luminosité du phototransistor du lampadaire";
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[Capteur SGP30] gaz %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Renvoie la quantité de CO2 (en ppm) ou de TVOC (en ppb) contenu dans l\'air grâce au capteur SGP30. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'Dioxyde de carbone (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'Composés organiques volatiles (TVOC) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Capteur de gaz multicanal] gaz %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Renvoie la quantité du gaz mesuré dans l\'air (en ppm) grâce au capteur de gaz multicanal. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Capteur de gaz multicanal v2] gaz %1 (V)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Renvoie la quantité du gaz mesuré dans l\'air (en V) grâce au capteur de gaz multicanal V2 grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['GAS_CO'] = 'Monoxyde de carbone (CO)';
Blockly.Msg['GAS_NO2'] = 'Dioxyde d\'azote (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'Ethanol (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'Dihydrogène (H2)';
Blockly.Msg['GAS_NH3'] = 'Ammoniac (NH3)';
Blockly.Msg['GAS_CH4'] = 'Méthane (CH4)';
Blockly.Msg['GAS_C3H8'] = 'Propane (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'Iso-propane (C4H10)';
Blockly.Msg['GAS_VOC'] = 'Composés organiques volatiles (COV)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Capteur de dioxygène] O2 (%) sur la broche %1';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Renvoie la concentration de dioxygène (O2) dans l\'air (en %) grâce au capteur de gas O2 grove sur les broches P0 à P4, ou P10.';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[Capteur SCD30] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Renvoie la concentration de CO2 dans l\'air (en ppm), l\'humidité (en %) ou la température en Celsius (°C), Fahrenheit (°F) ou Kelvin (K) from the grove SCD30 sensor. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'dioxyde de carbone (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = Blockly.Msg['SENSORS_TEMPERATURE'];
Blockly.Msg['SENSORS_SCD30_HUM'] = Blockly.Msg['SENSORS_HUMIDITY'];
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[Capteur SCD30] forcer la recalibration à %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Forcer la calibration du capteur SCD30 à la valeur donnée. Se placer en extérieur (là où la concentration est autour de 420 ppm environ, soit un air pur), redémarrer la carte, puis attendre 2 minutes. Conseil: Utiliser le bouton A ou B de la carte BBC micro:bit pour contrôler le lancement de la calibration. Sinon, en rebranchant la carte, le programme se lance et effectue de nouveau une calibration pas forcément souhaitée.';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Capteur de qualité d\'air] valeur sur la broche %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Renvoie la valeur de la qualité de l\'air (de 0 à 1023) sur les broches P0 à P4, ou P10. Le capteur est Air Quality Sensor v1.3 de Seeed.';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[Capteur HM330X] concentration de particules fines %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Détecte la densité de particules dans l\'air avec le capteur HM330X. brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
// Sensors - Climate
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[Capteur BMP280 %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), la pression (en Pascal) ou l\'altitude (en m). L\'altitude est calculée avec la pression et est initialisée à 0 au début du programme. Le bloc a besoin du capteur Grove BMP280 (adresse I2C: 0x77, couleur: bleu) ou le capteur HW-611 280 (adresse I2C: 0x76, couleur: violet). Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_BMP280_TEMP'] = Blockly.Msg['SENSORS_TEMPERATURE'];
Blockly.Msg['SENSORS_BMP280_PRESS'] = Blockly.Msg['SENSORS_PRESSURE'];
Blockly.Msg['SENSORS_BMP280_ALT'] = Blockly.Msg['SENSORS_ALTITUDE'];
Blockly.Msg['SENSORS_BME280_GETDATA_TITLE'] = '[Capteur BME280] %1';
Blockly.Msg['SENSORS_BME280_GETDATA_TOOLTIP'] = IMG_MODULE_BME280 + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C) de -40 à 85 °C, Fahrenheit (°F) ou Kelvin (K), l\'humidité (en %), la pression (en Pascal) ou l\'altitude (en m) grâce au capteur BME280.';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = '[Capteur H.T°] température en %1 sur les broches A0 %2 A1 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température du thermocouple en degré Celsius (50 à 600 °C), Fahrenheit (°F) ou Kelvin (K) grâce au capteur grove de haute température sur les broches P0 à P4, ou P10.';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Capteur d\'humidité] humidité du sol sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Renvoie l\'humidité (de 0 à 1023) mesurée grâce au capteur d\'humidité grove sur les broches P0/P14, P1/P15 ou P2/P16.';
Blockly.Msg['SENSORS_GETGROVECAPACITIVEMOISTURE_TITLE'] = '[Capteur d\'humidité capacitif] humidité du sol %1';
Blockly.Msg['SENSORS_GETGROVECAPACITIVEMOISTURE_TOOLTIP'] = IMG_MODULE_CAPACITIVE_MOISTURE + Blockly.Tooltip.SEP + 'Renvoie l\'humidité (de 0 à 1023) mesurée grâce au capteur d\'humidité capacitif grove sur les broches P0/P14, P1/P15 ou P2/P16.';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Capteur de T°] température en %1 sur la broche %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) du capteur de température Grove sur les broches P0 à P4, ou P10.';
Blockly.Msg['SENSORS_BAROMETER_READDATA_TITLE'] = '[Baromètre] %1';
Blockly.Msg['SENSORS_BAROMETER_READDATA_TOOLTIP'] = IMG_MODULE_SHT35 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), la pression (en hPa) ou l\'altitude (en m) grâce au baromètre. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_DHT_READDATA_TITLE'] = '[Capteur DHT11] %1 sur la broche %2 avec la carte %3';
Blockly.Msg['SENSORS_DHT_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur dht11 grove sur les broches digitales P0 à P20. Le capteur effectue une nouvelle mesure toutes les 2 secondes avec la micro:bit v1. Il effectue une nouvelle mesure toutes les 20 secondes avec la micro:bit v2.';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[Capteur TH02] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur TH02. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Capteur SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur SHT31. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SHT35_READDATA_TITLE'] = '[Capteur SHT35] %1';
Blockly.Msg['SENSORS_SHT35_READDATA_TOOLTIP'] = IMG_MODULE_SHT35 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur SHT35. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_MPX5700AP_GETPRESSURE_TITLE'] = '[Capteur MPX5700AP] pression (kPa) sur la broche %1';
Blockly.Msg['SENSORS_MPX5700AP_GETPRESSURE_TOOLTIP'] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + 'Permet de lire la pression du capteur Grove avec la calculatrice TI-83.';
Blockly.Msg['SENSORS_MPX5700AP_CALIBRATE_TITLE'] = '[Capteur MPX5700AP] calibrer le capteur m %1 b %2';
Blockly.Msg['SENSORS_MPX5700AP_CALIBRATE_TOOLTIP'] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + 'Permet de calibrer le capteur de pression grove avec la calculatrice TI-83.';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Capteur d\'eau] quantité d\'eau sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Renvoie la quantité d\'eau (de 0 à 255) mesurée grâce au capteur d\'eau grove sur les broches P0/P14, P1/P15 ou P2/P16.';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Capteur de pluie] état sur la broche %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Renvoie l\'état du capteur de pluie (1 s\'il pleut ou 0 sinon) sur les broches digitales P0 à P20.';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anémomètre] état sur la broche %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Renvoie l\'état de l\'anémomètre (deux fois état HAUT à chaque rotation) sur les broches digitales P0 à P20.';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Capteur de lumière] luminosité sur la broche %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Renvoie la luminosité (de 0 à 1023) du capteur de lumière Grove sur les broches P0 à P4, ou P10.';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[Capteur SI1145] luminosité %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Renvoie l\'indice de lumière ultraviolette, la luminosité visible (en lumen) ou infrarouge (en lumen) grâce au capteur Grove Sunlight ou le capteur GY1145. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SI1145_UV'] = 'indice UV';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visible (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrarouge (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Capteur ultraviolet] indice UV sur la broche %1';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Renvoie l\'indice de la lumière ultraviolette pour des ondes entre 240 et 380 nm du capteur Grove sur les broches P0 à P4, ou P10.';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Capteur de couleurs] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Permet de lire le niveau d\'une des trois couleurs primaires avec le capteur de couleur grove, le niveau est compris entre 0 et 255. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Capteur de son] niveau sonore sur la broche %1';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Renvoie le niveau sonore (0 à 1023) avec le capteur de son Grove sur les broches digitales P0 à P20.';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Capteur à ultrasons %1] %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Renvoie la distance (in cm) mesurée grâce au capteur grove à ultrasons sur les broches digitales P0 à P20. Attention, si le capteur est un modèle grove, TRIG et ECHO sont sur la même broche SIG.';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distance (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'durée de l\'aller-retour (µs)';
Blockly.Msg['SENSORS_ULTRASONIC_1PIN'] = 'sur la broche ';
Blockly.Msg['SENSORS_ULTRASONIC_2PINS'] = 'sur les broches ';
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TITLE'] = '[Time Of Flight] Distance en %1';
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TOOLTIP'] = IMG_MODULE_VL53L0X + Blockly.Tooltip.SEP + 'Retour les mesures de distance à partir du capteur Time Of Flight sur le port I2C.';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = '[Capteur de gestes] type de geste';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Renvoie le type de geste analysé (\'right\', \'left\', \'up\', \'down\', \'forward\', \'backward\', \'clockwise\', \'anticlockwise\') grâce au capteur de gestes grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Capteur de gestes] si le geste %1 est détecté';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Exécute des instructions si le geste sélectionné est détecté par le capteur de gestes grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'droit';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'gauche';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'haut';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'bas';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'avant';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'arrière';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'horaire';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'antihoraire';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'onde';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Capteur de ligne noire] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur de ligne noire grove (0 ou 1) sur les broches digitales P0 à P20.';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[Capteur de mouvement] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Renvoie vrai ou faux selon si le capteur Grove PIR Motion détecte un mouvement sur les broches digitales P0 à P20.';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Capteur de vibrations] état sur la broche %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Renvoie l\'état de la vibration (0 ou 1) grâce au capteur de vibration piezoélectrique sur les broches digitales P0 à P20.';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Module inclinaison] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'inclinaison du module Grove (0 ou 1) sur les broches digitales P0 à P20.';
// Other sensors
Blockly.Msg['SENSORS_GETGROVEBUTTON_TITLE'] = '[Module bouton] %1 sur la broche %2';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Renvoie la valeur numérique du bouton Grove (0/1 ou 0V/3.3V) sur les broches digitales P0 à P20.';
Blockly.Msg['SENSORS_GETGROVEBUTTON_VOLTAGE'] = 'tension';
Blockly.Msg['SENSORS_GETGROVEBUTTON_STATE'] = 'état';
Blockly.Msg['SENSORS_GET_EAR-CLIP_HEART_RATE_TITLE'] = '[Capteur de rythme cardiaque] bpm sur la broche %1';
Blockly.Msg['SENSORS_GET_EAR-CLIP_HEART_RATE_TOOLTIP'] = IMG_MODULE_EAR_CLIP + Blockly.Tooltip.SEP + 'Renvoie le nombre de battements par minute (bpm) grâce au capteur cardiaque grove.';
Blockly.Msg['SENSORS_FSR402_GETFORCE_TITLE'] = '[Détecteur de force] valeur sur la broche %1';
Blockly.Msg['SENSORS_FSR402_GETFORCE_TOOLTIP'] = IMG_MODULE_FORCE + Blockly.Tooltip.SEP + 'Renvoie la force exercée sur le détecteur rond grâce au capteur FSR402 sur les broches analogiques (P0 à P4 ou P10).';
Blockly.Msg['SENSORS_EMG_DETECTOR_TITLE'] = '[Détecteur EMG] valeur sur la broche %1';
Blockly.Msg['SENSORS_EMG_DETECTOR_TOOLTIP'] = IMG_MODULE_EMG_DETECTOR + Blockly.Tooltip.SEP + 'Mesure les courants électriques qui accompagnent l\'activité musculaire sur les broches analogiques (P0 à P4 ou P10).';
Blockly.Msg['SENSORS_GET_WATER_LEVEL_TITLE'] = '[Niveau d\'eau] valeur';
Blockly.Msg['SENSORS_GET_WATER_LEVEL_TOOLTIP'] = 'Mesure le niveau d\'eau en pourcentage (de 0 à 100%) sur le port I2C.';
// Actuators
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servomoteur] contrôler l\'angle à %1 ° sur la broche %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler l\'angle d\'un servomoteur (de 0 à 180) sur les broches digitales P0 à P20. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au servomoteur.';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Servomoteur continu] contrôler la vitesse à %1 (%) direction %2 sur la broche %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler la vitesse (de 0 à 100 %) d\'un servomoteur continu sur les broches PWM.';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Moteur] contrôler la puissance à %1 sur la broche %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permet de contrôler la puissance d\'un moteur (de 0 à 1023) sur les broches digitales P0 à P20. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au moteur.';
Blockly.Msg['ACTUATORS_FAN_SETPOWER_TITLE'] = '[Ventilateur] contrôler la puissance à %1 sur la broche %2';
Blockly.Msg['ACTUATORS_FAN_SETPOWER_TOOLTIP'] = IMG_MODULE_FAN + Blockly.Tooltip.SEP + 'Permet de contrôler la puissance d\'un mini ventilateur (de 0 à 1023) sur les broches digitales P0 à P20.';
Blockly.Msg['ACTUATORS_KITRONIK_CONTROLMOTOR_TITLE'] = '[Shield Kitronik] contrôler le moteur %1 direction %2 vitesse %3';
Blockly.Msg['ACTUATORS_KITRONIK_CONTROLMOTOR_TOOLTIP'] = IMG_SHIELD_KITRONIK + Blockly.Tooltip.SEP + 'Permet de contrôler MOTOR1, MOTOR2 ou les deux en changeant le sens (↻ : MARCHE AVANT, ↺ : MARCHE ARRIÈRE) ou la vitesse (de 0 à 100 %) du shield moteur Kitronik pour BBC:microbit. L\'alimentation du shield doit être comprise entre 3V et 10V.';
Blockly.Msg['ACTUATORS_KITRONIK_STOPMOTOR_TITLE'] = '[Shield Kitronik] arrêter le moteur %1';
Blockly.Msg['ACTUATORS_KITRONIK_STOPMOTOR_TOOLTIP'] = IMG_SHIELD_KITRONIK + Blockly.Tooltip.SEP + 'Permet d\'arrêter le MOTOR1, MOTOR2 ou les deux du shield moteur Kitronik pour BBC:microbit. L\'alimentation du shield doit être comprise entre 3V et 10V. ';
Blockly.Msg['ACTUATORS_KITRONIK_MOTOR_BOTH'] = 'les deux';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Module relais] contrôler le relais à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Permet de contrôler la valeur du relais (0 ou 1) sur les broches digitales P0 à P20.';
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TITLE'] = '[MOSFET] contrôler à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permet de contrôler l\'état du transitor MOSFET (0 ou 1) sur une broche PWM.';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TITLE'] = '[MOSFET] contrôler la puissance à %1 (%) sur la broche %2';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permet de contrôler la puissance de sortie du transitor MOSFET (de 0 à 100 %) sur une broche PWM.';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Moteur à vibration] contrôler le moteur à l\'état %1 sur la broche  %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver le moteur à vibration grove (0 ou 1) sur les broches digitales P0 à P20.';
// actuators - Kitronic Traffic
Blockly.Msg['ACTUATORS_ACCESSBIT_CONTROLBARRIER_TITLE'] = "[ACCESS:BIT] %1 la barrière";
Blockly.Msg['ACTUATORS_ACCESSBIT_CONTROLBARRIER_RAISE'] = "lever";
Blockly.Msg['ACTUATORS_ACCESSBIT_CONTROLBARRIER_LOWER'] = "abaisser";
Blockly.Msg['ACTUATORS_ACCESSBIT_CONTROLBARRIER_TOOLTIP'] = IMG_MODULE_ACCESSBIT + Blockly.Tooltip.SEP + "Contrôle la position de la barrière"
Blockly.Msg['ACTUATORS_ACCESSBIT_CONTROLBUZZER_TITLE'] = "[ACCESS:BIT] Allumer le buzzer pendant %1 ms";
Blockly.Msg['ACTUATORS_ACCESSBIT_CONTROLBUZZER_TOOLTIP'] = IMG_MODULE_ACCESSBIT + Blockly.Tooltip.SEP + "Fait vibrer le buzzer pendant le temps donné"

Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TITLE'] = '[Music] jouer la musique %1 sur %2';
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une musique avec le module buzzer ou speaker grove sur les broches digitales P0 à P20.';
Blockly.Msg['ACTUATORS_MUSIC_PLAYSONG_TITLE'] = '[Music] jouer la mélodie %1 %2 sur %3';
Blockly.Msg['ACTUATORS_MUSIC_PLAYSONG_ONCE'] = 'une fois';
Blockly.Msg['ACTUATORS_MUSIC_PLAYSONG_LOOP'] = 'en boucle';
Blockly.Msg['ACTUATORS_MUSIC_PLAYSONG_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une musique avec un module buzzer ou speaker sur les broches digitales P0 à P20.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TITLE'] = '[Music] jouer les notes sur';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer des notes avec un module buzzer ou speaker sur les broches digitales P0 à P20.';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TITLE'] = 'note %1 à l\'octave %2 durée %3';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de définir une note avec son octave et sa durée.';
Blockly.Msg['NOTE_C'] = 'Do';
Blockly.Msg['NOTE_C_SHARP'] = 'Do#';
Blockly.Msg['NOTE_D'] = 'Ré';
Blockly.Msg['NOTE_D_SHARP'] = 'Ré#';
Blockly.Msg['NOTE_E'] = 'Mi';
Blockly.Msg['NOTE_F'] = 'Fa';
Blockly.Msg['NOTE_F_SHARP'] = 'Fa#';
Blockly.Msg['NOTE_G'] = 'Sol';
Blockly.Msg['NOTE_G_SHARP'] = 'Sol#';
Blockly.Msg['NOTE_A'] = 'La';
Blockly.Msg['NOTE_A_SHARP'] = 'La#';
Blockly.Msg['NOTE_B'] = 'Si';
Blockly.Msg['MUSIC_SILENCE'] = 'Silence';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TITLE'] = '[Music] jouer la fréquence %1 pendant %2 (ms) sur %3';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une fréquence sur le haut-parleur intégré à la micro:bit ou avec un module buzzer (ou speaker) sur les broches digitales P0 à P20.';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TITLE'] = '[Music] arrêter la musique sur %1';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet d\'arrêter la musique en cours du haut-parleur intégré ou du buzzer sur les broches digitales P0 à P20.';
Blockly.Msg['ACTUATORS_MUSIC_SETVOLUME_TITLE'] = '[Music] définir le volume à %1';
Blockly.Msg['ACTUATORS_MUSIC_SETVOLUME_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de changer le volume du haut-parleur intégré à la micro:bit de 0 à 255.';
Blockly.Msg['ACTUATORS_MUSIC_SETTEMPO_TITLE'] = '[Music] définir la pulsation %1 et le tempo %2';
Blockly.Msg['ACTUATORS_MUSIC_SETTEMPO_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de définir le nombre de pulsations par mesure et le tempo de la musique jouée par les fonctions de la librairie music.';
Blockly.Msg['ACTUATORS_MUSIC_GETTEMPO_TITLE'] = '[Music] tempo de la musique';
Blockly.Msg['ACTUATORS_MUSIC_GETTEMPO_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet d\'obtenir le tempo de la musique dans un tuple d\'entiers (ticks, bpm).';
Blockly.Msg['ACTUATORS_KITRONIK_PLAY_FREQUENCY_TITLE'] = '[Kitronik env.] jouer la fréquence %1 pendant %2 ms';
Blockly.Msg['ACTUATORS_KITRONIK_PLAY_FREQUENCY_TOOLTIP'] = IMG_SHIELD_KITRONIK_ENV + Blockly.Tooltip.SEP + 'Permet de jouer une fréquence sur le haut-parleur intégré au shield Kitronik environmental.';
Blockly.Msg['ACTUATORS_SPEECH_SAYSOMETHING_TITLE'] = '[Speech] dire %1 vitesse %2 hauteur %3';
Blockly.Msg['ACTUATORS_SPEECH_SAYSOMETHING_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de dire une phrase avec la carte micro:bit. Il est possible de régler la vitesse et la hauteur de la voix (de 0 à 255).';
// Actuators - Others
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TITLE'] = '[Electroaimant] contrôler à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TOOLTIP'] = IMG_MODULE_ELECTROMAGNET + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver l\'électroaimant (HAUT ou BAS) sur les broches digitales.';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TITLE'] = '[Atomiseur d\'eau] contrôler à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TOOLTIP'] = IMG_MODULE_WATER_ATOMIZER + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver l\'atomiseur d\'eau (HAUT ou BAS) sur les broches digitales.';
// Robots - Remote Control
Blockly.Msg['ROBOTS_REMOTECONTROL_ONCOMMANDRECEIVED_TITLE'] = 'si la commande %1';
Blockly.Msg['ROBOTS_REMOTECONTROL_ONCOMMANDRECEIVED_RECEIVED_THEN'] = 'est reçue alors';
Blockly.Msg['ROBOTS_REMOTECONTROL_ONCOMMANDRECEIVED_BLACK_NEC_DETECTED_THEN'] = 'est reçue par télécommande noire NEC alors';
Blockly.Msg['ROBOTS_REMOTECONTROL_ONCOMMANDRECEIVED_BLACK_NEC_TOOLTIP'] = IMG_MODULE_BASIC_BLACK_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une des commandes est reçue d\'une télécommande NEC noire basique par transmission infrarouge. Il n\'est pas nécéssaire d\'utiliser le bloc \'décoder le récepteur infrarouge\'.';
Blockly.Msg['ROBOTS_REMOTECONTROL_ONCOMMANDRECEIVED_CAR_MP3_GRAY_DETECTED_THEN'] = 'est reçue par télécommande grise Car mp3 NEC alors';
Blockly.Msg['ROBOTS_REMOTECONTROL_ONCOMMANDRECEIVED_CAR_MP3_GRAY_TOOLTIP'] = IMG_MODULE_CAR_MP3_GRAY_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une des commandes est reçue d\'une télécommande NEC grise de type C_ar mp3 par transmission infrarouge. Il n\'est pas nécéssaire d\'utiliser le bloc \'décoder le récepteur infrarouge\'.';
Blockly.Msg['REMOTE_NEC_BUTTON'] = 'touche ';
Blockly.Msg['REMOTE_NEC_BUTTON_UP'] = 'haut';
Blockly.Msg['REMOTE_NEC_BUTTON_DOWN'] = 'bas';
Blockly.Msg['REMOTE_NEC_BUTTON_LEFT'] = 'gauche';
Blockly.Msg['REMOTE_NEC_BUTTON_RIGHT'] = 'droit';
Blockly.Msg['REMOTE_NEC_BUTTON_BACK'] = 'Retour';
// Robots - Maqueen
Blockly.Msg['ROBOTS_MAQUEEN_RIGHT'] = 'droit';
Blockly.Msg['ROBOTS_MAQUEEN_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_MAQUEEN_RIGHT&LEFT'] = 'droit & gauche';
Blockly.Msg['ROBOTS_MAQUEEN_ULTRASONICRANGER_TITLE'] = '[Maqueen] %1';
Blockly.Msg['ROBOTS_MAQUEEN_ULTRASONICRANGER_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Renvoie la distance (en cm) ou la durée de l\'aller-retour (en μs) de l\'onde entre un object et le robot Maqueen grâce au capteur à ultrasons.';
Blockly.Msg['ROBOTS_MAQUEEN_ULTRASONIC_DISTANCE'] = 'distance (cm)';
Blockly.Msg['ROBOTS_MAQUEEN_ULTRASONIC_DURATION'] = 'durée de l\'aller-retour (μs)';
Blockly.Msg['ROBOTS_MAQUEEN_CONTROLLED_TITLE'] = '[Maqueen] contrôler la LED rouge avant %1 état %2';
Blockly.Msg['ROBOTS_MAQUEEN_CONTROLLED_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permet de contrôler l\'état de la LED gauche (P8) ou droite (P12) du robot Maqueen.';
Blockly.Msg['ROBOTS_MAQUEEN_GO_TITLE'] = '[Maqueen] contrôler le robot %1 vitesse %2';
Blockly.Msg['ROBOTS_MAQUEEN_GO_FORWARD'] = 'avancer';
Blockly.Msg['ROBOTS_MAQUEEN_GO_REVERSE'] = 'reculer';
Blockly.Msg['ROBOTS_MAQUEEN_GO_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permet de contrôler la marche (AVANT/ARRIERE) ainsi que la vitesse (de 0 à 255) du robot Maqueen.';
Blockly.Msg['ROBOTS_MAQUEEN_CONTROLMOTOR_TITLE'] = '[Maqueen] contrôler le moteur %1 direction %2 vitesse %3';
Blockly.Msg['ROBOTS_MAQUEEN_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit (adresse I2C: 0x02) et gauche (adresse I2C: 0x00) en changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 255) du robot Maqueen.';
Blockly.Msg['ROBOTS_MAQUEEN_ROTATE_TITLE'] = '[Maqueen] pivoter %1 vitesse %2';
Blockly.Msg['ROBOTS_MAQUEEN_ROTATE_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit (adresse I2C: 0x02) et gauche (adresse I2C: 0x00) en changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 255) du robot Maqueen.';
Blockly.Msg['ROBOTS_MAQUEEN_STOPMOTORS_TITLE'] = '[Maqueen] arrêter le moteur %1';
Blockly.Msg['ROBOTS_MAQUEEN_STOPMOTORS_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permet d\'arrêter le moteur droit ou gauche du robot Maqueen.';
Blockly.Msg['ROBOTS_MAQUEEN_SETSERVOANGLE_TITLE'] = '[Maqueen] positionner le servomoteur %1 à l\'angle %2 °';
Blockly.Msg['ROBOTS_MAQUEEN_SETSERVOANGLE_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permet de contrôler les servomoteurs S1 (adresse I2C: 0x14) and S2 (adresse I2C: 0x15) en changeant l\'angle (de 0 à 180) du robot Maqueen.';
Blockly.Msg['ROBOTS_MAQUEEN_S1'] = 'S1';
Blockly.Msg['ROBOTS_MAQUEEN_S2'] = 'S2';
Blockly.Msg['ROBOTS_MAQUEEN_SERVO_BOTH'] = 'les deux';
Blockly.Msg['ROBOTS_MAQUEEN_MOVE_ONE_SQUARE_FORWARD_TITLE'] = '[Maqueen] avancer d\'une case';
Blockly.Msg['ROBOTS_MAQUEEN_MOVE_ONE_SQUARE_FORWARD_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Avance le robot Maqueen d\'une case.';
Blockly.Msg['ROBOTS_MAQUEEN_MOVE_ONE_SQUARE_BACKWARD_TITLE'] = '[Maqueen] reculer d\'une case';
Blockly.Msg['ROBOTS_MAQUEEN_MOVE_ONE_SQUARE_BACKWARD_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Recule le robot Maqueen d\'une case.';
Blockly.Msg['ROBOTS_MAQUEEN_TURN_LEFT_TITLE'] = '[Maqueen] pivoter à gauche';
Blockly.Msg['ROBOTS_MAQUEEN_TURN_LEFT_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Pivote le robot Maqueen de 90° vers la gauche.';
Blockly.Msg['ROBOTS_MAQUEEN_TURN_RIGHT_TITLE'] = '[Maqueen] pivoter à droite';
Blockly.Msg['ROBOTS_MAQUEEN_TURN_RIGHT_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Pivote le robot Maqueen de 90° vers la droite.';
Blockly.Msg['ROBOTS_MAQUEEN_STOP_ROBOT_TITLE'] = '[Maqueen] arrêter le robot';
Blockly.Msg['ROBOTS_MAQUEEN_STOP_ROBOT_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Arrête les moteurs du robot Maqueen.';
Blockly.Msg['ROBOTS_MAQUEEN_BLINK_ROBOT_TITLE'] = '[Maqueen] clignoter le robot';
Blockly.Msg['ROBOTS_MAQUEEN_BLINK_ROBOT_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Fait clignoter le robot Maqueen.';
Blockly.Msg['ROBOTS_MAQUEEN_READPATROL_TITLE'] = '[Maqueen]  état du capteur de ligne %1';
Blockly.Msg['ROBOTS_MAQUEEN_READPATROL_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permet de lire l\'état du capteur suiveur de ligne gauche ou droit du robot Maqueen. Le bloc renvoit 0 si le capteur se trouve au dessus de la ligne.';
Blockly.Msg['ROBOTS_MAQUEEN_SETNEOPIXEL_TITLE'] = '[Maqueen] contrôler la LED RGB en dessous %1 à R %2 G %3 B %4';
Blockly.Msg['ROBOTS_MAQUEEN_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED RGB du neopixel du robot Maqueen (P15) tel que les valeurs R,G,B soient comprises entre 0 et 255. Le neopixel est connecté à la broche P15 sur le robot.';
Blockly.Msg['ROBOTS_MAQUEEN_SETPALETTECOLOR_TITLE'] = '[Maqueen] contrôler la LED RGB en dessous %1 à %2';
Blockly.Msg['ROBOTS_MAQUEEN_SETPALETTECOLOR_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED RGB du module neopixel (P15) situé sous le robot Maqueen. Utiliser la palette pour changer la couleur.';
Blockly.Msg['ROBOTS_MAQUEEN_SETRAINBOW_TITLE'] = '[Maqueen] Arc-en-ciel';
Blockly.Msg['ROBOTS_MAQUEEN_SETRAINBOW_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB (P15).';
Blockly.Msg['ROBOTS_MAQUEEN_SETBUZZER_TITLE'] = '[Maqueen] contrôler le buzzer à la fréquence %1 pendant %2 (ms)';
Blockly.Msg['ROBOTS_MAQUEEN_SETBUZZER_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permet de définir une fréquence sur le buzzer du robot Maqueen (P0).';
Blockly.Msg['ROBOTS_MAQUEEN_PLAYMUSIC_TITLE'] = '[Maqueen] jouer la musique %1';
Blockly.Msg['ROBOTS_MAQUEEN_PLAYMUSIC_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permet de jouer une musique avec le buzzer du robot Maqueen connecté à la broche (P0).';
Blockly.Msg['ROBOTS_MAQUEEN_DECODEIRRECEIVER_TITLE'] = '[Maqueen] decoder le récepteur infrarouge';
Blockly.Msg['ROBOTS_MAQUEEN_DECODEIRRECEIVER_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Effectue une lecture du récepteur infrarouge (P16) du robot Maqueen.';
Blockly.Msg['ROBOTS_MAQUEEN_GETIRCODE_TITLE'] = '[Maqueen] code reçu du récepteur infrarouge';
Blockly.Msg['ROBOTS_MAQUEEN_GETIRCODE_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Renvoie le code hexadecimal reçu avec le détecteur infrarouge (P16) du robot Maqueen.';
// Robots - MaqueenPlus
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V2_ULTRASONICRANGER_TITLE'] = '[MaqueenPlus v2] %1';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V2_ULTRASONICRANGER_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS_V2 + Blockly.Tooltip.SEP + 'Renvoie la distance (en cm) ou la durée de l\'aller-retour (en μs) de l\'onde entre un object et le robot MaqueenPlus grâce au capteur à ultrasons.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_ULTRASONICRANGER_TRIG_ECHO_TITLE'] = '[MaqueenPlus %1] %2 TRIG %3 ECHO %4';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_ULTRASONICRANGER_TRIG_ECHO_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Renvoie la distance (en cm) ou la durée de l\'aller-retour (en μs) de l\'onde entre un object et le robot MaqueenPlus grâce au capteur à ultrasons branché sur les broches digitales indiquées.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V1_READPATROL_TITLE'] = '[MaqueenPlus v1]  état du capteur de ligne %1';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V1_READPATROL_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Permet de lire l\'état d\'un des capteurs suiveur de ligne du robot MaqueenPlus. Le bloc renvoit 1 si le capteur se trouve au dessus de la ligne.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V2_READPATROL_TITLE'] = '[MaqueenPlus v2]  état du capteur de ligne %1';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V2_READPATROL_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS_V2 + Blockly.Tooltip.SEP + 'Permet de lire l\'état d\'un des capteurs suiveur de ligne du robot MaqueenPlus. Le bloc renvoit 0 si le capteur se trouve au dessus de la ligne.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_LEFT_REAR'] = "arrière gauche";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_LEFT'] = "gauche";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_MIDDLE_LEFT'] = "milieu gauche";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_MIDDLE'] = "milieu";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_MIDDLE_RIGHT'] = "milieu droit";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_RIGHT'] = "droit";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_RIGHT_REAR'] = "arrière droit";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_CONTROLLED_TITLE'] = '[MaqueenPlus %1] contrôler la LED rouge avant %2 état %3';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_CONTROLLED_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Permet de contrôler l\'état de la LED gauche ou droite du robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_LED_LEFT'] = "gauche";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_LED_RIGHT'] = "droite";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_LED_LEFT&RIGHT'] = "gauche & droite";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_GO_TITLE'] = '[MaqueenPlus %1] contrôler le robot %2 vitesse %3';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_GO_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Permet de contrôler la marche (AVANT/ARRIERE) ainsi que la vitesse (de 0 à 255) du robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_ROTATE_TITLE'] = '[MaqueenPlus %1] pivoter %2 vitesse %3';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_ROTATE_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit et gaucheen changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 255) du robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_CONTROLMOTOR_TITLE'] = '[MaqueenPlus %1] contrôler le moteur %2 direction %3 vitesse %4';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit et gauche en changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 255) du robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_STOPMOTORS_TITLE'] = '[MaqueenPlus %1] arrêter le moteur %2';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_STOPMOTORS_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Permet d\'arrêter le moteur droit ou gauche du robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V1_SETSERVOANGLE_TITLE'] = '[MaqueenPlus v1] positionner le servomoteur %1 à l\'angle %2 °';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V1_SETSERVOANGLE_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Permet de contrôler les servomoteurs P0, P1, P2 en changeant l\'angle (de 0 à 180) du robot MaqueenPlus V1.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V2_SETSERVOANGLE_TITLE'] = '[MaqueenPlus v2] positionner le servomoteur %1 à l\'angle %2 °';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V2_SETSERVOANGLE_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS_V2 + Blockly.Tooltip.SEP + 'Permet de contrôler les servomoteurs P0, P1, P2 en changeant l\'angle (de 0 à 180) du robot MaqueenPlusc V2.'
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETNEOPIXEL_TITLE'] = '[MaqueenPlus v2] contrôler la LED RGB en dessous %1 à R %2 G %3 B %4';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS_V2 + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED RGB du neopixel du robot MaqueenPlus tel que les valeurs R,G,B soient comprises entre 0 et 255.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_BLINK_ROBOT_TITLE'] = '[MaqueenPlus v2] clignoter le robot';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_BLINK_ROBOT_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS_V2 + Blockly.Tooltip.SEP + 'Fait clignoter le robot MaqueenPlus v2.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETPALETTECOLOR_TITLE'] = '[MaqueenPlus v2] contrôler la LED RGB en dessous %1 à %2';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETPALETTECOLOR_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS_V2 + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED RGB du module neopixel situé sous le robot MaqueenPlus. Utiliser la palette pour changer la couleur.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETRAINBOW_TITLE'] = '[MaqueenPlus v2] Arc-en-ciel';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETRAINBOW_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS_V2 + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETBUZZER_TITLE'] = '[MaqueenPlus %1] contrôler le buzzer à la fréquence %2 pendant %3 (ms)';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETBUZZER_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Permet de définir une fréquence sur le buzzer du robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_DECODEIRRECEIVER_TITLE'] = '[MaqueenPlus] décoder le récepteur infrarouge';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_DECODEIRRECEIVER_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Effectue une lecture du récepteur infrarouge du robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_GETIRCODE_TITLE'] = '[MaqueenPlus] code reçu du récepteur infrarouge';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_GETIRCODE_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Renvoie le code hexadecimal reçu avec le détecteur infrarouge du robot MaqueenPlus.';
// Robots - Cutebot
Blockly.Msg['ROBOTS_CUTEBOT_ULTRASONICRANGER_TITLE'] = '[Cutebot] %1';
Blockly.Msg['ROBOTS_CUTEBOT_ULTRASONICRANGER_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Renvoie la distance (en cm) ou la durée de l\'aller-retour (en μs) de l\'onde entre un objet et le robot Cutebot grâce au capteur à ultrasons.';
Blockly.Msg['ROBOTS_CUTEBOT_ULTRASONIC_DISTANCE'] = 'distance (cm)';
Blockly.Msg['ROBOTS_CUTEBOT_ULTRASONIC_DURATION'] = 'durée de l\'aller-retour (μs)';
Blockly.Msg['ROBOTS_CUTEBOT_BLINK_ROBOT_TITLE'] = '[Cutebot] clignoter le robot';
Blockly.Msg['ROBOTS_CUTEBOT_BLINK_ROBOT_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Fait clignoter le robot Cutebot.';
Blockly.Msg['ROBOTS_CUTEBOT_READPATROL_TITLE'] = '[Cutebot] état du capteur de ligne %1';
Blockly.Msg['ROBOTS_CUTEBOT_RIGHT'] = 'droite';
Blockly.Msg['ROBOTS_CUTEBOT_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_CUTEBOT_READPATROL_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permet de lire l\'état du capteur suiveur de ligne gauche ou droit du robot Cutebot. Le bloc renvoie 1 si le capteur se trouve au-dessus de la ligne.';
Blockly.Msg['ROBOTS_CUTEBOT_CONTROLLED_TITLE'] = '[Cutebot] contrôler la LED RGB %1 %2';
Blockly.Msg['ROBOTS_CUTEBOT_CONTROLLED_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED RGB du robot Cutebot en sélectionnant une couleur dans la palette à disposition.';
Blockly.Msg['ROBOTS_CUTEBOT_CONTROL_RGB_LED_TITLE'] = '[Cutebot] contrôler la LED RGB %1 R %2 G %3 B %4';
Blockly.Msg['ROBOTS_CUTEBOT_CONTROL_RGB_LED_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED RGB du robot Cutebot telle que les valeurs R,G,B soient comprises entre 0 et 255.';
Blockly.Msg['ROBOTS_CUTEBOT_SETNEOPIXEL_TITLE'] = '[Cutebot] contrôler la LED RGB en dessous à %1 R %2 G %3 B %4';
Blockly.Msg['ROBOTS_CUTEBOT_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED RGB du neopixel du robot Cutebot (P15) telle que les valeurs R,G,B soient comprises entre 0 et 255. Le neopixel est connecté à la broche P15 sur le robot.';
Blockly.Msg['ROBOTS_CUTEBOT_SETPALETTECOLOR_TITLE'] = '[Cutebot] contrôler la LED RGB en dessous à %1 %2';
Blockly.Msg['ROBOTS_CUTEBOT_SETPALETTECOLOR_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED RGB du module neopixel (P15) situé sous le robot Cutebot. Utiliser la palette pour changer la couleur.';
Blockly.Msg['ROBOTS_CUTEBOT_GO_TITLE'] = '[Cutebot] contrôler le robot %1 vitesse %2 %';
Blockly.Msg['ROBOTS_CUTEBOT_GO_FORWARD'] = 'avancer';
Blockly.Msg['ROBOTS_CUTEBOT_GO_BACKWARD'] = 'reculer';
Blockly.Msg['ROBOTS_CUTEBOT_GO_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs du robot Cutebot pour le faire avancer ou reculer à une vitesse comprise entre 0 et 100%.';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_TITLE'] = '[Cutebot] pivoter à %1 vitesse %2 %';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_RIGHT'] = 'droite';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs du robot Cutebot pour le faire pivoter (à gauche ou à droite) à une vitesse comprise entre 0 et 100%.';
Blockly.Msg['ROBOTS_CUTEBOT_STOP_TITLE'] = '[Cutebot] arrêter le robot';
Blockly.Msg['ROBOTS_CUTEBOT_STOP_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permet d\'arrêter les moteurs du robot Cutebot.';
Blockly.Msg['ROBOTS_CUTEBOT_CONTROLMOTOR_TITLE'] = '[Cutebot] contrôler le moteur %1 direction %2 vitesse %3 %';
Blockly.Msg['ROBOTS_CUTEBOT_MOTOR_RIGHT'] = 'droit';
Blockly.Msg['ROBOTS_CUTEBOT_MOTOR_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_CUTEBOT_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit et gauche en changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 100%) du robot Cutebot.';
Blockly.Msg['ROBOTS_CUTEBOT_SETSERVOANGLE_TITLE'] = '[Cutebot] positionner le.s servomoteur.s %1 à l\'angle %2°';
Blockly.Msg['ROBOTS_CUTEBOT_S1'] = 'S1';
Blockly.Msg['ROBOTS_CUTEBOT_S2'] = 'S2';
Blockly.Msg['ROBOTS_CUTEBOT_SERVO_BOTH'] = 'S1 et S2';
Blockly.Msg['ROBOTS_CUTEBOT_SETSERVOANGLE_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permet de contrôler les servomoteurs S1 et S2 en changeant l\'angle (de 0 à 180°) du robot Cutebot.';
Blockly.Msg['ROBOTS_CUTEBOT_MOVE_ONE_SQUARE_FORWARD_TITLE'] = '[Cutebot] avancer d\'une case';
Blockly.Msg['ROBOTS_CUTEBOT_MOVE_ONE_SQUARE_FORWARD_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Avance le robot Cutebot d\'une case.';
Blockly.Msg['ROBOTS_CUTEBOT_MOVE_ONE_SQUARE_BACKWARD_TITLE'] = '[Cutebot] reculer d\'une case';
Blockly.Msg['ROBOTS_CUTEBOT_MOVE_ONE_SQUARE_BACKWARD_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Recule le robot Cutebot d\'une case.';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_LEFT_TITLE'] = '[Cutebot] pivoter à gauche';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_LEFT_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Pivote le robot Cutebot de 90° vers la gauche.';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_RIGHT_TITLE'] = '[Cutebot] pivoter à droite';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_RIGHT_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Pivote le robot Cutebot de 90° vers la droite.';
Blockly.Msg['ROBOTS_CUTEBOT_SETBUZZER_TITLE'] = '[Cutebot] contrôler le buzzer à la fréquence %1 pendant %2 (ms)';
Blockly.Msg['ROBOTS_CUTEBOT_SETBUZZER_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permet de définir une fréquence sur le buzzer du robot Cutebot (P0).';
Blockly.Msg['ROBOTS_CUTEBOT_PLAYMUSIC_TITLE'] = '[Cutebot] jouer la musique %1';
Blockly.Msg['ROBOTS_CUTEBOT_PLAYMUSIC_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permet de jouer une musique avec le buzzer du robot Cutebot connecté à la broche (P0).';
Blockly.Msg['ROBOTS_CUTEBOT_DECODEIRRECEIVER_TITLE'] = '[Cutebot] décoder le récepteur infrarouge';
Blockly.Msg['ROBOTS_CUTEBOT_DECODEIRRECEIVER_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Effectue une lecture du récepteur infrarouge (P16) du robot Cutebot.';
Blockly.Msg['ROBOTS_CUTEBOT_GETIRCODE_TITLE'] = '[Cutebot] code reçu du récepteur infrarouge';
Blockly.Msg['ROBOTS_CUTEBOT_GETIRCODE_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Renvoie le code hexadecimal reçu avec le détecteur infrarouge (P16) du robot Cutebot.';
// Robots - Cutebot Pro - Detection
Blockly.Msg['ROBOTS_CUTEBOTPRO_ULTRASONICRANGER_TITLE'] = '[Cutebot Pro] distance en %1';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ULTRASONIC_CM'] = '(cm)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ULTRASONIC_INCH'] = '(inch)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ULTRASONICRANGER_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Renvoie la distance (en cm ou en inch) de l\'onde entre un objet et le robot Cutebot Pro grâce au capteur à ultrasons. Ce dernier est lié à la broche P8 et P12 de la carte BBC micro:bit.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETLINESTATE_TITLE'] = '[Cutebot Pro] état du suiveur de ligne';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETLINESTATE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'obtenir l\'état du suiveur de ligne. Celui-ci est composé de 4 capteurs à infrarouges situés sous le robot Cutebot Pro qui renvoient donc 16 états différents (entiers de 0 à 15).';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ISSPECIFICSTATE_TITLE'] = '[Cutebot Pro] état du suiveur de ligne est %1';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ISSPECIFICSTATE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Renvoie Vrai si le suiveur de ligne détecte l\'état specifié dans le bloc. Le suiveur de ligne est composé de 4 capteurs à infrarouges situés sous le robot Cutebot Pro qui renvoient 16 états différents (entiers de 0 à 15). Pour chaque état du suiveur de ligne, les valeurs des 4 capteurs tel que [gauche, centre gauche, centre droit, droit], soit en regardant dans la direction du robot.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETLINEOFFSET_TITLE'] = '[Cutebot Pro] décalage par rapport à la ligne en %1';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETLINEOFFSET_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'obtenir le décalage (en cm) ou (en inch) par rapport à la ligne de -3 cm (robot décalé à droite) à 3 cm (robot décalé à gauche). 0 signifie que le robot se trouve bien dans l\'alignement. Il est possible ainsi d\'orienter le robot selon cette valeur pour suivre la ligne.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ISABOVELINE_TITLE'] = '[Cutebot Pro] capteur %1 au-dessus de la ligne noire ?';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ISABOVELINE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Retourne Vrai si le capteur sélectionné du suiveur de ligne (de 1 à 4) se trouve au-dessus d\'une ligne noire.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETGRAYSCALEVALUE_TITLE'] = '[Cutebot Pro] niveau de gris du capteur %1';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETGRAYSCALEVALUE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'obtenir la valeur du capteur sélectionné du suiveur de ligne (de 1 à 4) en niveau de gris, de 0 à 255.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_READVERSION_TITLE'] = '[Cutebot Pro] version du robot';
Blockly.Msg['ROBOTS_CUTEBOTPRO_READVERSION_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'obtenir la version du robot Cutebot Pro.';
// Robots - Cutebot Pro - Moving
Blockly.Msg['ROBOTS_CUTEBOTPRO_GO_TITLE'] = '[Cutebot Pro] %1 à la vitesse %2 %';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GO_FORWARD'] = 'avancer';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GO_BACKWARD'] = 'reculer';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GO_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs du robot Cutebot Pro pour le faire avancer ou reculer à une vitesse comprise entre 0 et 100 %.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURN_TITLE'] = '[Cutebot Pro] tourner à %1 vitesse %2 %';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURN_RIGHT'] = 'droite';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURN_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURN_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs du robot Cutebot Pro pour le faire pivoter (à gauche ou à droite) à une vitesse comprise entre 0 et 100 %.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_STOP_TITLE'] = '[Cutebot Pro] arrêter les moteurs du robot';
Blockly.Msg['ROBOTS_CUTEBOTPRO_STOP_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'arrêter les moteurs du robot Cutebot Pro.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_CONTROLMOTOR_TITLE'] = '[Cutebot Pro] contrôler le moteur %1 direction %2 vitesse %3 %';
Blockly.Msg['ROBOTS_CUTEBOTPRO_MOTOR_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_CUTEBOTPRO_MOTOR_RIGHT'] = 'droit';
Blockly.Msg['ROBOTS_CUTEBOTPRO_MOTOR_BOTH'] = 'gauche & droit';
Blockly.Msg['ROBOTS_CUTEBOTPRO_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit et gauche en changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 100 %) du robot Cutebot Pro.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_UNIT_CM_S'] = '(cm/s)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_UNIT_INCH_S'] = '(inch/s)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETMOTORSPEED_TITLE'] = '[Cutebot Pro] vitesse du moteur %1 en %2';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETMOTORSPEED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'obtenir la vitesse de la roue sélectionnée (en m/s) ou en (inch/s) du robot Cutebot Pro.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETANGULARDISTANCE_DEGREES'] = 'distance angulaire parcourue (°)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETANGULARDISTANCE_ROTATIONS'] = 'tours effectués';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETANGULARDISTANCE_PULSES'] = 'impulsions détectées';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETANGULARDISTANCE_TITLE'] = '[Cutebot Pro] %1 de la roue %2';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETANGULARDISTANCE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'obtenir la distance angulaire parcourue (en °) ou le nombre d\'impulsions détectées par une des roues du robot Cutebot Pro depuis la dernière initialisation. Noter qu\'une rotation de 1 ° correspond à 4 impulsions. Attention, plus la distance angulaire parcourue est faible, moins la mesure est précise.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_INITANGULARDISTANCE_TITLE'] = '[Cutebot Pro] réinitialiser la mesure angulaire %1';
Blockly.Msg['ROBOTS_CUTEBOTPRO_INITANGULARDISTANCE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de réinitialiser la mesure de la distance angulaire parcourue par chaque roue du robot Cutebot Pro.';
// Robots - Cutebot Pro - RGB LED
Blockly.Msg['ROBOTS_CUTEBOTPRO_RIGHT'] = 'droite';
Blockly.Msg['ROBOTS_CUTEBOTPRO_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_CUTEBOTPRO_BOTH'] = 'droite & gauche';
Blockly.Msg['ROBOTS_CUTEBOTPRO_CONTROLLED_TITLE'] = '[Cutebot Pro] contrôler la LED RGB %1 %2';
Blockly.Msg['ROBOTS_CUTEBOTPRO_CONTROLLED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de la LED RGB gauche ou droite du robot Cutebot Pro en sélectionnant une couleur dans la palette à disposition.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_CONTROL_RGB_LED_TITLE'] = '[Cutebot Pro] contrôler la LED RGB %1 R %2 G %3 B %4';
Blockly.Msg['ROBOTS_CUTEBOTPRO_CONTROL_RGB_LED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de la LED RGB gauche ou droite du robot Cutebot Pro telle que les valeurs R,G,B soient comprises entre 0 et 255.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SWITCHOFFLED_TITLE'] = '[Cutebot Pro] éteindre les deux LED RGB avant';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SWITCHOFFLED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'éteindre les deux LED RGB avant du robot Cutebot Pro.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETNEOPIXEL_TITLE'] = '[Cutebot Pro] contrôler la LED RGB en dessous %1 à R %2 G %3 B %4';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur des deux LED RGB du module neopixel situé sous le robot Cutebot Pro tel que les valeurs (R,G,B) soient comprises entre 0 et 255. Le module est lié à la broche P15 de la carte BBC micro:bit.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETNEOPIXELPALETTE_TITLE'] = '[Cutebot Pro] contrôler la LED RGB en dessous %1 à %2';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETNEOPIXELPALETTE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur des deux LED RGB du module neopixel situé sous le robot Cutebot Pro. Utiliser la palette pour changer la couleur. Le module est lié à la broche P15 de la carte BBC micro:bit.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SWITCHOFFNEOPIXEL_TITLE'] = '[Cutebot Pro] éteindre la LED RGB en dessous %1';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SWITCHOFFNEOPIXEL_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'éteindre les LED RGB du module neopixel situé sous le robot Cutebot Pro. Le module est lié à la broche P15 de la carte BBC micro:bit.';
// Robots - Cutebot Pro - PID
Blockly.Msg['ROBOTS_CUTEBOTPRO_UNIT_CM'] = '(cm)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_UNIT_INCH'] = '(inch)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNWITHSPEED_TITLE'] = '[Cutebot Pro] %1 à la vitesse %2 %3';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNWITHSPEED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'avancer ou de reculer à une certaine vitesse (en cm/s) ou (en inch/s) avec le robot Cutebot Pro. Attention, les vitesses sont garanties entre 20 et 60 cm/s. En dehors de cet intervalle, les moteurs parviennent moins à établir une vitesse précise.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETMOTORSSPEED_TITLE'] = '[Cutebot Pro] régler la vitesse du moteur gauche à %1 moteur droit à %2 en %3';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETMOTORSSPEED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'appliquer une vitesse (en cm/s) ou (en inch/s) sur les moteurs droit et gauche du robot Cutebot Pro.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNWITHRADIUS_TITLE'] = '[Cutebot Pro] tourner à %1 rayon de braquage %2 à la vitesse %3 %4';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNWITHRADIUS_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de déplacer le robot Cutebot Pro sur un arc avec un rayon de braquage spécificé (en cm) ou (en inch) à une certaine vitesse (en cm/s) ou (en inch/s). Le robot peut se déplacer dans le sens horaire (vers la droite) ou antihoraire (vers la gauche). Attention, la vitesse et le rayon de braquage doivent être dans la même unité spatiale.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUN_WAITING'] = 'attendre ?';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUN_WAITING_YES']= 'oui';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUN_WAITING_NO'] = 'non';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNDISTANCE_TITLE'] = '[Cutebot Pro] %1 de %2 %3';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNDISTANCE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de parcourir une certaine distance (en cm) ou (en inch) en marche AVANT ou ARRIERE avec le robot Cutebot Pro.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURNWITHANGLE_TITLE'] = '[Cutebot Pro] tourner à %1 de %2 °';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURNWITHANGLE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de tourner le robot Cutebot Pro à gauche ou à droite d\'un certain angle (en °).';
Blockly.Msg['ROBOTS_CUTEBOTPRO_DEFINESQUARE_TITLE'] = '[Cutebot Pro] définir la dimension d\'une case à %1 %2';
Blockly.Msg['ROBOTS_CUTEBOTPRO_DEFINESQUARE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de définir la dimension d\'une case (en cm) ou (en inch) pour le déplacement du robot Cutebot Pro par unité.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNSQUARE_TITLE'] = '[Cutebot Pro] %1 de %2 case.s';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNSQUARE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'avancer ou de reculer d\'un certain nombre de cases. La valeur doit être un nombre entier.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_PLACEWITHANGLE_TITLE'] = '[Cutebot Pro] tourner à %1 à l\'angle %2 °';
Blockly.Msg['ROBOTS_CUTEBOTPRO_PLACEWITHANGLE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de tourner le robot Cutebot Pro à gauche ou à droite à une position angulaire (en °).';
Blockly.Msg['ROBOTS_CUTEBOTPRO_UNIT_DEG'] = '(°)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_UNIT_TOUR'] = '(Tr)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURNWHEEL_TITLE'] = '[Cutebot Pro] tourner la roue %1 de %2 %3';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURNWHEEL_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de tourner les roues droite et/ou gauche d\'un certain angle (en °) ou (en Tr) du robot Cutebot Pro. 1 Tr correspond à 360 °, soit un tour complet de la roue.';
// Robots - Cutebot Pro - Servomotors
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETSERVOANGLE_TITLE'] = '[Cutebot Pro] positionner le.s servomoteur.s %1 à %2 °';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETSERVOANGLE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de contrôler l\'angle (en °) des servomoteurs pouvant se placer sur les broches S1, S2, S3 et S4 à l\'arrière du robot Cutebot Pro.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETSERVOSPEED_TITLE'] = '[Cutebot Pro] contrôler le.s servo.s continu.s %1 direction %2 vitesse %3 %';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETSERVOSPEED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de contrôler la vitesse (en %) des servomoteurs continus pouvant se placer sur les broches S1, S2, S3 et S4 à l\'arrière du robot Cutebot Pro.';
// Robots - Cutebot Pro - Extended motor (M port)
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETEXTENDEDMOTORSPEED_TITLE'] = '[Cutebot Pro] contrôler le moteur direction %1 vitesse %2 % sur le port M';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETEXTENDEDMOTORSPEED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet de contrôler la vitesse (de 0 à 100 %) et le sens de rotation du moteur branché sur le port d\'extension M du robot Cutebot Pro.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_STOPEXTENDEDMOTOR_TITLE'] = '[Cutebot Pro] arrêter le moteur du port M';
Blockly.Msg['ROBOTS_CUTEBOTPRO_STOPEXTENDEDMOTOR_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Permet d\'arrêter le moteur branché sur le port d\'extension M du robot Cutebot Pro.';
// Robots - Cutebot Pro - Remote control
Blockly.Msg['ROBOTS_CUTEBOTPRO_DECODEIRRECEIVER_TITLE'] = '[Cutebot] décoder le récepteur infrarouge';
Blockly.Msg['ROBOTS_CUTEBOTPRO_DECODEIRRECEIVER_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Effectue une lecture du récepteur infrarouge du robot Cutebot Pro. Le récepteur IR est lié à la broche P16 de la carte BBC micro:bit.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETIRCODE_TITLE'] = '[Cutebot] code reçu du récepteur infrarouge';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETIRCODE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Renvoie le code hexadecimal reçu avec le détecteur infrarouge du robot Cutebot Pro. S\'utilise avec le bloc \'décoder le récepteur infrarouge\'. Le récepteur IR est lié à la broche P16 de la carte BBC micro:bit.';
// Robots - Kit:robot v2
Blockly.Msg['ROBOTS_KITROBOT_RIGHT'] = 'droit';
Blockly.Msg['ROBOTS_KITROBOT_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_KITROBOT_RIGHT&LEFT'] = 'droit & gauche';
Blockly.Msg['ROBOTS_KITROBOT_ULTRASONICRANGER_TITLE'] = '[Kit:robot v2] %1';
Blockly.Msg['ROBOTS_KITROBOT_ULTRASONICRANGER_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Renvoie la distance (en cm) ou la durée de l\'aller-retour (en μs) de l\'onde entre un object et le robot Kit:robot v2 grâce au capteur à ultrasons.';
Blockly.Msg['ROBOTS_KITROBOT_ULTRASONIC_DISTANCE'] = 'distance (cm)';
Blockly.Msg['ROBOTS_KITROBOT_ULTRASONIC_DURATION'] = 'durée de l\'aller-retour (μs)';
Blockly.Msg['ROBOTS_KITROBOT_GO_TITLE'] = '[Kit:robot v2] contrôler le robot %1 vitesse %2 %';
Blockly.Msg['ROBOTS_KITROBOT_GO_FORWARD'] = 'avancer';
Blockly.Msg['ROBOTS_KITROBOT_GO_REVERSE'] = 'reculer';
Blockly.Msg['ROBOTS_KITROBOT_GO_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la marche (AVANT/ARRIERE) ainsi que la vitesse (de 0 à 100%) du robot Kit:robot v2.';
Blockly.Msg['ROBOTS_KITROBOT_CONTROLMOTOR_TITLE'] = '[Kit:robot v2] contrôler le moteur %1 direction %2 vitesse %3 %';
Blockly.Msg['ROBOTS_KITROBOT_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit et gauche en changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 100%) du robot Kit:robot v2.';
Blockly.Msg['ROBOTS_KITROBOT_ROTATE_TITLE'] = '[Kit:robot v2] pivoter %1 vitesse %2 %';
Blockly.Msg['ROBOTS_KITROBOT_ROTATE_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit et gauche en changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 100%) du robot Kit:robot v2.';
Blockly.Msg['ROBOTS_KITROBOT_STOPMOTORS_TITLE'] = '[Kit:robot v2] arrêter le moteur %1';
Blockly.Msg['ROBOTS_KITROBOT_STOPMOTORS_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permet d\'arrêter le moteur droit ou gauche du robot Kit:robot v2.';
Blockly.Msg['ROBOTS_KITROBOT_SERVO_BOTH'] = 'les deux';
Blockly.Msg['ROBOTS_KITROBOT_MOVE_ONE_SQUARE_FORWARD_TITLE'] = '[Kit:robot v2] avancer d\'une case';
Blockly.Msg['ROBOTS_KITROBOT_MOVE_ONE_SQUARE_FORWARD_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Avance le robot Kit:robot v2 d\'une case.';
Blockly.Msg['ROBOTS_KITROBOT_MOVE_ONE_SQUARE_BACKWARD_TITLE'] = '[Kit:robot v2] reculer d\'une case';
Blockly.Msg['ROBOTS_KITROBOT_MOVE_ONE_SQUARE_BACKWARD_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Recule le robot Kit:robot v2 d\'une case.';
Blockly.Msg['ROBOTS_KITROBOT_TURN_LEFT_TITLE'] = '[Kit:robot v2] pivoter à gauche';
Blockly.Msg['ROBOTS_KITROBOT_TURN_LEFT_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Pivote le robot Kit:robot v2 de 90° vers la gauche.';
Blockly.Msg['ROBOTS_KITROBOT_TURN_RIGHT_TITLE'] = '[Kit:robot v2] pivoter à droite';
Blockly.Msg['ROBOTS_KITROBOT_TURN_RIGHT_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Pivote le robot Kit:robot v2 de 90° vers la droite.';
Blockly.Msg['ROBOTS_KITROBOT_STOP_ROBOT_TITLE'] = '[Kit:robot v2] arrêter le robot';
Blockly.Msg['ROBOTS_KITROBOT_STOP_ROBOT_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Arrête les moteurs du robot Kit:robot v2.';
Blockly.Msg['ROBOTS_KITROBOT_BLINK_ROBOT_TITLE'] = '[Kit:robot v2] clignoter le robot';
Blockly.Msg['ROBOTS_KITROBOT_BLINK_ROBOT_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Fait clignoter le robot Kit:robot v2.';
Blockly.Msg['ROBOTS_KITROBOT_READPATROL_TITLE'] = '[Kit:robot v2]  état du capteur de ligne %1';
Blockly.Msg['ROBOTS_KITROBOT_READPATROL_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permet de lire l\'état du capteur suiveur de ligne gauche ou droit du robot Kit:robot v2. Le bloc renvoit 0 ou 1 si le capteur se trouve au dessus de la ligne ou non.';
Blockly.Msg['ROBOTS_KITROBOT_SETNEOPIXEL_TITLE'] = '[Kit:robot v2] contrôler la LED RGB en %1 à R %2 G %3 B %4';
Blockly.Msg['ROBOTS_KITROBOT_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED RGB du neopixel du robot Kit:robot v2 tel que les valeurs R,G,B soient comprises entre 0 et 255.';
Blockly.Msg['ROBOTS_KITROBOT_SETPALETTECOLOR_TITLE'] = '[Kit:robot v2] contrôler la LED RGB %1 à %2';
Blockly.Msg['ROBOTS_KITROBOT_SETPALETTECOLOR_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED RGB du module neopixel situé sur le robot Kit:robot v2. Utiliser la palette pour changer la couleur.';
Blockly.Msg['ROBOTS_KITROBOT_SETRAINBOW_TITLE'] = '[Kit:robot v2] Arc-en-ciel';
Blockly.Msg['ROBOTS_KITROBOT_SETRAINBOW_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB.';
Blockly.Msg['ROBOTS_KITROBOT_SETBUZZER_TITLE'] = '[Kit:robot v2] contrôler le buzzer à la fréquence %1 pendant %2 (ms)';
Blockly.Msg['ROBOTS_KITROBOT_SETBUZZER_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permet de définir une fréquence sur le buzzer du robot Kit:robot v2.';
// Robots - Codo
Blockly.Msg['ROBOTS_CODO_GO_TITLE'] = '[Codo] contrôler le robot %1 vitesse %2';
Blockly.Msg['ROBOTS_CODO_GO_FORWARD'] = 'avancer';
Blockly.Msg['ROBOTS_CODO_GO_BACKWARD'] = 'reculer';
Blockly.Msg['ROBOTS_CODO_GO_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la direction (avant/arrière) ainsi que la vitesse (de 0 à 255) du robot Codo.';
Blockly.Msg['ROBOTS_CODO_TURN_TITLE'] = '[Codo] pivoter vers là %1 vitesse %2';
Blockly.Msg['ROBOTS_CODO_TURN_RIGHT'] = 'droite';
Blockly.Msg['ROBOTS_CODO_TURN_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_CODO_TURN_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la direction (droite/gauche) ainsi que la vitesse (de 0 to 255) du robot Codo.';
Blockly.Msg['ROBOTS_CODO_STOP_TITLE'] = '[Codo] arrêter la course du robot';
Blockly.Msg['ROBOTS_CODO_STOP_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permet d\'arrêter la course du robot Codo.';
Blockly.Msg['ROBOTS_CODO_CONTROLMOTOR_TITLE'] = '[Codo] contrôler le moteur %1 direction %2 vitesse %3';
Blockly.Msg['ROBOTS_CODO_MOTOR_RIGHT'] = 'droit';
Blockly.Msg['ROBOTS_CODO_MOTOR_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_CODO_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permet de contrôler le moteur (droit/gauche), direction (horaire/antihoraire) et la vitesse (de 0 à 100) du robot Oobybot.';
// Robots - Oobybot
Blockly.Msg['ROBOTS_OOBYBOT_CONTROLLED_TITLE'] = '[Oobybot] contrôler les LED à l\'état %1 sur la pin %2';
Blockly.Msg['ROBOTS_OOBYBOT_CONTROLLED_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permet de contrôler les LED (P0)';
Blockly.Msg['ROBOTS_OOBYBOT_GO_TITLE'] = '[Oobybot] contrôler le robot %1 vitesse %2%';
Blockly.Msg['ROBOTS_OOBYBOT_GO_FORWARD'] = 'avancer';
Blockly.Msg['ROBOTS_OOBYBOT_GO_BACKWARD'] = 'reculer';
Blockly.Msg['ROBOTS_OOBYBOT_GO_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la direction (avant/arrière) ainsi que la vitesse (de 0 à 100%) du robot Oobybot.';
Blockly.Msg['ROBOTS_OOBYBOT_TURN_TITLE'] = '[Oobybot] pivoter vers la %1 vitesse %2%';
Blockly.Msg['ROBOTS_OOBYBOT_TURN_RIGHT'] = 'droite';
Blockly.Msg['ROBOTS_OOBYBOT_TURN_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_OOBYBOT_TURN_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la direction (droite/gauche) ainsi que la vitesse (de 0 to 100%) du robot Oobybot.';
Blockly.Msg['ROBOTS_OOBYBOT_STOP_TITLE'] = '[Oobybot] arrêter la course du robot';
Blockly.Msg['ROBOTS_OOBYBOT_STOP_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permet d\'arrêter la course du robot Oobybot.';
Blockly.Msg['ROBOTS_OOBYBOT_CONTROLMOTOR_TITLE'] = '[Oobybot] contrôler le moteur %1 direction %2 vitesse %3 %';
Blockly.Msg['ROBOTS_OOBYBOT_MOTOR_RIGHT'] = 'droit';
Blockly.Msg['ROBOTS_OOBYBOT_MOTOR_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_OOBYBOT_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permet de contrôler le moteur (droit/gauche), direction (horaire/antihoraire) et la vitesse (de 0 à 100%) du robot Oobybot.';
// Robots - Buggy
Blockly.Msg['ROBOTS_BUGGY_GO_TITLE'] = '[Buggy] contrôler le robot %1 vitesse %2';
Blockly.Msg['ROBOTS_BUGGY_GO_FORWARD'] = 'avancer';
Blockly.Msg['ROBOTS_BUGGY_GO_BACKWARD'] = 'reculer';
Blockly.Msg['ROBOTS_BUGGY_GO_TOOLTIP'] = IMG_ROBOT_BUGGY + Blockly.Tooltip.SEP + 'Permet de contrôler la direction (avant/arrière) ainsi que la vitesse (de 0 à 255) du robot Buggy.';
Blockly.Msg['ROBOTS_BUGGY_TURN_TITLE'] = '[Buggy] pivoter vers la %1 vitesse %2';
Blockly.Msg['ROBOTS_BUGGY_TURN_RIGHT'] = 'à droite';
Blockly.Msg['ROBOTS_BUGGY_TURN_LEFT'] = 'à gauche';
Blockly.Msg['ROBOTS_BUGGY_TURN_TOOLTIP'] = IMG_ROBOT_BUGGY + Blockly.Tooltip.SEP + 'Permet de contrôler la direction (droite/gauche) ainsi que la vitesse (de 0 to 255) du robot Buggy.';
Blockly.Msg['ROBOTS_BUGGY_STOP_TITLE'] = '[Buggy] arrêter la course du robot';
Blockly.Msg['ROBOTS_BUGGY_STOP_TOOLTIP'] = IMG_ROBOT_BUGGY + Blockly.Tooltip.SEP + 'Permet d\'arrêter la course du robot Buggy.';
Blockly.Msg['ROBOTS_BUGGY_CONTROLMOTOR_TITLE'] = '[Buggy] contrôler le moteur %1 direction %2 vitesse %3';
Blockly.Msg['ROBOTS_BUGGY_MOTOR_RIGHT'] = 'droit';
Blockly.Msg['ROBOTS_BUGGY_MOTOR_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_BUGGY_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_BUGGY + Blockly.Tooltip.SEP + 'Permet de contrôler le moteur (droit/gauche), direction (horaire/antihoraire) et la vitesse (de 0 à 255) du robot Buggy.';
// Robots - Bit:Bot
Blockly.Msg['ROBOTS_BITBOT_READLIGHTSENSOR_TITLE'] = '[Bit:Bot] luminosité du capteur %1';
Blockly.Msg['ROBOTS_BITBOT_READLIGHTSENSOR_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Renvoie la luminosité (de 0 à 255) grâce au capteur de lumière interne droit ou gauche du robot Bit:Bot.';
Blockly.Msg['ROBOTS_BITBOT_READPATROL_TITLE'] = '[Bit:Bot] état du capteur de ligne %1';
Blockly.Msg['ROBOTS_BITBOT_READPATROL_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Permet de lire l\'état du capteur suiveur de ligne gauche ou droit du robot Bit:Bot. Le bloc renvoit 1 si le capteur se trouve au dessus de la ligne.';
Blockly.Msg['ROBOTS_BITBOT_RIGHT'] = 'Droit';
Blockly.Msg['ROBOTS_BITBOT_LEFT'] = 'Gauche';
Blockly.Msg['ROBOTS_BITBOT_RIGHT&LEFT'] = 'Droit & Gauche';
Blockly.Msg['ROBOTS_BITBOT_GO_TITLE'] = '[Bit:Bot] contrôler le robot %1 vitesse %2';
Blockly.Msg['ROBOTS_BITBOT_GO_FORWARD'] = 'Avancer';
Blockly.Msg['ROBOTS_BITBOT_GO_REVERSE'] = 'Reculer';
Blockly.Msg['ROBOTS_BITBOT_GO_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la marche (AVANT/ARRIERE) ainsi que sa vitesse (de 0 à 1023) du robot Bit:Bot';
Blockly.Msg['ROBOTS_BITBOT_CONTROLMOTOR_TITLE'] = '[Bit:Bot] contrôler le moteur %1 direction %2 vitesse %3';
Blockly.Msg['ROBOTS_BITBOT_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit (P0, P8) et gauche (P1, P12) en changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 1023) du robot Bit:Bot.';
Blockly.Msg['ROBOTS_BITBOT_STOPMOTORS_TITLE'] = '[Bit:Bot] arrêter le moteur %1';
Blockly.Msg['ROBOTS_BITBOT_STOPMOTORS_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Permet d\'arrêter le moteur droit ou gauche du robot Bit:Bot.';
Blockly.Msg['ROBOTS_BITBOT_SETNEOPIXEL_TITLE'] = '[Bit:Bot] contrôler la LED %1 à  R %2 G %3 B %4';
Blockly.Msg['ROBOTS_BITBOT_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du neopixel du robot Bit:Bot (P13) tel que les valeurs (R, G, B) soient comprises entre 0 et 255.';
Blockly.Msg['ROBOTS_BITBOT_SETPALETTECOLOR_TITLE'] = '[Bit:Bot] contrôler la LED %1 à %2';
Blockly.Msg['ROBOTS_BITBOT_SETPALETTECOLOR_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du module neopixel du robot Bit:Bot (P13). Utiliser la palette pour changer la couleur des LED RGB.';
Blockly.Msg['ROBOTS_BITBOT_SETRAINBOW_TITLE'] = '[Bit:Bot] Arc-en-ciel';
Blockly.Msg['ROBOTS_BITBOT_SETRAINBOW_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB du robot Bit:Bot (P13).';
// Robots - BitCar
Blockly.Msg['ROBOTS_BITCAR_ULTRASONICRANGER_TITLE'] = '[BitCar] %1';
Blockly.Msg['ROBOTS_BITCAR_ULTRASONICRANGER_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Renvoie la distance (en cm) ou la durée de l\'aller-retour (en μs) de l\'onde entre un object et le robot BitCar grâce au capteur à ultrasons.';
Blockly.Msg['ROBOTS_BITCAR_READPATROL_TITLE'] = '[BitCar]  état du capteur de ligne %1';
Blockly.Msg['ROBOTS_BITCAR_READPATROL_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Permet de lire l\'état d\'un des capteurs suiveur de ligne du robot BitCar. Le bloc renvoit 0 si le capteur se trouve au dessus de la ligne.';
Blockly.Msg['ROBOTS_BITCAR_GO_TITLE'] = '[BitCar] contrôler le robot %1 vitesse %2 %';
Blockly.Msg['ROBOTS_BITCAR_GO_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Permet de contrôler la marche (AVANT/ARRIERE) ainsi que la vitesse (de 0 à 100) du robot BitCar.';
Blockly.Msg['ROBOTS_BITCAR_ROTATE_TITLE'] = '[BitCar] pivoter %1 vitesse %2 %';
Blockly.Msg['ROBOTS_BITCAR_ROTATE_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit et gaucheen changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 100) du robot BitCar.';
Blockly.Msg['ROBOTS_BITCAR_CONTROLMOTOR_TITLE'] = '[BitCar] contrôler le moteur %1 direction %2 vitesse %3 %';
Blockly.Msg['ROBOTS_BITCAR_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Permet de contrôler les moteurs droit et gauche en changeant la direction (↻ : AVANT, ↺ : ARRIERE) et la vitesse (de 0 à 100) du robot BitCar.';
Blockly.Msg['ROBOTS_BITCAR_STOPMOTORS_TITLE'] = '[BitCar] arrêter le moteur %1';
Blockly.Msg['ROBOTS_BITCAR_STOPMOTORS_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Permet d\'arrêter le moteur droit ou gauche du robot BitCar.';
Blockly.Msg['ROBOTS_BITCAR_BLINK_ROBOT_TITLE'] = '[BitCar] clignoter le robot';
Blockly.Msg['ROBOTS_BITCAR_BLINK_ROBOT_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Fait clignoter le robot Maqueen.';
Blockly.Msg['ROBOTS_BITCAR_SETNEOPIXEL_TITLE'] = '[BitCar] contrôler la LED RGB en dessous %1 à R %2 G %3 B %4';
Blockly.Msg['ROBOTS_BITCAR_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED RGB du neopixel du robot BitCar tel que les valeurs R,G,B soient comprises entre 0 et 255.';
Blockly.Msg['ROBOTS_BITCAR_SETPALETTECOLOR_TITLE'] = '[BitCar] contrôler la LED RGB en dessous %1 à %2';
Blockly.Msg['ROBOTS_BITCAR_SETPALETTECOLOR_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED RGB du module neopixel situé sous le robot BitCar. Utiliser la palette pour changer la couleur.';
Blockly.Msg['ROBOTS_BITCAR_SETRAINBOW_TITLE'] = '[BitCar] Arc-en-ciel';
Blockly.Msg['ROBOTS_BITCAR_SETRAINBOW_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB.';
Blockly.Msg['ROBOTS_BITCAR_SETBUZZER_TITLE'] = '[BitCar] contrôler le buzzer à la fréquence %1 pendant %2 (ms)';
Blockly.Msg['ROBOTS_BITCAR_SETBUZZER_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Permet de définir une fréquence sur le buzzer du robot BitCar.';
Blockly.Msg['ROBOTS_BITCAR_DECODEIRRECEIVER_TITLE'] = '[BitCar] décoder le récepteur infrarouge';
Blockly.Msg['ROBOTS_BITCAR_DECODEIRRECEIVER_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Effectue une lecture du récepteur infrarouge du robot BitCar.';
Blockly.Msg['ROBOTS_BITCAR_GETIRCODE_TITLE'] = '[BitCar] code reçu du récepteur infrarouge';
Blockly.Msg['ROBOTS_BITCAR_GETIRCODE_TOOLTIP'] = IMG_ROBOT_BITCAR + Blockly.Tooltip.SEP + 'Renvoie le code hexadecimal reçu avec le détecteur infrarouge du robot BitCar.';
// Robots - Gamepad
Blockly.Msg['ROBOTS_BITPLAYER_ONBUTTONEVENT_TITLE'] = '[BitPlayer] si le bouton %1 est %2 alors';
Blockly.Msg['ROBOTS_BITPLAYER_ONBUTTONEVENT_TOOLTIP'] = IMG_ROBOT_BITPLAYER + Blockly.Tooltip.SEP + 'Exécute des instructions si un des boutons de la manette BitPlayer est utilisé. Un bouton a deux états : \'pressé\' ou \'relaché\'.';
Blockly.Msg['ROBOTS_BITPLAYER_GETAXIS_TITLE'] = '[BitPlayer] valeur de l\'axe %1';
Blockly.Msg['ROBOTS_BITPLAYER_GETAXIS_TOOLTIP'] = IMG_ROBOT_BITPLAYER + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'axe X ou Y du joystick de la manette BitPlayer. Joystick : 2 axes analogiques (X : P1 Y : P2).';
Blockly.Msg['ROBOTS_GAMEPAD_V4_ONBUTTONEVENT_TITLE'] = '[Gamepad v4] si le bouton %1 est %2 alors';
Blockly.Msg['ROBOTS_GAMEPAD_V4_ONBUTTONEVENT_TOOLTIP'] = IMG_ROBOT_GAMEPAD_V4 + Blockly.Tooltip.SEP + 'Exécute des instructions si un des boutons de la manette \'Micro:GamePad (V4.0) DFR0536\' est utilisé. Un bouton a deux états : \'pressé\' ou \'relaché\'. Touches : A(A), B(B), C(P13), D(P14), E(P15), F(P16), Z(P8).';
Blockly.Msg['ROBOTS_GAMEPAD_V4_LED_MOTOR_TITLE'] = '[Gamepad v4] LED et vibration à l\'état %1';
Blockly.Msg['ROBOTS_GAMEPAD_V4_LED_MOTOR_TOOLTIP'] = IMG_ROBOT_GAMEPAD_V4 + Blockly.Tooltip.SEP + 'Permet de contrôler l\'état de la LED et du moteur à vibration de la manette \'Micro:GamePad (V4.0) DFR0536\' (P16).';
Blockly.Msg['ROBOTS_GAMEPAD_V4_GETAXIS_TITLE'] = '[Gamepad v4] valeur de l\'axe %1';
Blockly.Msg['ROBOTS_GAMEPAD_V4_GETAXIS_TOOLTIP'] = IMG_ROBOT_GAMEPAD_V4 + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'axe X ou Y (de 0 à 1023) du joystick de la manette \'Micro:GamePad (V4.0) DFR0536\'. Joystick : 2 axes analogiques (X : P1 Y : P2) 1 axe numérique (Z : P8).';
Blockly.Msg['ROBOTS_GAMEPAD_CONTROLLED_TITLE'] = '[Gamepad] contrôler la LED à l\'état %1';
Blockly.Msg['ROBOTS_GAMEPAD_CONTROLLED_TOOLTIP'] = IMG_ROBOT_GAMEPAD + Blockly.Tooltip.SEP + 'Permet de contrôler l\'état de la LED de la manette \'Gamepad expansion DFR0536\' (P16).';
Blockly.Msg['ROBOTS_GAMEPAD_SETMOTORVIBRATION_TITLE'] = '[Gamepad] contrôler la vibration de la manette à %1';
Blockly.Msg['ROBOTS_GAMEPAD_SETMOTORVIBRATION_TOOLTIP'] = IMG_ROBOT_GAMEPAD + Blockly.Tooltip.SEP + 'Permet de contrôler l\'état du moteur à vibrations de la manette \'Gamepad expansion DFR0536\' (P12).';
Blockly.Msg['ROBOTS_GAMEPAD_SETBUZZERFREQ_TITLE'] = '[Gamepad] contrôler le buzzer à la fréquence %1 pendant %2 (ms)';
Blockly.Msg['ROBOTS_GAMEPAD_SETBUZZERFREQ_TOOLTIP'] = IMG_ROBOT_GAMEPAD + Blockly.Tooltip.SEP + 'Permet de définir une fréquence sur le buzzer de la manette \'Gamepad expansion DFR0536\' (P0).';
Blockly.Msg['ROBOTS_GAMEPAD_PLAYMUSIC_TITLE'] = '[Gamepad] jouer la musique %1';
Blockly.Msg['ROBOTS_GAMEPAD_PLAYMUSIC_TOOLTIP'] = IMG_ROBOT_GAMEPAD + Blockly.Tooltip.SEP + 'Permet de jouer une musique avec le buzzer de la manette \'Gamepad expansion DFR0536\' (P0).';
Blockly.Msg['ROBOTS_GAMEPAD_ONBUTTONEVENT_TITLE'] = '[Gamepad] si le bouton %1 est %2 alors';
Blockly.Msg['ROBOTS_GAMEPAD_PRESSED'] = 'pressé';
Blockly.Msg['ROBOTS_GAMEPAD_RELEASED'] = 'relaché';
Blockly.Msg['ROBOTS_GAMEPAD_ONBUTTONEVENT_TOOLTIP'] = IMG_ROBOT_GAMEPAD + Blockly.Tooltip.SEP + 'Exécute des instructions si un des boutons de la manette \'Gamepad Expansion DFR0536\' est utilisé. Un bouton a deux états : \'pressé\' ou \'relaché\'. Table des broches : ([X, P1], [Y, P2], [UP, P8], [DOWN, P13], [LEFT, P14], [RIGHT, P15]).';
// Tello
Blockly.Msg['TELLO_TAKEOFF_TITLE'] = '[Tello] faire décoller le drone';
Blockly.Msg['TELLO_TAKEOFF_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de faire décoller le drone Tello. Attention: vous avez besoin d\'un module Grove Wifi UART v2 pour piloter le drone avec une micro:bit v2.';
Blockly.Msg['TELLO_LAND_TITLE'] = '[Tello] faire atterrir le drone';
Blockly.Msg['TELLO_LAND_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de faire atterrir le drone Tello. Attention: vous avez besoin d\'un module Grove Wifi UART v2 pour piloter le drone avec une micro:bit v2.';
Blockly.Msg['TELLO_DRONE_INIT_TITLE'] = '[Tello] se connecter au drone Tello, SSID%1 Sur la broche TX %2 et RX %3 du module Grove UART WIFI v2';
Blockly.Msg['TELLO_DRONE_INIT_TOOLTIP'] = IMG_MODULE_WIFI + Blockly.Tooltip.SEP + 'Permet de se connecter et d\'initialiser le drone Tello avec un module Grove Wifi UART v2.';
Blockly.Msg['TELLO_FLIP_TITLE'] = '[Tello] faire un flip %1';
Blockly.Msg['TELLO_FLIP_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de faire un flip (avant, arrière, à droite et à gauche) avec le drone Tello';
Blockly.Msg['TELLO_FLIP_FORWARD'] = 'avant';
Blockly.Msg['TELLO_FLIP_BACKWARD'] = 'arrière';
Blockly.Msg['TELLO_FLIP_RIGHT'] = 'à droite';
Blockly.Msg['TELLO_FLIP_LEFT'] = 'à gauche';
Blockly.Msg['TELLO_GO_TITLE'] = '[Tello] se déplacer avec l\'accéléromètre. %1 Pas de déplacement de %2 cm avec une vitesse de %3 cm/s';
Blockly.Msg['TELLO_GO_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de déplacer le drone Tello avec l\'accéléromètre de la micro:bit. Le pas est un nombre entre 20 et 100 et la vitesse un nombre entre 10 et et 100 cm/s';
Blockly.Msg['TELLO_MOVE_TITLE'] = '[Tello] déplacer le drone %1 de %2 cm';
Blockly.Msg['TELLO_MOVE_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de déplacer le drone Tello dans une direction (avant, arrière, à droite et à gauche) sur une certaine distance en cm (entre 20 et 500 cm).';
Blockly.Msg['TELLO_MOVE_UP_DOWN_TITLE'] = '[Tello] déplacer le drone vers %1 de %2 cm';
Blockly.Msg['TELLO_MOVE_UP_DOWN_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de déplacer le drone Tello dans une direction (vers le haut et vers le bas) sur une certaine distance en cm (entre 20 et 500 cm).';
Blockly.Msg['TELLO_MOVE_UP'] = 'le haut';
Blockly.Msg['TELLO_MOVE_DOWN'] = 'le bas';
Blockly.Msg['TELLO_MOVE_LEFT'] = 'à gauche';
Blockly.Msg['TELLO_MOVE_RIGHT'] = 'à droite';
Blockly.Msg['TELLO_MOVE_FORWARD'] = 'avant';
Blockly.Msg['TELLO_MOVE_BACK'] = 'arrière';
Blockly.Msg['TELLO_ROTATE_TITLE'] = '[Tello] faire pivoter le drone dans le sens %1 de %2 degrés';
Blockly.Msg['TELLO_ROTATE_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de faire pivoter le drone Tello dans une direction (dans le sens des aiguilles d\'une montre CW et dans le sens inverse des aiguilles d\'une montre CCW) entre 1 et 360 degrés.';
Blockly.Msg['TELLO_ROTATE_CW'] = 'horaire';
Blockly.Msg['TELLO_ROTATE_CCW'] = 'anti-horaire';
Blockly.Msg['TELLO_EMERGENCY_TITLE'] = '[Tello] arrêt d\'urgence';
Blockly.Msg['TELLO_EMERGENCY_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de couper les moteurs de drone Tello en cas d\'urgence. Attention : en fonction de la hauteur du drone, l\'arrêt d\'urgence peut endommager le Tello.';
Blockly.Msg['TELLO_STOP_TITLE'] = '[Tello] immobiliser le drone';
Blockly.Msg['TELLO_STOP_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet d\'arrêter le mouvement du drone Tello.';
Blockly.Msg['TELLO_SPEED_TITLE'] = '[Tello] vitesse du Drone (cm/s)';
Blockly.Msg['TELLO_SPEED_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de lire la vitesse du drone Tello en cm/s (entre 0 et 100 cm/s).';
Blockly.Msg['TELLO_BATTERY_TITLE'] = '[Tello] batterie du drone (%)';
Blockly.Msg['TELLO_BATTERY_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de lire le niveau de batterie du drone Tello en % entre (0 et 100).';
Blockly.Msg['TELLO_FLIGHT_TIME_TITLE'] = '[Tello] temps de vol (s)';
Blockly.Msg['TELLO_FLIGHT_TIME_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de lire le temps de vol du drone Tello en s.';
Blockly.Msg['TELLO_STREAMING_VIDEO_ON_TITLE'] = '[Tello] activer la vidéo en streaming';
Blockly.Msg['TELLO_STREAMING_VIDEO_ON_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet d\'activer la vidéo en streaming du drone Tello. Se connecter sur le réseau wifi du drone Tello  (SSID: \'TELLO-XXXXXX\', pw:\'\') puis rentrer l\'url \'0.0.0.0:11111\' dans un navigateur web ou mobile pour avoir le retour vidéo en temps réel.';
Blockly.Msg['TELLO_STREAMING_VIDEO_OFF_TITLE'] = '[Tello] désactiver la vidéo en streaming';
Blockly.Msg['TELLO_STREAMING_VIDEO_OFF_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de désactiver la vidéo en streaming du drone Tello.';
Blockly.Msg['TELLO_RECTANGLE_FORM_TITLE'] = '[Tello] dessiner un rectangle de %1 cm par %2 cm';
Blockly.Msg['TELLO_RECTANGLE_FORM_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de faire un rectangle avec le drone Tello. La largeur et la longueur sont comprises entre 20 et 500 cm.';
Blockly.Msg['TELLO_SQUARE_FORM_TITLE'] = '[Tello] dessiner un carré de %1 cm de côté';
Blockly.Msg['TELLO_SQUARE_FORM_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permet de faire un carré avec le drone Tello. La longueur du côté est comprise entre 20 et 500 cm.';
//Cameras
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_TITLE'] = '[HuskyLens] activer le mode %1';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permet de choisir le mode de détection sur la caméra HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_FACE_RECOGNITION'] = 'détection de visage';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_OBJECT_TRACKING'] = 'suivi d\'objet';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_OBJECT_RECOGNITION'] = 'détection d\'objet';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_LINE_TRACKING'] = 'suivi de ligne';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_COLOR_RECOGNITION'] = 'détection de couleur';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_TAG_RECOGNITION'] = 'détection AprilTag';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_OBJECT_CLASSIFICATION'] = 'classification d\'objet';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_TEXT_TITLE'] = '[HuskyLens] afficher le texte %1 à la position (%2,%3)';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_TEXT_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Affiche du texte à la position (x,y) sur l\'écran de la caméra HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_CLEAR_SCREEN_TITLE'] = '[HuskyLens] effacer l\'écran';
Blockly.Msg['CAMERAS_HUSKYLENS_CLEAR_SCREEN_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Efface tout le texte affiché à l\'écran de la caméra HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_LEARN_ID_TITLE'] = '[HuskyLens] apprendre l\'ID n°%1 automatiquement';
Blockly.Msg['CAMERAS_HUSKYLENS_LEARN_ID_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Apprend à reconnaitre automatiquement un ID avec la caméra HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_FORGET_IDS_TITLE'] = '[HuskyLens] oublier tous les IDs';
Blockly.Msg['CAMERAS_HUSKYLENS_FORGET_IDS_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Efface tous les IDs enregistrés de la caméra HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_GET_DATA_TITLE'] = '[HuskyLens] récupérer les données %1';
Blockly.Msg['CAMERAS_HUSKYLENS_GET_DATA_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permet d\'obtenir les données renvoyées par la caméra HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_BLOCKS'] = 'blocs';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_ARROWS'] = 'flèches';
Blockly.Msg['CAMERAS_HUSKYLENS_CUSTOM_NAME_TITLE'] = '[HuskyLens] associer le nom %1 à l\'ID n°%2';
Blockly.Msg['CAMERAS_HUSKYLENS_CUSTOM_NAME_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permet d\'associer un nom à un ID déjà enregistré (mode détection de visage).';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_BLOCKS_DATA_TITLE'] = '[HuskyLens] obtenir %1 des blocs détectés';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_BLOCKS_DATA_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permet d\'obtenir les informations de détection de la caméra HuskyLens. Chaque élément identifié est stocké dans un tableau sous la forme [x1, y1, largeur, hauteur, id].';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_ID'] = 'les IDs';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_X'] = 'les coordonées X';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_Y'] = 'les coordonées Y';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_X1'] = 'les coordonées X (origine)';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_Y1'] = 'les coordonées Y (origine)';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_X2'] = 'les coordonées X (arrivée)';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_Y2'] = 'les coordonées Y (arrivée)';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_WIDTH'] = 'les largeurs';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_HEIGHT'] = 'les hauteurs';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_ALL'] = 'toutes les données';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_SINGLE_X'] = 'coordonée X';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_SINGLE_Y'] = 'coordonée Y';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_SINGLE_WIDTH'] = 'largeur';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_SINGLE_HEIGHT'] = 'hauteur';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_BLOCKS_XY_TITLE'] = '[HuskyLens] obtenir la %1 du bloc détecté';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_BLOCKS_XY_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permet d\'obtenir les coordonnées X ou Y du bloc détecté par la caméra HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_ARROWS_DATA_TITLE'] = '[HuskyLens] obtenir %1 des flèches détectés';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_ARROWS_DATA_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permet d\'obtenir les informations de détection de la caméra HuskyLens. Chaque élément identifié est stocké dans un tableau sous la forme [x1, y1, x2, y2, id].';
Blockly.Msg['CAMERAS_HUSKYLENS_DETECTED_ELEMENTS_TITLE'] = '[HuskyLens] obtenir le nombre d\'éléments %1 détectés';
Blockly.Msg['CAMERAS_HUSKYLENS_DETECTED_ELEMENTS_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permet d\'obtenir le nombre d\'éléments détectés par la caméra HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_CHECK_ID_TITLE'] = '[HuskyLens] %2 vérifier si l\'ID n°%1 est détecté';
Blockly.Msg['CAMERAS_HUSKYLENS_CHECK_ID_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Renvoi Vrai ou Faux si l\'ID est détecté par la caméra HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_GET_LINE_DIRECTION_TITLE'] = '[HuskyLens] si la ligne ID n°%1 %2';
Blockly.Msg['CAMERAS_HUSKYLENS_LINE_STRAIGHT'] = 'est droite';
Blockly.Msg['CAMERAS_HUSKYLENS_LINE_LEFT'] = 'tourne à gauche';
Blockly.Msg['CAMERAS_HUSKYLENS_LINE_RIGHT'] = 'tourne à droite';
Blockly.Msg['CAMERAS_HUSKYLENS_GET_LINE_DIRECTION_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Détecte la direction de la ligne grâce à la caméra HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_SAVE_MODEL_TITLE'] = '[HuskyLens] sauvegarder en tant que modèle n°%1';
Blockly.Msg['CAMERAS_HUSKYLENS_SAVE_MODEL_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Sauvegarde le modèle sur la carte SD de la caméra HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_LOAD_MODEL_TITLE'] = '[HuskyLens] charger le modèle n°%1';
Blockly.Msg['CAMERAS_HUSKYLENS_LOAD_MODEL_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Charge le modèle sur la carte SD de la caméra HuskyLens.';

// IA SENSORS
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TITLE'] = '%1 charger le modèle local';
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TOOLTIP'] = 'Permet de charger un modèle IA stocké localement depuis le navigateur web.';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TITLE'] = '%1 charger le modèle depuis l\'url %2';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TOOLTIP'] = 'Permet de charger un modèle IA stocké depuis le cloud.';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TITLE'] = '%1 lancer la prédiction';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TIME_WINDOW'] = 'fenêtre';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TOOLTIP'] = 'Permet de lancer une prédiction à partir d\'un capteur. Ajuster la fenêtre de temps pour obtenir une prédiction, si nécessaire.';
Blockly.Msg['VITTAIA_SENSOR_ACC'] = 'accéléromètre';
Blockly.Msg['VITTAIA_DETECT_CLASS_TITLE'] = '%1 si la classe %2 %3 détectée alors';
Blockly.Msg['VITTAIA_DETECT_CLASS_TOOLTIP'] = 'Permet de détecter la classe d\'un objet.';
Blockly.Msg['VITTAIA_IS'] = 'est';
Blockly.Msg['VITTAIA_ISNOT'] = 'n\'est pas';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TITLE'] = '%1 classe detectée';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TOOLTIP'] = 'Permet de récupérer la classe avec la plus haute probabilité.';