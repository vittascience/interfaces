/**
 * @fileoverview Spanish messages for Micro:bit. (ES)
 */
'use strict';

// Display - Micro:bit 
Blockly.Msg['SHOW_LEDS_TITLE'] = 'mostrar leds';
Blockly.Msg['SHOW_LEDS_TOOLTIP'] = 'Muestra la imagen personalizada en la pantalla de la placa micro:bit';
Blockly.Msg['SHOW_STRING_TITLE'] = 'desplazarse %1';
Blockly.Msg['SHOW_STRING_TOOLTIP'] = 'Desplazarse por una cadena en la pantalla de la placa micro:bit';
Blockly.Msg['DISPLAY_SHOW_STRING_DELAY'] = 'retraso (ms)';
Blockly.Msg['SHOW_NUMBER_TITLE'] = 'mostrar %1';
Blockly.Msg['SHOW_NUMBER_TOOLTIP'] = 'Muestra una a una las cifras en la pantalla de la placa micro:bit';
Blockly.Msg['SHOW_ICON_TITLE'] = 'mostrar icono %1';
Blockly.Msg['SHOW_ICON_TOOLTIP'] = 'Muestra el icono seleccionado en la pantalla de la placa micro:bit';
Blockly.Msg['SHOW_ICON_SIMPLE_TITLE'] = "mostrar icono %1";
Blockly.Msg['SHOW_ICON_SIMPLE_TOOLTIP'] = 'Muestra el icono seleccionado en la pantalla de la placa micro:bit';
Blockly.Msg['SHOW_GAUGE_TITLE'] = 'mostrar medidor de %1 Máximo %2';
Blockly.Msg['SHOW_GAUGE_TOOLTIP'] = 'Mostrar la varilla de un sensor (o número) en la pantalla de la placa micro:bit fijando el valor máximo correspondiente a la varilla llena';
Blockly.Msg['PLOT_BAR_GRAPH_TITLE'] = 'trazar el gráfico de %1';
Blockly.Msg['PLOT_BAR_GRAPH_TOOLTIP'] = 'Muestra un gráfico de barras verticales basado en los valores "value" y "high". Si "high" es igual a 0, el gráfico se ajusta automáticamente';
Blockly.Msg['PLOT_BAR_GRAPH_TO'] = 'a';
Blockly.Msg['SET_PIXEL_TITLE'] = 'control led x %1 y %2 a estado %3';
Blockly.Msg['SET_PIXEL_TOOLTIP'] = 'Permite controlar el estado (ON/OFF) de cada LED de la pantalla de micro:bit';
Blockly.Msg['GET_PIXEL_STATE_TITLE'] = 'estado del LED en x %1 y %2';
Blockly.Msg['GET_PIXEL_STATE_TOOLTIP'] = 'Permite verificar el estado (ENCENDIDO/APAGADO) de cada LED en la pantalla de la placa micro:bit.';
Blockly.Msg['TOGGLE_PIXEL_STATE_TITLE'] = 'alternar estado del LED en x %1 y %2';
Blockly.Msg['TOGGLE_PIXEL_STATE_TOOLTIP'] = 'Permite alternar el estado (ENCENDIDO/APAGADO) de cada LED en la pantalla de la placa micro:bit.';
Blockly.Msg['SET_LIGHT_PIXEL_TITLE'] = 'control led x %1 y %2 light %3';
Blockly.Msg['SET_LIGHT_PIXEL_TOOLTIP'] = 'Permite controlar la luz (de 0 a 9) de cada LED de la pantalla micro:bit';
Blockly.Msg['SET_BRIGHTNESS_TITLE'] = 'ajustar brillo %1';
Blockly.Msg['SET_BRIGHTNESS_TOOLTIP'] = 'Permite elegir el brillo (de 0 a 9) de la pantalla LED de la placa micro:bit.';
Blockly.Msg['SHOW_CLOCK_TITLE'] = 'Mostrar reloj %1';
Blockly.Msg['SHOW_CLOCK_TOOLTIP'] = 'Muestra la aguja horaria de un reloj en la pantalla de la placa micro:bit';
Blockly.Msg['SHOW_ARROW_TITLE'] = 'mostrar flecha %1';
Blockly.Msg['SHOW_ARROW_TOOLTIP'] = 'Permite mostrar flechas de 8 direcciones (N,NE,E,SE,S...) en la pantalla de micro:bit';
Blockly.Msg['CLEAR_TITLE'] = 'limpiar la pantalla';
Blockly.Msg['CLEAR_TOOLTIP'] = 'Borrar la pantalla de la placa micro:bit';
// Display - Screen
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD] mostrar texto %1 en la línea %2 posición %3';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Mostrar texto en la pantalla lcd 1602 de Grove. Conecte el lcd en el puerto I2C';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD] limpiar pantalla';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Habilitar para borrar todo el texto del lcd. Conecte el lcd en el puerto I2C';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[Pantalla OLED] mostrar texto %1 en la posición x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Activar la escritura de texto en la pantalla OLED. Conecte la pantalla OLED en el puerto I2C';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TITLE'] = '[Pantalla OLED] controla el píxel x %1 y %2 al estado %3';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Habilitar para controlar cada píxel de la pantalla OLED. Conecte la pantalla OLED en el puerto I2C';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[Pantalla OLED] limpiar pantalla';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Habilitar para borrar toda la pantalla oled. Conecte la pantalla OLED en el puerto I2C';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[Pantalla OLED] mostrar icono %1 en x %2 y %3 al estado %4';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Activar el icono de micro:bit de la biblioteca de imágenes. Conectar la pantalla OLED en el puerto I2C';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] controla el LED al estado %1 en el pin %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Permite encender o apagar el kit de LEDs Grove (0 o 1) en los pines digitales P0 a P20';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] establece la intensidad del LED a %1 en el pin %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Habilitar para establecer la intensidad del LED de 0 a 255 en los pines PWM';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[LED de color variable] establece el brillo a %1 (%) en el pin %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Permite establecer el brillo de un LED de 0 a 100% en los pines PWM. Cuando se utiliza por primera vez, los valores RGB se establecen en 0. Utilice un destornillador para ajustar los colores R, G y B detrás del módulo';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] define %1 LED en el pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite definir el número de LED del neopixel. Este bloque debe utilizarse en la configuración';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] establece el LED %1 en R %2 G %3 B %4 en el pin %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar cada color de LED de los neopíxeles como (R,G,B) de 0 a 255. Utilizar P15 para ajustar el neopixel Maqueen';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] establece el LED %1 a %2 en el pin %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Habilitar para controlar cada color del LED del neopixel. Utilizar P15 para ajustar el neopixel Maqueen';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] establece todos los LED al color R %1 G %2 B %3 en el pin %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar todos los LED del neopixel al valor de color elegido como (R,G,B) de 0 a 255. Utilice P15 para ajustar el neopixel Maqueen';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] establece todos los LED al color %1 en el pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Habilitar para controlar todos los LED del neopixel al valor de color elegido. Utilizar P15 para ajustar el neopixel Maqueen';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] establece un arco iris en el pin %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Habilitar para mostrar un arco iris en el módulo neopixel, establecer el pin y el número de LED';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_LEDCONTROL_TITLE'] = '[ZIP Halo HD] controlar el LED %1 en R %2 G %3 B %4';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_LEDCONTROL_TOOLTIP'] = 'Permite controlar el color de cada LED como (R,G,B) de 0 a 255 en el módulo Zip Halo LED de Kitronik.';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_SETPALETTECOLOR_TITLE'] = '[ZIP Halo HD] controlar el LED %1 con color %2';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_SETPALETTECOLOR_TOOLTIP'] = 'Permite controlar el color de cada LED en el módulo Zip Halo LED de Kitronik. Usa la paleta para cambiar el color.';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_SETALLLEDRGB_TITLE'] = '[ZIP Halo HD] controlar todas las LEDs en R %1 G %2 B %3';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_SETALLLEDRGB_TOOLTIP'] = 'Permite controlar todas las LEDs en el módulo Zip Halo LED de Kitronik con el color elegido como (R,G,B) de 0 a 255.';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_SETALLLEDCOLOR_TITLE'] = '[ZIP Halo HD] controlar todas las LEDs con color %1';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_SETALLLEDCOLOR_TOOLTIP'] = 'Permite controlar todas las LEDs en el módulo Zip Halo LED de Kitronik con el color elegido. Usa la paleta para cambiar el color.';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_RAINBOW_TITLE'] = '[ZIP Halo HD] Arcoíris';
Blockly.Msg['DISPLAY_ZIP_HALO_LED_RAINBOW_TOOLTIP'] = 'Muestra el espectro de colores en las LEDs RGB del módulo Zip Halo LED de Kitronik.';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[Módulo de 4 dígitos] mostrar %1 %2 en los pines CLK %3 DIO %4';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Habilitar para mostrar los números o la temperatura en la pantalla de 4 dígitos del módulo (TM1637) en los pines digitales de P0 a P20';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[Módulo de 4 dígitos] mostrar reloj en los pines CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Habilitar para mostrar el reloj en la pantalla de 4 dígitos (TM1637) en los pines digitales de P0 a P20. Advertencia, obtener el reloj real sólo es posible si el micro:bit permanece en modo de encendido';
Blockly.Msg['DISPLAY_4DIGIT_NUMBER'] = 'número';
Blockly.Msg['DISPLAY_4DIGIT_TEMPERATURE'] = Blockly.Msg['SENSORS_TEMPERATURE'];
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[Módulo de barra de LEDs] establece el nivel de %1 en los pines DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Habilitar para mostrar el nivel del valor de entrada en la pantalla de la barra de LEDs de la ranura (MY9221) en los pines digitales de P0 a P20';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TITLE'] = '[Barra de LED del módulo] invierte la pantalla %1 DI pins %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permite invertir los 10 LEDs del módulo MY9221 con los pines digitales P0 a P20';
// display - Kitronic Traffic
Blockly.Msg['DISPLAY_TRAFFICLIGHT_SETLED_TITLE'] = '[Semáforo] poner %1 LED en estado %2';
Blockly.Msg['DISPLAY_TRAFFICLIGHT_SETLED_TOOLTIP'] = IMG_MODULE_TRAFFIC_LIGHT + Blockly.Tooltip.SEP + 'Permite controlar el semáforo Kitronik';
Blockly.Msg['DISPLAY_TRAFFICLIGHT_RED'] = 'rojo';
Blockly.Msg['DISPLAY_TRAFFICLIGHT_ORANGE'] = 'naranja';
Blockly.Msg['DISPLAY_TRAFFICLIGHT_GREEN'] = 'verde';
Blockly.Msg['DISPLAY_LAMPBIT_SETLED_TITLE'] = "[LAMP:BIT] poner el LED en %1";
Blockly.Msg['DISPLAY_LAMPBIT_SETLED_TOOLTIP'] = IMG_MODULE_LAMPBIT + Blockly.Tooltip.SEP + "Controla el LED de la farola";
//Display - RGB LED MATRIX
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_TITLE'] = '[Matriz LED RGB] display %1 %2';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_TOOLTIP'] = IMG_MODULE_RGB_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Permite mostrar un dibujo en la matriz LED RGB de 8x8';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_STOPDISPLAY_TITLE'] = '[Matriz de LEDs RGB] borra la matriz';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_STOPDISPLAY_TOOLTIP'] = IMG_MODULE_RGB_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Apaga todos los LEDs de la matriz';
Blockly.Msg['DISPLAY_LED_MATRIX_DURATION'] = 'durante';
Blockly.Msg['DISPLAY_LED_MATRIX_DURATION_UNIT'] = 'ms';
//Display - LED MATRIX
Blockly.Msg['DISPLAY_LED_MATRIX_TITLE'] = '[Matriz LED] display %1 %2';
Blockly.Msg['DISPLAY_LED_MATRIX_TOOLTIP'] = IMG_MODULE_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Permite mostrar un dibujo en la matriz LED monocromática de 8x8';
Blockly.Msg['DISPLAY_LED_MATRIX_CLEAR_TITLE'] = '[Matriz LED] borrar la matriz';
Blockly.Msg['DISPLAY_LED_MATRIX_CLEAR_TOOLTIP'] = IMG_MODULE_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Apaga todos los LEDs de la matriz';
// Display - Morpion
Blockly.Msg['DISPLAY_MORPION_NEWGAME_TITLE'] = '[Pantalla OLED] Tic Tac Toe - nuevo juego';
Blockly.Msg['DISPLAY_MORPION_NEWGAME_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Habilitar para iniciar un nuevo juego de tres en raya en la pantalla OLED. Conecte la pantalla OLED en el puerto I2C. Advertencia, el juego utiliza toda la memoria micro:bit, no se puede conectar ningún otro dispositivo durante el juego del tres en raya';
Blockly.Msg['DISPLAY_MORPION_MOVECURSOR_TITLE'] = '[Pantalla OLED] Tic Tac Toe - mover cursor';
Blockly.Msg['DISPLAY_MORPION_MOVECURSOR_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permite mover el cursor de la cuadrícula de Tic Tac Toe en la pantalla OLED. El cursor pasa por la rejilla cuadro a cuadro. Conecte la pantalla OLED en el puerto I2C. Advertencia, el juego utiliza toda la memoria micro:bit, no se puede conectar ningún otro dispositivo durante el juego del tres en raya';
Blockly.Msg['DISPLAY_MORPION_SETPLAYERFIGURE_TITLE'] = '[Pantalla OLED] Tic Tac Toe - añadir %1';
Blockly.Msg['DISPLAY_MORPION_SETPLAYERFIGURE_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Habilitar para añadir figura de jugador (Cruz o Círculo) en la parrilla de Tic Tac Toe en la pantalla OLED. Conecte la pantalla OLED en el puerto I2C. Advertencia, el juego utiliza toda la memoria micro:bit, no se puede conectar ningún otro dispositivo durante el juego de tres en raya';
Blockly.Msg['DISPLAY_MORPION_CROSS'] = 'cruz';
Blockly.Msg['DISPLAY_MORPION_CIRCLE'] = 'círculo';
Blockly.Msg['DISPLAY_MORPION_ISENDGAME_TITLE'] = '[Pantalla OLED] Tic Tac Toe - ¿es el final del juego?';
Blockly.Msg['DISPLAY_MORPION_ISENDGAME_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Habilitar para devolver el estado actual del juego Tic Tac Toe. Conecte la pantalla OLED en el puerto I2C. Advertencia, el juego utiliza toda la memoria micro:bit, no se puede conectar ningún otro dispositivo durante el juego Tic Tac Toe';
// Display - Games
Blockly.Msg['DISPLAY_GAMES_LEFT'] = 'izquierda';
Blockly.Msg['DISPLAY_GAMES_RIGHT'] = 'derecha';
Blockly.Msg['DISPLAY_GAMES_UP'] = 'arriba';
Blockly.Msg['DISPLAY_GAMES_DOWN'] = 'abajo';
Blockly.Msg['DISPLAY_GAMES_CREATESPRITE_TITLE'] = 'crear sprite en x %1 y %2';
Blockly.Msg['DISPLAY_GAMES_CREATESPRITE_TOOLTIP'] = 'Crear un sprite en la pantalla de micro:bit';
Blockly.Msg['DISPLAY_GAMES_DELETESPRITE_TITLE'] = 'borrar %1';
Blockly.Msg['DISPLAY_GAMES_DELETESPRITE_TOOLTIP'] = 'Eliminado el sprite seleccionado';
Blockly.Msg['DISPLAY_GAMES_ISSPRITEDELETED_TITLE'] = '¿Se ha borrado %1?';
Blockly.Msg['DISPLAY_GAMES_ISSPRITEDELETED_TOOLTIP'] = 'Devuelve True si el sprite seleccionado está borrado';
Blockly.Msg['DISPLAY_GAMES_MOVESPRITE_TITLE'] = 'mover %1 por %2 a %3';
Blockly.Msg['DISPLAY_GAMES_MOVESPRITE_TOOLTIP'] = 'Mover el sprite seleccionado por el número de paso y dirección elegidos';
Blockly.Msg['DISPLAY_GAMES_GETSPRITEPOSITION_TITLE'] = 'posición %1 %2';
Blockly.Msg['DISPLAY_GAMES_GETSPRITEPOSITION_TOOLTIP'] = 'Obtener la posición del sprite seleccionada';
Blockly.Msg['DISPLAY_GAMES_CHANGESCORE_TITLE'] = 'Cambiar la puntuación por %1';
Blockly.Msg['DISPLAY_GAMES_CHANGESCORE_TOOLTIP'] = 'Incrementar la puntuación del juego';
Blockly.Msg['DISPLAY_GAMES_GETSCORE_TITLE'] = 'puntuación';
Blockly.Msg['DISPLAY_GAMES_GETSCORE_TOOLTIP'] = 'Devuelve la puntuación del juego';
Blockly.Msg['DISPLAY_GAMES_STOPGAME_TITLE'] = 'parar el juego';
Blockly.Msg['DISPLAY_GAMES_STOPGAME_TOOLTIP'] = 'Para el juego';
Blockly.Msg['DISPLAY_GAMES_ISENDGAME_TITLE'] = 'es el final del juego';
Blockly.Msg['DISPLAY_GAMES_ISENDGAME_TOOLTIP'] = 'Devuelve True si el juego está parado';
Blockly.Msg['DISPLAY_GAMES_RESTARTGAME_TITLE'] = 'reinicia el juego';
Blockly.Msg['DISPLAY_GAMES_RESTARTGAME_TOOLTIP'] = 'Reinicia el juego';
// Input/Output - Micro:bit
Blockly.Msg['IO_WAIT_TITLE'] = 'espera %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Detener la ejecución del código (duración en segundos o milisegundos)';
Blockly.Msg['IO_WAIT_SECOND'] = 'segundo.s';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milisegundo.s';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microsegundo.s';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'espera hasta %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Detener la ejecución del código hasta que se cumpla la condición';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'Inicializar el cronómetro';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Permite inicializar el cronómetro (en segundos)';
Blockly.Msg['IO_RESETCHRONOMETER_TITLE'] = 'reiniciar cronómetro';
Blockly.Msg['IO_RESETCHRONOMETER_TOOLTIP'] = 'Reinicia un cronómetro a 0 (en segundos).';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'Obtener cronómetro en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Devuelve el valor del cronómetro desde la inicialización en segundos o milisegundos';
Blockly.Msg['IO_ONBUTTONPRESSED_TITLE'] = 'al pulsar el botón %1 %2 entonces';
Blockly.Msg['IO_ONBUTTONPRESSED_TOOLTIP'] = 'Ejecutar instrucciones si se pulsa el botón elegido (A o B)';
Blockly.Msg['IO_ISPRESSED'] = 'es';
Blockly.Msg['IO_WASPRESSED'] = 'era';
Blockly.Msg['IO_ONPINTOUCHED_TITLE'] = 'en %1 tocado entonces';
Blockly.Msg['IO_ONPINTOUCHED_TOOLTIP'] = 'Ejecutar instrucciones si se toca (o se pulsa) el logotipo de micro:bit o el pin P0, P1 o P2';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_TITLE'] = 'en %1 entonces';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_SHAKE'] = 'agitar';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_UP'] = 'logo arriba';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_DOWN'] = 'logo abajo';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FACE_UP'] = 'pantalla arriba';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FACE_DOWN'] = 'pantalla abajo';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_LEFT'] = 'inclinación hacia la izquierda';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_RIGHT'] = 'inclinación hacia la derecha';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_FREEFALL'] = 'caída libre';
Blockly.Msg['SENSORS_ACCELEROMETER_ON_MOVEMENT_TOOLTIP'] = 'ejecutar instrucciones si la placa micro:bit se agita';
Blockly.Msg['IO_ISBUTTONPRESSED_TITLE'] = 'botón %1 %2 pulsado';
Blockly.Msg['IO_ISBUTTONPRESSED_TOOLTIP'] = 'Devuelve \'True\' si el botón A o B está pulsado, en caso contrario devuelve \'False\'';
Blockly.Msg['IO_ISPINTOUCHED_TITLE'] = '%1 está tocado';
Blockly.Msg['IO_ISPINTOUCHED_TOOLTIP'] = 'Devuelve \'True\' si el logo del micro:bit o el pin P0, P1 o P2 es tocado (o pulsado), de lo contrario devuelve \'False\'';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TITLE'] = 'obtiene las pulsaciones del botón %1';
Blockly.Msg['IO_BUTTONS_GET_PRESSES_TOOLTIP'] = 'Devuelve el número de pulsaciones del botón A o B';
Blockly.Msg['IO_RUN_EVERY_TITLE'] = 'repetir cada %1 hora.s %2 minuto.s %3 segundo.s %4 milisegundo.s';
Blockly.Msg['IO_RUN_EVERY_TOOLTIP'] = 'Ejecuta una función repetidamente. Cada argumento es una unidad de tiempo diferente y se suman. Por ejemplo, run_every(min=2, s=30) programa el recordatorio cada dos minutos y medio . Tenga en cuenta que esta función solo está disponible con micro:bit V2.';
Blockly.Msg['IO_MICROBIT_RESET_TITLE'] = '[Micro:bit] reiniciar placa';
Blockly.Msg['IO_MICROBIT_RESET_TOOLTIP'] = 'Reinicia la placa micro:bit. Esto puede ser útil para restablecer el estado de la placa o reiniciar el programa en ejecución.';
// Input/Output - Microphone module
Blockly.Msg['IO_MICRO_LOUD'] = 'fuerte';
Blockly.Msg['IO_MICRO_QUIET'] = 'silencioso';
Blockly.Msg['IO_MICRO_IS'] = 'es';
Blockly.Msg['IO_MICRO_WAS'] = 'era';
Blockly.Msg['IO_MICRO_ONSOUNDDETECTED_TITLE'] = '[Micro] si %1 sonido %2 detectado entonces';
Blockly.Msg['IO_MICRO_ONSOUNDDETECTED_TOOLTIP'] = 'Ejecutar instrucciones si se detecta la condición de sonido (fuerte/silencioso). Opción \'era\': Ejecutar instrucciones si se ha producido un sonido (fuerte/silencioso) desde la última llamada a \'was_sound()\'';
Blockly.Msg['IO_MICRO_GETCURRENTSOUND_TITLE'] = '[Micro] condición de sonido';
Blockly.Msg['IO_MICRO_GETCURRENTSOUND_TOOLTIP'] = 'Devuelve la condición de sonido (fuerte/silencioso)';
Blockly.Msg['IO_MICRO_WASSOUNDDETECTED_TITLE'] = '[Micro] %1 sonido fue detectado';
Blockly.Msg['IO_MICRO_WASSOUNDDETECTED_TOOLTIP'] = 'Devuelve True si se ha producido un sonido (fuerte/silencioso) desde la última llamada a \'was_sound()\'';
Blockly.Msg['IO_MICRO_GETSOUNDLEVEL_TITLE'] = '[Micro] nivel de sonido';
Blockly.Msg['IO_MICRO_GETSOUNDLEVEL_TOOLTIP'] = 'Habilitar du obtener el nivel de sonido de 0 a 255';
Blockly.Msg['IO_MICRO_GETHISTORYSOUND_TITLE'] = '[Micro] historial de sonidos';
Blockly.Msg['IO_MICRO_GETHISTORYSOUND_TOOLTIP'] = 'Devuelve el historial de sonidos desde la última llamada a \'get_sounds()\'';
Blockly.Msg['IO_MICRO_SETSOUNDTHRESHOLD_TITLE'] = '[Micro] establece %1 umbral de sonido a %2';
Blockly.Msg['IO_MICRO_SETSOUNDTHRESHOLD_TOOLTIP'] = 'Habilitar para establecer el umbral de sonido alto/silencioso de 0 a 255';
Blockly.Msg['IO_MICRO_SOUNDCONDITION_TITLE'] = '[Micro] %1';
Blockly.Msg['IO_MICRO_SOUNDCONDITION_TOOLTIP'] = 'Habilitar para utilizar las constantes (LOUD/QUIET) del módulo de micrófono en la categoría \'Lógica\'';
// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Teclado numérico táctil] obtener número en los pines RX %1 TX %2';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Habilitar para obtener el número tocado del módulo de teclado numérico en los pines RX y TX. Cuando conectes el dispositivo, asegúrate de "cruzar" los cables. El pin TX de micro:bit tiene que estar conectado con el pin RX del dispositivo, y el pin RX con el pin TX del dispositivo';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Módulo Joystick] valor del eje del joystick %1 en los pines A0 %2 A1 %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Devuelve el valor del eje del joystick (de 0 a 1023) en los pines analógicos P0 a P4, o P10';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TITLE'] = '[Módulo de botones de colores] estado en el pin SIG2 %1';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el estado del botón de color Grove (0 o 1) en los pines digitales P0 a P20';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TITLE'] = '[Módulo de botones de color] controla el LED al estado %1 en el pin SIG1 %2';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Permite encender o apagar el LED Button Grove (0 o 1) en los pines digitales P0 hasta P20';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Módulo de ángulo rotativo] ángulo en el pin %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Devuelve la posición del ángulo rotativo de la ranura (de 0 a 1023) en los pines analógicos P0 a P4, o P10';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Potenciómetro de deslizamiento] valor de posición en el pin %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Devuelve el valor de posición del potenciómetro de deslizamiento de la ranura (de 0 a 1023) en los pines analógicos P0 a P4, o P10';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Sensor táctil] estado del tacto en el pin %1 ';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Devuelve el estado del sensor táctil de la arboleda (0 o 1) en los pines digitales P0 a P20';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Módulo de botones] estado del botón en el pin %1 ';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el estado del botón Grove (0 o 1) en los pines digitales P0 a P20';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Módulo de Interruptores] estado del interruptor en el pin %1 ';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Devuelve el estado del interruptor de la ranura (0 o 1) en los pines digitales P0 hasta P20';
// Input/Output - Pins
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'ALTO (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAJO (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Devuelve un valor booleano (1 si es HIGH o 0 si es LOW)';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'leer pin digital %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Habilitar para leer el valor digital de los pines (0 o 1)';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'escribir en el pin digital %1 estado %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Habilitar para escribir el valor (0 o 1) en el pin digital';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'leer pin analógico %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Habilitar para leer el valor analógico de los pines (0-1023)';
Blockly.Msg['IO_WRITEANALOGPIN_TITLE'] = 'Escribe en el pin analógico %1 el valor %2';
Blockly.Msg['IO_WRITEANALOGPIN_TOOLTIP'] = 'Habilitar para escribir en el pin analógico el valor (0-1023). Esta función no escribe realmente el valor analógico, escribe la señal PWM. Por ejemplo, escribiendo 511 tiene un ciclo de trabajo del 50%, la tensión media es de 1,65V';
Blockly.Msg['IO_SETPWM_TITLE'] = 'aplicar una señal de periodo %1 %2 en el pin %3';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Habilitar para aplicar una señal PWM en un pin';
Blockly.Msg['IO_READPULSEIN_TITLE'] = 'Leer pulso en (μs) del estado %1 en el pin %2';
Blockly.Msg['IO_READPULSEIN_TOOLTIP'] = 'Devuelve la duración del pulso en. Elección del estado (HIGH o LOW)';
Blockly.Msg['IO_SET_PULL_TITLE'] = 'ajustar el pin %1 al estado %2';
Blockly.Msg['IO_SET_PULL_TOOLTIP'] = 'Configura el pin para que esté en modo de lectura digital con el modo pull dado.';
Blockly.Msg['IO_SET_PULL_UP'] = 'arriba';
Blockly.Msg['IO_SET_PULL_DOWN'] = 'abajo';
Blockly.Msg['IO_SET_NO_PULL'] = 'ninguno';
// Micro:bit Logs
Blockly.Msg['COMMUNICATION_LOG_DELETE_TITLE'] = 'borrar el registro en la micro:bit';
Blockly.Msg['COMMUNICATION_LOG_DELETE_TOOLTIP'] = 'Borra el registro (HTML) en la placa micro:bit.';
Blockly.Msg['COMMUNICATION_LOG_SERIAL_TITLE'] = 'obtener comentarios en la consola';
Blockly.Msg['COMMUNICATION_LOG_SERIAL_TOOLTIP'] = 'Permite escribir datos del registro en la consola en tiempo real.';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TITLE'] = 'añadir una nueva etiqueta con un temporizador %1';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TOOLTIP'] = 'Permite añadir una etiqueta a la columna de datos del registro. La etiqueta puede ser texto o un número. El temporizador puede ser en segundos, milisegundos, minutos, horas o días.';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TIMESTAMP_MILLISECONDS'] = 'milisegundos';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TIMESTAMP_SECONDS'] = 'segundos';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TIMESTAMP_MINUTES'] = 'minutos';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TIMESTAMP_HOURS'] = 'horas';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TIMESTAMP_DAYS'] = 'días';
Blockly.Msg['COMMUNICATION_LOG_SETLABEL_TIMESTAMP_NONE'] = 'Ninguno';
Blockly.Msg['COMMUNICATION_LOG_ADDDATA_TITLE'] = 'añadir datos a una etiqueta';
Blockly.Msg['COMMUNICATION_LOG_ADDDATA_TOOLTIP'] = 'Permite añadir datos a la columna de datos del registro. La etiqueta puede ser texto o un número. Los datos pueden ser texto o un número.';
Blockly.Msg['COMMUNICATION_LOG_DATA_TITLE'] = 'etiqueta %1 datos %2';
Blockly.Msg['COMMUNICATION_LOG_DATA_TOOLTIP'] = 'Permite añadir datos a la columna de datos del registro. La etiqueta puede ser texto o un número. Los datos pueden ser texto o un número.';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'escribir en el puerto serie %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Escribe una cadena en el puerto serie';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'con';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'newline(s)';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'escribir gráfico';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Este bloque permite escribir datos (digitales) que serán visibles en el trazador. Se puede utilizar con uno o más bloques en formato  "Nombre" y  "Datos". Haga clic en el icono \'Modo gráfico\' para mostrar los gráficos';
Blockly.Msg['COMMUNICATION_DATA'] = 'Datos';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nombre %1 Datos %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Este bloque debe utilizarse en el bloque "Escribir en gráfico". Debe contener el nombre del valor (de texto) a mostrar y el valor en cuestión';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'reproducir música %1 en el puerto serie';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Reproducir la nota seleccionada hasta la ejecución del bloque "Detener la música"';
Blockly.Msg['NOTE_C'] = 'C';
Blockly.Msg['NOTE_C_SHARP'] = 'C#';
Blockly.Msg['NOTE_D'] = 'D';
Blockly.Msg['NOTE_D_SHARP'] = 'D#';
Blockly.Msg['NOTE_E'] = 'E';
Blockly.Msg['NOTE_F'] = 'F';
Blockly.Msg['NOTE_F_SHARP'] = 'F#';
Blockly.Msg['NOTE_G'] = 'G';
Blockly.Msg['NOTE_G_SHARP'] = 'G#';
Blockly.Msg['NOTE_A'] = 'A';
Blockly.Msg['NOTE_A_SHARP'] = 'A#';
Blockly.Msg['NOTE_B'] = 'B';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'reproduce la frecuencia %1 (Hz) en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Este bloque permite reproducir una frecuencia determinada en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'detener la música del puerto serie';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'detener la nota actual del puerto serie';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE'] = 'sobre los datos serie recibidos en %1 entonces';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones si se reciben datos por el puerto serie en la variable \'serialData\'';
// Communication - Radio
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TITLE'] = '[Radio] enviar cadena %1';
Blockly.Msg['COMMUNICATION_RADIO_SENDSTRING_TOOLTIP'] = 'Habilitar el envío de cadena por el módulo de radio de micro:bit';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TITLE'] = '[Radio] enviar número o lista %1';
Blockly.Msg['COMMUNICATION_RADIO_SEND_TOOLTIP'] = 'Habilitar el envío de números o listas por el módulo de radio';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TITLE'] = '[Radio] enviar valor %1 como %2';
Blockly.Msg['COMMUNICATION_RADIO_SENDVALUE_TOOLTIP'] = 'Habilitar el envío de datos con \'nombre\' y su valor por módulo de radio';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TITLE'] = '[Radio] sobre datos recibidos en %1 entonces';
Blockly.Msg['COMMUNICATION_RADIO_ONSTRINGRECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones sobre la cadena recibida por la radio en la variable \'stringData\'';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TITLE'] = '[Radio] sobre los datos recibidos en %1 entonces';
Blockly.Msg['COMMUNICATION_RADIO_ONNUMBERRECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones sobre el número recibido por la radio en la variable \'numberData\'';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TITLE'] = '[Radio] sobre datos recibidos en %1 %2 entonces';
Blockly.Msg['COMMUNICATION_RADIO_ONVALUERECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones sobre el nombre como cadena y el valor como número recibidos por la radio en las variables \'nombre\' y \'valor\'';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TITLE'] = '[Radio] set Channel %1 Power %2 Data size %3 Group %4';
Blockly.Msg['COMMUNICATION_RADIO_CONFIG_TOOLTIP'] = 'Permite configurar el canal de frecuencia (de 0 a 83), el tamaño de los datos (bytes), la potencia de transmisión (de 0 a 7) y el grupo (de 0 a 255)';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] escribe en la tarjeta SD %1 placa %2 en los pines RXI %3 TXO %4 %5 Datas %6';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'El bloque permite escribir datos en la tarjeta SD del módulo Openlog. Para el openlog, el baudrate tiene que ser definido a la mitad del baudrate de micro:bit. Ejemplo: micro:bit v1 (9600 en el archivo config.txt), la tasa de baudios es 4800 en la función uart.init()';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] enviar en los pines RX %1 TX %2 mensaje %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Habilitar el envío de cualquier dato por el módulo bluetooth HC05 en los pines RX/TX';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] sobre mensaje recibido RX %1 TX %2 en %3 entonces';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones sobre los datos recibidos por el módulo Bluetooth HC05 en la variable \'bluetoothData\' en los pines TX/RX';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_SENDDATA_TITLE'] = '[HM10 BT] enviar en los pines RX %1 TX %2 mensaje %3';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HM10_BT + Blockly.Tooltip.SEP + 'Habilitar el envío de cualquier dato por el módulo bluetooth HM10 en los pines RX/TX';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[HM10 BT] en mensaje recibido RX %1 TX %2 en %3 entonces';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HM10_BT + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones sobre los datos recibidos por el módulo Bluetooth HM10 en la variable \'HM10Data\' en los pines TX/RX. Por defecto, el nombre del módulo es MLT-BT05';
// Communication - Tracking modules
Blockly.Msg['COMMUNICATION_GPS_INFO_TYPE'] = 'tipo de trama';
Blockly.Msg['COMMUNICATION_GPS_INFO_CLOCK'] = 'reloj (h, m, s)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LATITUDE'] = 'latitud (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LONGITUDE'] = 'longitud (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_SATELLITE'] = 'número de satélites utilizados';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALTITUDE'] = 'altitud (m)';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALL_FRAME'] = 'todos los fotogramas';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TITLE'] = '[GPS] NMEA frames on pins RX %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Devuelve la lista de tramas NMEA leídas con el módulo GPS Grove SIM28 o Air530 en los pines RX/TX. No es necesario invertir los cables entre los pines del módulo y los indicados en el bloque. La inversión se hace automáticamente en el código python.NAdvertencia: Si utiliza la consola para mostrar los datos del GPS, conecte su tarjeta a la interfaz antes de enviar el programa haciendo clic en el botón [>_ REPL]. Luego transfiera su programa usando el botón [Descargar .hex]';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TITLE'] = '[GPS] get %3 on RX %1 TX %2 pins';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Devuelve los datos seleccionados entre (tipo de trama, reloj, latitud, longitud, altitud) analizados de la trama NMEA (GNGGA o GPGGA) leída con el módulo GPS Grove SIM28 o Air530 en los pines RX/TX. No es necesario invertir los cables entre los pines del módulo y los indicados en el bloque. La inversión se hace automáticamente en el código python.NAdvertencia: Si utiliza la consola para mostrar los datos del GPS, conecte su tarjeta a la interfaz antes de enviar el programa haciendo clic en el botón [>_ REPL]. Luego, transfiera su programa utilizando el botón [Descargar .hex]';
// 05/22 The 2 following blocks removed from toolbox. We keep the block cause of user projects.
Blockly.Msg['COMMUNICATION_GPS_ONDATARECEIVED_TITLE'] = '[GPS] sobre los datos recibidos en los pines TX %1 RX %2 en %3 entonces';
Blockly.Msg['COMMUNICATION_GPS_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones sobre los datos recibidos por el módulo GPS en la variable \'gpsData\' en los pines TX/RX';
Blockly.Msg['COMMUNICATION_GPS_GETINFORMATIONS_TITLE'] = '[GPS] obtiene %1 con datos %2';
Blockly.Msg['COMMUNICATION_GPS_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Devuelve los datos analizados del módulo gps grove elegido en (\'reloj\',\'latitud,\'longitud\')';
// end of the 2 blocks
Blockly.Msg['COMMUNICATION_RTC_MODULE_PCF85063TP'] = 'Alta precisión (0x51)';
Blockly.Msg['COMMUNICATION_RTC_MODULE_DS1307'] = 'v1.2 (0x68)';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TITLE'] = '[Clock RTC %1] initialize at %2 date %3';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permite inicializar el módulo de reloj RTC de alta precisión de Grove (PCF85063TP) o RTC v1.2 (DS1307) para poder leer la fecha y la hora exactas mediante el bloque \'Leer módulo de reloj\'. Coloca el bloque \'on start\'. Conecte el módulo en el puerto I2C. Advertencia: Para que funcione, el módulo DS1307 debe tener una pequeña batería descargada';
Blockly.Msg['DAY_MONDAY'] = 'lunes';
Blockly.Msg['DAY_TUESDAY'] = 'martes';
Blockly.Msg['DAY_WEDNESDAY'] = 'miércoles';
Blockly.Msg['DAY_THURSDAY'] = 'thursday';
Blockly.Msg['DAY_FRIDAY'] = 'viernes';
Blockly.Msg['DAY_SATURDAY'] = 'sábado';
Blockly.Msg['DAY_SUNDAY'] = 'domingo';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TITLE'] = '[Clock RTC %1] initialize at hour %2 minute %3 second %4';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permite inicializar el módulo de reloj RTC de alta precisión de Grove (PCF85063TP) o RTC v1.2 (DS1307) para poder leer la fecha y la hora exactas mediante el bloque \'Leer módulo de reloj\'. Coloca el bloque \'on start\'. Conecte el módulo en el puerto I2C. Advertencia: Para que funcione, el módulo DS1307 debe tener una pequeña batería descargada';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TITLE'] = '[Clock RTC %1] read %2';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Lea la fecha y la hora (elija en el menú desplegable) del módulo de reloj RTC de alta precisión de Grove (PCF85063TP) o RTC v1.2 (DS1307). Para obtener un resultado correcto, utilice primero los dos bloques "Inicializar el módulo de reloj". Conecte el módulo en el puerto I2C. Advertencia: Para que funcione, el módulo DS1307 debe tener una pequeña batería descargada';
Blockly.Msg['CLOCK_ALL_DATA'] = 'tiempo';
Blockly.Msg['CLOCK_YEAR'] = 'año';
Blockly.Msg['CLOCK_MONTH'] = 'mes';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'día del mes';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'día de la semana';
Blockly.Msg['CLOCK_HOUR'] = 'hora';
Blockly.Msg['CLOCK_MINUTE'] = 'minuto';
Blockly.Msg['CLOCK_SECOND'] = 'segundo';
// Communication - UART
Blockly.Msg['COMMUNICATION_SERIAL_INIT_TITLE'] = '[uart] redirigir serie a RX %2 TX %3 baudrate %1';
Blockly.Msg['COMMUNICATION_SERIAL_INIT_TOOLTIP'] = 'Habilitar para redirigir la conexión serie con RX y TX. Cuando conectes el dispositivo, asegúrate de "cruzar" los cables. El pin TX de micro:bit debe estar conectado con el pin RX del dispositivo, y el pin RX con el pin TX del dispositivo';
Blockly.Msg['COMMUNICATION_SERIAL_REDIRECTTOUSB_TITLE'] = '[uart] redirige el puerto serie al puerto USB';
Blockly.Msg['COMMUNICATION_SERIAL_REDIRECTTOUSB_TOOLTIP'] = 'Habilitar para redirigir la conexión serie a USB. Se utiliza si se conectan algunos dispositivos UART al mismo tiempo';
Blockly.Msg['COMMUNICATION_UART_WRITE_TITLE'] = '[uart] escribir datos %1';
Blockly.Msg['COMMUNICATION_UART_WRITE_TOOLTIP'] = 'Escribir datos en el puerto uart';
Blockly.Msg['COMMUNICATION_UART_READ_TITLE'] = '[uart] leer datos';
Blockly.Msg['COMMUNICATION_UART_READ_TOOLTIP'] = 'leer datos del puerto uart';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TITLE'] = '[uart] Datos disponibles';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TOOLTIP'] = 'Devuelve un boolen (1 si hay datos para leer 0 si no)';
// Sensors - common msg
Blockly.Msg['SENSORS_TEMPERATURE'] = 'temperatura';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'en';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humedad (%)';
Blockly.Msg['SENSORS_PRESSURE'] = 'presión (Pa)';
Blockly.Msg['SENSORS_ALTITUDE'] = 'altitud (m)';
// Sensors - Micro:bit
Blockly.Msg['SENSORS_GETACCELERATION_TITLE'] = 'aceleración (mg) %1';
Blockly.Msg['SENSORS_GETACCELERATION_TOOLTIP'] = 'Devuelve la aceleración (en mg) con el acelerómetro interno de micro:bit';
Blockly.Msg['SENSORS_GETLIGHT_TITLE'] = 'nivel de luz';
Blockly.Msg['SENSORS_GETLIGHT_TOOLTIP'] = 'Devuelve el nivel de luz (de 0 a 255) con algún LED de la pantalla de micro:bit.';
Blockly.Msg['SENSORS_CALIBRATECOMPASS_TITLE'] = 'Calibrar brújula';
Blockly.Msg['SENSORS_CALIBRATECOMPASS_TOOLTIP'] = 'Habilitar para calibrar la brújula interna del micro:bit. Basta con agitar la placa para calibrarla. Un smiley \'feliz\' aparece cuando se completa la calibración';
Blockly.Msg['SENSORS_GETCOMPASS_TITLE'] = 'rumbo de la brújula (°)';
Blockly.Msg['SENSORS_GETCOMPASS_TOOLTIP'] = 'Devuelve el rumbo de la brújula (de 0° a 360°) con la brújula interna de micro:bit';
Blockly.Msg['SENSORS_ISCOMPASSCALIBRATED_TITLE'] = '¿Calibrado el compás?';
Blockly.Msg['SENSORS_ISCOMPASSCALIBRATED_TOOLTIP'] = 'Devuelve \'True\' si la brújula está calibrada, en caso contrario devuelve \'False\'';
Blockly.Msg['SENSORS_GETTEMPERATURE_TITLE'] = Blockly.Msg['SENSORS_TEMPERATURE'] + ' en %1';
Blockly.Msg['SENSORS_GETTEMPERATURE_TOOLTIP'] = 'Devuelve la temperatura en grados Celius (°C), Fahrenheit (°F) o Kelvin (K) del procesador micro:bit';
Blockly.Msg['SENSORS_GETROTATION_TITLE'] = 'rotación (°) %1';
Blockly.Msg['SENSORS_GETROTATION_PITCH'] = 'tono';
Blockly.Msg['SENSORS_GETROTATION_ROLL'] = 'balanceo';
Blockly.Msg['SENSORS_GETROTATION_TOOLTIP'] = 'Devuelve la rotación (de -180° a 180°) con el acelerómetro interno de micro:bit';
Blockly.Msg['SENSORS_GETMAGNETICFORCE_TITLE'] = 'intensidad del campo magnético %1 (nT)';
Blockly.Msg['SENSORS_GETMAGNETICFORCE_TOOLTIP'] = 'Devuelve la intensidad del campo magnético (en nT) en la dirección elegida desde la brújula interna de micro:bit';
// Sensors - Enviro:bit
Blockly.Msg['SENSORS_TCS3472_GETRGB_TITLE'] = '[Enviro:bit - TCS3472] %1';
Blockly.Msg['SENSORS_TCS3472_GETRGB_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Permite leer el nivel de uno de los tres colores primarios (de 0 a 255) con el sensor de color integrado TCS3472 en el escudo Enviro:bit';
Blockly.Msg['SENSORS_TCS3472_GETBRIGHTNESS_TITLE'] = '[Enviro:bit - TCS3472] brillo';
Blockly.Msg['SENSORS_TCS3472_GETBRIGHTNESS_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Habilitar para medir el brillo (de 0 a 1000) con el sensor TCS3472 del escudo Enviro:bit';
Blockly.Msg['SENSORS_TCS3472_SETLED_TITLE'] = '[Enviro:bit - TCS3472] poner el LED en estado %1';
Blockly.Msg['SENSORS_TCS3472_SETLED_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Habilitar para controlar el LED integrado del sensor TCS3472 desde el escudo Enviro:bit';
Blockly.Msg['SENSORS_ENVIROBIT_BME280_GETDATA_TITLE'] = '[Enviro:bit - BME280] %1';
Blockly.Msg['SENSORS_ENVIROBIT_BME280_GETDATA_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grados Celius (°C), Fahrenheit (°F) o Kelvin (K), la presión (en Pa), la humedad (en %) o la altitud (en m) del sensor BME280 en el escudo Enviro:bit';
Blockly.Msg['SENSORS_BME280_TEMP'] = Blockly.Msg['SENSORS_TEMPERATURE'];
Blockly.Msg['SENSORS_BME280_HUM'] = Blockly.Msg['SENSORS_HUMIDITY'];
Blockly.Msg['SENSORS_BME280_PRESS'] = Blockly.Msg['SENSORS_PRESSURE'];
Blockly.Msg['SENSORS_BME280_ALT'] = Blockly.Msg['SENSORS_ALTITUDE'];
Blockly.Msg['SENSORS_ENVIRO_BIT_GETSOUNDLEVEL_TITLE'] = '[Enviro:bit - micro] nivel de sonido';
Blockly.Msg['SENSORS_ENVIRO_BIT_GETSOUNDLEVEL_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Toma una lectura del nivel de sonido (de 0 a 443) que puedes utilizar para comparar diferentes niveles de sonido';
Blockly.Msg['SENSORS_ENVIRO_BIT_WAIT_CLAP_TITLE'] = '[Enviro:bit - micro] está escuchando %1 clap.s en %2 segundo.s';
Blockly.Msg['SENSORS_ENVIRO_BIT_WAIT_CLAP_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Escucha un nivel de sonido alto dos veces en un segundo, devuelve True si se detecta.';
Blockly.Msg['SENSORS_WEATHERBIT_BME280_GETDATA_TITLE'] = '[Weather:bit - BME280] %1';
Blockly.Msg['SENSORS_WEATHERBIT_BME280_GETDATA_TOOLTIP'] = IMG_MODULE_WEATHER_BIT + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grados Celius (°C), Fahrenheit (°F) o Kelvin (K), la presión (en Pa), la humedad (en %) o la altitud (en m) del sensor BME280 en el escudo Weather:bit';
Blockly.Msg['SENSORS_WEATHERBIT_GETSOILMOISTURE_TITLE'] = '[Weather:bit] humedad del suelo';
Blockly.Msg['SENSORS_WEATHERBIT_GETSOILMOISTURE_TOOLTIP'] = IMG_MODULE_WEATHER_BIT_MOSITURE + Blockly.Tooltip.SEP + 'Devuelve la medición (de 0 a 1023) del sensor de humedad (SOIL MOISTURE) en P0';
Blockly.Msg['SENSORS_WEATHERBIT_ANEMOMETER_GET_SPEED_TITLE'] = '[Weather:bit] velocidad del viento en %1';
Blockly.Msg['SENSORS_WEATHERBIT_ANEMOMETER_GET_SPEED_TOOLTIP'] = IMG_MODULE_WEATHER_BIT_KIT_MICROBIT + Blockly.Tooltip.SEP + 'Devuelve la velocidad del viento con el anemómetro en la unidad elegida (en m/s, km/s, pulgadas/s o nudos). El anemómetro está conectado al puerto RJ45 WIND del escudo Weather:bit';
Blockly.Msg['SENSORS_UNIT_M_S'] = '(m/s)';
Blockly.Msg['SENSORS_UNIT_KM_H'] = '(km/h)';
Blockly.Msg['SENSORS_UNIT_INCH_S'] = '(inch/s)';
Blockly.Msg['SENSORS_UNIT_KNOT'] = '(nudos)';
Blockly.Msg['SENSORS_WEATHERBIT_WEATHERCOCK_GET_DIRECTION_TITLE'] = '[Weather:bit - wind] dirección del viento';
Blockly.Msg['SENSORS_WEATHERBIT_WEATHERCOCK_GET_DIRECTION_TOOLTIP'] = IMG_MODULE_WEATHER_BIT_KIT_MICROBIT + Blockly.Tooltip.SEP + 'Devuelve la dirección del viento (N,S,E,W,NE,NO,SE,SO) en una cadena. La veleta se conecta con el anemómetro en el puerto RJ45 WIND del escudo Weather:bit';
Blockly.Msg['SENSORS_WEATHERBIT_RAIN_GAUGE_GET_DUMPS_TITLE'] = '[Weather:bit - rain] rain dumps (mm)';
Blockly.Msg['SENSORS_WEATHERBIT_RAIN_GAUGE_GET_DUMPS_TOOLTIP'] = IMG_MODULE_WEATHER_BIT_KIT_MICROBIT + Blockly.Tooltip.SEP + 'Devuelve la precipitación de agua en altura del agua caída en el suelo reportada a una unidad de superficie. El pluviómetro se conecta al puerto RJ45 RAIN del escudo Weather:bit';
// Sensors - Kitronik environmental
Blockly.Msg['SENSORS_KITRONIK_BME280_GETDATA_TITLE'] = '[Kitronik env. - BME280] %1';
Blockly.Msg['SENSORS_KITRONIK_BME280_GETDATA_TOOLTIP'] = IMG_SHIELD_KITRONIK_ENV + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grados Celsius (°C) de -40 a 85°C, Fahrenheit (°F) o Kelvin (K), la humedad (en %), la presión (en Pascales) o la altitud (en m) gracias al sensor BME280 del escudo Kitronik.';
Blockly.Msg['SENSORS_KITRONIK_KLIMATE_BME280_GETDATA_TITLE'] = '[Kitronik Klimate - BME280] %1';
Blockly.Msg['SENSORS_KITRONIK_KLIMATE_BME280_GETDATA_TOOLTIP'] = IMG_SHIELD_KITRONIK_KLIMATE + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grados Celsius (°C) de -40 a 85°C, Fahrenheit (°F) o Kelvin (K), la humedad (en %), la presión (en Pascales) o la altitud (en m) gracias al sensor BME280 del escudo Kitronik.';
// Sensors - Kitronic Traffic
Blockly.Msg['SENSORS_LAMPBIT_GETLUMINOSITY_TITLE'] = "[LAMP:BIT] luminosidad";
Blockly.Msg['SENSORS_LAMPBIT_GETLUMINOSITY_TOOLTIP'] = IMG_MODULE_LAMPBIT + Blockly.Tooltip.SEP + "Recupera la luminosidad del fototransistor de la farola";
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[Sensor SGP30] gas %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Devuelve la cantidad de CO2 (en ppm) o TVOC (en ppb) en el aire del sensor sgp30. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'dióxido de carbono (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'compuestos orgánicos volátiles (TVOC) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Sensor de gas multicanal] gas %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Devuelve la cantidad de gas elegida en el aire (en ppm) del sensor de gas multicanal de Grove. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Sensor de gas multicanal v2] gas %1 (V)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Devuelve la cantidad de gas elegida en el aire (en V) del sensor multicanal de gas V2. Conecte el sensor en el puerto I2C';
Blockly.Msg['GAS_CO'] = 'monóxido de carbono (CO)';
Blockly.Msg['GAS_NO2'] = 'dióxido de nitrógeno (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'etanol (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'dihidrógeno (H2)';
Blockly.Msg['GAS_NH3'] = 'amoníaco (NH3)';
Blockly.Msg['GAS_CH4'] = 'metano (CH4)';
Blockly.Msg['GAS_C3H8'] = 'propano (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'isopropano (C4H10)';
Blockly.Msg['GAS_VOC'] = 'compuestos orgánicos volátiles (COV)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Sensor de gas oxígeno] O2 (%) en el pin %1';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Devuelve la concentración de O2 (en %) del sensor de O2 del surco en los pines P0 a P4, o P10';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[Sensor SCD30] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Devuelve la concentración de CO2 (en ppm), la humedad (en %) o la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K) del sensor SCD30 de Grove. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'dióxido de carbono (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = Blockly.Msg['SENSORS_TEMPERATURE'];
Blockly.Msg['SENSORS_SCD30_HUM'] = Blockly.Msg['SENSORS_HUMIDITY'];
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[Capteur SCD30] forzar recalibración a %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Forzar la calibración del sensor SCD30 al valor dado (en ppm). Salga al exterior (donde la concentración sea de aproximadamente 420 ppm, es decir, aire limpio), reinicie la placa y espere 2 minutos. Consejo: Utilice el botón A o B de la placa BBC micro:bit para controlar el inicio de la calibración. De lo contrario, al volver a conectar la placa, el programa se lanza y vuelve a realizar una calibración no necesariamente deseada';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Sensor de calidad del aire] valor en el pin %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Devuelve el valor de la calidad del aire (de 0 a 1023) en los pines P0 a P4, o P10.';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[Sensor HM330X] concentración de partículas %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Detecta la densidad de partículas en el aire con el sensor HM330X. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
// Sensors - Climate
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[Sensor BMP280 %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grados Celius (°C), Fahrenheit (°F) o Kelvin (K), presión (en Pa). La altitud se inicializa en 0 cuando el programa se pone en marcha. Utiliza el sensor de barómetro Grove (dirección: 0x77, color: azul) o el sensor HW-611 280 (dirección: 0x76, color: púrpura). Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_BMP280_TEMP'] = Blockly.Msg['SENSORS_TEMPERATURE'];
Blockly.Msg['SENSORS_BMP280_PRESS'] = Blockly.Msg['SENSORS_PRESSURE'];
Blockly.Msg['SENSORS_BMP280_ALT'] = Blockly.Msg['SENSORS_ALTITUDE'];
Blockly.Msg['SENSORS_BME280_GETDATA_TITLE'] = '[Sensor BME280] %1';
Blockly.Msg['SENSORS_BME280_GETDATA_TOOLTIP'] = IMG_MODULE_BME280 + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grados Celsius (°C) de -40 a 85 °C, Fahrenheit (°F) o Kelvin (K), humedad (en %), presión (en Pascal) o altitud (en m) del sensor BME280';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = '[sensor H.T°] temperatura en %1 en los pines A0 %2 A1 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Devuelve la temperatura del termopar entre 50 y 600 °C con el sensor de alta temperatura de Grove. Conecte el sensor en los pines analógicos';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Sensor de humedad] humedad en el pin %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Devuelve la medición de humedad (de 0 a 1023) del sensor de humedad de la arboleda en los pines P0 a P4, o P10';
Blockly.Msg['SENSORS_GETGROVECAPACITIVEMOISTURE_TITLE'] = '[Sensor de Humedad Capacitivo] humedad del suelo %1';
Blockly.Msg['SENSORS_GETGROVECAPACITIVEMOISTURE_TOOLTIP'] = IMG_MODULE_CAPACITIVE_MOISTURE + Blockly.Tooltip.SEP + 'Devuelve la humedad (de 0 a 1023) medida por el sensor de humedad capacitivo Grove en los pines P0/P14, P1/P15, o P2/P16.';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Sensor de temperatura] temperatura en %1 en el pin %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de temperatura de la arboleda en grados Celius (°C), Fahrenheit (°F) o Kelvin (K) en los pines analógicos P0 a P4, o P10';
Blockly.Msg['SENSORS_DHT_READDATA_TITLE'] = '[Sensor DHT11] %1 en el pin %2 con %3';
Blockly.Msg['SENSORS_DHT_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad del aire (en %) del sensor dht11 en los pines digitales P0 a P20. El sensor realiza una nueva medición cada 2 segundos con el micro:bit v1. Realiza una nueva medición cada 20 segundos con el micro:bit v2';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[Sensor TH02] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad del aire (en %) del sensor TH02. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Sensor SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad del aire (en %) del sensor SHT31. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_MPX5700AP_GETPRESSURE_TITLE'] = '[Sensor MPX5700AP] presión (kPa) en el pin %1';
Blockly.Msg['SENSORS_MPX5700AP_GETPRESSURE_TOOLTIP'] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + 'Permite leer la presión del sensor de ranura con la calculadora TI-83';
Blockly.Msg['SENSORS_MPX5700AP_CALIBRATE_TITLE'] = '[Sensor MPX5700AP] calibrar sensor de presión m %1 b %2';
Blockly.Msg['SENSORS_MPX5700AP_CALIBRATE_TOOLTIP'] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + 'Habilitar para calibrar el sensor de presión con la calculadora TI-83';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Sensor de agua] cantidad de agua en el pin %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Devuelve la cantidad de agua (de 0 a 255) del sensor de agua de la arboleda en los pines P0 a P4, o P10';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Sensor de pluviómetro] valor de estado en el pin %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Devuelve el estado del pluviómetro (1 si está lloviendo o 0 si no) en los pines digitales P0 a P20';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anemómetro] valor del estado en el pin %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Devuelve el estado del anemómetro de la arboleda (dos veces el estado HIGH en cada rotación) en los pines digitales P0 hasta P20';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Sensor de luz] nivel de luz en el pin %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de luz de la arboleda (de 0 a 1023) en los pines analógicos P0 a P4, o P10';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[Sensor SI1145] obtener luz %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Devuelve el índice de luz ultravioleta, luz IR (en lumen) o luz visible (en lumen) del sensor si1145. Funciona con el sensor de luz solar Grove o el sensor GY1145. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_SI1145_UV'] = 'Índice UV';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visible (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrarrojo (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Sensor Ultravioleta] Índice UV en el pin %1';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Devuelve el índice UV, para las ondas entre 240 nm y 380 nm, con el sensor de rayos UV en los pines analógicos A0 a A5';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Sensor de color] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Permite leer el nivel de uno de los tres colores primarios con el sensor de color Grove, devuelve un nivel entre 0 y 255. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Sensor de sonido] nivel de sonido (dB) en el pin %1 ';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de sonido de la arboleda (de 0 a 1023 convertido en dB) en los pines analógicos P0 a P4, o P10';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Sensor Ultrasónico %1] obtiene %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Devuelve la medida de la distancia (en cm) o la duración del viaje de ida y vuelta (en µs) del sensor ultrasónico del ranger en los pines digitales P0 a P20. Atención, si es un sensor de ranger, TRIG y ECHO están conectados a SIG';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distancia (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'duración del viaje de ida y vuelta (µs)';
Blockly.Msg['SENSORS_ULTRASONIC_1PIN'] = 'en el pin';
Blockly.Msg['SENSORS_ULTRASONIC_2PINS'] = 'en pines';
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TITLE'] = '[Time Of Flight] Distance in %1';
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TOOLTIP'] = IMG_MODULE_VL53L0X + Blockly.Tooltip.SEP + 'Devuelve las mediciones de distancia del sensor TOF en el puerto I2C.';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = '[Sensor de gestos] tipo de gesto';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Devuelve el tipo de gesto (\'derecha\', \'izquierda\', \'arriba\', \'abajo\', \'hacia delante\', \'hacia atrás\', \'en el sentido de las agujas del reloj\', \'en sentido contrario\') del sensor de gestos Grove. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Sensor de gestos] en el gesto %1 detectado entonces';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Ejecuta las instrucciones si el sensor de gestos de Grove detecta el gesto seleccionado. Conecte el sensor en el puerto I2C';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'derecho';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'izquierda';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'arriba';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'abajo';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'hacia adelante';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'hacia atrás';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'en el sentido de las agujas del reloj';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'en sentido contrario a las agujas del reloj';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'onda';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Sensor del buscador de líneas] estado del buscador de líneas en el pin %1';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Devuelve el estado del sensor táctil de ranura (0 o 1) en los pines digitales P0 a P20';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[Sensor de movimiento PIR] valor del estado de movimiento en el pin %1';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Devuelve el estado de movimiento del PIR (0 si hay movimiento o 1 en caso contrario) en los pines digitales P0 a P20';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Sensor de vibración piezoeléctrico] valor del estado en el pin %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Devuelve el estado de vibración (0 o 1) del sensor piezoeléctrico de vibración en los pines digitales P0 a P20';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Módulo de inclinación] estado de inclinación en el pin %1';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Devuelve el estado de inclinación de la arboleda (0 o 1) en los pines digitales P0 hasta P20';
// Other sensors
Blockly.Msg['SENSORS_GETGROVEBUTTON_TITLE'] = '[Módulo de botones] botón %1 en el pin %2';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el valor numérico del botón Grove (0/1 o 0V/3.3V) en los pines digitales P0 hasta P20';
Blockly.Msg['SENSORS_GETGROVEBUTTON_VOLTAGE'] = 'voltaje';
Blockly.Msg['SENSORS_GETGROVEBUTTON_STATE'] = 'estado';
Blockly.Msg['SENSORS_GET_EAR-CLIP_HEART_RATE_TITLE'] = '[Sensor de Frecuencia Cardíaca] bpm en el pin %1';
Blockly.Msg['SENSORS_GET_EAR-CLIP_HEART_RATE_TOOLTIP'] = IMG_MODULE_EAR_CLIP + Blockly.Tooltip.SEP + 'Devuelve el número de latidos por minuto (bpm) medido por el sensor cardíaco Grove.';
Blockly.Msg['SENSORS_GET_WATER_LEVEL_TITLE'] = '[Nivel de agua] valor';
Blockly.Msg['SENSORS_GET_WATER_LEVEL_TOOLTIP'] = 'Mide el nivel de agua en porcentaje (de 0 a 100%) en el puerto I2C.';
// Actuadores
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servo Motor] establecer ángulo a %1 ° en el pin %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permite controlar el ángulo de un servo motor (de 0 a 180) en los pines digitales P0 a P20. Tenga en cuenta que la configuración debe estar alimentada por una batería para proporcionar suficiente corriente al servo motor.';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Servo Continuo] establecer velocidad a %1 (%) dirección %2 en el pin %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Permite controlar la velocidad (de 0 a 100%) de un servo motor continuo en los pines PWM.';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Motor] establecer potencia a %1 en el pin %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permite controlar la potencia de un motor (de 0 a 1023) en los pines digitales P0 a P20. Tenga en cuenta que la configuración debe estar alimentada por una batería para proporcionar suficiente corriente al motor.';
Blockly.Msg["ACTUATORS_FAN_SETPOWER_TITLE"] = "[Ventilador] establecer potencia a %1 en el pin %2";
Blockly.Msg["ACTUATORS_FAN_SETPOWER_TOOLTIP"] = IMG_MODULE_FAN + Blockly.Tooltip.SEP + "Permite controlar la potencia de un mini ventilador (de 0 a 1023) en los pines digitales P0 a P20.";
Blockly.Msg['ACTUATORS_KITRONIK_CONTROLMOTOR_TITLE'] = '[Kitronik Shield] controlar motor %1 dirección %2 velocidad %3';
Blockly.Msg['ACTUATORS_KITRONIK_CONTROLMOTOR_TOOLTIP'] = IMG_SHIELD_KITRONIK + Blockly.Tooltip.SEP + 'Permite controlar MOTOR1, MOTOR2 o ambos cambiando la dirección (↻: ADELANTE, ↺: ATRÁS) o la velocidad (de 0 a 100%) del escudo de motor Kitronik para BBC micro:bit. La fuente de alimentación del escudo debe estar entre 3V y 10V.';
Blockly.Msg['ACTUATORS_KITRONIK_STOPMOTOR_TITLE'] = '[Kitronik Shield] detener motor %1';
Blockly.Msg['ACTUATORS_KITRONIK_STOPMOTOR_TOOLTIP'] = IMG_SHIELD_KITRONIK + Blockly.Tooltip.SEP + 'Permite detener MOTOR1, MOTOR2 o ambos en el escudo de motor Kitronik para BBC micro:bit. La fuente de alimentación del escudo debe estar entre 3V y 10V.';
Blockly.Msg['ACTUATORS_KITRONIK_MOTOR_BOTH'] = 'ambos';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Módulo Relé] controlar relé al estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Permite controlar el estado del relé (0 o 1) en los pines digitales P0 a P20.';
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TITLE'] = '[MOSFET] establecer estado a %1 en el pin %2';
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permite controlar el estado del transistor MOSFET (0 o 1) en un pin PWM.';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TITLE'] = '[MOSFET] establecer potencia a %1 (%) en el pin %2';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permite controlar la potencia de salida del transistor MOSFET (de 0 a 100%) en un pin PWM.';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Motor de Vibración] controlar motor al estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Permite activar o desactivar el motor de vibración Grove (0 o 1) en los pines digitales P0 a P20.';
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TITLE'] = '[Electroimán] controlar estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TOOLTIP'] = IMG_MODULE_ELECTROMAGNET + Blockly.Tooltip.SEP + 'Permite activar o desactivar el electroimán (HIGH o LOW) en los pines digitales.';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TITLE'] = '[Atomizador de Agua] controlar estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TOOLTIP'] = IMG_MODULE_WATER_ATOMIZER + Blockly.Tooltip.SEP + 'Permite activar o desactivar el atomizador de agua (HIGH o LOW) en los pines digitales.';

// Actuadores - Kitronik Traffic
Blockly.Msg['ACTUATORS_ACCESSBIT_CONTROLBARRIER_TITLE'] = "[ACCESS:BIT] %1 la barrera";
Blockly.Msg['ACTUATORS_ACCESSBIT_CONTROLBARRIER_RAISE'] = "levantar";
Blockly.Msg['ACTUATORS_ACCESSBIT_CONTROLBARRIER_LOWER'] = "bajar";
Blockly.Msg['ACTUATORS_ACCESSBIT_CONTROLBARRIER_TOOLTIP'] = IMG_MODULE_ACCESSBIT + Blockly.Tooltip.SEP + "Controla la posición de la barrera";
Blockly.Msg['ACTUATORS_ACCESSBIT_CONTROLBUZZER_TITLE'] = "[ACCESS:BIT] Zumbador encendido por %1 ms";
Blockly.Msg['ACTUATORS_ACCESSBIT_CONTROLBUZZER_TOOLTIP'] = IMG_MODULE_ACCESSBIT + Blockly.Tooltip.SEP + "Activa el zumbador durante el tiempo establecido";

// MÚSICA
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TITLE'] = '[Música] reproducir música %1 en %2';
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permite reproducir música con el zumbador o módulo de altavoz Grove en los pines digitales P0 a P20.';
Blockly.Msg['ACTUATORS_MUSIC_PLAYSONG_TITLE'] = '[Música] reproducir melodía %1 %2 en %3';
Blockly.Msg['ACTUATORS_MUSIC_PLAYSONG_ONCE'] = 'una vez';
Blockly.Msg['ACTUATORS_MUSIC_PLAYSONG_LOOP'] = 'en bucle';
Blockly.Msg['ACTUATORS_MUSIC_PLAYSONG_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permite reproducir una melodía con un zumbador o un módulo de altavoz en los pines digitales P0 a P20.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TITLE'] = '[Música] reproducir notas en';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permite reproducir notas con un zumbador o módulo de altavoz en los pines digitales P0 a P20.';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TITLE'] = 'nota %1 en octava %2 duración %3';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permite definir una nota con su octava y duración.';
Blockly.Msg['MUSIC_SILENCE'] = 'Silencio';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TITLE'] = '[Música] reproducir frecuencia %1 durante %2 (ms) en %3';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TITLE'] = '[Música] detener música en %1';
Blockly.Msg['ACTUATORS_MUSIC_SETVOLUME_TITLE'] = '[Música] establecer volumen a %1';
Blockly.Msg['ACTUATORS_MUSIC_SETTEMPO_TITLE'] = '[Música] establecer compases por medida %1 y tempo %2';
Blockly.Msg['ACTUATORS_MUSIC_GETTEMPO_TITLE'] = '[Música] obtener tempo de la música';
Blockly.Msg['ACTUATORS_KITRONIK_PLAY_FREQUENCY_TITLE'] = '[Kitronik Env. Shield] reproducir frecuencia %1 durante %2 ms';
Blockly.Msg['ACTUATORS_SPEECH_SAYSOMETHING_TITLE'] = '[Voz] decir %1 velocidad %2 tono %3';
// Robots - Maqueen
Blockly.Msg['ROBOTS_REMOTECONTROL_ONCOMMANDRECEIVED_TITLE'] = 'si comando %1';
Blockly.Msg['ROBOTS_REMOTECONTROL_ONCOMMANDRECEIVED_RECEIVED_THEN'] = 'recibido entonces';
Blockly.Msg['ROBOTS_REMOTECONTROL_ONCOMMANDRECEIVED_BLACK_NEC_DETECTED_THEN'] = 'recibido por el mando a distancia negro básico NEC entonces';
Blockly.Msg['ROBOTS_REMOTECONTROL_ONCOMMANDRECEIVED_BLACK_NEC_TOOLTIP'] = IMG_MODULE_BASIC_BLACK_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones sobre el comando recibido por transmisión IR desde el control remoto negro básico NEC.';
Blockly.Msg['ROBOTS_REMOTECONTROL_ONCOMMANDRECEIVED_CAR_MP3_GRAY_DETECTED_THEN'] = 'recibido por el mando a distancia gris NEC <br>Car mp3<br> entonces';
Blockly.Msg['ROBOTS_REMOTECONTROL_ONCOMMANDRECEIVED_CAR_MP3_GRAY_TOOLTIP'] = IMG_MODULE_CAR_MP3_GRAY_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones sobre el comando recibido por transmisión IR desde el mando a distancia gris NEC Car mp3.';
Blockly.Msg['REMOTE_NEC_BUTTON'] = 'pad ';
Blockly.Msg['REMOTE_NEC_BUTTON_UP'] = 'arriba';
Blockly.Msg['REMOTE_NEC_BUTTON_DOWN'] = 'abajo';
Blockly.Msg['REMOTE_NEC_BUTTON_LEFT'] = 'izquierda';
Blockly.Msg['REMOTE_NEC_BUTTON_RIGHT'] = 'derecha';
Blockly.Msg['REMOTE_NEC_BUTTON_BACK'] = 'atrás';
// Robots - Maqueen
Blockly.Msg['ROBOTS_MAQUEEN_RIGHT'] = 'Derecha';
Blockly.Msg['ROBOTS_MAQUEEN_LEFT'] = 'Izquierda';
Blockly.Msg['ROBOTS_MAQUEEN_RIGHT&LEFT'] = 'Derecha e izquierda';
Blockly.Msg['ROBOTS_MAQUEEN_ULTRASONICRANGER_TITLE'] = '[Maqueen] ultrasónico %1';
Blockly.Msg['ROBOTS_MAQUEEN_ULTRASONICRANGER_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Devuelve el valor de la distancia (en cm) o la duración de la onda de ida y vuelta (en μs) desde cualquier objeto hasta el robot maqueen con sensor de alcance ultrasónico';
Blockly.Msg['ROBOTS_MAQUEEN_ULTRASONIC_DISTANCE'] = 'distancia (cm)';
Blockly.Msg['ROBOTS_MAQUEEN_ULTRASONIC_DURATION'] = 'duración del viaje de ida y vuelta (μs)';
Blockly.Msg['ROBOTS_MAQUEEN_CONTROLLED_TITLE'] = '[Maqueen] controla el LED rojo %1 al estado %2';
Blockly.Msg['ROBOTS_MAQUEEN_CONTROLLED_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Habilitar para controlar el valor del estado del LED derecho o izquierdo del robot maqueen';
Blockly.Msg['ROBOTS_MAQUEEN_GO_TITLE'] = '[Maqueen] controlar robot %1 velocidad %2';
Blockly.Msg['ROBOTS_MAQUEEN_GO_FORWARD'] = 'hacia adelante';
Blockly.Msg['ROBOTS_MAQUEEN_GO_REVERSE'] = 'hacia atrás';
Blockly.Msg['ROBOTS_MAQUEEN_GO_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permite controlar la marcha del coche (ADELANTE/ATRÁS) y la velocidad (de 0 a 255) del robot maqueen';
Blockly.Msg['ROBOTS_MAQUEEN_CONTROLMOTOR_TITLE'] = '[Maqueen] controlar motor %1 dirección %2 velocidad %3';
Blockly.Msg['ROBOTS_MAQUEEN_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permite controlar el motor derecho (dirección I2C : 0x02) y el motor izquierdo (dirección I2C : 0x00) cambiando la dirección (↻ : FOWARD, ↺ : REVERSE) o la velocidad (de 0 a 255) del robot maqueen';
Blockly.Msg['ROBOTS_MAQUEEN_ROTATE_TITLE'] = '[Maqueen] rotar %1 velocidad %2';
Blockly.Msg['ROBOTS_MAQUEEN_ROTATE_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permite controlar el motor derecho (dirección I2C: 0x02) y el motor izquierdo (dirección I2C: 0x00) cambiando la dirección (↻: ADELANTE, ↺: ATRÁS) o la velocidad (de 0 a 255) del robot Maqueen.';
Blockly.Msg['ROBOTS_MAQUEEN_STOPMOTORS_TITLE'] = '[Maqueen] parar motor %1';
Blockly.Msg['ROBOTS_MAQUEEN_STOPMOTORS_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Habilitar para detener el motor derecho, el izquierdo o ambos del robot maqueen';
Blockly.Msg['ROBOTS_MAQUEEN_SETSERVOANGLE_TITLE'] = '[Maqueen] establece el servo %1 al ángulo %2 °';
Blockly.Msg['ROBOTS_MAQUEEN_SETSERVOANGLE_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permite controlar el servomotor S1 (dirección I2C : 0x14) y S2 (dirección I2C : 0x15) mediante el ajuste del ángulo (de 0 a 180) del robot maqueen';
Blockly.Msg['ROBOTS_MAQUEEN_S1'] = 'S1';
Blockly.Msg['ROBOTS_MAQUEEN_S2'] = 'S2';
Blockly.Msg['ROBOTS_MAQUEEN_SERVO_BOTH'] = 'ambos';
Blockly.Msg['ROBOTS_MAQUEEN_MOVE_ONE_SQUARE_FORWARD_TITLE'] = '[Maqueen] mover un cuadrado hacia adelante';
Blockly.Msg['ROBOTS_MAQUEEN_MOVE_ONE_SQUARE_FORWARD_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Mueve el robot Maqueen una casilla hacia adelante';
Blockly.Msg['ROBOTS_MAQUEEN_MOVE_ONE_SQUARE_BACKWARD_TITLE'] = '[Maqueen] retrocede una casilla';
Blockly.Msg['ROBOTS_MAQUEEN_MOVE_ONE_SQUARE_BACKWARD_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Mueve el robot Maqueen una casilla hacia atrás';
Blockly.Msg['ROBOTS_MAQUEEN_TURN_LEFT_TITLE'] = '[Maqueen] gira a la izquierda';
Blockly.Msg['ROBOTS_MAQUEEN_TURN_LEFT_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Gira el robot Maqueen a la izquierda';
Blockly.Msg['ROBOTS_MAQUEEN_TURN_RIGHT_TITLE'] = '[Maqueen] gira a la derecha';
Blockly.Msg['ROBOTS_MAQUEEN_TURN_RIGHT_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Gira el robot Maqueen a la derecha';
Blockly.Msg['ROBOTS_MAQUEEN_STOP_ROBOT_TITLE'] = '[Maqueen] está deteniendo el robot';
Blockly.Msg['ROBOTS_MAQUEEN_STOP_ROBOT_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Detener los motores del robot Maqueen.';
Blockly.Msg['ROBOTS_MAQUEEN_BLINK_ROBOT_TITLE'] = '[Maqueen] robot parpadeante';
Blockly.Msg['ROBOTS_MAQUEEN_BLINK_ROBOT_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Blink the Maqueen robot.';
Blockly.Msg['ROBOTS_MAQUEEN_READPATROL_TITLE'] = '[Maqueen] lee la línea de patrulla %1';
Blockly.Msg['ROBOTS_MAQUEEN_READPATROL_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permite leer el estado del sensor de patrulla de línea del robot maqueen. El bloque devuelve 0 si el sensor está sobre la línea';
Blockly.Msg['ROBOTS_MAQUEEN_SETNEOPIXEL_TITLE'] = '[Maqueen] establece el color R %2 G %3 B %4 en el LED %1';
Blockly.Msg['ROBOTS_MAQUEEN_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permite controlar cada color del LED ([R,G,B] de 0 a 255) del neopixel Maqueen (P15)';
Blockly.Msg['ROBOTS_MAQUEEN_SETPALETTECOLOR_TITLE'] = '[Maqueen] establece el color %2 en el LED %1';
Blockly.Msg['ROBOTS_MAQUEEN_SETPALETTECOLOR_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Permite controlar cada color del LED del neopixel Maqueen (P15). Elección del color en la paleta';
Blockly.Msg['ROBOTS_MAQUEEN_SETRAINBOW_TITLE'] = '[Maqueen] Rainbow';
Blockly.Msg['ROBOTS_MAQUEEN_SETRAINBOW_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Habilitar para mostrar un arco iris en el LED RGB de Maqueen (P15)';
Blockly.Msg['ROBOTS_MAQUEEN_SETBUZZER_TITLE'] = '[Maqueen] establece el zumbido a la frecuencia %1 durante %2 (ms)';
Blockly.Msg['ROBOTS_MAQUEEN_SETBUZZER_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Habilitar para controlar el zumbador de Maqueen a cualquier frecuencia (P0)';
Blockly.Msg['ROBOTS_MAQUEEN_PLAYMUSIC_TITLE'] = '[Maqueen] reproducir música %1';
Blockly.Msg['ROBOTS_MAQUEEN_PLAYMUSIC_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Activar la reproducción de música en el timbre de Maqueen (P0)';
Blockly.Msg['ROBOTS_MAQUEEN_DECODEIRRECEIVER_TITLE'] = '[Maqueen] decodifica el receptor de infrarrojos';
Blockly.Msg['ROBOTS_MAQUEEN_DECODEIRRECEIVER_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Habilitar para hacer una lectura del receptor de infrarrojos conectado a P16 del robot maqueen';
Blockly.Msg['ROBOTS_MAQUEEN_GETIRCODE_TITLE'] = '[Maqueen] código del receptor de infrarrojos';
Blockly.Msg['ROBOTS_MAQUEEN_GETIRCODE_TOOLTIP'] = IMG_ROBOT_MAQUEEN + Blockly.Tooltip.SEP + 'Obtener el código hexadecimal recibido por el receptor de infrarrojos del robot maqueen';
// Robots - MaqueenPlus
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V2_ULTRASONICRANGER_TITLE'] = '[MaqueenPlus %1] %2';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V2_ULTRASONICRANGER_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Devuelve la distancia (en cm) o el tiempo de ida y vuelta (en μs) de la onda entre un objeto y el robot MaqueenPlus usando el sensor ultrasónico.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_ULTRASONICRANGER_TRIG_ECHO_TITLE'] = '[MaqueenPlus %1] %2 TRIG %3 ECHO %4';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_ULTRASONICRANGER_TRIG_ECHO_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Devuelve la distancia (en cm) o la duración de ida y vuelta (en μs) de la onda entre un objeto y el robot MaqueenPlus utilizando el sensor ultrasónico conectado a los pines digitales especificados.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V1_READPATROL_TITLE'] = '[MaqueenPlus v1] estado del sensor de línea %1';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V1_READPATROL_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Lee el estado de uno de los sensores seguidores de línea del robot MaqueenPlus. El bloque devuelve 0 si el sensor está sobre la línea.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V2_READPATROL_TITLE'] = '[MaqueenPlus v2] estado del sensor de línea %1';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V2_READPATROL_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Lee el estado de uno de los sensores seguidores de línea del robot MaqueenPlus. El bloque devuelve 0 si el sensor está sobre la línea.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_LEFT_REAR'] = "trasero izquierdo";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_LEFT'] = "izquierdo";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_MIDDLE_LEFT'] = "medio izquierdo";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_MIDDLE'] = "medio";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_MIDDLE_RIGHT'] = "medio derecho";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_RIGHT'] = "derecho";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_RIGHT_REAR'] = "trasero derecho";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_CONTROLLED_TITLE'] = '[MaqueenPlus %1] controlar el LED rojo delantero %2 estado %3';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_CONTROLLED_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Controla el estado del LED izquierdo o derecho del robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_LED_LEFT'] = "izquierdo";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_LED_RIGHT'] = "derecho";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_LED_LEFT&RIGHT'] = "izquierdo y derecho";
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_GO_TITLE'] = '[MaqueenPlus %1] controlar el robot %2 velocidad %3';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_GO_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Controla el movimiento (ADELANTE/ATRÁS) y la velocidad (de 0 a 255) del robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_ROTATE_TITLE'] = '[MaqueenPlus %1] girar %2 velocidad %3';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_ROTATE_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Controla los motores derecho e izquierdo cambiando la dirección (↻: ADELANTE, ↺: ATRÁS) y la velocidad (de 0 a 255) del robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_CONTROLMOTOR_TITLE'] = '[MaqueenPlus %1] controlar el motor %2 dirección %3 velocidad %4';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Controla los motores derecho e izquierdo cambiando la dirección (↻: ADELANTE, ↺: ATRÁS) y la velocidad (de 0 a 255) del robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_STOPMOTORS_TITLE'] = '[MaqueenPlus %1] detener el motor %2';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_STOPMOTORS_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Detiene el motor derecho o izquierdo del robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V1_SETSERVOANGLE_TITLE'] = '[MaqueenPlus v1] posicionar el servomotor %1 en el ángulo %2 °';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V1_SETSERVOANGLE_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Controla los servomotores P0, P1, P2 cambiando el ángulo (de 0 a 180) del robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V2_SETSERVOANGLE_TITLE'] = '[MaqueenPlus v2] posicionar el servomotor %1 en el ángulo %2 °';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_V2_SETSERVOANGLE_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Controla los servomotores P0, P1, P2 cambiando el ángulo (de 0 a 180) del robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETNEOPIXEL_TITLE'] = '[MaqueenPlus v2] controlar el LED RGB debajo %1 a R %2 G %3 B %4';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Controla el color de cada LED RGB del neopixel del robot MaqueenPlus donde los valores R,G,B varían de 0 a 255.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_BLINK_ROBOT_TITLE'] = '[MaqueenPlus v2] parpadear el robot';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_BLINK_ROBOT_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Hace parpadear el robot Maqueen.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETPALETTECOLOR_TITLE'] = '[MaqueenPlus v2] controlar el LED RGB debajo %1 a %2';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETPALETTECOLOR_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Controla el color de cada LED RGB del módulo neopixel situado debajo del robot MaqueenPlus. Utilizar la paleta para cambiar el color.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETRAINBOW_TITLE'] = '[MaqueenPlus v2] Arcoíris';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETRAINBOW_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Muestra el espectro de colores en los LEDs RGB.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETBUZZER_TITLE'] = '[MaqueenPlus %1] controlar el zumbador a la frecuencia %2 durante %3 (ms)';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_SETBUZZER_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Establece una frecuencia en el zumbador del robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_DECODEIRRECEIVER_TITLE'] = '[MaqueenPlus] decodificar el receptor infrarrojo';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_DECODEIRRECEIVER_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Realiza una lectura del receptor infrarrojo del robot MaqueenPlus.';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_GETIRCODE_TITLE'] = '[MaqueenPlus] código recibido del receptor infrarrojo';
Blockly.Msg['ROBOTS_MAQUEEN_PLUS_GETIRCODE_TOOLTIP'] = IMG_ROBOT_MAQUEEN_PLUS + Blockly.Tooltip.SEP + 'Devuelve el código hexadecimal recibido con el detector infrarrojo del robot MaqueenPlus.';
// Robots - Cutebot
Blockly.Msg['ROBOTS_CUTEBOT_ULTRASONICRANGER_TITLE'] = '[Cutebot] %1';
Blockly.Msg['ROBOTS_CUTEBOT_ULTRASONICRANGER_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Devuelve la distancia (en cm) o la duración de ida y vuelta (en μs) de la onda entre un objeto y el robot Cutebot utilizando el sensor ultrasónico.';
Blockly.Msg['ROBOTS_CUTEBOT_ULTRASONIC_DISTANCE'] = 'distancia (cm)';
Blockly.Msg['ROBOTS_CUTEBOT_ULTRASONIC_DURATION'] = 'duración de ida y vuelta (μs)';
Blockly.Msg['ROBOTS_CUTEBOT_BLINK_ROBOT_TITLE'] = '[Cutebot] parpadear robot';
Blockly.Msg['ROBOTS_CUTEBOT_BLINK_ROBOT_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Hace que el robot Cutebot parpadee.';
Blockly.Msg['ROBOTS_CUTEBOT_READPATROL_TITLE'] = '[Cutebot] estado del sensor de línea %1';
Blockly.Msg['ROBOTS_CUTEBOT_RIGHT'] = 'derecho';
Blockly.Msg['ROBOTS_CUTEBOT_LEFT'] = 'izquierdo';
Blockly.Msg['ROBOTS_CUTEBOT_READPATROL_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Lee el estado del sensor seguidor de línea izquierdo o derecho del robot Cutebot. El bloque devuelve 1 si el sensor está sobre la línea.';
Blockly.Msg['ROBOTS_CUTEBOT_CONTROLLED_TITLE'] = '[Cutebot] controlar LED RGB %1 %2';
Blockly.Msg['ROBOTS_CUTEBOT_CONTROLLED_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permite controlar el color de cada LED RGB del robot Cutebot seleccionando un color de la paleta disponible.';
Blockly.Msg['ROBOTS_CUTEBOT_CONTROL_RGB_LED_TITLE'] = '[Cutebot] controlar LED RGB %1 R %2 G %3 B %4';
Blockly.Msg['ROBOTS_CUTEBOT_CONTROL_RGB_LED_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permite controlar el color de cada LED RGB del robot Cutebot, con valores R, G y B que van de 0 a 255.';
Blockly.Msg['ROBOTS_CUTEBOT_SETNEOPIXEL_TITLE'] = '[Cutebot] controlar LED RGB debajo en %1 R %2 G %3 B %4';
Blockly.Msg['ROBOTS_CUTEBOT_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permite controlar el color de cada LED RGB del neopixel debajo del robot Cutebot (P15), con valores R, G y B que van de 0 a 255. El neopixel está conectado al pin P15 del robot.';
Blockly.Msg['ROBOTS_CUTEBOT_SETPALETTECOLOR_TITLE'] = '[Cutebot] controlar LED RGB debajo en %1 %2';
Blockly.Msg['ROBOTS_CUTEBOT_SETPALETTECOLOR_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permite controlar el color de cada LED RGB del módulo neopixel (P15) ubicado debajo del robot Maqueen. Usa la paleta para cambiar el color.';
Blockly.Msg['ROBOTS_CUTEBOT_GO_TITLE'] = '[Cutebot] controlar robot %1 velocidad %2 %';
Blockly.Msg['ROBOTS_CUTEBOT_GO_FORWARD'] = 'adelante';
Blockly.Msg['ROBOTS_CUTEBOT_GO_BACKWARD'] = 'atrás';
Blockly.Msg['ROBOTS_CUTEBOT_GO_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permite controlar los motores del robot Cutebot para que avance o retroceda a una velocidad del 0 al 100%.';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_TITLE'] = '[Cutebot] girar %1 velocidad %2 %';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_RIGHT'] = 'derecha';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_LEFT'] = 'izquierda';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permite controlar los motores del robot Cutebot para que gire (a la derecha o a la izquierda) a una velocidad del 0 al 100%.';
Blockly.Msg['ROBOTS_CUTEBOT_STOP_TITLE'] = '[Cutebot] detener robot';
Blockly.Msg['ROBOTS_CUTEBOT_STOP_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Detiene los motores del robot Cutebot.';
Blockly.Msg['ROBOTS_CUTEBOT_CONTROLMOTOR_TITLE'] = '[Cutebot] controlar motor %1 dirección %2 velocidad %3 %';
Blockly.Msg['ROBOTS_CUTEBOT_MOTOR_RIGHT'] = 'derecho';
Blockly.Msg['ROBOTS_CUTEBOT_MOTOR_LEFT'] = 'izquierdo';
Blockly.Msg['ROBOTS_CUTEBOT_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permite controlar los motores derecho e izquierdo cambiando la dirección (↻: ENFRENTE, ↺: ATRÁS) y la velocidad (del 0 al 100%) del robot Cutebot.';
Blockly.Msg['ROBOTS_CUTEBOT_SETSERVOANGLE_TITLE'] = '[Cutebot] ajustar servo(s) %1 a un ángulo de %2°';
Blockly.Msg['ROBOTS_CUTEBOT_S1'] = 'S1';
Blockly.Msg['ROBOTS_CUTEBOT_S2'] = 'S2';
Blockly.Msg['ROBOTS_CUTEBOT_SERVO_BOTH'] = 'S1 y S2';
Blockly.Msg['ROBOTS_CUTEBOT_SETSERVOANGLE_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permite controlar los servomotores S1 y S2 cambiando el ángulo (de 0 a 180°) del robot Cutebot.';
Blockly.Msg['ROBOTS_CUTEBOT_MOVE_ONE_SQUARE_FORWARD_TITLE'] = '[Cutebot] avanzar una casilla';
Blockly.Msg['ROBOTS_CUTEBOT_MOVE_ONE_SQUARE_FORWARD_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Mueve el robot Cutebot una casilla hacia adelante.';
Blockly.Msg['ROBOTS_CUTEBOT_MOVE_ONE_SQUARE_BACKWARD_TITLE'] = '[Cutebot] retroceder una casilla';
Blockly.Msg['ROBOTS_CUTEBOT_MOVE_ONE_SQUARE_BACKWARD_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Mueve el robot Cutebot una casilla hacia atrás.';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_LEFT_TITLE'] = '[Cutebot] girar a la izquierda';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_LEFT_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Gira el robot Cutebot 90° hacia la izquierda.';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_RIGHT_TITLE'] = '[Cutebot] girar a la derecha';
Blockly.Msg['ROBOTS_CUTEBOT_TURN_RIGHT_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Gira el robot Cutebot 90° hacia la derecha.';
Blockly.Msg['ROBOTS_CUTEBOT_SETBUZZER_TITLE'] = '[Cutebot] controlar el buzzer a la frecuencia %1 durante %2 (ms)';
Blockly.Msg['ROBOTS_CUTEBOT_SETBUZZER_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permite establecer una frecuencia en el buzzer del robot Cutebot (P0).';
Blockly.Msg['ROBOTS_CUTEBOT_PLAYMUSIC_TITLE'] = '[Cutebot] reproducir música %1';
Blockly.Msg['ROBOTS_CUTEBOT_PLAYMUSIC_TOOLTIP'] = IMG_ROBOT_CUTEBOT + Blockly.Tooltip.SEP + 'Permite reproducir música con el buzzer del robot Cutebot conectado al pin (P0).';
Blockly.Msg['ROBOTS_CUTEBOT_DECODEIRRECEIVER_TITLE'] = '[Cutebot] decodificar el receptor infrarrojo';
Blockly.Msg['ROBOTS_CUTEBOT_DECODEIRRECEIVER_TOOLTIP'] = 'Realiza una lectura del receptor infrarrojo (P16) del robot Cutebot.';
Blockly.Msg['ROBOTS_CUTEBOT_GETIRCODE_TITLE'] = '[Cutebot] código recibido del receptor infrarrojo';
Blockly.Msg['ROBOTS_CUTEBOT_GETIRCODE_TOOLTIP'] = 'Devuelve el código hexadecimal recibido con el detector infrarrojo (P16) del robot Cutebot.';// Robots - Kitrobot
// Robots - Cutebot Pro - Detection
Blockly.Msg['ROBOTS_CUTEBOTPRO_ULTRASONICRANGER_TITLE'] = '[Cutebot Pro] distance in %1';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ULTRASONIC_CM'] = '(cm)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ULTRASONIC_INCH'] = '(inch)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ULTRASONICRANGER_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Returns the distance (in cm or inch) of the wave between an object and the Cutebot Pro robot using the ultrasonic sensor. The latter is linked to pin P8 and P12 of the BBC micro:bit board.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETLINESTATE_TITLE'] = '[Cutebot Pro] line follower status';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETLINESTATE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Gets the line follower status. It is composed of 4 infrared sensors located under the Cutebot Pro robot that return 16 different states (integers from 0 to 15).';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ISSPECIFICSTATE_TITLE'] = '[Cutebot Pro] line follower status is %1';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ISSPECIFICSTATE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Really returns whether the line follower detects the state specified in the block. The line follower is made up of 4 infrared sensors located under the Cutebot Pro robot which return 16 different states (integers from 0 to 15). For each state of the line follower, the values ​​of the 4 sensors such as [left, center left, center right, right], either looking in the direction of the robot.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETLINEOFFSET_TITLE'] = '[Cutebot Pro] offset from line at %1';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETLINEOFFSET_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to get the offset (in cm) or (in inches) from the line from -3 cm (robot offset to the right) to 3 cm (robot offset to the left). 0 means that the robot is well aligned. It is thus possible to orient the robot according to this value to follow the line.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ISABOVELINE_TITLE'] = '[Cutebot Pro] sensor %1 above black line?';
Blockly.Msg['ROBOTS_CUTEBOTPRO_ISABOVELINE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Returns True if the selected line follower sensor (1 to 4) is above a black line.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETGRAYSCALEVALUE_TITLE'] = '[Cutebot Pro] sensor gray level %1';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETGRAYSCALEVALUE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Gets the value of the selected line follower sensor (from 1 to 4) in grayscale, from 0 to 255.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_READVERSION_TITLE'] = '[Cutebot Pro] robot version';
Blockly.Msg['ROBOTS_CUTEBOTPRO_READVERSION_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Used to obtain the version of the Cutebot Pro robot.';
// Robots - Cutebot Pro - Moving
Blockly.Msg['ROBOTS_CUTEBOTPRO_GO_TITLE'] = '[Cutebot Pro] %1 at speed %2 %';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GO_FORWARD'] = 'forward';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GO_BACKWARD'] = 'go back';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GO_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to control the Cutebot Pro robot\'s motors to move it forward or backward at a speed between 0 and 100%.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURN_TITLE'] = '[Cutebot Pro] turn at %1 speed %2%';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURN_RIGHT'] = 'right';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURN_LEFT'] = 'left';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURN_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to control the Cutebot Pro robot\'s motors to turn (left or right) at a speed between 0 and 100%.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_STOP_TITLE'] = '[Cutebot Pro] stop the robot\'s motors';
Blockly.Msg['ROBOTS_CUTEBOTPRO_STOP_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to stop the Cutebot Pro robot\'s motors.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_CONTROLMOTOR_TITLE'] = '[Cutebot Pro] control motor %1 direction %2 speed %3 %';
Blockly.Msg['ROBOTS_CUTEBOTPRO_MOTOR_LEFT'] = 'left';
Blockly.Msg['ROBOTS_CUTEBOTPRO_MOTOR_RIGHT'] = 'right';
Blockly.Msg['ROBOTS_CUTEBOTPRO_MOTOR_BOTH'] = 'left & right';
Blockly.Msg['ROBOTS_CUTEBOTPRO_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to control the right and left motors by changing the direction (↻: FORWARD, ↺: REVERSE) and speed (from 0 to 100%) of the Cutebot Pro robot.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_UNIT_CM_S'] = '(cm/s)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_UNIT_INCH_S'] = '(inch/s)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETMOTORSPEED_TITLE'] = '[Cutebot Pro] motor speed %1 to %2';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETMOTORSPEED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Gets the speed of the selected wheel (in m/s) or (inch/s) of the Cutebot Pro robot.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETANGULARDISTANCE_DEGREES'] = 'angular distance traveled (°)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETANGULARDISTANCE_ROTATIONS'] = 'rotations performed';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETANGULARDISTANCE_PULSES'] = 'pulses detected';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETANGULARDISTANCE_TITLE'] = '[Cutebot Pro] %1 of wheel %2';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETANGULARDISTANCE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to obtain the angular distance traveled (in °) or the number of pulses detected by one of the Cutebot Pro robot\'s wheels since the last initialization. Note that a rotation of 1 ° corresponds to 4 pulses. Be careful, the lower the angular distance traveled, the less accurate the measurement.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_INITANGULARDISTANCE_TITLE'] = '[Cutebot Pro] reset angular measurement %1';
Blockly.Msg['ROBOTS_CUTEBOTPRO_INITANGULARDISTANCE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to reset the measurement of the angular distance traveled by each wheel of the Cutebot Pro robot.';
// Robots - Cutebot Pro - RGB LED
Blockly.Msg['ROBOTS_CUTEBOTPRO_RIGHT'] = 'right';
Blockly.Msg['ROBOTS_CUTEBOTPRO_LEFT'] = 'left';
Blockly.Msg['ROBOTS_CUTEBOTPRO_BOTH'] = 'right & left';
Blockly.Msg['ROBOTS_CUTEBOTPRO_CONTROLLED_TITLE'] = '[Cutebot Pro] control RGB LED %1 %2';
Blockly.Msg['ROBOTS_CUTEBOTPRO_CONTROLLED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to control the color of the left or right RGB LED of the Cutebot Pro robot by selecting a color from the available palette.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_CONTROL_RGB_LED_TITLE'] = '[Cutebot Pro] control RGB LED %1 R %2 G %3 B %4';
Blockly.Msg['ROBOTS_CUTEBOTPRO_CONTROL_RGB_LED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to control the color of the left or right RGB LED of the Cutebot Pro robot such that the R,G,B values ​​are between 0 and 255.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SWITCHOFFLED_TITLE'] = '[Cutebot Pro] turn off both front RGB LEDs';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SWITCHOFFLED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to turn off the two front RGB LEDs of the Cutebot Pro robot.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETNEOPIXEL_TITLE'] = '[Cutebot Pro] control the RGB LED below %1 to R %2 G %3 B %4';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to control the color of the two RGB LEDs on the neopixel module located under the Cutebot Pro robot so that the values ​​(R,G,B) are between 0 and 255. The module is linked to pin P15 of the BBC micro:bit board.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETNEOPIXELPALETTE_TITLE'] = '[Cutebot Pro] control the RGB LED below %1 to %2';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETNEOPIXELPALETTE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Controls the color of the two RGB LEDs on the neopixel module located under the Cutebot Pro robot. Use the palette to change the color. The module is linked to pin P15 on the BBC micro:bit board.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SWITCHOFFNEOPIXEL_TITLE'] = '[Cutebot Pro] turn off the RGB LED below %1';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SWITCHOFFNEOPIXEL_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Turns off the RGB LEDs on the neopixel module located under the Cutebot Pro robot. The module is linked to pin P15 of the BBC micro:bit board.';
// Robots - Cutebot Pro - PID
Blockly.Msg['ROBOTS_CUTEBOTPRO_UNIT_CM'] = '(cm)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_UNIT_INCH'] = '(inch)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUN_WAITING'] = 'wait ?';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNWITHSPEED_TITLE'] = '[Cutebot Pro] %1 at speed %2 %3';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNWITHSPEED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to run forward or backward at a certain speed (in cm/s) or (in inch/s) with the Cutebot Pro robot. Please note, speeds are guaranteed between 20 and 60 cm/s. Outside this interval, the motors are less able to establish a precise speed.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETMOTORSSPEED_TITLE'] = '[Cutebot Pro] set the speed of the left motor to %1, the right motor to %2 in %3';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETMOTORSSPEED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to set a speed (in cm/s) or (in inch/s) on the right and left motors of the Cutebot Pro robot.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNWITHRADIUS_TITLE'] = '[Cutebot Pro] turn at %1 turning radius %2 at speed %3 %4';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNWITHRADIUS_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to move the Cutebot Pro robot on an arc with a specific turning radius (in cm) or (in inches) at a certain speed (in cm /s) or (in inches/s). The robot can move clockwise (to the right) or counterclockwise (to the left). Be careful, the speed and the turning radius must be in the same spatial unit.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUN_WAITING_YES']= 'yes';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUN_WAITING_NO'] = 'no';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNDISTANCE_TITLE'] = '[Cutebot Pro] %1 of %2 %3';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNDISTANCE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to travel a certain distance (in cm) or (in inches) FORWARD or BACKWARD with the Cutebot Pro robot.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_DEFINESQUARE_TITLE'] = '[Cutebot Pro] define the dimension of a square at %1 %2';
Blockly.Msg['ROBOTS_CUTEBOTPRO_DEFINESQUARE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to define the size of a square (in cm) or (in inches) for the Cutebot Pro robot to move per unit.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNSQUARE_TITLE'] = '[Cutebot Pro] %1 of %2 square.s';
Blockly.Msg['ROBOTS_CUTEBOTPRO_RUNSQUARE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to move forward or backward a certain number of squares. The value must be an integer.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURNWITHANGLE_TITLE'] = '[Cutebot Pro] turn %1 by %2 °';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURNWITHANGLE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to turn the Cutebot Pro robot left or right by a certain angle (in °).';
Blockly.Msg['ROBOTS_CUTEBOTPRO_PLACEWITHANGLE_TITLE'] = '[Cutebot Pro] rotate to %1 at angle %2°';
Blockly.Msg['ROBOTS_CUTEBOTPRO_PLACEWITHANGLE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to rotate the Cutebot Pro robot left or right at an angular position (in °).';
Blockly.Msg['ROBOTS_CUTEBOTPRO_UNIT_DEG'] = '(°)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_UNIT_TOUR'] = '(Tr)';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURNWHEEL_TITLE'] = '[Cutebot Pro] turn wheel %1 by %2 %3';
Blockly.Msg['ROBOTS_CUTEBOTPRO_TURNWHEEL_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to turn the right and/or left wheels by a certain angle (in °) or (in Tr) of the Cutebot Pro robot. 1 Tr corresponds to 360 °, or one complete turn of the wheel.';
// Robots - Cutebot Pro - Servomotors
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETSERVOANGLE_TITLE'] = '[Cutebot Pro] position the servomotor.s %1 at %2 °';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETSERVOANGLE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to control the angle (in °) of the servos that can be placed on pins S1, S2, S3 and S4 at the back of the Cutebot Pro robot.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETSERVOSPEED_TITLE'] = '[Cutebot Pro] control the continuous servo.s %1 direction %2 speed %3 %';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETSERVOSPEED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to control the speed (in %) of the continuous servo motors that can be placed on pins S1, S2, S3 and S4 on the back of the Cutebot Pro robot.';
// Robots - Cutebot Pro - Extended motor (M port)
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETEXTENDEDMOTORSPEED_TITLE'] = '[Cutebot Pro] control motor direction %1 speed %2% on port M';
Blockly.Msg['ROBOTS_CUTEBOTPRO_SETEXTENDEDMOTORSPEED_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to control the speed (from 0 to 100%) and the direction of rotation of the motor connected to the M extension port of the Cutebot Pro robot .';
Blockly.Msg['ROBOTS_CUTEBOTPRO_STOPEXTENDEDMOTOR_TITLE'] = '[Cutebot Pro] stop M port motor';
Blockly.Msg['ROBOTS_CUTEBOTPRO_STOPEXTENDEDMOTOR_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Allows you to stop the motor connected to the extension port M of the Cutebot Pro robot.';
// Robots - Cutebot Pro - Remote control
Blockly.Msg['ROBOTS_CUTEBOTPRO_DECODEIRRECEIVER_TITLE'] = '[Cutebot] decode the infrared receiver';
Blockly.Msg['ROBOTS_CUTEBOTPRO_DECODEIRRECEIVER_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Reads the infrared receiver of the Cutebot Pro robot. The IR receiver is tied to pin P16 on the BBC micro:bit board.';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETIRCODE_TITLE'] = '[Cutebot] code received from the infrared receiver';
Blockly.Msg['ROBOTS_CUTEBOTPRO_GETIRCODE_TOOLTIP'] = IMG_ROBOT_CUTEBOT_PRO + Blockly.Tooltip.SEP + 'Returns the hex code received with the infrared detector of the Cutebot Pro robot. Use with the \'decode infrared receiver\' block. The IR receiver is tied to pin P16 on the BBC micro:bit board.';
// Robots - Kitrobot
Blockly.Msg['ROBOTS_KITROBOT_RIGHT'] = 'destra';
Blockly.Msg['ROBOTS_KITROBOT_LEFT'] = 'sinistra';
Blockly.Msg['ROBOTS_KITROBOT_RIGHT&LEFT'] = 'destra & sinistra';
Blockly.Msg['ROBOTS_KITROBOT_ULTRASONICRANGER_TITLE'] = '[Kit:robot v2] %1';
Blockly.Msg['ROBOTS_KITROBOT_ULTRASONICRANGER_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Restituisce la distanza (in cm) o la durata del viaggio di andata e ritorno (in μs) dell\'onda tra un oggetto e il Kit:robot v2 utilizzando il sensore ultrasonico.';
Blockly.Msg['ROBOTS_KITROBOT_ULTRASONIC_DISTANCE'] = 'distanza (cm)';
Blockly.Msg['ROBOTS_KITROBOT_ULTRASONIC_DURATION'] = 'durata del viaggio di andata e ritorno (μs)';
Blockly.Msg['ROBOTS_KITROBOT_GO_TITLE'] = '[Kit:robot v2] controlla il robot %1 velocità %2 %';
Blockly.Msg['ROBOTS_KITROBOT_GO_FORWARD'] = 'vai avanti';
Blockly.Msg['ROBOTS_KITROBOT_GO_REVERSE'] = 'vai indietro';
Blockly.Msg['ROBOTS_KITROBOT_GO_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permette di controllare il camminare (AVANTI/INDIETRO) così come la velocità (da 0 al 100%) del Kit:robot v2.';
Blockly.Msg['ROBOTS_KITROBOT_CONTROLMOTOR_TITLE'] = '[Kit:robot v2] controlla il motore %1 direzione %2 velocità %3 %';
Blockly.Msg['ROBOTS_KITROBOT_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permette di controllare i motori destro e sinistro cambiando la direzione (↻: AVANTI, ↺: INDIETRO) e la velocità (da 0 al 100%) del Kit:robot v2.';
Blockly.Msg['ROBOTS_KITROBOT_ROTATE_TITLE'] = '[Kit:robot v2] ruota %1 velocità %2 %';
Blockly.Msg['ROBOTS_KITROBOT_ROTATE_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permette di controllare i motori destro e sinistro cambiando la direzione (↻: AVANTI, ↺: INDIETRO) e la velocità (da 0 al 100%) del Kit:robot v2.';
Blockly.Msg['ROBOTS_KITROBOT_STOPMOTORS_TITLE'] = '[Kit:robot v2] ferma il motore %1';
Blockly.Msg['ROBOTS_KITROBOT_STOPMOTORS_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permette di fermare il motore destro o sinistro del Kit:robot v2.';
Blockly.Msg['ROBOTS_KITROBOT_SERVO_BOTH'] = 'entrambi';
Blockly.Msg['ROBOTS_KITROBOT_MOVE_ONE_SQUARE_FORWARD_TITLE'] = '[Kit:robot v2] muovi in avanti di una casella';
Blockly.Msg['ROBOTS_KITROBOT_MOVE_ONE_SQUARE_FORWARD_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Muove il Kit:robot v2 in avanti di una casella.';
Blockly.Msg['ROBOTS_KITROBOT_MOVE_ONE_SQUARE_BACKWARD_TITLE'] = '[Kit:robot v2] muovi indietro di una casella';
Blockly.Msg['ROBOTS_KITROBOT_MOVE_ONE_SQUARE_BACKWARD_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Muove il Kit:robot v2 indietro di una casella.';
Blockly.Msg['ROBOTS_KITROBOT_TURN_LEFT_TITLE'] = '[Kit:robot v2] gira a sinistra';
Blockly.Msg['ROBOTS_KITROBOT_TURN_LEFT_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Ruota il Kit:robot v2 di 90° a sinistra.';
Blockly.Msg['ROBOTS_KITROBOT_TURN_RIGHT_TITLE'] = '[Kit:robot v2] gira a destra';
Blockly.Msg['ROBOTS_KITROBOT_TURN_RIGHT_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Ruota il Kit:robot v2 di 90° a destra.';
Blockly.Msg['ROBOTS_KITROBOT_STOP_ROBOT_TITLE'] = '[Kit:robot v2] ferma il robot';
Blockly.Msg['ROBOTS_KITROBOT_STOP_ROBOT_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Ferma i motori del Kit:robot v2.';
Blockly.Msg['ROBOTS_KITROBOT_BLINK_ROBOT_TITLE'] = '[Kit:robot v2] fa lampeggiare il robot';
Blockly.Msg['ROBOTS_KITROBOT_BLINK_ROBOT_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Fa lampeggiare il Kit:robot v2.';
Blockly.Msg['ROBOTS_KITROBOT_READPATROL_TITLE'] = '[Kit:robot v2] stato del sensore di linea %1';
Blockly.Msg['ROBOTS_KITROBOT_READPATROL_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permette di leggere lo stato del sensore di seguimento della linea sinistra o destra del Kit:robot v2. Il blocco restituisce 0 o 1 a seconda se il sensore è sopra la linea o meno.';
Blockly.Msg['ROBOTS_KITROBOT_SETNEOPIXEL_TITLE'] = '[Kit:robot v2] controlla il LED RGB %1 a R %2 G %3 B %4';
Blockly.Msg['ROBOTS_KITROBOT_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permette di controllare il colore di ciascun LED RGB del neopixel del Kit:robot v2 in modo che i valori R,G,B siano compresi tra 0 e 255.';
Blockly.Msg['ROBOTS_KITROBOT_SETPALETTECOLOR_TITLE'] = '[Kit:robot v2] controlla il LED RGB %1 a %2';
Blockly.Msg['ROBOTS_KITROBOT_SETPALETTECOLOR_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permette di controllare il colore di ciascun LED RGB del neopixel del Kit:robot v2 in modo che i valori R,G,B siano compresi tra 0 e 255.';
Blockly.Msg['ROBOTS_KITROBOT_SETRAINBOW_TITLE'] = '[Kit:robot v2] arco iris';
Blockly.Msg['ROBOTS_KITROBOT_SETRAINBOW_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Muestra el espectro de colores en los LED RGB.';
Blockly.Msg['ROBOTS_KITROBOT_SETBUZZER_TITLE'] = '[Kit:robot v2] controlar el zumbador a la frecuencia %1 para %2 (ms)';
Blockly.Msg['ROBOTS_KITROBOT_SETBUZZER_TOOLTIP'] = IMG_ROBOT_KITROBOT + Blockly.Tooltip.SEP + 'Permite configurar una frecuencia en el zumbador del Kit:robot v2.';
// Robots - Codo
Blockly.Msg['ROBOTS_CODO_GO_TITLE'] = '[Codo] controlar robot %1 velocidad %2';
Blockly.Msg['ROBOTS_CODO_GO_FORWARD'] = 'hacia adelante';
Blockly.Msg['ROBOTS_CODO_GO_BACKWARD'] = 'hacia atrás';
Blockly.Msg['ROBOTS_CODO_GO_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permite controlar la marcha del coche (adelante/atrás) y la velocidad (de 0 a 255) del robot Codo';
Blockly.Msg['ROBOTS_CODO_TURN_TITLE'] = '[Codo] gira %1 velocidad %2';
Blockly.Msg['ROBOTS_CODO_TURN_RIGHT'] = 'derecha';
Blockly.Msg['ROBOTS_CODO_TURN_LEFT'] = 'izquierda';
Blockly.Msg['ROBOTS_CODO_TURN_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permite controlar la dirección (derecha/izquierda) y la velocidad (de 0 a 255) del robot Codo';
Blockly.Msg['ROBOTS_CODO_STOP_TITLE'] = '[Codo] detener la marcha del robot';
Blockly.Msg['ROBOTS_CODO_STOP_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Detener la marcha del robot Codo';
Blockly.Msg['ROBOTS_CODO_CONTROLMOTOR_TITLE'] = '[Codo] controlar motor %1 dirección %2 velocidad %3';
Blockly.Msg['ROBOTS_CODO_MOTOR_RIGHT'] = 'derecha';
Blockly.Msg['ROBOTS_CODO_MOTOR_LEFT'] = 'izquierda';
Blockly.Msg['ROBOTS_CODO_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permite controlar el motor (derecha/izquierda), la dirección (horario/antihorario) y la velocidad (de 0 a 255) del robot Codo';
// Robots - Oobybot
Blockly.Msg['ROBOTS_OOBYBOT_CONTROLLED_TITLE'] = '[Oobybot] controlar las LED a l\'estado %1 sobre la pin %2';
Blockly.Msg['ROBOTS_OOBYBOT_CONTROLLED_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permite controlar les la (P0)';
Blockly.Msg['ROBOTS_OOBYBOT_GO_TITLE'] = '[Oobybot] controlar el robot %1 velocidad %2%';
Blockly.Msg['ROBOTS_OOBYBOT_GO_FORWARD'] = 'avanzar';
Blockly.Msg['ROBOTS_OOBYBOT_GO_BACKWARD'] = 'retroceder';
Blockly.Msg['ROBOTS_OOBYBOT_GO_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permite controlar la dirección (adelante/atrás) así como la velocidad (de 0 a 100%) del robot Oobybot.';
Blockly.Msg['ROBOTS_OOBYBOT_TURN_TITLE'] = '[Oobybot] dar la vuelta %1 velocidad %2%';
Blockly.Msg['ROBOTS_OOBYBOT_TURN_RIGHT'] = 'derecha';
Blockly.Msg['ROBOTS_OOBYBOT_TURN_LEFT'] = 'izquierda';
Blockly.Msg['ROBOTS_OOBYBOT_TURN_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permite controlar la dirección (derecha/izquierda) así como la velocidad (de 0 a 100%) del robot Oobybot.';
Blockly.Msg['ROBOTS_OOBYBOT_STOP_TITLE'] = '[Oobybot] detener la ejecución del robot';
Blockly.Msg['ROBOTS_OOBYBOT_STOP_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Le permite detener la ejecución del robot Oobybot.';
Blockly.Msg['ROBOTS_OOBYBOT_CONTROLMOTOR_TITLE'] = '[Oobybot] controlar el moteur %1 dirección %2 así como la velocidad %3%';
Blockly.Msg['ROBOTS_OOBYBOT_MOTOR_RIGHT'] = 'derecha';
Blockly.Msg['ROBOTS_OOBYBOT_MOTOR_LEFT'] = 'izquierda';
Blockly.Msg['ROBOTS_OOBYBOT_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_OOBYBOT + Blockly.Tooltip.SEP + 'Permite controlar el motor (derecha/izquierda), la dirección (sentido horario/antihorario) y la velocidad (de 0 a 100 %) del robot Oobybot.';
// Robots - Buggy
Blockly.Msg['ROBOTS_BUGGY_GO_TITLE'] = '[Buggy] controlar robot %1 velocidad %2';
Blockly.Msg['ROBOTS_BUGGY_GO_FORWARD'] = 'hacia adelante';
Blockly.Msg['ROBOTS_BUGGY_GO_BACKWARD'] = 'hacia atrás';
Blockly.Msg['ROBOTS_BUGGY_GO_TOOLTIP'] = IMG_ROBOT_BUGGY + Blockly.Tooltip.SEP + 'Permite controlar la marcha del coche (adelante/atrás) y la velocidad (de 0 a 255) del robot Buggy';
Blockly.Msg['ROBOTS_BUGGY_TURN_TITLE'] = '[Buggy] giro %1 velocidad %2';
Blockly.Msg['ROBOTS_BUGGY_TURN_RIGHT'] = 'derecha';
Blockly.Msg['ROBOTS_BUGGY_TURN_LEFT'] = 'izquierda';
Blockly.Msg['ROBOTS_BUGGY_TURN_TOOLTIP'] = IMG_ROBOT_BUGGY + Blockly.Tooltip.SEP + 'Permite controlar la dirección (derecha/izquierda) y la velocidad (de 0 a 255) del robot Buggy';
Blockly.Msg['ROBOTS_BUGGY_STOP_TITLE'] = '[Buggy] detener la marcha del robot';
Blockly.Msg['ROBOTS_BUGGY_STOP_TOOLTIP'] = IMG_ROBOT_BUGGY + Blockly.Tooltip.SEP + 'Detener la marcha del robot Buggy';
Blockly.Msg['ROBOTS_BUGGY_CONTROLMOTOR_TITLE'] = '[Buggy] controlar motor %1 dirección %2 velocidad %3';
Blockly.Msg['ROBOTS_BUGGY_MOTOR_RIGHT'] = 'derecha';
Blockly.Msg['ROBOTS_BUGGY_MOTOR_LEFT'] = 'izquierda';
Blockly.Msg['ROBOTS_BUGGY_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_BUGGY + Blockly.Tooltip.SEP + 'Permite controlar el motor (derecha/izquierda), la dirección (horario/antihorario) y la velocidad (de 0 a 255) del robot Buggy';
// Robots - Bit:Bot
Blockly.Msg['ROBOTS_BITBOT_READLIGHTSENSOR_TITLE'] = '[Bit:Bot] lee el nivel de luz en el sensor %1';
Blockly.Msg['ROBOTS_BITBOT_READLIGHTSENSOR_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Devuelve el nivel de luz (de 0 a 255) con el sensor de luz interno de bit:bot';
Blockly.Msg['ROBOTS_BITBOT_READPATROL_TITLE'] = '[Bit:Bot] leer línea de patrulla %1';
Blockly.Msg['ROBOTS_BITBOT_READPATROL_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Permite leer el estado del sensor de patrulla de línea del robot bit:bot. El bloque devuelve 1 si el sensor está sobre la línea';
Blockly.Msg['ROBOTS_BITBOT_RIGHT'] = 'Derecha';
Blockly.Msg['ROBOTS_BITBOT_LEFT'] = 'Izquierda';
Blockly.Msg['ROBOTS_BITBOT_RIGHT&LEFT'] = 'Derecha e izquierda';
Blockly.Msg['ROBOTS_BITBOT_GO_TITLE'] = '[Bit:Bot] controlar robot %1 velocidad %2';
Blockly.Msg['ROBOTS_BITBOT_GO_FORWARD'] = 'Hacia adelante';
Blockly.Msg['ROBOTS_BITBOT_GO_REVERSE'] = 'Reverse';
Blockly.Msg['ROBOTS_BITBOT_GO_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Permite controlar la marcha del coche (ADELANTE/INVERSO) o la velocidad (de 0 a 1023) del robot bit:bot';
Blockly.Msg['ROBOTS_BITBOT_CONTROLMOTOR_TITLE'] = '[Bit:Bot] controlar motor %1 dirección %2 velocidad %3';
Blockly.Msg['ROBOTS_BITBOT_CONTROLMOTOR_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Permite controlar el motor derecho (P0, P8) y el motor izquierdo (P1, P12) cambiando la dirección (↻ : FOWARD, ↺ : REVERSE) o la velocidad (de 0 a 1023) del robot bit:bot';
Blockly.Msg['ROBOTS_BITBOT_STOPMOTORS_TITLE'] = '[Bit:Bot] parar motor %1';
Blockly.Msg['ROBOTS_BITBOT_STOPMOTORS_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Habilitar para detener el motor derecho, el izquierdo o ambos del robot bit:bot';
Blockly.Msg['ROBOTS_BITBOT_SETNEOPIXEL_TITLE'] = '[Bit:Bot] establece el color R %2 G %3 B %4 en el LED %1';
Blockly.Msg['ROBOTS_BITBOT_SETNEOPIXEL_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Permite controlar cada color del LED del neopixel Maqueen (P13) como (R,G,B) de 0 a 255';
Blockly.Msg['ROBOTS_BITBOT_SETPALETTECOLOR_TITLE'] = '[Bit:Bot] establece el color %2 en el LED %1';
Blockly.Msg['ROBOTS_BITBOT_SETPALETTECOLOR_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Permite controlar cada color del LED del neopixel Bit:Bot (P13). Elección del color en la paleta';
Blockly.Msg['ROBOTS_BITBOT_SETRAINBOW_TITLE'] = '[Bit:Bot] arco iris';
Blockly.Msg['ROBOTS_BITBOT_SETRAINBOW_TOOLTIP'] = IMG_ROBOT_BITBOT + Blockly.Tooltip.SEP + 'Habilitar para mostrar un arco iris en el LED RGB de bit:bot (P13)';
// Robots - Gamepad
Blockly.Msg['ROBOTS_GAMEPAD_V4_ONBUTTONEVENT_TITLE'] = '[Gamepad v4] si el botón %1 está %2 entonces';
Blockly.Msg['ROBOTS_GAMEPAD_V4_ONBUTTONEVENT_TOOLTIP'] = IMG_ROBOT_GAMEPAD_V4 + Blockly.Tooltip.SEP + 'Ejecuta instrucciones si se usa uno de los botones del \'Micro:GamePad (V4.0) DFR0536\'. Un botón tiene dos estados: \'presionado\' o \'soltado\'. Teclas: A(A), B(B), C(P13), D(P14), E(P15), F(P16), Z(P8).';
Blockly.Msg['ROBOTS_GAMEPAD_V4_LED_MOTOR_TITLE'] = '[Gamepad v4] LED y motor de vibración en estado %1';
Blockly.Msg['ROBOTS_GAMEPAD_V4_LED_MOTOR_TOOLTIP'] = IMG_ROBOT_GAMEPAD_V4 + Blockly.Tooltip.SEP + 'Permite controlar el estado del LED y del motor de vibración en el \'Micro:GamePad (V4.0) DFR0536\' (P16).';
Blockly.Msg['ROBOTS_GAMEPAD_V4_GETAXIS_TITLE'] = '[Gamepad v4] valor del eje %1';
Blockly.Msg['ROBOTS_GAMEPAD_V4_GETAXIS_TOOLTIP'] = IMG_ROBOT_GAMEPAD_V4 + Blockly.Tooltip.SEP + 'Devuelve el valor del eje X o Y (de 0 a 1023) del joystick del \'Micro:GamePad (V4.0) DFR0536\'. Joystick: 2 ejes analógicos (X: P1 Y: P2) 1 eje digital (Z: P8).';

Blockly.Msg['ROBOTS_GAMEPAD_CONTROLLED_TITLE'] = '[Gamepad] poner el LED en estado %1';
Blockly.Msg['ROBOTS_GAMEPAD_CONTROLLED_TOOLTIP'] = IMG_ROBOT_GAMEPAD + Blockly.Tooltip.SEP + 'Habilitar para controlar el estado del LED del Gamepad Expansión DFR035 (P16)';
Blockly.Msg['ROBOTS_GAMEPAD_SETMOTORVIBRATION_TITLE'] = '[Gamepad] establece la vibración del motor al estado %1';
Blockly.Msg['ROBOTS_GAMEPAD_SETMOTORVIBRATION_TOOLTIP'] = IMG_ROBOT_GAMEPAD + Blockly.Tooltip.SEP + 'Habilitar para controlar el estado de vibración del motor del Gamepad Expansión DFR035 (P12)';
Blockly.Msg['ROBOTS_GAMEPAD_SETBUZZERFREQ_TITLE'] = '[Gamepad] establece el zumbido a la frecuencia %1 durante %2 (ms)';
Blockly.Msg['ROBOTS_GAMEPAD_SETBUZZERFREQ_TOOLTIP'] = IMG_ROBOT_GAMEPAD + Blockly.Tooltip.SEP + 'Habilitar para controlar el zumbido del Gamepad a cualquier frecuencia (P0)';
Blockly.Msg['ROBOTS_GAMEPAD_PLAYMUSIC_TITLE'] = '[Gamepad] reproducir música %1';
Blockly.Msg['ROBOTS_GAMEPAD_PLAYMUSIC_TOOLTIP'] = IMG_ROBOT_GAMEPAD + Blockly.Tooltip.SEP + 'Activar la reproducción de música en el timbre del Gamepad (P0)';
Blockly.Msg['ROBOTS_GAMEPAD_ONBUTTONEVENT_TITLE'] = '[Gamepad] en el botón %1 %2 entonces';
Blockly.Msg['ROBOTS_GAMEPAD_PRESSED'] = 'pulsado';
Blockly.Msg['ROBOTS_GAMEPAD_RELEASED'] = 'liberado';
Blockly.Msg['ROBOTS_GAMEPAD_ONBUTTONEVENT_TOOLTIP'] = IMG_ROBOT_GAMEPAD + Blockly.Tooltip.SEP + 'Ejecuta las instrucciones si se utiliza algún botón del gamepad. El botón tiene dos estados : \'pulsado\' o \'liberado\'. Tabla de pines : ([X, P1], [Y, P2], [ARRIBA, P8], [ABAJO, P13], [IZQUIERDA, P14], [DERECHA, P15])';
// Tello
Blockly.Msg['TELLO_TAKEOFF_TITLE'] = '[Tello] despegar el dron';
Blockly.Msg['TELLO_TAKEOFF_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite que el dron Tello despegue. Nota: Se necesita un módulo Grove Wifi UART v2 para controlar el dron con una micro:bit v2.';
Blockly.Msg['TELLO_LAND_TITLE'] = '[Tello] aterrizar el dron';
Blockly.Msg['TELLO_LAND_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite que el dron Tello aterrice. Nota: Se necesita un módulo Grove Wifi UART v2 para controlar el dron con una micro:bit v2.';
Blockly.Msg['TELLO_DRONE_INIT_TITLE'] = '[Tello] conectar al dron Tello, SSID %1 en el pin TX %2 y el pin RX %3 del módulo Grove';
Blockly.Msg['TELLO_DRONE_INIT_TOOLTIP'] = IMG_MODULE_WIFI + Blockly.Tooltip.SEP + 'Permite conectar e inicializar el dron Tello con un módulo Grove Wifi UART v2.';
Blockly.Msg['TELLO_FLIP_TITLE'] = '[Tello] hacer un giro %1';
Blockly.Msg['TELLO_FLIP_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite hacer un giro (adelante, atrás, derecha e izquierda) con el dron Tello';
Blockly.Msg['TELLO_FLIP_FORWARD'] = 'adelante';
Blockly.Msg['TELLO_FLIP_BACKWARD'] = 'atrás';
Blockly.Msg['TELLO_FLIP_RIGHT'] = 'derecha';
Blockly.Msg['TELLO_FLIP_LEFT'] = 'izquierda';
Blockly.Msg['TELLO_GO_TITLE'] = '[Tello] mover con el acelerómetro. %1 Mover %2 cm a una velocidad de %3 cm/s';
Blockly.Msg['TELLO_GO_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite mover el dron Tello con el acelerómetro de la micro:bit. El paso es un número entre 20 y 100, y la velocidad es un número entre 10 y 100 cm/s.';
Blockly.Msg['TELLO_MOVE_TITLE'] = '[Tello] mover el dron %1 por %2 cm';
Blockly.Msg['TELLO_MOVE_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite mover el dron Tello en una dirección (adelante, atrás, derecha e izquierda) durante una cierta distancia en cm (entre 20 y 500 cm).';
Blockly.Msg['TELLO_MOVE_UP_DOWN_TITLE'] = '[Tello] mover el dron %1 por %2 cm';
Blockly.Msg['TELLO_MOVE_UP_DOWN_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite mover el dron Tello en una dirección (hacia arriba o hacia abajo) por una cierta distancia en cm (entre 20 y 500 cm).';
Blockly.Msg['TELLO_MOVE_UP'] = 'hacia arriba';
Blockly.Msg['TELLO_MOVE_DOWN'] = 'hacia abajo';
Blockly.Msg['TELLO_MOVE_LEFT'] = 'a la izquierda';
Blockly.Msg['TELLO_MOVE_RIGHT'] = 'a la derecha';
Blockly.Msg['TELLO_MOVE_FORWARD'] = 'adelante';
Blockly.Msg['TELLO_MOVE_BACK'] = 'atrás';
Blockly.Msg['TELLO_ROTATE_TITLE'] = '[Tello] girar el dron en sentido %1 por %2 grados';
Blockly.Msg['TELLO_ROTATE_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite girar el dron Tello en una dirección (en sentido horario CW y en sentido antihorario CCW) entre 1 y 360 grados.';
Blockly.Msg['TELLO_ROTATE_CW'] = 'en sentido horario';
Blockly.Msg['TELLO_ROTATE_CCW'] = 'en sentido antihorario';
Blockly.Msg['TELLO_EMERGENCY_TITLE'] = '[Tello] parada de emergencia';
Blockly.Msg['TELLO_EMERGENCY_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite detener los motores del dron Tello en caso de emergencia. Nota: Dependiendo de la altura del dron, la parada de emergencia puede dañar el Tello.';
Blockly.Msg['TELLO_STOP_TITLE'] = '[Tello] detener el dron';
Blockly.Msg['TELLO_STOP_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite detener el movimiento del dron Tello.';
Blockly.Msg['TELLO_SPEED_TITLE'] = '[Tello] velocidad del dron (cm/s)';
Blockly.Msg['TELLO_SPEED_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite leer la velocidad del dron Tello en cm/s (entre 0 y 100 cm/s).';
Blockly.Msg['TELLO_BATTERY_TITLE'] = '[Tello] nivel de batería del dron (%)';
Blockly.Msg['TELLO_BATTERY_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite leer el nivel de batería del dron Tello en % (entre 0 y 100).';
Blockly.Msg['TELLO_FLIGHT_TIME_TITLE'] = '[Tello] tiempo de vuelo (s)';
Blockly.Msg['TELLO_FLIGHT_TIME_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite leer el tiempo de vuelo del dron Tello en segundos.';
Blockly.Msg['TELLO_STREAMING_VIDEO_ON_TITLE'] = '[Tello] activar transmisión de video';
Blockly.Msg['TELLO_STREAMING_VIDEO_ON_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite activar la transmisión de video desde el dron Tello. Conéctate a la red Wi-Fi del dron Tello (SSID: \'TELLO-XXXXXX\', pw:\'\') y ingresa la URL \'0.0.0.0:11111\' en un navegador web o móvil para recibir retroalimentación de video en tiempo real.';
Blockly.Msg['TELLO_STREAMING_VIDEO_OFF_TITLE'] = '[Tello] desactivar transmisión de video';
Blockly.Msg['TELLO_STREAMING_VIDEO_OFF_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite desactivar la transmisión de video desde el dron Tello.';
Blockly.Msg['TELLO_RECTANGLE_FORM_TITLE'] = '[Tello] dibujar un rectángulo con un ancho de %1 cm y una altura de %2 cm';
Blockly.Msg['TELLO_RECTANGLE_FORM_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite dibujar un rectángulo con el dron Tello. El ancho y la altura están entre 20 y 500 cm.';
Blockly.Msg['TELLO_SQUARE_FORM_TITLE'] = '[Tello] dibujar un cuadrado con un lado de %1 cm';
Blockly.Msg['TELLO_SQUARE_FORM_TOOLTIP'] = IMG_DRONE_TELLO + Blockly.Tooltip.SEP + 'Permite dibujar un cuadrado con el dron Tello. La longitud del lado está entre 20 y 500 cm.';
// HuskyLens
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_TITLE'] = '[HuskyLens] activar modo %1';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permite elegir el modo de detección en la cámara HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_FACE_RECOGNITION'] = 'detección de rostros';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_OBJECT_TRACKING'] = 'seguimiento de objetos';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_OBJECT_RECOGNITION'] = 'detección de objetos';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_LINE_TRACKING'] = 'seguimiento de líneas';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_COLOR_RECOGNITION'] = 'detección de colores';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_TAG_RECOGNITION'] = 'detección de AprilTag';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_MODE_OBJECT_CLASSIFICATION'] = 'clasificación de objetos';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_TEXT_TITLE'] = '[HuskyLens] mostrar texto %1 en la posición (%2,%3)';
Blockly.Msg['CAMERAS_HUSKYLENS_SET_TEXT_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Muestra texto en la posición (x,y) en la pantalla de la cámara HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_CLEAR_SCREEN_TITLE'] = '[HuskyLens] limpiar pantalla';
Blockly.Msg['CAMERAS_HUSKYLENS_CLEAR_SCREEN_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Elimina todo el texto mostrado en la pantalla de la cámara HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_LEARN_ID_TITLE'] = '[HuskyLens] aprender ID N.º %1 automáticamente';
Blockly.Msg['CAMERAS_HUSKYLENS_LEARN_ID_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Aprende a reconocer automáticamente un ID con la cámara HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_FORGET_IDS_TITLE'] = '[HuskyLens] olvidar todos los ID';
Blockly.Msg['CAMERAS_HUSKYLENS_FORGET_IDS_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Borra todos los ID grabados en la cámara HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_GET_DATA_TITLE'] = '[HuskyLens] obtener datos de %1';
Blockly.Msg['CAMERAS_HUSKYLENS_GET_DATA_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permite obtener los datos devueltos por la cámara HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_BLOCKS'] = 'bloques';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_ARROWS'] = 'flechas';
Blockly.Msg['CAMERAS_HUSKYLENS_CUSTOM_NAME_TITLE'] = '[HuskyLens] asociar nombre %1 con ID N.º %2';
Blockly.Msg['CAMERAS_HUSKYLENS_CUSTOM_NAME_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permite asociar un nombre con un ID ya registrado.';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_BLOCKS_DATA_TITLE'] = '[HuskyLens] obtener %1 de bloques detectados';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_BLOCKS_DATA_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permite obtener información de detección de la cámara HuskyLens. Cada elemento identificado se almacena en un arreglo en forma [x1, y1, ancho, alto, id].';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_ID'] = 'IDs';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_X'] = 'coordenadas X';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_Y'] = 'coordenadas Y';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_X1'] = 'coordenadas X (origen)';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_Y1'] = 'coordenadas Y (origen)';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_X2'] = 'coordenadas X (final)';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_Y2'] = 'coordenadas Y (final)';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_SINGLE_X'] = 'coordenada X';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_SINGLE_Y'] = 'coordenada Y';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_SINGLE_WIDTH'] = 'ancho';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_SINGLE_HEIGHT'] = 'alto';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_BLOCKS_XY_TITLE'] = '[HuskyLens] obtener %1 del bloque detectado';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_BLOCKS_XY_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permite obtener las coordenadas X o Y del bloque detectado por la cámara HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_WIDTH'] = 'anchos';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_HEIGHT'] = 'altos';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_ALL'] = 'todos los datos';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_ARROWS_DATA_TITLE'] = '[HuskyLens] obtener %1 de flechas detectadas';
Blockly.Msg['CAMERAS_HUSKYLENS_REQUEST_ARROWS_DATA_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permite obtener información de detección de la cámara HuskyLens. Cada elemento identificado se almacena en un arreglo en forma [x1, y1, x2, y2, id].';
Blockly.Msg['CAMERAS_HUSKYLENS_DETECTED_ELEMENTS_TITLE'] = '[HuskyLens] obtener el número de elementos %1 detectados';
Blockly.Msg['CAMERAS_HUSKYLENS_DETECTED_ELEMENTS_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Permite obtener el número de elementos detectados por la cámara HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_CHECK_ID_TITLE'] = '[HuskyLens] %2 verificar si el ID N.º %1 está detectado';
Blockly.Msg['CAMERAS_HUSKYLENS_CHECK_ID_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Devuelve Verdadero o Falso si el ID es detectado por la cámara HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_GET_LINE_DIRECTION_TITLE'] = '[HuskyLens] si la línea ID N.º %1 %2';
Blockly.Msg['CAMERAS_HUSKYLENS_LINE_STRAIGHT'] = 'es recta';
Blockly.Msg['CAMERAS_HUSKYLENS_LINE_LEFT'] = 'gira a la izquierda';
Blockly.Msg['CAMERAS_HUSKYLENS_LINE_RIGHT'] = 'gira a la derecha';
Blockly.Msg['CAMERAS_HUSKYLENS_GET_LINE_DIRECTION_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Detecta la dirección de la línea usando la cámara HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_SAVE_MODEL_TITLE'] = '[HuskyLens] guardar como modelo N.º %1';
Blockly.Msg['CAMERAS_HUSKYLENS_SAVE_MODEL_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Guarda el modelo en la tarjeta SD de la cámara HuskyLens.';
Blockly.Msg['CAMERAS_HUSKYLENS_LOAD_MODEL_TITLE'] = '[HuskyLens] cargar modelo N.º %1';
Blockly.Msg['CAMERAS_HUSKYLENS_LOAD_MODEL_TOOLTIP'] = IMG_HUSKYLENS + Blockly.Tooltip.SEP + 'Carga el modelo desde la tarjeta SD de la cámara HuskyLens.';

Blockly.Msg['IO_GETMAGNETICSWITCH_TITLE'] = '[Módulo interruptor magnético] estado en el pin %1';
Blockly.Msg['IO_GETMAGNETICSWITCH_TOOLTIP'] = IMG_MODULE_MAGNETIC_SWITCH + Blockly.Tooltip.SEP + 'Devuelve el valor del interruptor magnético Grove (0 o 1) en los pines digitales P0 a P20.';
Blockly.Msg['SENSORS_BAROMETER_READDATA_TITLE'] = '[Barómetro] %1';
Blockly.Msg['SENSORS_BAROMETER_READDATA_TOOLTIP'] = IMG_MODULE_SHT35 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), la presión (en hPa) o la altitud (en m) usando el barómetro. Conectar el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_SHT35_READDATA_TITLE'] = '[Sensor SHT35] %1';
Blockly.Msg['SENSORS_SHT35_READDATA_TOOLTIP'] = IMG_MODULE_SHT35 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad (en %) usando el sensor SHT35. Conectar el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_FSR402_GETFORCE_TITLE'] = '[Sensor de fuerza] valor en el pin %1';
Blockly.Msg['SENSORS_FSR402_GETFORCE_TOOLTIP'] = IMG_MODULE_FORCE + Blockly.Tooltip.SEP + 'Devuelve la fuerza aplicada en el sensor redondo usando el sensor FSR402 en los pines analógicos (P0 a P4 o P10).';
Blockly.Msg['SENSORS_EMG_DETECTOR_TITLE'] = '[Detector EMG] valor en el pin %1';
Blockly.Msg['SENSORS_EMG_DETECTOR_TOOLTIP'] = IMG_MODULE_EMG_DETECTOR + Blockly.Tooltip.SEP + 'Mide las corrientes eléctricas que acompañan la actividad muscular en los pines analógicos (P0 a P4 o P10).';
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TITLE'] = '[Electroimán] controlar a estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TOOLTIP'] = IMG_MODULE_ELECTROMAGNET + Blockly.Tooltip.SEP + 'Permite activar o desactivar el electroimán (ALTO o BAJO) en los pines digitales.';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TITLE'] = '[Atomizador de agua] controlar a estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TOOLTIP'] = IMG_MODULE_WATER_ATOMIZER + Blockly.Tooltip.SEP + 'Permite activar o desactivar el atomizador de agua (ALTO o BAJO) en los pines digitales.';

// IA Sensors
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TITLE'] = '%1 cargar modelo local';
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TOOLTIP'] = 'Permite cargar un modelo de IA almacenado localmente desde el navegador web.';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TITLE'] = '%1 cargar modelo desde la URL %2';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TOOLTIP'] = 'Permite cargar un modelo de IA almacenado en la nube.';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TITLE'] = '%1 Ejecutar predicción a partir de datos del sensor';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TIME_WINDOW'] = 'ventana';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TOOLTIP'] = 'Permite ejecutar una predicción a partir de un sensor. Ajusta la ventana de tiempo para obtener una predicción si es necesario.';
Blockly.Msg['VITTAIA_SENSOR_ACC'] = 'acelerómetro';
Blockly.Msg['VITTAIA_DETECT_CLASS_TITLE'] = '%1 si la clase %2 %3 es detectada entonces';
Blockly.Msg['VITTAIA_DETECT_CLASS_TOOLTIP'] = 'Permite detectar la clase de un objeto.';
Blockly.Msg['VITTAIA_IS'] = 'es';
Blockly.Msg['VITTAIA_ISNOT'] = 'no es';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TITLE'] = '%1 clase detectada';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TOOLTIP'] = 'Permite obtener la clase con la mayor probabilidad.';
