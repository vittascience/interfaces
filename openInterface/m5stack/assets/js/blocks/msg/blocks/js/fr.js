/**
 * @fileoverview English messages for M5Stack. (EN)
 */
'use strict';
//Screen
Blockly.Msg['SCREEN_SET_BACKGROUND_COLOR_PALETTE_TITLE'] = '[Ecran] appliquer la couleur de fond en %1';
Blockly.Msg['SCREEN_SET_BACKGROUND_COLOR_PALETTE_TOOLTIP'] = 'Permet d\'appliquer une couleur, choisie dans la palette, sur la totalité de l\'écran de la M5Stack.';
Blockly.Msg['SCREEN_SET_BACKGROUND_COLOR_RGB_TITLE'] = '[Ecran] appliquer la couleur de fond à R %1 G %2 B %3';
Blockly.Msg['SCREEN_SET_BACKGROUND_COLOR_RGB_TOOLTIP'] = 'Permet d\'appliquer une couleur sur la totalité de l\'écran de la M5Stack en spécifiant les valeurs RGB (0-255).';
// Screen - draw - title
Blockly.Msg['SCREEN_DRAW_M5TITLE_DEFINE_TITLE'] = '[Dessin - titre] id %1 définir le titre %2 position %3';
Blockly.Msg['SCREEN_DRAW_M5TITLE_DEFINE_TOOLTIP'] = 'Permet d\'ajouter un titre en haut de l\'écran M5Stack.';
Blockly.Msg['SCREEN_DRAW_M5TITLE_SETFGCOLOR_TITLE'] = '[Dessin - titre] id %1 changer la couleur du titre à %2';
Blockly.Msg['SCREEN_DRAW_M5TITLE_SETFGCOLOR_TOOLTIP'] = 'Permet de changer la couleur du titre.';
Blockly.Msg['SCREEN_DRAW_M5TITLE_SETBGCOLOR_TITLE'] = '[Dessin - titre] id %1 changer la couleur de fond à %2';
Blockly.Msg['SCREEN_DRAW_M5TITLE_SETBGCOLOR_TOOLTIP'] = 'Permet de changer la couleur de fond du titre.';
Blockly.Msg['SCREEN_DRAW_M5TITLE_SETTITLE_TITLE'] = '[Dessin - titre] id %1 changer le titre à %2';
Blockly.Msg['SCREEN_DRAW_M5TITLE_SETTITLE_TOOLTIP'] = 'Permet de changer le texte du titre.';
Blockly.Msg['SCREEN_DRAW_M5TITLE_CONTROLDISPLAY_TITLE'] = '[Dessin - titre] id %1 contrôler l\'affichage à l\'état %2';
Blockly.Msg['SCREEN_DRAW_M5TITLE_CONTROLDISPLAY_TOOLTIP'] = 'Permet d\'afficher ou de masquer le titre.';
// Screen - draw - label
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_DEFINE_TITLE'] = '[Dessin - texte] id %1 définir le texte %2 à x %3 y %4';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_DEFINE_TOOLTIP'] = 'Permet de définir un texte sur l\'écran de la M5Stack de x (0-250) y (0-300).';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_SETCOLOR_TITLE'] = '[Dessin - texte] id %1 changer la couleur du texte à %2';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_SETCOLOR_TOOLTIP'] = 'Permet de changer la couleur du texte.';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_SETPOSITION_TITLE'] = '[Dessin - texte] id %1 changer la position en x %2 y %3';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_SETPOSITION_TOOLTIP'] = 'Permet de modifier la position du texte.';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_SETFONT_TITLE'] = '[Dessin - texte] id %1 changer la police à %2';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_SETFONT_TOOLTIP'] = 'Permet de changer la police du texte.';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_SETTEXT_TITLE'] = '[Dessin - texte] id %1 changer le texte à %2';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_SETTEXT_TOOLTIP'] = 'Permet de modifier la valeur du texte.';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_SETROTATE_TITLE'] = '[Dessin - texte] id %1 changer la rotation à l\'angle %2 (°)';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_SETROTATE_TOOLTIP'] = 'Permet de modifier la rotation du texte.';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_CONTROLDISPLAY_TITLE'] = '[Dessin - texte] id %1 contrôler l\'affichage du texte à l\'état %2';
Blockly.Msg['SCREEN_DRAW_M5TEXTBOX_CONTROLDISPLAY_TOOLTIP'] = 'Permet d\'afficher ou de masquer le texte.';
// Screen - draw - rectangle
Blockly.Msg['SCREEN_DRAW_M5RECT_DEFINE_TITLE'] = '[Dessin - rect] id %1 définir un rectangle à la position x %2 y %3';
Blockly.Msg['SCREEN_DRAW_M5RECT_DEFINE_TOOLTIP'] = 'Permet d\'ajouter un rectangle sur l\'écran de la M5Stack en x (0-250) y (0-300).';
Blockly.Msg['SCREEN_DRAW_M5RECT_SETSIZE_TITLE'] = '[Dessin - rect] id %1 changer la taille avec largeur %2 hauteur %3';
Blockly.Msg['SCREEN_DRAW_M5RECT_SETSIZE_TOOLTIP'] = 'Permet de modifier la taille du rectangle.';
Blockly.Msg['SCREEN_DRAW_M5RECT_SETBGCOLOR_TITLE'] = '[Dessin - rect] id %1 changer la couleur de remplissage à %2';
Blockly.Msg['SCREEN_DRAW_M5RECT_SETBGCOLOR_TOOLTIP'] = 'Permet de changer la couleur de remplissage du rectangle.';
Blockly.Msg['SCREEN_DRAW_M5RECT_SETBORDERCOLOR_TITLE'] = '[Dessin - rect] id %1 changer la couleur de la bordure à %2';
Blockly.Msg['SCREEN_DRAW_M5RECT_SETBORDERCOLOR_TOOLTIP'] = 'Permet de changer la couleur de bordure du rectangle.';
Blockly.Msg['SCREEN_DRAW_M5RECT_SETPOSITION_TITLE'] = '[Dessin - rect] id %1 changer la position en x %2 y %3';
Blockly.Msg['SCREEN_DRAW_M5RECT_SETPOSITION_TOOLTIP'] = 'Permet de modifier la position du rectangle.';
Blockly.Msg['SCREEN_DRAW_M5RECT_CONTROLDISPLAY_TITLE'] = '[Dessin - rect] id %1 contrôle l\'affichage du rectangle à l\'état %2';
Blockly.Msg['SCREEN_DRAW_M5RECT_CONTROLDISPLAY_TOOLTIP'] = 'Permet d\'afficher ou de masquer le rectangle.';
// Screen - draw - circle
Blockly.Msg['SCREEN_DRAW_M5CIRCLE_DEFINE_TITLE'] = '[Dessin - cercle] id %1 définir un cercle à la position x %2 y %3';
Blockly.Msg['SCREEN_DRAW_M5CIRCLE_DEFINE_TOOLTIP'] = 'Permet d\'ajouter un cercle sur l\'écran de la M5Stack en x (0-250) y (0-300).';
Blockly.Msg['SCREEN_DRAW_M5CIRCLE_SETSIZE_TITLE'] = '[Dessin - cercle] id %1 changer le rayon du cercle à %2';
Blockly.Msg['SCREEN_DRAW_M5CIRCLE_SETSIZE_TOOLTIP'] = 'Permet de modifier le rayon du cercle.';
Blockly.Msg['SCREEN_DRAW_M5CIRCLE_SETBGCOLOR_TITLE'] = '[Dessin - cercle] id %1 changer la couleur de remplissage à %2';
Blockly.Msg['SCREEN_DRAW_M5CIRCLE_SETBGCOLOR_TOOLTIP'] = 'Permet de changer la couleur de remplissage du cercle.';
Blockly.Msg['SCREEN_DRAW_M5CIRCLE_SETBORDERCOLOR_TITLE'] = '[Dessin - cercle] id %1 changer la couleur de la bordure à %2';
Blockly.Msg['SCREEN_DRAW_M5CIRCLE_SETBORDERCOLOR_TOOLTIP'] = 'Permet de changer la couleur de bordure du cercle.';
Blockly.Msg['SCREEN_DRAW_M5CIRCLE_SETPOSITION_TITLE'] = '[Dessin - cercle] id %1 changer la position en x %2 y %3';
Blockly.Msg['SCREEN_DRAW_M5CIRCLE_SETPOSITION_TOOLTIP'] = 'Permet de modifier la position du cercle.';
Blockly.Msg['SCREEN_DRAW_M5CIRCLE_CONTROLDISPLAY_TITLE'] = '[Dessin - cercle] id %1 contrôle l\'affichage du cercle à l\'état %2';
Blockly.Msg['SCREEN_DRAW_M5CIRCLE_CONTROLDISPLAY_TOOLTIP'] = 'Permet d\'afficher ou de masquer le cercle.';
// Screen - draw - triangle
Blockly.Msg['SCREEN_DRAW_M5TRIANGLE_DEFINE_TITLE'] = '[Dessin - triangle] id %1 définir un triangle aux positions x1 %2 y1 %3 x2 %4 y2 %5 x3 %6 y3 %7';
Blockly.Msg['SCREEN_DRAW_M5TRIANGLE_DEFINE_TOOLTIP'] = 'Permet d\'ajouter un triangle sur l\'écran de la M5Stack aux positions des 3 angles.';
Blockly.Msg['SCREEN_DRAW_M5TRIANGLE_SETSIZE_TITLE'] = '[Dessin - triangle] id %1 changer la position des angles à x1 %2 y1 %3 x2 %4 y2 %5 x3 %6 y3 %7';
Blockly.Msg['SCREEN_DRAW_M5TRIANGLE_SETSIZE_TOOLTIP'] = 'Permet de modifier la position des 3 angles du triangle.';
Blockly.Msg['SCREEN_DRAW_M5TRIANGLE_SETBGCOLOR_TITLE'] = '[Dessin - triangle] id %1 changer la couleur de remplissage à %2';
Blockly.Msg['SCREEN_DRAW_M5TRIANGLE_SETBGCOLOR_TOOLTIP'] = 'Permet de changer la couleur de remplissage du triangle.';
Blockly.Msg['SCREEN_DRAW_M5TRIANGLE_SETBORDERCOLOR_TITLE'] = '[Dessin - triangle] id %1 changer la couleur de la bordure à %2';
Blockly.Msg['SCREEN_DRAW_M5TRIANGLE_SETBORDERCOLOR_TOOLTIP'] = 'Permet de changer la couleur de bordure du triangle.';
Blockly.Msg['SCREEN_DRAW_M5TRIANGLE_CONTROLDISPLAY_TITLE'] = '[Dessin - triangle] id %1 contrôle l\'affichage du triangle à l\'état %2';
Blockly.Msg['SCREEN_DRAW_M5TRIANGLE_CONTROLDISPLAY_TOOLTIP'] = 'Permet d\'afficher ou de masquer le triangle.';
// Screen - draw - line
Blockly.Msg['SCREEN_DRAW_M5LINE_DEFINE_TITLE'] = '[Dessin - ligne] id %1 définir une ligne entre x1 %2 y1 %3 x2 %4 y2 %5 type %6';
Blockly.Msg['SCREEN_DRAW_M5LINE_DEFINE_TOOLTIP'] = 'Permet d\'ajouter un ligne sur l\'écran de la M5Stack.';
Blockly.Msg['SCREEN_DRAW_M5LINE_SETSIZE_TITLE'] = '[Dessin - ligne] id %1 repositionner la ligne entre x1 %2 y1 %3 x2 %4 y2 %5';
Blockly.Msg['SCREEN_DRAW_M5LINE_SETSIZE_TOOLTIP'] = 'Permet de modifier la position de la ligne.';
Blockly.Msg['SCREEN_DRAW_M5LINE_SETCOLOR_TITLE'] = '[Dessin - ligne] id %1 changer la couleur à %2';
Blockly.Msg['SCREEN_DRAW_M5LINE_SETCOLOR_TOOLTIP'] = 'Permet de changer la couleur de la ligne.';
Blockly.Msg['SCREEN_DRAW_M5LINE_CONTROLDISPLAY_TITLE'] = '[Dessin - ligne] id %1 contrôle l\'affichage de la ligne à l\'état %2';
Blockly.Msg['SCREEN_DRAW_M5LINE_CONTROLDISPLAY_TOOLTIP'] = 'Permet d\'afficher ou de masquer la ligne.';
// Input/Output - Esp32
Blockly.Msg['IO_WAIT_TITLE'] = 'attendre %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Effectue une pause dans l\'exécution du code.';
Blockly.Msg['IO_WAIT_SECOND'] = 'seconde(s)';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milliseconde(s)';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microseconde(s)';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'attendre jusqu\'à %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Arrête l\'excution du code jusqu\'à ce que la condition soit satisfaite.';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'démarrer le chronomètre';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Initialise un chronomètre à 0 (en secondes).';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'valeur du chronomètre en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Renvoie la valeur du chronomètre à partir de l\'initialisation (en secondes ou millisecondes).';
Blockly.Msg['IO_M5STACK_ON_BUTTON_PRESSED_EVENT_TITLE'] = 'si le bouton %1 %2 alors';
Blockly.Msg['IO_M5STACK_ON_BUTTON_PRESSED_EVENT_TOOLTIP'] = 'Permet de créer un évènement sur les boutons A, B ou C. Ce bloc exécute des instructions à n\'importe quel instant dès que l\'évènement est détecté.';
Blockly.Msg['IO_WAS_PRESSED'] = 'a été appuyé';
Blockly.Msg['IO_WAS_RELEASED'] = 'a été relâché';
Blockly.Msg['IO_WAS_LONG_PRESSED'] = 'a longtemps été appuyé';
Blockly.Msg['IO_WAS_DOUBLE_PRESSED'] = 'a été appuyé 2 fois';
Blockly.Msg['IO_M5STACK_GET_BUTTON_STATE_TITLE'] = 'bouton %1 %2';
Blockly.Msg['IO_M5STACK_GET_BUTTON_STATE_TOOLTIP'] = 'Retourne l\'état de l\'évènement courant (pressé ou relâché) des boutons A, B ou C.';
Blockly.Msg['IO_IS_PRESSED'] = 'est appuyé';
Blockly.Msg['IO_IS_RELEASED'] = 'est relâché';
Blockly.Msg['IO_M5STACK_IS_CHARGING_TITLE'] = '[batterie] en chargement ?';
Blockly.Msg['IO_M5STACK_IS_CHARGING_TOOLTIP'] = 'Retourne \'True\' si la batterie de la M5Stack est en train de charger.';
Blockly.Msg['IO_M5STACK_IS_CHARGE_FULL_TITLE'] = '[batterie] est chargée ?';
Blockly.Msg['IO_M5STACK_IS_CHARGE_FULL_TOOLTIP'] = 'Retourne \'True\' si la batterie de la M5Stack est complètement chargée.';
Blockly.Msg['IO_M5STACK_SET_CHARGE_TITLE'] = '[batterie] contrôler le chargement à %1';
Blockly.Msg['IO_M5STACK_SET_CHARGE_TOOLTIP'] = 'Permet d\'activer ou de désactiver le chargement de la batterie de la M5Stack.';
Blockly.Msg['IO_M5STACK_GET_BATTERY_LEVEL_TITLE'] = '[batterie] niveau de la batterie (%)';
Blockly.Msg['IO_M5STACK_GET_BATTERY_LEVEL_TOOLTIP'] = 'Retourne le niveau de la batterie de (0-100) en %.';
// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Clavier numérique] chiffre sur les broches RX %1 TX %2';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Permet d\'obtenir la touche appuyée du clavier numérique grove sur les broches TX et RX. Quand vous connectez le module, s\'assurer que les broches sont \'croisées\' : RX de la carte avec TX du module et inversement.';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Module joytsick] valeur de l\'axe %1 sur les broches X %2 Y %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'axe X ou Y (de 0 à 1023) du joystick Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TITLE'] = '[Module bouton coloré] état sur la broche SIG2 %1 ';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Renvoie l\'état du bouton coloré grove (0 or 1) sur les broches digitales.';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TITLE'] = '[Module bouton coloré] contrôler la LED à l\'état %1 sur la broche SIG1 %2';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Permet d\'allumer ou éteindre la LED (0 or 1) sur les broches digitales.';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Potentiomètre rotatif] valeur sur la broche %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Renvoie l\'angle (de 0 à 1023) du potentiomètre rotatif Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Potentiomètre linéaire] valeur sur la broche %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Renvoie la position (de 0 à 1023) du potentiomètre linéaire Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Capteur tactile] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur tactile Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Module bouton] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Renvoie la valeur du bouton Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Module interrupteur] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'interrupteur Grove (0 ou 1) sur les broches digitales.';
// Input/Output - Pins
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'HAUT (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAS (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Retourne une valeur booléenne (1 si HAUT ou 0 si BAS).';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'état de la broche numérique %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée digitale (0 ou 1).';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'écrire l\'état %1 sur la broche numérique %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Permet d\'écrire une valeur sur une entrée digitale (0 ou 1).';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'lire la broche analogique %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée analogique (0-1023), ce qui correspond à une tensio entre 0 et 3.6V.';
Blockly.Msg['IO_WRITEPWMPIN_TITLE'] = 'écrire la valeur %1 sur la broche PWM %2';
Blockly.Msg['IO_WRITEPWMPIN_TOOLTIP'] = 'Permet d\'appliquer un signal PWM avec une fréquence fixée à 10kH et en changeant le cycle de 0 à 1023. La valeur 512 correspondra à 50% du cycle, donc environ 1.66V.';
Blockly.Msg['IO_WRITEANALOGPIN_TITLE'] = 'écrire la valeur %1 sur la broche analogique %2 (DAC)';
Blockly.Msg['IO_WRITEANALOGPIN_TOOLTIP'] = 'Permet d\'appliquer une tension analogique sur les broches DAC p25 et p26 (de 0 à 255). L\'Esp32 utilise un convertisseur Numérique-Analogique (DAC) pour appliquer une tension comprise entre 0 et 3.3V.';
Blockly.Msg['IO_SETPWM_TITLE'] = 'appliquer un signal carré de fréquence %1 (Hz) sur la broche %2';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Permet d\'appliquer un signal carré (PWM) avec un cycle fixé à 50% sur une broche. Ce bloc permet de changer la fréquence du signal.';
Blockly.Msg['IO_STOPPWM_TITLE'] = 'arrêter le signal PWM de la broche %1';
Blockly.Msg['IO_STOPPWM_TOOLTIP'] = 'Permet d\'arrêter le signal PWM appliqué sur une broche.';
Blockly.Msg['IO_GETVOLTAGE_TITLE'] = 'convertir %1 sur %2 en tension';
Blockly.Msg['IO_GETVOLTAGE_TOOLTIP'] = 'Permet de convertir une valeur analogique en tension en choisissant la résolution (10-bit: 1024, 12-bit: 4096, 9-bit: 512, 11-bit: 2048) et un maximum de 3.6V.';
//Communication - Internal Bluetooth
Blockly.Msg['COMMUNICATION_START_BT_TITLE'] = '[ESP32 Bluetooth UART] initialiser le bluetooth %1';
Blockly.Msg['COMMUNICATION_START_BT_TOOLTIP'] = 'Permet d\'intialiser le service Bluetooth de l\'ESP32 avec un nom attribué.';
Blockly.Msg['COMMUNICATION_SEND_BT_TITLE'] = '[ESP32 Bluetooth UART] envoyer donnée %1';
Blockly.Msg['COMMUNICATION_SEND_BT_TOOLTIP'] = 'Permet d\'envoyer des données via le Bluetooth de l\'ESP32.';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TITLE'] = '[Bluetooth] si message reçu dans %1 alors';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TOOLTIP'] = 'Permet d\'exécuter des instructions si une donnée est reçue par Bluetooth (BLE).';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TITLE'] = '[Bluetooth Fizziq App] envoyer %1 %2';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TOOLTIP'] = IMG_MODULE_FIZZIQ + Blockly.Tooltip.SEP + 'Envoyer des données (Température, Humidité, etc) via Bluetooth à Fizziq App.';
Blockly.Msg['FIZZ_TEMP'] = 'Température';
Blockly.Msg['FIZZ_HUM'] = 'Humidité';
Blockly.Msg['FIZZ_VOLTAGE'] = 'Tension';
Blockly.Msg['FIZZ_WEIGHT'] = 'Poids';
Blockly.Msg['FIZZ_PRESSURE'] = 'Pression';
Blockly.Msg['FIZZ_CONCENTRATION'] = 'Concentration';
Blockly.Msg['FIZZ_MAGNETIC'] = 'Champ magnétique';
Blockly.Msg['FIZZ_BRIGHTNESS'] = 'Luminosité';
Blockly.Msg['FIZZ_ACCELERATION'] = 'Accélération';
Blockly.Msg['FIZZ_COMPASS'] = 'Boussole';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'écrire dans la console %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Permet d\'écrire des données dans le port série.';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'avec';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'saut(s) de ligne';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE then'] = 'on serial data received in %1 then';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si une donnée est reçue par le port série dans la variable \'serialData\'.';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'jouer la note %1 sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Joue la note selectionnée jusqu\'à l\'exécution du bloc "Fin de la note".';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'jouer la fréquence %1 (Hz) sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Ce bloc permet de jouer une fréquence donnée sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'terminer la note sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Arrête la note en cours.';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'tracer le graphe';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Ce bloc permet d\'écrire des données (numériques) qui seront visibles dans le traceur. Il peut être utilisé avec un ou plusieurs blocs au format "Nom" et "Données". Pour visualiser les graphiques, cliquer sur l\'icone \'Mode Graphique\' dans la console.';
Blockly.Msg['COMMUNICATION_DATA'] = 'Donnée';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nom %1 Valeur %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Ce bloc est à utiliser avec le bloc "Tracer le graphique". Il doit lui-même contenir le nom de la valeur à afficher (texte), et la valeur en question (nombre).';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] écrire dans la carte SD %1 baudrate %2 sur les broches RXI %3 TXO %4 %5 Données %6';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'Permet d\'écrire des données dans la carte micro SD avec le module Openlog. Fonctionnement en transmission UART.';
Blockly.Msg['COMMUNICATION_WRITE_SD_TITLE'] = '[SD M5Stack] écrire dans la carte SD avec le fichier %1 les données %2';
Blockly.Msg['COMMUNICATION_WRITE_SD_TOOLTIP'] = 'Permet d\'écrire des données dans la carte micro SD de la M5Stack.';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] envoyer sur les broches RX %1 TX %2 message %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permet d\'envoyer des données via le module BLuetooth HC05 sur les broches RX/TX.';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] si message reçu sur les broches RX %1 TX %2 dans %3 alors';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par un module Bluetooth HC05 dans la variable \'bluetoothData\' sur les broches RX/TX.';
// Communication - Tracking modules
Blockly.Msg['COMMUNICATION_GPS_M5_GETINFORMATIONS_TITLE'] = '[Module GPS M5] obtenir %1';
Blockly.Msg['COMMUNICATION_GPS_M5_GETINFORMATIONS_TOOLTIP'] = '';
Blockly.Msg['COMMUNICATION_GPS_M5_INFO_FRAME'] = 'la trame complète';
Blockly.Msg['COMMUNICATION_GPS_M5_INFO_TIME'] = 'l\'heure';
Blockly.Msg['COMMUNICATION_GPS_M5_INFO_LATITUDE'] = 'la latitude';
Blockly.Msg['COMMUNICATION_GPS_M5_INFO_LONGITUDE'] = 'la longitude';
Blockly.Msg['COMMUNICATION_GPS_M5_INFO_SATELLITE'] = 'le nombre de satellites utilisés';
Blockly.Msg['COMMUNICATION_GPS_M5_INFO_SPEED'] = 'la vitesse';
Blockly.Msg['COMMUNICATION_GPS_M5_INFO_COURSE'] = 'le cap';
Blockly.Msg['COMMUNICATION_GPS_INFO_TYPE'] = 'le type de la trame';
Blockly.Msg['COMMUNICATION_GPS_INFO_CLOCK'] = 'l\'heure (h, m, s)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LATITUDE'] = 'la latitude (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LONGITUDE'] = 'la longitude (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_SATELLITE'] = 'le nombre de satellites utilisés';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALTITUDE'] = 'l\'altitude (m)';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALL_FRAME'] = 'toute la trame';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TITLE'] = '[GPS] trames NMEA sur les broches RX %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Renvoie la liste des trames NMEA lues avec le module GPS Grove SIM28 ou Air530 sur les broches RX/TX. Les fils n\'ont pas besoin d\'être inversée entre les broches du module et celles indiquées dans le bloc. L\'inversion se fait automatiquement dans le code python.\nAttention: Si vous utilisez la console pour afficher les données du GPS, connecter votre carte à l\'interface avant d\'envoyer le programme en cliquant sur le bouton [>_ REPL]. Ensuite, transférer votre programme en utilisant le bouton [Télécharger .hex].';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TITLE'] = '[GPS] obtenir %3 sur les broches RX %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Renvoie la donnée sélectionnée parmi (le type de trame, l\'horloge, la latitude, la longitude, l\'altitude) annalysée de la trame NMEA (GNGGA ou GPGGA) lue avec le module GPS Grove SIM28 ou Air530 sur les broches RX/TX. Les fils n\'ont pas besoin d\'être inversée entre les broches du module et celles indiquées dans le bloc. L\'inversion se fait automatiquement dans le code python.\nAttention: Si vous utilisez la console pour afficher les données du GPS, connecter votre carte à l\'interface avant d\'envoyer le programme en cliquant sur le bouton [>_ REPL]. Ensuite, transférer votre programme en utilisant le bouton [Télécharger .hex].';
Blockly.Msg['COMMUNICATION_RTC_MODULE_PCF85063TP'] = 'Haute Précision (0x51)';
Blockly.Msg['COMMUNICATION_RTC_MODULE_DS1307'] = 'v1.2 (0x68)';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TITLE'] = '[Horloge RTC %1] initialiser à %2 date %3';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet d\'initialiser le module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307), pour pouvoir lire la date et l\'heure précise avec le bloc \'Lire le module horloge\'. Placer dans le bloc \'Au démarrage\'. Brancher le module RTC sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['DAY_MONDAY'] = 'lundi';
Blockly.Msg['DAY_TUESDAY'] = 'mardi';
Blockly.Msg['DAY_WEDNESDAY'] = 'mercredi';
Blockly.Msg['DAY_THURSDAY'] = 'jeudi';
Blockly.Msg['DAY_FRIDAY'] = 'vendredi';
Blockly.Msg['DAY_SATURDAY'] = 'samedi';
Blockly.Msg['DAY_SUNDAY'] = 'dimanche';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TITLE'] = '[Horloge RTC %1] initialiser à heure %2 minute %3 seconde %4';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet d\'initialiser le module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307), pour pouvoir lire la date et l\'heure précise avec le bloc \'Lire le module horloge\'. Placer dans le bloc \'Au démarrage\'. Brancher le module sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TITLE'] = '[Horloge RTC %1] lire %2';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet de lire la date et l\'heure du module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307). Pour avoir un résultat correct, utiliser au préalable les deux blocs \'Initialiser le module horloge\'. Brancher le module sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['CLOCK_ALL_DATA'] = 'l\'horloge';
Blockly.Msg['CLOCK_YEAR'] = 'année';
Blockly.Msg['CLOCK_MONTH'] = 'mois';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'jour du mois';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'jour de la semaine';
Blockly.Msg['CLOCK_HOUR'] = 'heure';
Blockly.Msg['CLOCK_MINUTE'] = 'minute';
Blockly.Msg['CLOCK_SECOND'] = 'seconde';
// Communication - UART
Blockly.Msg['COMMUNICATION_UART_INIT_TITLE'] = '[uart %1] définir la connexion série sur RX %2 TX %3 Baudrate %4';
Blockly.Msg['COMMUNICATION_UART_INIT_TOOLTIP'] = 'Permet de définir la connexion série de la carte ESP32 sur le port UART (1 ou 2). Le port 0 est réservé au REPL.';
Blockly.Msg['COMMUNICATION_UART_WRITE_TITLE'] = '[uart %1] écrire la donnée %2';
Blockly.Msg['COMMUNICATION_UART_WRITE_TOOLTIP'] = 'Permet d\'écrire des données dans le port UART (1 ou 2). Par défaut, les broches sont telles que: UART 1 (tx=10, rx=9) et UART 2 (tx=17, rx=16). Sinon, utilisez le bloc \'Définir la connexion série sur RX TX Baudrate ...\'.';
Blockly.Msg['COMMUNICATION_UART_READ_TITLE'] = '[uart %1] lire les données';
Blockly.Msg['COMMUNICATION_UART_READ_TOOLTIP'] = 'Permet de lire des données depuis le port UART (1 ou 2). Par défaut, les broches sont telles que: UART 1 (tx=10, rx=9) et UART 2 (tx=17, rx=16). Sinon, utilisez le bloc \'Définir la connexion série sur RX TX Baudrate ...\'.';
Blockly.Msg['COMMUNICATION_UART_READ_SIZE'] = 'taille des données';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TITLE'] = '[uart %1] données disponibles';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TOOLTIP'] = 'Retourne la taille des données disponibles sur le port UART (1 ou 2). Par défaut, les broches sont telles que: UART 1 (tx=10, rx=9) et UART 2 (tx=17, rx=16). Sinon, utilisez le bloc \'Définir la connexion série sur RX TX Baudrate ...\'.';
// Display - Screen
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD] afficher le texte %1 sur la ligne %2 position %3';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Affiche du texte sur l\'une des deux lignes de l\'écran LCD1602 grove. Brancher le module sur un port I2C';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD] nettoyer l\'écran';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Permet d\'effacer tous les caractères de l\'écran LCD. Brancher le module sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[OLED] afficher le texte %1 à la position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'écrire du texte sur un écran OLED de taille 128x64. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TITLE'] = '[OLED] contrôler le pixel x %1 y %2 état %3';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de contrôler chaque pixel de l\'écran OLED de taille 128x64. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TITLE'] = '[OLED] dessiner une ligne de (%1, %2) à (%3, %4)';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de dessiner une ligne entre deux points de l\'écran OLED de taille 128x64. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TITLE'] = '[OLED] définir le fond en %1';
Blockly.Msg['DISPLAY_OLED_WHITE'] = 'blanc';
Blockly.Msg['DISPLAY_OLED_BLACK'] = 'noir';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'inverser le rétroélcairage de l\'écran. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[OLED] effacer l\'écran';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'effacer le contenu de l\'écran OLED. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[OLED] afficher l\'icône %1 position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'afficher une icône de la librairie Image de ESP32, à la position (x,y) sur l\'écran grove OLED. Brancher l\'afficheur sur un port I2C.';
// Display - Neopixel
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] définir %1 LED sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de définir le nombre de LED du neopixel. Ce bloc doit être utilisé dans le bloc \'Au démarrage\'.';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] contrôler la LED %1 à R %2 G %3 B %4 sur la broche %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED tel que (R,G,B) de 0 à 255 du module neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] contrôler la LED %1 à %2 sur la broche %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du module neopixel. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] contrôler toutes les LED à R %1 G %2 B %3 sur la broche %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie telle que (R,G,B) soit de 0 à 255.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] contrôler toutes les LED à %1 sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] Arc-en-ciel sur la broche %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB. Il est possible de modifier la broche et le nombre de LED du module neopixel.';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] contrôler la LED %1 sur la broche  %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Permet d\'activer ou désactiver la LED Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] régler la luminosité à %1 (%) sur la broche %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 100% sur les broches PWM.';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[Variable Color LED] régler la luminosité à %1 (%) sur la broche %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 100 % sur les broches PWM. A la premièe utilisation, les valeurs RGB sont fixées à 0. Utiliser un tournevis pour régler les couleurs R, G et B derrière le module.';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[Afficheur 4-digit] afficher %1 %2 sur les broches CLK %3 DIO %4';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher un nombre, une température ou l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales.';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[Afficheur 4-digit] l\'horloge sur les broches CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales. Attention, l\'heure réelle est récupérée seulement la carte microbit reste allumée.';
Blockly.Msg['DISPLAY_4DIGIT_NUMBER'] = 'le nombre entier';
Blockly.Msg['DISPLAY_4DIGIT_TEMPERATURE'] = 'la température';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[Module LED Bar] afficher le niveau de %1 sur les broches DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permet d\'afficher le niveau de la valeur en entrée sur le module LED Bar (MY9221) avec les broches digitales.';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TITLE'] = '[Module LED Bar] inverser l\'afficheur %1 les broches DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permet d\'inverser les 10 LED du module LED Bar (MY9221) avec les broches digitales.';
// Display - Chainable LED
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TITLE'] = '[Chainable LED] definir %1 LED sur les broches CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Permet de paramétrer la chaîne de LED RGB en définissant le nombre de modules en série sur les broches digitales D0 à D13.';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TITLE'] = '[Chainable LED] contrôler la LED %1 à R %2 G %3 B %4 sur les broches CIN %5 DIN %6';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la DEL RGB, donner une valeur entre 0 et 255 pour Rouge, Vert et Bleu.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TITLE'] = '[Chainable LED] contrôler la LED %1 à %2 sur les broches CIN %3 DIN %4';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la DEL RGB, choisir une couleur dans la palette.';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TITLE'] = '[Chainable LED] contrôler toutes les LED à R %1 G %2 B %3 sur les broches CIN %4 DIN %5';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur des DEL RGB, donner une valeur entre 0 et 255 pour Rouge, Vert et Bleu.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE'] = '[Chainable LED] contrôler toutes les LED à %1 sur les broches CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur des DEL RGB, choisir une couleur dans la palette.';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TITLE'] = '[Chainable LED] éteindre sur les broches CIN %1 DIN %2';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc éteignant toutes les DEL RGB.';
// Sensors - M5Stack
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TITLE'] = 'lire le capteur à effet Hall';
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TOOLTIP'] = 'Renvoie la valeur du capteur à effet Hall de la carte.';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TITLE'] = 'température du processeur en %1';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TOOLTIP'] = 'Retourne la température du processeur.';
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[Capteur SGP30] gaz %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Renvoie la quantité de CO2 (en ppm) ou de TVOC (en ppb) contenu dans l\'air grâce au capteur SGP30. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'Dioxyde de carbone (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'Composés organiques volatiles (TVOC) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Capteur de gaz multicanal] gaz %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Renvoie la quantité du gaz mesuré dans l\'air (en ppm) grâce au capteur de gaz multicanal. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Capteur de gaz multicanal v2] gaz %1 (V)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Renvoie la quantité du gaz mesuré dans l\'air (en V) grâce au capteur de gaz multicanal V2 grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['GAS_CO'] = 'Monoxyde de carbone (CO)';
Blockly.Msg['GAS_NO2'] = 'Dioxyde d\'azote (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'Ethanol (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'Dihydrogène (H2)';
Blockly.Msg['GAS_NH3'] = 'Ammoniac (NH3)';
Blockly.Msg['GAS_CH4'] = 'Méthane (CH4)';
Blockly.Msg['GAS_C3H8'] = 'Propane (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'Iso-propane (C4H10)';
Blockly.Msg['GAS_VOC'] = 'Composés organiques volatiles (COV)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Capteur de dioxygène] O2 (%) sur la broche %1';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Renvoie la concentration de dioxygène (O2) dans l\'air (en %) grâce au capteur de gas O2 grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove)..';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[Capteur SCD30] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Renvoie la concentration de CO2 dans l\'air (en ppm), l\'humidité (en %) ou la température en Celsius (°C), Fahrenheit (°F) ou Kelvin (K) from the grove SCD30 sensor. Bancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'dioxyde de carbone (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = 'température';
Blockly.Msg['SENSORS_SCD30_HUM'] = 'humidité (%)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[Capteur SCD30] forcer la recalibration à %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Forcer la calibration du capteur SCD30 à la valeur donnée (in ppm). Se placer en extérieur (là où la concentration est autour de 420 ppm environ, soit un air pur), redémarrer la carte, puis attendre 2 minutes. Conseil: Utiliser les boutons SW1, SW2 ou SW3 de la carte STM32 NUCLEO pour contrôler le lancement de la calibration. Sinon, en rebranchant la carte, le programme se lance et effectue de nouveau une calibration pas forcément souhaitée.';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Capteur de qualité d\'air] valeur sur la broche %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Renvoie la valeur de la qualité de l\'air (de 0 à 1023) sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[Capteur HM330X] concentration de particules fines %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Détecte la densité de particules dans l\'air avec le capteur HM330X. Bancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
// Sensors - Climate
Blockly.Msg['SENSORS_TEMPERATURE'] = 'température';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humidité (%)';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'en';
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[Capteur BMP280 %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), la pression (en Pascal) ou l\'altitude (en m). L\'altitude est calculée avec la pression et est initialisée à 0 au début du programme. Le bloc a besoin du capteur Grove BMP280 (adresse I2C: 0x77, couleur: bleu) ou le capteur HW-611 280 (adresse I2C: 0x76, couleur: violet). Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_BMP280_TEMP'] = 'température';
Blockly.Msg['SENSORS_BMP280_PRESS'] = 'pression (Pa)';
Blockly.Msg['SENSORS_BMP280_ALT'] = 'l\'altitude (m)';
Blockly.Msg['SENSORS_BME280_READDATA_TITLE'] = '[Capteur BME280] %1';
Blockly.Msg['SENSORS_BME280_READDATA_TOOLTIP'] = IMG_MODULE_ENVIRO_BIT + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C) de -40 à 85 °C, Fahrenheit (°F) ou Kelvin (K), l\'humidité (en %), la pression (en Pascal) ou l\'altitude (en m) grâce au capteur BME280 du shield Enviro:bit.';
Blockly.Msg['SENSORS_BME280_TEMP'] = 'température';
Blockly.Msg['SENSORS_BME280_HUM'] = 'humidité (%)';
Blockly.Msg['SENSORS_BME280_PRESS'] = 'pression (Pa)';
Blockly.Msg['SENSORS_BME280_ALT'] = 'l\'altitude (m)';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = '[Capteur H.T°] température en %1 sur les broches A0 %2 A1 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température du thermocouple en degré Celsius (50 à 600 °C), Fahrenheit (°F) ou Kelvin (K) grâce au capteur grove de haute température sur .';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Capteur d\'humidité] humidité du sol sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Renvoie l\'humidité (de 0 à 1023) mesurée grâce au capteur d\'humidité grove sur les broches analogiques IO34, IO35, IO36 et IO39.';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Capteur de T°] température en %1 sur la broche %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) du capteur de température Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TITLE'] = '[Capteur DS18B20] température en %1 sur la broche %2';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) du capteur de température étanche DS18B20 sur les broches digitales.';
Blockly.Msg['SENSORS_DHT11_READDATA_TITLE'] = '[Capteur DHT11] %1 sur la broche %2';
Blockly.Msg['SENSORS_DHT11_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur dht11 grove sur les broches digitales.';
Blockly.Msg['SENSORS_DHT22_READDATA_TITLE'] = '[Capteur DHT22] %1 sur la broche %2';
Blockly.Msg['SENSORS_DHT22_READDATA_TOOLTIP'] = IMG_MODULE_DHT22 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) avec une grande précision grâce au capteur dht22 grove sur les broches digitales.';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[Capteur TH02] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur TH02. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Capteur SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur SHT31. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Capteur d\'eau] quantité d\'eau sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Renvoie la quantité d\'eau (de 0 à 255) mesurée grâce au capteur d\'eau grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Capteur de pluie] état sur la broche %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Renvoie l\'état du capteur de pluie (1 s\'il pleut ou 0 sinon) sur les broches digitales.';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anémomètre] état sur la broche %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Renvoie l\'état de l\'anémomètre (deux fois état HAUT à chaque rotation) sur les broches digitales.';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Capteur de lumière] luminosité sur la broche %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Renvoie la luminosité (de 0 à 1023) du capteur de lumière Grove sur les broches analogiques IO34, IO35, IO36 et IO39.';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[Capteur SI1145] luminosité %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Renvoie l\'indice de lumière ultraviolette, la luminosité visible (en lumen) ou infrarouge (en lumen) grâce au capteur Grove Sunlight ou le capteur GY1145. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SI1145_UV'] = 'indice UV';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visible (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrarouge (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Capteur ultraviolet] indice UV sur la broche %1';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Renvoie l\'indice de la lumière ultraviolette pour des ondes entre 240 et 380 nm du capteur Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Capteur de couleurs] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Permet de lire le niveau d\'une des trois couleurs primaires avec le capteur de couleur grove, le niveau est compris entre 0 et 255. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Capteur de son] niveau sonore sur la broche %1';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Renvoie le niveau sonore (0 à 1023) avec le capteur de son Grove sur les broches digitales.';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Capteur à ultrasons %1] %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Renvoie la distance (in cm) mesurée grâce au capteur grove à ultrasons sur les broches digitales. Attention, si le capteur est un modèle grove, TRIG et ECHO sont sur la même broche SIG.';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distance (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'durée de l\'aller-retour (µs)';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = '[Capteur de gestes] type de geste';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Renvoie le type de geste analysé (\'right\', \'left\', \'up\', \'down\', \'forward\', \'backward\', \'clockwise\', \'anticlockwise\') grâce au capteur de gestes grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Capteur de gestes] si le geste %1 est détecté';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Exécute des instructions si le geste selectionné est détecté par le capteur de gestes grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'droit';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'gauche';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'haut';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'bas';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'avant';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'arrière';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'horaire';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'antihoraire';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'onde';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Capteur de ligne noire] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur de ligne noire grove (0 ou 1) les broches digitales.';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[Capteur de mouvement] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur de mouvement Grove PIR Motion (0 ou 1) les broches digitales.';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Capteur de vibrations] état sur la broche %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Renvoie l\'état de la vibration (0 ou 1) grâce au capteur de vibration piezoélectrique les broches digitales.';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Module inclinaison] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'inclinaison du module Grove (0 ou 1) les broches digitales.';
// Other sensors
Blockly.Msg['SENSORS_GETGROVEBUTTON_TITLE'] = '[Module bouton] %1 sur la broche %2';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Renvoie la valeur numérique du bouton Grove (0/1 ou 0V/3.3V) les broches digitales.';
Blockly.Msg['SENSORS_GETGROVEBUTTON_VOLTAGE'] = 'tension';
Blockly.Msg['SENSORS_GETGROVEBUTTON_STATE'] = 'état';
// Actuators
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servomoteur] contrôler l\'angle à %1 sur la broche %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler l\'angle d\'un servomoteur (de 0 à 180) sur les broches digitales. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au servomoteur.';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Servomoteur continu] contrôler la vitesse à %1 (%) direction %2 sur la broche %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler la vitesse (de 0 à 100 %) d\'un servomoteur continu sur les broches PWM.';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Moteur] contrôler la puissance à %1 sur la broche %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permet de contrôler la puissance d\'un moteur (de 0 à 1023) sur les broches digitales. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au moteur.';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Module relais] contrôler le relais à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Permet de contrôler la valeur du relais (0 ou 1) sur les broches digitales.';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Moteur à vibration] contrôler le moteur à l\'état %1 sur la broche  %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver le moteur à vibration grove (0 ou 1) sur les broches digitales.';
// Actuators - Music
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TITLE'] = '[Buzzer/Speaker] jouer la musique %1 sur %2';
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une musique avec un module Grove buzzer (ou speaker) sur les broches digitales.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TITLE'] = '[Buzzer/Speaker] jouer les notes sur';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer des notes avec un module Grove buzzer (ou speaker) sur les broches digitales.';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TITLE'] = 'note %1 à l\'octave %2 durée %3';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de définir une note à une certaine octave pendant une durée déterminée.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TITLE'] = '[Buzzer/Speaker] jouer la fréquence %1 pendant %2 (ms) sur %3';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une fréquence avec un module Grove buzzer (ou speaker) sur les broches digitales.';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TITLE'] = '[Buzzer/Speaker] arrêter la musique sur %1';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet d\'arrêter la musique en cours du module Grove buzzer (ou speaker) sur les broches digitales.';
// Notes
Blockly.Msg['NOTE_C'] = 'Do';
Blockly.Msg['NOTE_C_SHARP'] = 'Do#';
Blockly.Msg['NOTE_D'] = 'Ré';
Blockly.Msg['NOTE_D_SHARP'] = 'Ré#';
Blockly.Msg['NOTE_E'] = 'Mi';
Blockly.Msg['NOTE_F'] = 'Fa';
Blockly.Msg['NOTE_F_SHARP'] = 'Fa#';
Blockly.Msg['NOTE_G'] = 'Sol';
Blockly.Msg['NOTE_G_SHARP'] = 'Sol#';
Blockly.Msg['NOTE_A'] = 'La';
Blockly.Msg['NOTE_A_SHARP'] = 'La#';
Blockly.Msg['NOTE_B'] = 'Si';
Blockly.Msg['MUSIC_SILENCE'] = 'Silence';