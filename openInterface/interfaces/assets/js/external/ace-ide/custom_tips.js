const PYB_TIPS = {
    "pyb": "pyboard library.",
    "pyb.delay(ms) ": "Delay for the given number of milliseconds.    Parameters:  ms (int) -- the number of milliseconds to delay.  ",
    "pyb.udelay(us) ": "Delay for the given number of microseconds.    Parameters:  us (int) -- the number of microseconds to delay.  ",
    "pyb.millis() ": "Returns the number of milliseconds since the board was last reset.    Returns: milliseconds since reset.    Return type: int  ",
    "pyb.micros() ": "Returns the number of microseconds since the board was last reset.    Returns: microseconds since reset.    Return type: int  ",
    "pyb.elapsed_millis(start) ": "Returns the number of milliseconds which have elapsed since start.    Parameters:  start (int) -- the number of milliseconds to start counting from.    Returns: milliseconds since start.    Return type: int  ",
    "pyb.elapsed_micros(start) ": "Returns the number of microseconds which have elapsed since start.    Parameters:  start (int) -- the number of microseconds to start counting from.    Returns: microseconds since start.    Return type: int  ",
    "pyb.hard_reset() ": "Resets the board in a manner similar to pushing the external RESET button.  ",
    "pyb.bootloader() ": "Activate the bootloader without BOOT* pins.  ",
    "pyb.fault_debug(valus) ": "Enable or disable hard-fault debugging.  A hard-fault is when there is a fatal error in the underlying system, like an  invalid memory access.    Parameters:  value (bool) --     False: board will automatically reset if there is a hard fault  True: when the board has a hard fault, it will print the registers and the stack  \\ttrace, and then cycle the LEDs indefinitely  ",
    "pyb.disable_irq() ": "Disable interrupt requests.    Returns: Previous IRQ state.    Return type: bool  ",
    "pyb.enable_irq(state=True) ": "Enable interrupt requests.    Parameters:  state (bool) -- Whether the IRQs are enabled  ",
    "pyb.freq([sysclk[, hclk[, pclk1[, pclk2]]]]) ": "If given no arguments, returns a tuple of clock frequencies:  (sysclk, hclk, pclk1, pclk2). Otherwise, sets the frequency of the CPU, and the  busses if additional arguments are given.    Parameters:  sysclk (int) [optional] -- frequency of the CPU in MHz.  hclk (int) [optional] -- frequency of the AHB bus, core memory and DMA.  pclk1 (int) [optional] -- frequency of the APB1 bus.  pclk2 (int) [optional] -- frequency of the APB2 bus.    Returns: clock frequencies.    Return type: tuple  ",
    "pyb.wfi() ": "Wait for an internal or external interrupt.  This function will block for at most 1ms.  ",
    "pyb.stop() ": "Put the board in a \u201csleeping\u201d state. To wake from this sleep state requires an  external interrupt or a real-time-clock event. Upon waking execution continues  where it left off.  ",
    "pyb.standby() ": "Put the board into a \u201cdeep sleep\u201d state. To wake from this sleep state requires  a real-time-clock event, or an external interrupt on X1 (PA0=WKUP) or  X18 (PC13=TAMP1). Upon waking the system undergoes a hard reset.  ",
    "pyb.info([dump_alloc_table]) ": "Print out lots of information about the board.    Parameter:  dump_alloc_table (bool) [optional] -- Whether to dump the alloc table.  ",
    "pyb.main(filename) ": "Set the filename of the main script to run after boot.py is finished.    It only makes sense to call this function from within boot.py.    Parameter:  filename (string) -- name of the desired main file.  ",
    "pyb.mount(device, mountpoint, *, readonly=False, mkfs=False) ": "Mount a block device and make it available as part of the filesystem.    See online documentation for full instructions.  ",
    "pyb.repl_uart(uart) ": "Get or set the UART object where the REPL is repeated on.    Parameter:  uart (pyb.UART) -- The uart to use  .",
    "pyb.rng() ": "Returns a 30-bit hardware generated random number.    Returns: 30-bit random number.    Return value: int  ",
    "pyb.sync() ": "Sync all file systems.  ",
    "pyb.unique_id() ": "Returns a string of 12 bytes (96 bits which is the unique ID of the MCU.    Returns: unique ID of the MCU.    Return value: string  ",
    "pyb.usb_mode([modestr, ]vid=0xf055, pid=0x9801, hid=pyb.hid_mouse) ": "If called with no arguments, return the current USB mode as a string. If called  with modestr provided, attempts to set USB mode.    This can only be done when called from boot.py before pyb.main() has been called.    See online documentation for full instructions.  ",
    "pyb.Accel() ": "Create an accelerometer object.  ",
    "pyb.Accel.filtered_xyz() ": "Get filtered x, y and z values.    Returns: accelerometer x, y, and z values.    Return type: 3-tuple  ",
    "pyb.Accel.tilt() ": "Get the tilt register.    Returns: contents of tilt register,    Return type: int  ",
    "pyb.Accel.x() ": "Get the x-axis register.    Returns: contents of x-axis register,    Return type: int  ",
    "pyb.Accel.y() ": "Get the y-axis register.    Returns: contents of y-axis register,    Return type: int  ",
    "pyb.Accel.z() ": "Get the z-axis register.    Returns: contents of z-axis register,    Return type: int  ",
    "pyb.ADC(pin) ": "An Analog to Digital conversion object associated with the given pin    Parameter:  pin (pyb.Pin) -- the pin to read values from  ",
    "pyb.ADC.read() ": "Read the value on the analog pin and return it.  The returned value will be between 0 and 4095.    Returns: analog value of pin.    Return type: int  ",
    "pyb.ADC.read_timed(buf, timer) ": "Read analog values into buf at a rate set by the timer object.    Parameters:  buf (bytearray or array.array) -- The ADC values have 12-bit resolution and are  stored directly into buf if its element size is 16 bits or greater. If buf has  only 8-bit elements (eg a bytearray) then the sample resolution will be reduced  to 8 bits.  timer (pyb.Timer) -- a Timer object, a sample is read each time the timer triggers.",
    "pyb.CAN(bus, ...) ": "Construct a CAN object on the given bus. With no additional parameters, the CAN  object is created but not initialised. If extra arguments are given, the bus is  initialised. See CAN.init() for parameters of initialisation.    Parameters:  bus can be 1-2, or 'YA' or 'YB'.",
    "pyb.CAN.init(mode, extframe=False, prescaler=100, *, sjw=1, bs1=6, bs2=8, auto_restart=False) ": "Initialise the CAN bus with the given parameters.    Parameters:  mode (int) -- one of: NORMAL, LOOPBACK, SILENT, SILENT_LOOPBACK. These are  included in the pyb.CAN class as class variables.  extframe (bool) -- if extframe is True then the bus uses extended identifiers in  the frames (29 bits); otherwise it uses standard 11 bit identifiers.  prescaler (int) -- used to set the duration of 1 time quanta; the time quanta  will be the input clock divided by the prescaler.  sjw (int) -- is the resynchronisation jump width in units of the time quanta; it  can be 1, 2, 3, 4  bs1 (int) -- defines the location of the sample point in units of the time  quanta; it can be between 1 and 1024 inclusive.  bs2 (int) -- defines the location of the transmit point in units of the time  quanta; it can be between 1 and 16 inclusive.  auto_restart (bool) -- sets whether the controller will automatically try and  restart communications after entering the bus-off state.  ",
    "pyb.CAN.deinit() ": "Turn off the CAN bus.  ",
    "pyb.CAN.restart() ": "Force a software restart of the CAN controller without resetting its configuration.  ",
    "pyb.CAN.state() ": "Returns the state of the controller.    Returns: the state of the controller.  Can be one of the following: CAN.STOPPED, CAN.ERROR_ACTIVE, CAN.ERROR_WARNING,  CAN.ERROR_PASSIVE, CAN.BUS_OFF.    Return type: int  ",
    "pyb.CAN.info([list]) ": "Get information about the controller\u2019s error states and TX and RX buffers.    Parameters:  list (list) [optional] -- If list is provided then it should be a list object  with at least 8 entries, which will be filled in with the information.    Returns: If list parameter is not provided, a new list will be created and filled in.    Return type: list  ",
    "pyb.CAN.setfilter(bank, mode, fifo, params, *, rtr) ": "Configure a filter bank    Parameters:  bank (int) -- the filter bank that is to be configured  mode (int) -- the mode the filter should operate in. One of the following:  CAN.LIST16, CAN.LIST32, CAN.MASK16, CAN.MASK32  fifo (int) -- which fifo (0 or 1) a message should be stored in, if it is  accepted by this filter  params (array (int)) -- values that defines the filter. The contents of the array  depends on the mode argument  rtr (array (bool)) [optional]  -- array that states if a filter should accept a  remote transmission request message. If this argument is not given then it defaults to False for all entries.",
    "pyb.CAN.clearfilter(bank) ": "Clear and disables a filter bank    Parameters:  bank (int) -- the filter bank that is to be cleared.  ",
    "pyb.CAN.any(fifo) ": "Whether any message waiting on the FIFO    Parameters:  fifo (int) -- the FIFO to check.    Returns: Whether a message is waiting    Return type: bool  ",
    "pyb.DAC(port, bits=8, *, buffering=None) ": "Construct a new DAC object on the given port.    Parameters:  port (pyb.Pin or int) -- can be a pin object, or an integer (1 or 2). DAC(1) is  on pin X5 and DAC(2) is on pin X6.  bits (int) -- The resolution, and can be 8 or 12. The maximum value for the write  and write_timed methods will be 2**bits-1  buffering (bool or None) -- The buffering parameter selects the behaviour of the  DAC op-amp output buffer, whose purpose is to reduce the output impedance. It can  be None to select the default, False to disable buffering completely, or True to  enable output buffering.  ",
    "pyb.DAC.init(bits=8, *, buffering=None) ": "Reinitialise the DAC.    Parameters:  bits (int) -- The resolution, and can be 8 or 12. The maximum value for the write and write_timed methods will be 2**bits-1  buffering (bool or None) -- The buffering parameter selects the behaviour of the DAC op-amp output buffer, whose purpose is to reduce the output impedance. It can be None to select the default, False to disable buffering completely, or True to enable output buffering.  ",
    "pyb.DAC.deinit() ": "De-initialise the DAC making its pin available for other uses.  ",
    "pyb.DAC.noise(freq) ": "Generate a pseudo-random noise signal. A new random sample is written to the DAC  output at the given frequency.    Parameters:  freq (int) -- the frequency to generate noise at.  ",
    "pyb.DAC.triangle(freq) ": "Generate a triangle wave. The value on the DAC output changes at the given  frequency, and the frequency of the repeating triangle wave itself is 2048 times smaller.    Parameters: freq (int) -- the frequency to generate the wave at.  ",
    "pyb.DAC.write(value) ": "Direct access to the DAC output. The minimum value is 0. The maximum value is 2**bits-1.    Parameters: value (int) -- the value to write to the DAC  ",
    "pyb.DAC.write_timed(data, freq, *, mode=DAC.NORMAL) ": "Initiates a burst of RAM to DAC using a DMA transfer. The input data is treated  as an array of bytes in 8-bit mode, and an array of unsigned half-words  (array typecode \u2018H\u2019) in 12-bit mode.    Parameters:  data (array) -- data to be written to the DAC.  freq (int or Timer) -- frequency or Timer to determin how often to trigger DAC sample  mode (constant) -- can be DAC.NORMAL or DAC.CIRCULAR.",
    "pyb.ExtInt(pin, mode, pull, callback) ": "Create an ExtInt object.    Parameters:  pin (pyb.Pin) -- the pin on which to enable the interrupt.  mode (constant) can be one of: ExtInt.IRQ_RISING - trigger on a rising edge;  ExtInt.IRQ_FALLING - trigger on a falling edge; ExtInt.IRQ_RISING_FALLING - trigger  on a rising or falling edge.  pull (constant) -- can be one of: - pyb.Pin.PULL_NONE - no pull up or down  resistors; pyb.Pin.PULL_UP - enable the pull-up resistor;  pyb.Pin.PULL_DOWN - enable the pull-down resistor.  callback (function) -- the function to call when the interrupt triggers. The  callback function must accept exactly 1 argument, which is the line that triggered the interrupt.  ",
    "pyb.ExtInt.regs() ": "Prints the values of the EXTI registers.  ",
    "pyb.ExtInt.disable() ": "Disable the interrupt associated with the ExtInt object.  ",
    "pyb.ExtInt.enable() ": "Enable a disabled interrupt.  ",
    "pyb.ExtInt.line() ": "Returns the line number that the pin is mapped to.    Returns: line number that the pin is mapped to    Return type: int  ",
    "pyb.ExtInt.swint() ": "Trigger the callback from software.  ",
    "pyb.I2C(bus, ...) ": "Construct an I2C object on the given bus. bus can be 1 or 2, \u2018X\u2019 or \u2018Y\u2019. With no  additional parameters, the I2C object is created but not initialised. If extra  arguments are given, the bus is initialised. See init for parameters of initialisation.    Parameters:  bus (int or string) -- the bus to attach to. Can be 1 or 2, \u2018X\u2019 or \u2018Y\u2019.  ",
    "pyb.I2C.deinit() ": "Turn off the I2C bus.  ",
    "pyb.I2C.init(mode, *, addr=0x12, baudrate=400000, gencall=False, dma=False) ": "Initialise the I2C bus with the given parameters    Parameters:  mode (constant) -- must be either I2C.MASTER or I2C.SLAVE  addr (int) -- the 7-bit address (only sensible for a slave)  baudrate (int) -- the SCL clock rate (only sensible for a master)  gencall (bool) -- whether to support general call mode  dma (bool) -- whether to allow the use of DMA for the I2C transfers  ",
    "pyb.I2C.is_ready(addr) ": "Check if an I2C device responds to the given address. Only valid when in master mode.    Parameters:  addr (int) -- the address to check    Returns: Whether the address responds    Return type: bool  ",
    "pyb.I2C.mem_read(data, addr, memaddr, *, timeout=5000, addr_size=8) ": "Read from the memory of an I2C device    Parameters:  data (int or buffer) -- number of bytes to read or a buffer to read into  addr (int) -- the I2C device address  memaddr (int) -- the memory location within the I2C device  timeout (int) the timeout in milliseconds to wait for the read  addr_size (int) -- width of memaddr: 8 or 16 bits    Returns: the read data. This is only valid in master mode.    Return type: bytes  ",
    "pyb.I2C.mem_write(data, addr, memaddr, *, timeout=5000, addr_size=8) ": "Write to the memory of an I2C device  Parameters:  data (int or buffer) -- number of bytes to write or a buffer to write into  addr (int) -- the I2C device address  memaddr (int) -- the memory location within the I2C device  timeout (int) the timeout in milliseconds to wait for the write  addr_size (int) -- width of memaddr: 8 or 16 bits  ",
    "pyb.I2C.recv(recv, addr=0x00, *, timeout=5000) ": "Receive data on the bus.    Parameters:  recv (int or buffer) -- can be the number of bytes to receive, or a mutable  buffer, which will be filled with received bytes  addr (int) -- the address to receive from (only required in master mode)  timeout (int) -- the timeout in milliseconds to wait for the receive    Returns: if recv is an integer then a new buffer of the bytes received    Return type: bytes  ",
    "pyb.I2C.send(send, addr=0x00, *, timeout=5000) ": "Send data on the bus.    Parameters:  send (int or buffer) -- the data to send  addr (int) the address to send to (only required in master mode)  timeout (int) -- the timeout in milliseconds to wait for the send  ",
    "pyb.I2C.scan() ": "Scan all I2C addresses from 0x01 to 0x7f and return a list of those that respond.  Only valid when in master mode.    Returns: valid I2C addresses on the bus    Return type: list  ",
    "pyb.LCD(skin_position) ": "Construct an LCD object in the given skin position.    Parameters:  skin_position (string) -- can be \u2018X\u2019 or \u2018Y\u2019, and should match the position where  the LCD pyskin is plugged in.  ",
    "pyb.LCD.command(instr_data, buf) ": "Send an arbitrary command to the LCD controller.    Parameters:  instr_data (int) -- 0 for instr_data to send an instruction, otherwise pass 1  to send data  buf (int or buffer) -- a buffer with the instructions/data to send  ",
    "pyb.LCD.contrast(value) ": "Set the contrast of the LCD    Parameters:  value (int) -- the contrast value, valid values are between 0 and 47.  ",
    "pyb.LCD.fill(color) ": "Fill the screen with the given colour.    Parameters:  color (int) -- 0 or 1 for white or black respectively.  ",
    "pyb.LCD.get(x, y) ": "Get the pixel at the position (x, y)    Parameters:  x (int) -- the X coordinate  y (int) -- the Y coordinate    Returns: the pixel value, either 0 or 1.    Return type: int  ",
    "pyb.LCD.light(value) ": "Turn the backlight on/off.    Parameters:  value (int or bool) -- True or 1 turns it on, False or 0 turns it off.  ",
    "pyb.LCD.pixel(x, y, colour) ": "Set the pixel at (x, y) to the given colour (0 or 1).    Parameters:  x (int) -- the X coordinate  y (int) -- the Y coordinate  color (int) -- the color.  ",
    "pyb.LCD.show() ": "Show the hidden buffer on the screen.  ",
    "pyb.LCD.text(str, x, y, colour) ": "Draw the given text to the position (x, y) using the given colour (0 or 1).    Parameters:  str (string) -- the text to display.  x (int) -- the X coordinate  y (int) -- the Y coordinate  color (int) -- the color.  ",
    "pyb.LCD.write(str) ": "Write the string str to the screen. It will appear immediately.    Parameters:  str (string) -- the text to display.  ",
    "pyb.LED(id) ": "Create an LED object associated with the given LED    Parameters:  id (int) -- the LED number, 1-4  ",
    "pyb.LED.intensity([value]) ": "Get or set the LED intensity. If no argument is given, return the LED intensity.    Parameters:  value (int) [optional] -- intensity value ranges between 0 (off) and 255 (full on)    Returns: None or LED intensity    Return type: None or int  ",
    "pyb.LED.off() ": "Turn the LED off.  ",
    "pyb.LED.on() ": "Turn the LED on.  ",
    "pyb.LED.toggle() ": "Toggle the LED between on (maximum intensity) and off. If the LED is at non-zero  intensity then it is considered \u201con\u201d and toggle will turn it off.  ",
    "pyb.Pin(id, ...) ": "Create a new Pin object associated with the id. If additional arguments are given,  they are used to initialise the pin. See pyb.Pin.init()    Parameters:  id (constant or string) -- the identifier of the pin to use  ",
    "pyb.Pin.debug([state]) ": "Get or set the debugging state    Parameters:  state (bool) [optional] -- the debugging state to set, if any.    Returns: whether the debugging state is set (if nothing is passed to the method)    Return type: bool  ",
    "pyb.Pin.init(mode, pull=Pin.PULL_NONE, af=-1) ": "Initialise the pin    Parameters:  mode (constant) -- can be one of: Pin.IN, Pin.OUT_PP, Pin.OUT_OD, Pin.AF_PP, Pin.AF_OD, Pin.ANALOG  pull (constant) -- can be one of: Pin.PULL_NONE, Pin.PULL_UP, Pin.PULL_DOWN  af (int) -- when mode is Pin.AF_PP or Pin.AF_OD, then af can be the index or name  of one of the alternate functions associated with a pin  ",
    "pyb.Pin.value([value]) ": "Get or set the digital logic level of the pin    Parameters:  value (int or bool) [optional] -- if value converts to True, the pin is set high,  otherwise it is set low    Returns: with no argument, return 0 or 1 depending on the logic level of the pin    Return type: int  ",
    "pyb.Pin.af() ": "Returns the currently configured alternate-function of the pin    Returns: one of the integer representations of the allowed constants for af    Return type: int  ",
    "pyb.Pin.af_list() ": "Returns an array of alternate functions available for this pin.    Returns:array of alternate functions available    Return type: list  ",
    "pyb.Pin.gpio() ": "Returns the base address of the GPIO block associated with this pin.    Returns: the base address of the GPIO block    Return type: int",
    "pyb.Pin.mode() ": "Returns the currently configured mode of the pin.    Returns: integer returned will match one of the allowed constants for the mode    Return type: int",
    "pyb.Pin.name() ": "Returns the pin name.    Returns: the name of the pin    Return type: string",
    "pyb.Pin.names() ": "Returns the board and cpu names for the pin.    Returns: the names of the pin    Return type: list",
    "pyb.Pin.pin() ": "Returns the CPU pin number.    Returns: the number of the pin    Return type: int",
    "pyb.Pin.port() ": "Returns the CPU port number.    Returns: the number of the port    Return type: int",
    "pyb.Pin.pull() ": "Returns the currently configured pull of the pin.    Returns: The integer returned will match one of the allowed constants for the pull    Return type: int",
    "pyb.RTC() ": "Create an RTC object.  ",
    "pyb.RTC.datetime([datetimetuple]) ": "Get or set the date and time of the RTC. With no arguments, this method returns  an 8-tuple with the current date and time. With 1 argument (being an 8-tuple) it  sets the date and time    Parameters:  datetimetuple (tuple) [optional] -- The 8-tuple has the following format:  (year, month, day, weekday, hours, minutes, seconds, subseconds). All tuple  elements are integers    Returns: the current date and time    Return type: tuple (8 elements)  ",
    "pyb.RTC.wakeup(timeout, callback=None) ": "Set the RTC wakeup timer to trigger repeatedly at every timeout milliseconds.  This trigger can wake the pyboard from both the sleep states: pyb.stop() and pyb.standby()    Parameters:  timeout (int or None) -- timeout in milliseconds or None to disable timer  callback (function or None) -- if callback is given then it is executed at every  trigger of the wakeup timer. callback must take exactly one argument  ",
    "pyb.RTC.info() ": "Get information about the startup time and reset source    Returns: RTC info: lower 0xffff are the number of milliseconds the RTC took to  start up, bit 0x10000 is set if a power-on reset occurred, bit 0x20000 is set if  an external reset occurred    Return type: int  ",
    "pyb.RTC.calibration([cal]) ": "Get or set RTC calibration.    Parameters: cal (int) [optional] -- The usable calibration range is: (-511 * 0.954) ~= -487.5 ppm up to (512 * 0.954) ~= 488.5 ppm    Returns: with no arguments, the current calibration value, in the range [-511 : 512]    Return type: int  ",
    "pyb.Servo(id) ": "Create a servo object.    Paramaters:  id (int) -- can be 1-4, and corresponds to pins X1 through X4.  ",
    "pyb.Servo.angle([angle, time=0]) ": "If arguments are given, sets the angle of the servo  If no arguments are given, gets the angle of the servo.    Parameters:  angle (float or int) [optional] -- the angle to move to in degrees.  time (int) -- the number of milliseconds to take to get to the specified angle.  If omitted, then the servo moves as quickly as possible to its new position.    Returns: the current angle of the servo (if no arguments are given)    Return type: float  ",
    "pyb.Servo.speed([speed, time=0]) ": "If no arguments are given, returns the current speed.  If arguments are given, sets the speed of the servo.    Parameters:  speed (int) -- the speed to change to, between -100 and 100.  time (int) -- the number of milliseconds to take to get to the specified speed.  If omitted, then the servo accelerates as quickly as possible.    Returns: the current speed of the servo (if no arguments given)    Return type: int  ",
    "pyb.Servo.pulse_width([value]) ": "If no arguments are given, returns the current raw pulse-width value.  If an argument is given, sets the raw pulse-width value.    Parameters: value (int) [optional] -- the desired pulse width value.    Returns: the current raw pulse-width value (if no arguments are given)    Return type: int  ",
    "pyb.SPI(bus, ...) ": "Construct an SPI object on the given bus. With no additional parameters, the SPI  object is created but not initialised. If extra arguments are given, the bus is  initialised. See init for parameters of initialisation.    Parameters:  bus (int or string) -- can be 1 or 2, or \u2018X\u2019 or \u2018Y\u2019  SPI(1) is on the X position: (NSS, SCK, MISO, MOSI) = (X5, X6, X7, X8) = (PA4, PA5, PA6, PA7)  SPI(2) is on the Y position: (NSS, SCK, MISO, MOSI) = (Y5, Y6, Y7, Y8) = (PB12, PB13, PB14, PB15)  ",
    "pyb.SPI.deinit() ": "Turn off the SPI bus.  ",
    "pyb.SPI.init(mode, baudrate=328125, *, prescaler, polarity=1, phase=0, bits=8, firstbit=SPI.MSB, ti=False, crc=None) ": "Initialise the SPI bus with the given parameters    Parameters:  mode (constant) -- must be either SPI.MASTER or SPI.SLAVE.  baudrate (int) -- the SCK clock rate (only sensible for a master).  prescaler (int) -- the prescaler to use to derive SCK from the APB bus frequency, overrides baudrate.  polarity (int) -- can be 0 or 1, the level the idle clock line sits at.  phase (int) -- 0 or 1 to sample data on the first or second clock edge respectively.  bits (int) -- 8 or 16, and is the number of bits in each transferred word.  firstbit (constant) -- can be SPI.MSB or SPI.LSB  crc (None) -- can be None for no CRC, or a polynomial specifier.  ",
    "pyb.SPI.recv(recv, *, timeout=5000) ": "Receive data on the bus    Parameters:  recv (int or buffer) -- can be the number of bytes to receive, or a mutable  buffer, which will be filled with received bytes.  timeout (int) -- the timeout in milliseconds to wait for the receive.    Returns: if recv is an integer then a new buffer of the bytes received, otherwise  the same buffer that was passed in to recv,    Return type: buffer  ",
    "pyb.SPI.send(send, *, timeout=5000) ": "Send data on the bus    Parameters:  send (bytes) -- the data to send (an integer to send, or a buffer object)  timeout (int) -- the timeout in milliseconds to wait for the send  ",
    "pyb.SPI.send_recv(send, recv=None, *, timeout=5000) ": "Send and receive data on the bus at the same time    Parameters:  send (bytes) -- the data to send (an integer to send, or a buffer object)  recv (buffer) -- a mutable buffer which will be filled with received bytes. It  can be the same as send, or omitted. If omitted, a new buffer will be created  timeout (int) -- the timeout in milliseconds to wait for the receive.    Returns: buffer with the received bytes.    Return type: bytes  ",
    "pyb.Switch() ": "Create and return a switch object.    Returns: Switch object    Return type: Switch class  ",
    "pyb.Switch.value() ": "Get the current switch state.    Returns: True if pressed down, False otherwise.    Return type: bool  ",
    "pyb.Switch.callback(fun) ": "Register the given function to be called when the switch is pressed down    Parameters:  fun (function) -- the function to execute or None. If fun is None, then it disables the callback.  ",
    "pyb.Timer(id, ...) ": "Construct a new timer object of the given id. If additional arguments are given,  then the timer is initialised by init(...).    Parameters:  id (int) -- can be 1 to 14.  ",
    "pyb.Timer.init(*, freq, prescaler, period) ": "Initialise the timer. Initialisation must be either by frequency (in Hz) or by  prescaler and period    Parameters:  freq (int) -- specifies the periodic frequency of the timer.  prescaler (int) -- [0-0xffff] specifies the value to be loaded into the timer\u2019s Prescaler  Register (PSC). The timer clock source is divided by prescaler + 1  period (int) -- [0-0xffff] for timers 1, 3, 4, and 6-15. [0-0x3fffffff] for  timers 2 & 5. Specifies the value to be loaded into the timer\u2019s AutoReload Register (ARR)  ",
    "pyb.Timer.deinit() ": "Deinitialises the timer, callback, and channel callbacks associated with the Timer  ",
    "pyb.Timer.counter([value]) ": "Get or set the timer counter.  ",
    "pyb.Timer.freq([value]) ": "Get or set the frequency for the timer (changes prescaler and period if set).  ",
    "pyb.Timer.period([value]) ": "Get or set the period of the timer.  ",
    "pyb.Timer.prescaler([value]) ": "Get or set the prescaler for the timer.  ",
    "pyb,Timer.source_freq() ": "Get the frequency of the source of the timer.  ",
    "pyb.UART(bus, ...) ": "Construct a UART object on the given bus.  With no additional parameters, the UART object is created but not initialised.  If extra arguments are given, the bus is initialised. See init for parameters  of initialisation.    Parameters:  bus (int or string) -- can be 1-6, or \u2018XA\u2019, \u2018XB\u2019, \u2018YA\u2019, or \u2018YB\u2019.  ",
    "pyb.UART.init(baudrate, bits=8, parity=None, stop=1, *, timeout=1000, flow=0, timeout_char=0, read_buf_len=64)": "Initialise the UART bus with the given parameters    Parameters:  baudrate (int) -- the clock rate  bits (int) -- the number of bits per character, 7, 8 or 9  parity (int) -- the parity, None, 0 (even) or 1 (odd)  stop (int) -- the number of stop bits, 1 or 2  flow (int) -- the flow control type. Can be 0, UART.RTS, UART.CTS or UART.RTS | UART.CTS  timeout (int) -- the timeout in milliseconds to wait for writing/reading the first character  timeout_char (int) -- the timeout in milliseconds to wait between characters  while writing or reading.  read_buf_len (int) -- the character length of the read buffer (0 to disable)  ",
    "pyb.UART.deinit() ": "Turn off the UART bus.  ",
    "pyb.UART.any() ": "Returns the number of bytes waiting (may be 0).  ",
    "pyb.UART.read([nbytes]) ": "Read characters. If nbytes is specified then read at most that many bytes.  If nbytes is not given then the method reads as much data as possible. It returns  after the timeout has elapsed.    Parameters:  nbytes (int) [optional] -- number of bytes to attempt to return    Returns: a bytes object containing the bytes read in, None on timeout.    Return type: bytes or None",
    "pyb.UART.readchar() ": "Receive a single character on the bus.    Returns: the character read, as an integer, returns -1 on timeout.    Return type: int  ",
    "pyb.UART.readinto(buf[, nbytes]) ": "Read bytes into the buf    Parameters:  buf (buffer) -- buffer to store bytes in  nbytes (int) [optional] -- if specified then read at most that many bytes,  otherwise, read at most len(buf) bytes    Returns: number of bytes read and stored into buf or None on timeout    Return type: int  ",
    "pyb.UART.readline() ": "Read a line, ending in a newline character. If such a line exists, return is  immediate. If the timeout elapses, all available data is returned regardless of  whether a newline exists.    Returns: the line read or None on timeout if no data is available    Return type: bytes  ",
    "pyb.UART.write(buf) ": "Write the buffer of bytes to the bus.  Parameters:  buf (buffer) -- if characters are 7 or 8 bits wide then each byte is one character. If characters  are 9 bits wide then two bytes are used for each character (little endian and  buf must contain an even number of bytes    Returns: number of bytes written. If a timeout occurs and no bytes were written returns None    Return type: int  ",
    "pyb.UART.writechar(char) ": "Write a single character on the bus    Parameters:  char (int) -- the integer to write  ",
    "pyb.UART.sendbreak() ": "Send a break condition on the bus.  This drives the bus low for a duration of 13 bits.  ",
    "pyb.USB_HID() ": "Create a new USB_HID object.  ",
    "pyb.USB_HID.recv(data, *, timeout=5000) ": "Receive data on the bus    Parameters:  data can be an integer, which is the number of bytes to receive, or a mutable  buffer (int or buffer) -- which will be filled with received bytes.  timeout (int) -- the timeout in milliseconds to wait for the receive    Returns: if data is an integer then a new buffer of the bytes received, otherwise  the number of bytes read into data is returned    Return type: int or buffer  ",
    "pyb.USB_HID.send(data) ": "Send data over the USB HID interface    Parameters:  data (multiple) -- the data to send (a tuple/list of integers, or a bytearray)  ",
    "pyb.USB_VCP() ": "Create a new USB_VCP object  ",
    "pyb.USB_VCP.setinterrupt(chr) ": "Set the character which interrupts running Python code, set to 3 (CTRL-C) by default.  ",
    "pyb.USB_VCP.isconnected() ": "Whether USB is connected as a serial device    Returns: True if USB is connected as a serial device, else False    Return type: bool  ",
    "pyb.USB_VCP.any() ": "Whether any characters are waiting    Returns: True if any characters waiting, else False    Return type: bool  ",
    "pyb.USB_VCP.close() ": "This method does nothing. It exists so the USB_VCP object can act as a file.  ",
    "pyb.USB_VCP.read([nbytes]) ": "Read at most nbytes from the serial device and return them as a bytes object  ",
    "pyb.USB_VCP.readinto(buf[, maxlen]) ": "Read bytes from the serial device and store them into buf    Parameters:  buf (buffer) -- a buffer-like object to read into  maxlen (int) -- if maxlen is given and then at most min(maxlen, len(buf)) bytes are read    Returns: the number of bytes read and stored into buf or None if no pending data available    Return type: int  ",
    "pyb.USB_VCP.readline() ": "Read a whole line from the serial device.    Returns: a bytes object containing the data    Return type: bytes  ",
    "pyb.USB_VCP.readlines() ": "Read as much data as possible from the serial device, breaking it into lines    Returns: a list of bytes objects, each object being one of the lines    Return type: list  ",
    "pyb.USB_VCP.write(buf) ": "Write the bytes from buf to the serial device.  ",
    "pyb.USB_VCP.recv(data, *, timeout=5000) ": "Receive data on the bus    Parameters:  data (int or buffer) -- the number of bytes to receive, or a mutable buffer,  which will be filled with received bytes  timeout (int) -- the timeout in milliseconds to wait for the receive    Returns: if data is an integer then a new buffer of the bytes received, otherwise  the number of bytes read into data is returned  Return type: int or buffer  ",
    "pyb.USB_VCP.send(data, *, timeout=5000) ": "Send data over the USB VCP:    Parameters:  data (int of buffer) -- the data to send  timeout (int) -- the timeout in milliseconds to wait for the send.    Returns: the number of bytes sent    Return type: int  "
};

const ESP_TIPS =
{
    "random": "random library.",
    "random.getrandbits(n) ": "Returns an integer with n random bits.",
    "random.seed(n) ": "Initialise the random number generator with a known integer 'n'.",
    "random.randint(a, b) ": "Returns a random whole number between a and b (inclusive).",
    "random.randrange(stop) ": "Returns a random whole number between 0 and up to (but not including) stop.",
    "random.choice(seq) ": "Returns a randomly selected element from a sequence of objects (such as a list).",
    "random.random() ": "Returns a random floating point number between 0.0 and 1.0.",
    "random.uniform(a, b) ": "Returns a random floating point number between a and b (inclusive).",
    "os": "os library.",
    "os.listdir() ": "Returns a list of the names of all the files contained within the local\\non-device file system.",
    "os.remove(filename) ": "Remove (delete) the file named filename.",
    "os.size(filename) ": "Returns the size, in bytes, of the file named filename.",
    "os.uname() ": "Returns information about MicroPython and the device.",
    "os.getcwd() ": "Returns current working directory",
    "os.chdir(path) ": "Change current working directory",
    "os.mkdir(path) ": "Make new directory",
    "os.rmdir(path) ": "Remove directory",
    "os.listdir(path='.') ": "Returns list of directory. Defaults to current working directory.",
    "sys": "sys library.",
    "sys.version ": "Returns Python version as a string",
    "sys.version_info ": "Returns Python version as a tuple",
    "sys.implementation ": "Returns MicroPython version",
    "sys.platform ": "Returns hardware platform as string, e.g. 'esp8266' or 'esp32'",
    "sys.byteorder ": "Returns platform endianness. 'little' for least-significant byte first or 'big' for most-significant byte first.",
    "sys.print_exception(ex) ": "Print to the REPL information about the exception 'ex'.",
    "machine": "machine library.",
    "machine.reset() ": "Resets the device in a manner similar to pushing the external RESET button",
    "machine.freq() ": "Returns CPU frequency in hertz.",
    "machine.Pin(id [, mode, pull])": "Create a Pin-object. Only id is mandatory. mode (optional): specifies the pin mode (Pin.OUT or Pin.IN) pull (optional): specifies if the pin has a pull resistor attached pull can be one of: None, Pin.PULL_UP or Pin.PULL_DOWN.",
    "machine.Pin.value([x])": "This method allows to set and get the value of the pin, depending on whether the argument x is supplied or not. If the argument is omitted, the method returns the actual input value (0 or 1) on the pin. If the argument is supplied, the method sets the output to the given value.",
    "machine.Pin.OUT ": "",
    "machine.Pin.IN ": "",
    "machine.Pin.PULL_UP ": "",
    "machine.Pin.PULL_DOWN ": "",
    "machine.ADC(pin)": "Create an ADC object associated with the given pin.  This allows you to then read analog values on that pin. machine.ADC(machine.Pin(39))",
    "machine.ADC.read() ": "Read the analog pin value.\\n\\nadc = machine.ADC(machine.Pin(39))\\nvalue = adc.read()",
    "time": "time library.",
    "time.sleep(seconds) ": "Sleep the given number of seconds.",
    "time.sleep_ms(milliseconds) ": "Sleep the given number of milliseconds.",
    "time.sleep_us(milliseconds) ": "Sleep the given number of microseconds.",
    "time.ticks_ms() ": "Returns number of milliseconds from an increasing counter. Wraps around after some value.",
    "time.ticks_us() ": "Returns number of microseconds from an increasing counter. Wraps around after some value.",
    "time.ticks_diff() ": "Compute difference between values ticks values obtained from time.ticks_ms() and time.ticks_us().",
    "time.time()  ": "Returns the number of seconds, as an integer, since the Epoch, assuming that underlying RTC is set and maintained. If an RTC is not set, this function returns number of seconds since a port-specific reference point in time (usually since boot or reset).",
    "network": "network library.",
    "network.WLAN(interface_id) ": "Create a WLAN interface object. Supported interfaces are: network.STA_IF (station aka client, connects to upstream WiFi access points) and  network.AP_IF (access point mode, allows other WiFi clients to connect).",
    "network.WLAN.STA_IF ": "",
    "network.WLAN.AP_IF": "",
    "network.WLAN.active([ is_active ])": "Activates or deactivates the network interface when given boolean argument. When argument is omitted the function returns the current state.",
    "network.WLAN.connect(ssid, password)": "Connect to the specified wireless network using the specified password.",
    "network.WLAN.disconnect() ": "Disconnect from the currently connected wireless network.",
    "network.WLAN.scan() ": "Scan for the available wireless networks. Scanning is only possible on STA interface. Returns list of tuples with the information about WiFi access points: (ssid, bssid, channel, RSSI, authmode, hidden)",
    "network.WLAN.status()": "Returns the current status of the wireless connection. Possible values: - STAT_IDLE (no connection and no activity) - STAT_CONNECTING (connecting in progress) - STAT_WRONG_PASSWORD (failed due to incorrect password - STAT_NO_AP_FOUND (failed because no access point replied - STAT_CONNECT_FAIL (failed due to other problems - STAT_GOT_IP (connection successful)",
    "network.WLAN.isconnected()": "In case of STA mode, returns True if connected to a WiFi access point and has a valid IP address. In AP mode returns True when a station is connected. Returns False otherwise.",
    "network.WLAN.ifconfig([ (ip, subnet, gateway, dns) ])": "Get/set IP-level network interface parameters: IP address, subnet mask, gateway and DNS server. When called with no arguments, this method returns a 4-tuple with the above information. To set the above values, pass a 4-tuple with the required information. For example: nic = network.WLAN(network.WLAN.AP_IF) nic.ifconfig(('192.168.0.4', '255.255.255.0', '192.168.0.1', '8.8.8.8'))",
    "urequests": "urequests library.",
    "urequests.get(url, headers={})": "Send HTTP GET request to the given URL.  An optional dictionary of HTTP headers can be provided. Returns a urequests.Response-object",
    "urequests.post(url, data=None, json=None, headers={}) ": "Send HTTP POST request to the given URL. Returns a urequests.Response-object. - data (optional): bytes to send in the body of the request. - json (optional): JSON data to send in the body of the Request. - headers (optional): An optional dictionary of HTTP headers.",
    "urequests.Response() ": "Object returned by",
    "urequests.Response.text ": "String representation of response",
    "urequests.Response.json() ": "Convert Response from JSON to Python dictionary.",
    "neopixel": "neopixel library.",
    "neopixel.NeoPixel(pin, n)": "Create a list representing a strip of 'n' neopixels controlled from the specified pin (e.g. machine.Pin(0)). Use the resulting object to change each pixel by position (starting from 0). Individual pixels are given RGB (red, green, blue) values between 0-255 as a tuple. For example, (255, 255, 255) is white: np = neopixel.NeoPixel(machine.Pin(0 8)\\nnp[0] = (255, 0, 128) np.write()",
    "neopixel.NeoPixel.write() ": "Show the pixels. Must be called for any updates to become visible.",
    "math": "math library.",
    "math.sqrt(x) ": "Returns the square root of 'x'.",
    "math.pow(x, y) ": "Returns 'x' raised to the power 'y'.",
    "math.exp(x) ": "Returns math.e**'x'.",
    "math.log(x, base=math.e) ": "With one argument, return the natural logarithm of 'x' (to base e).\\nWith two arguments, return the logarithm of 'x' to the given 'base'.",
    "math.cos(x) ": "Returns the cosine of 'x' radians.",
    "math.sin(x) ": "Returns the sine of 'x' radians.",
    "math.tan(x) ": "Returns the tangent of 'x' radians.",
    "math.acos(x) ": "Returns the arc cosine of 'x', in radians.",
    "math.asin(x) ": "Returns the arc sine of 'x', in radians.",
    "math.atan(x) ": "Returns the arc tangent of 'x', in radians.",
    "math.atan2(x, y) ": "Returns atan(y / x) in radians.",
    "math.ceil(x) ": "Returns the ceiling of 'x', the smallest integer greater than or equal to 'x'.",
    "math.copysign(x, y) ": "Returns a float with the magnitude (absolute value) of 'x' but the sign of 'y'.",
    "math.fabs(x) ": "Returns the absolute value of 'x'.",
    "math.floor(x) ": "Returns the floor of 'x', the largest integer less than or equal to 'x'.",
    "math.fmod(x, y) ": "Returns 'x' modulo 'y'.",
    "math.frexp(x) ": "Returns the mantissa and exponent of 'x' as the pair (m, e).",
    "math.ldexp(x, i) ": "Returns 'x' * (2**'i').",
    "math.modf(x) ": "Returns the fractional and integer parts of x.\\nBoth results carry the sign of x and are floats.",
    "math.isfinite(x) ": "Returns True if 'x' is neither an infinity nor a NaN, and False otherwise.",
    "math.isinf(x) ": "Returns True if 'x' is a positive or negative infinity, and False otherwise.",
    "math.isnan(x) ": "Returns True if 'x' is a NaN (not a number and False otherwise.",
    "math.trunc(x) ": "Returns the Real value 'x' truncated to an Integral (usually an integer).",
    "math.radians(x) ": "Convert angle 'x' from degrees to radians.",
    "math.degrees(x) ": "Convert angle 'x' from radians to degrees."
};


function assignTips(doc){
    var tips = null;
    if(doc.getElementById('esp32')){
        tips=ESP_TIPS;
    }
    else if(getElementById('wb55')){
        mode=PYB_TIPS;
    }
    else{
        return;
    }
    return tips;
}

// This function assigns a score "ranking in the suggestions" to the tip
// In order to primarily show libs and native keywords and keep suggestion simple

function generateScore(libValue, libMeta) {
    var score = 500; //median value to reference rankings
    if (libMeta.match('library') != null) {
        score = 1000; //show first
    }
    else if (libValue.match(/(.*)\.(.*)\.(.*)/) != null) { // as in machine.Pin*
        // console.log('method or attribute')
        score = 0; //show last
    }
    else if(libValue.match(/(.*)\.(.*)\(/)){
        score = 500; //show intermediate
    }
    return score;
};

function generateDict(tips) {
    var Keys = Object.keys(tips);
    var Values = Object.values(tips);
    var Dict = [];
    for (var i = 0; i < Keys.length; i++) {
        Dict.push({ caption: 'blabla', value: Keys[i], score: generateScore(Keys[i], Values[i]), meta: Values[i] });
    }
    return Dict;
};
