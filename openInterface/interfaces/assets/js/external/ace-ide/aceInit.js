/**
 * @fileoverview ACE init, additional
 *  functions and constants to implement code completion for MicroPython (ESP32 & STM32).
 */


/**
 *  PYBOARD MicroPython libraries and metadata for descriptions
 */
const STM_TIPS_EN = {
    "pyb": "pyboard library.",
    "pyb.delay(ms)": "Delay for the given number of milliseconds.    Parameters:  ms (int) -- the number of milliseconds to delay.  ",
    "pyb.udelay(us)": "Delay for the given number of microseconds.    Parameters:  us (int) -- the number of microseconds to delay.  ",
    "pyb.millis()": "Returns the number of milliseconds since the board was last reset.    Returns: milliseconds since reset.    Return type: int  ",
    "pyb.micros()": "Returns the number of microseconds since the board was last reset.    Returns: microseconds since reset.    Return type: int  ",
    "pyb.elapsed_millis(start)": "Returns the number of milliseconds which have elapsed since start.    Parameters:  start (int) -- the number of milliseconds to start counting from.    Returns: milliseconds since start.    Return type: int  ",
    "pyb.elapsed_micros(start)": "Returns the number of microseconds which have elapsed since start.    Parameters:  start (int) -- the number of microseconds to start counting from.    Returns: microseconds since start.    Return type: int  ",
    "pyb.hard_reset()": "Resets the board in a manner similar to pushing the external RESET button.  ",
    "pyb.bootloader()": "Activate the bootloader without BOOT* pins.  ",
    "pyb.fault_debug(valus)": "Enable or disable hard-fault debugging.  A hard-fault is when there is a fatal error in the underlying system, like an  invalid memory access.    Parameters:  value (bool) --     False: board will automatically reset if there is a hard fault  True: when the board has a hard fault, it will print the registers and the stack  \\ttrace, and then cycle the LEDs indefinitely  ",
    "pyb.disable_irq()": "Disable interrupt requests.    Returns: Previous IRQ state.    Return type: bool  ",
    "pyb.enable_irq(state=True)": "Enable interrupt requests.    Parameters:  state (bool) -- Whether the IRQs are enabled  ",
    "pyb.freq([sysclk[, hclk[, pclk1[, pclk2]]]])": "If given no arguments, returns a tuple of clock frequencies:  (sysclk, hclk, pclk1, pclk2). Otherwise, sets the frequency of the CPU, and the  busses if additional arguments are given.    Parameters:  sysclk (int) [optional] -- frequency of the CPU in MHz.  hclk (int) [optional] -- frequency of the AHB bus, core memory and DMA.  pclk1 (int) [optional] -- frequency of the APB1 bus.  pclk2 (int) [optional] -- frequency of the APB2 bus.    Returns: clock frequencies.    Return type: tuple  ",
    "pyb.wfi()": "Wait for an internal or external interrupt.  This function will block for at most 1ms.  ",
    "pyb.stop()": "Put the board in a \u201csleeping\u201d state. To wake from this sleep state requires an  external interrupt or a real-time-clock event. Upon waking execution continues  where it left off.  ",
    "pyb.standby()": "Put the board into a \u201cdeep sleep\u201d state. To wake from this sleep state requires  a real-time-clock event, or an external interrupt on X1 (PA0=WKUP) or  X18 (PC13=TAMP1). Upon waking the system undergoes a hard reset.  ",
    "pyb.info([dump_alloc_table])": "Print out lots of information about the board.    Parameter:  dump_alloc_table (bool) [optional] -- Whether to dump the alloc table.  ",
    "pyb.main(filename)": "Set the filename of the main script to run after boot.py is finished.    It only makes sense to call this function from within boot.py.    Parameter:  filename (string) -- name of the desired main file.  ",
    "pyb.mount(device, mountpoint, *, readonly=False, mkfs=False)": "Mount a block device and make it available as part of the filesystem.    See online documentation for full instructions.  ",
    "pyb.repl_uart(uart)": "Get or set the UART object where the REPL is repeated on.    Parameter:  uart (pyb.UART) -- The uart to use  .",
    "pyb.rng()": "Returns a 30-bit hardware generated random number.    Returns: 30-bit random number.    Return value: int  ",
    "pyb.sync()": "Sync all file systems.  ",
    "pyb.unique_id()": "Returns a string of 12 bytes (96 bits which is the unique ID of the MCU.    Returns: unique ID of the MCU.    Return value: string  ",
    "pyb.usb_mode([modestr, ]vid=0xf055, pid=0x9801, hid=pyb.hid_mouse)": "If called with no arguments, return the current USB mode as a string. If called  with modestr provided, attempts to set USB mode.    This can only be done when called from boot.py before pyb.main() has been called.    See online documentation for full instructions.  ",
    // "pyb.Accel()": "Create an accelerometer object.  ",
    // "pyb.Accel.filtered_xyz()": "Get filtered x, y and z values.    Returns: accelerometer x, y, and z values.    Return type: 3-tuple  ",
    // "pyb.Accel.tilt()": "Get the tilt register.    Returns: contents of tilt register,    Return type: int  ",
    // "pyb.Accel.x()": "Get the x-axis register.    Returns: contents of x-axis register,    Return type: int  ",
    // "pyb.Accel.y()": "Get the y-axis register.    Returns: contents of y-axis register,    Return type: int  ",
    // "pyb.Accel.z()": "Get the z-axis register.    Returns: contents of z-axis register,    Return type: int  ",
    "pyb.ADC(pin)": "An Analog to Digital conversion object associated with the given pin    Parameter:  pin (pyb.Pin) -- the pin to read values from  ",
    "pyb.ADC.read()": "Read the value on the analog pin and return it.  The returned value will be between 0 and 4095.    Returns: analog value of pin.    Return type: int  ",
    "pyb.ADC.read_timed(buf, timer)": "Read analog values into buf at a rate set by the timer object.    Parameters:  buf (bytearray or array.array) -- The ADC values have 12-bit resolution and are  stored directly into buf if its element size is 16 bits or greater. If buf has  only 8-bit elements (eg a bytearray) then the sample resolution will be reduced  to 8 bits.  timer (pyb.Timer) -- a Timer object, a sample is read each time the timer triggers.",
    // "pyb.CAN(bus, ...)": "Construct a CAN object on the given bus. With no additional parameters, the CAN  object is created but not initialised. If extra arguments are given, the bus is  initialised. See CAN.init() for parameters of initialisation.    Parameters:  bus can be 1-2, or 'YA' or 'YB'.",
    // "pyb.CAN.init(mode, extframe=False, prescaler=100, *, sjw=1, bs1=6, bs2=8, auto_restart=False)": "Initialise the CAN bus with the given parameters.    Parameters:  mode (int) -- one of: NORMAL, LOOPBACK, SILENT, SILENT_LOOPBACK. These are  included in the pyb.CAN class as class variables.  extframe (bool) -- if extframe is True then the bus uses extended identifiers in  the frames (29 bits); otherwise it uses standard 11 bit identifiers.  prescaler (int) -- used to set the duration of 1 time quanta; the time quanta  will be the input clock divided by the prescaler.  sjw (int) -- is the resynchronisation jump width in units of the time quanta; it  can be 1, 2, 3, 4  bs1 (int) -- defines the location of the sample point in units of the time  quanta; it can be between 1 and 1024 inclusive.  bs2 (int) -- defines the location of the transmit point in units of the time  quanta; it can be between 1 and 16 inclusive.  auto_restart (bool) -- sets whether the controller will automatically try and  restart communications after entering the bus-off state.  ",
    // "pyb.CAN.deinit()": "Turn off the CAN bus.  ",
    // "pyb.CAN.restart()": "Force a software restart of the CAN controller without resetting its configuration.  ",
    // "pyb.CAN.state()": "Returns the state of the controller.    Returns: the state of the controller.  Can be one of the following: CAN.STOPPED, CAN.ERROR_ACTIVE, CAN.ERROR_WARNING,  CAN.ERROR_PASSIVE, CAN.BUS_OFF.    Return type: int  ",
    // "pyb.CAN.info([list])": "Get information about the controller\u2019s error states and TX and RX buffers.    Parameters:  list (list) [optional] -- If list is provided then it should be a list object  with at least 8 entries, which will be filled in with the information.    Returns: If list parameter is not provided, a new list will be created and filled in.    Return type: list  ",
    // "pyb.CAN.setfilter(bank, mode, fifo, params, *, rtr)": "Configure a filter bank    Parameters:  bank (int) -- the filter bank that is to be configured  mode (int) -- the mode the filter should operate in. One of the following:  CAN.LIST16, CAN.LIST32, CAN.MASK16, CAN.MASK32  fifo (int) -- which fifo (0 or 1) a message should be stored in, if it is  accepted by this filter  params (array (int)) -- values that defines the filter. The contents of the array  depends on the mode argument  rtr (array (bool)) [optional]  -- array that states if a filter should accept a  remote transmission request message. If this argument is not given then it defaults to False for all entries.",
    // "pyb.CAN.clearfilter(bank)": "Clear and disables a filter bank    Parameters:  bank (int) -- the filter bank that is to be cleared.  ",
    // "pyb.CAN.any(fifo)": "Whether any message waiting on the FIFO    Parameters:  fifo (int) -- the FIFO to check.    Returns: Whether a message is waiting    Return type: bool  ",
    "pyb.DAC(port, bits=8, *, buffering=None)": "Construct a new DAC object on the given port.    Parameters:  port (pyb.Pin or int) -- can be a pin object, or an integer (1 or 2). DAC(1) is  on pin X5 and DAC(2) is on pin X6.  bits (int) -- The resolution, and can be 8 or 12. The maximum value for the write  and write_timed methods will be 2**bits-1  buffering (bool or None) -- The buffering parameter selects the behaviour of the  DAC op-amp output buffer, whose purpose is to reduce the output impedance. It can  be None to select the default, False to disable buffering completely, or True to  enable output buffering.  ",
    "pyb.DAC.init(bits=8, *, buffering=None)": "Reinitialise the DAC.    Parameters:  bits (int) -- The resolution, and can be 8 or 12. The maximum value for the write and write_timed methods will be 2**bits-1  buffering (bool or None) -- The buffering parameter selects the behaviour of the DAC op-amp output buffer, whose purpose is to reduce the output impedance. It can be None to select the default, False to disable buffering completely, or True to enable output buffering.  ",
    "pyb.DAC.deinit()": "De-initialise the DAC making its pin available for other uses.  ",
    "pyb.DAC.noise(freq)": "Generate a pseudo-random noise signal. A new random sample is written to the DAC  output at the given frequency.    Parameters:  freq (int) -- the frequency to generate noise at.  ",
    "pyb.DAC.triangle(freq)": "Generate a triangle wave. The value on the DAC output changes at the given  frequency, and the frequency of the repeating triangle wave itself is 2048 times smaller.    Parameters: freq (int) -- the frequency to generate the wave at.  ",
    "pyb.DAC.write(value)": "Direct access to the DAC output. The minimum value is 0. The maximum value is 2**bits-1.    Parameters: value (int) -- the value to write to the DAC  ",
    "pyb.DAC.write_timed(data, freq, *, mode=DAC.NORMAL)": "Initiates a burst of RAM to DAC using a DMA transfer. The input data is treated  as an array of bytes in 8-bit mode, and an array of unsigned half-words  (array typecode \u2018H\u2019) in 12-bit mode.    Parameters:  data (array) -- data to be written to the DAC.  freq (int or Timer) -- frequency or Timer to determin how often to trigger DAC sample  mode (constant) -- can be DAC.NORMAL or DAC.CIRCULAR.",
    "pyb.ExtInt(pin, mode, pull, callback)": "Create an ExtInt object.    Parameters:  pin (pyb.Pin) -- the pin on which to enable the interrupt.  mode (constant) can be one of: ExtInt.IRQ_RISING - trigger on a rising edge;  ExtInt.IRQ_FALLING - trigger on a falling edge; ExtInt.IRQ_RISING_FALLING - trigger  on a rising or falling edge.  pull (constant) -- can be one of: - pyb.Pin.PULL_NONE - no pull up or down  resistors; pyb.Pin.PULL_UP - enable the pull-up resistor;  pyb.Pin.PULL_DOWN - enable the pull-down resistor.  callback (function) -- the function to call when the interrupt triggers. The  callback function must accept exactly 1 argument, which is the line that triggered the interrupt.  ",
    "pyb.ExtInt.regs()": "Prints the values of the EXTI registers.  ",
    "pyb.ExtInt.disable()": "Disable the interrupt associated with the ExtInt object.  ",
    "pyb.ExtInt.enable()": "Enable a disabled interrupt.  ",
    "pyb.ExtInt.line()": "Returns the line number that the pin is mapped to.    Returns: line number that the pin is mapped to    Return type: int  ",
    "pyb.ExtInt.swint()": "Trigger the callback from software.  ",
    "pyb.I2C(bus, ...)": "Construct an I2C object on the given bus. bus can be 1 or 2, \u2018X\u2019 or \u2018Y\u2019. With no  additional parameters, the I2C object is created but not initialised. If extra  arguments are given, the bus is initialised. See init for parameters of initialisation.    Parameters:  bus (int or string) -- the bus to attach to. Can be 1 or 2, \u2018X\u2019 or \u2018Y\u2019.  ",
    "pyb.I2C.deinit()": "Turn off the I2C bus.  ",
    "pyb.I2C.init(mode, *, addr=0x12, baudrate=400000, gencall=False, dma=False)": "Initialise the I2C bus with the given parameters    Parameters:  mode (constant) -- must be either I2C.MASTER or I2C.SLAVE  addr (int) -- the 7-bit address (only sensible for a slave)  baudrate (int) -- the SCL clock rate (only sensible for a master)  gencall (bool) -- whether to support general call mode  dma (bool) -- whether to allow the use of DMA for the I2C transfers  ",
    "pyb.I2C.is_ready(addr)": "Check if an I2C device responds to the given address. Only valid when in master mode.    Parameters:  addr (int) -- the address to check    Returns: Whether the address responds    Return type: bool  ",
    "pyb.I2C.mem_read(data, addr, memaddr, *, timeout=5000, addr_size=8)": "Read from the memory of an I2C device    Parameters:  data (int or buffer) -- number of bytes to read or a buffer to read into  addr (int) -- the I2C device address  memaddr (int) -- the memory location within the I2C device  timeout (int) the timeout in milliseconds to wait for the read  addr_size (int) -- width of memaddr: 8 or 16 bits    Returns: the read data. This is only valid in master mode.    Return type: bytes  ",
    "pyb.I2C.mem_write(data, addr, memaddr, *, timeout=5000, addr_size=8)": "Write to the memory of an I2C device  Parameters:  data (int or buffer) -- number of bytes to write or a buffer to write into  addr (int) -- the I2C device address  memaddr (int) -- the memory location within the I2C device  timeout (int) the timeout in milliseconds to wait for the write  addr_size (int) -- width of memaddr: 8 or 16 bits  ",
    "pyb.I2C.recv(recv, addr=0x00, *, timeout=5000)": "Receive data on the bus.    Parameters:  recv (int or buffer) -- can be the number of bytes to receive, or a mutable  buffer, which will be filled with received bytes  addr (int) -- the address to receive from (only required in master mode)  timeout (int) -- the timeout in milliseconds to wait for the receive    Returns: if recv is an integer then a new buffer of the bytes received    Return type: bytes  ",
    "pyb.I2C.send(send, addr=0x00, *, timeout=5000)": "Send data on the bus.    Parameters:  send (int or buffer) -- the data to send  addr (int) the address to send to (only required in master mode)  timeout (int) -- the timeout in milliseconds to wait for the send  ",
    "pyb.I2C.scan()": "Scan all I2C addresses from 0x01 to 0x7f and return a list of those that respond.  Only valid when in master mode.    Returns: valid I2C addresses on the bus    Return type: list  ",
    // "pyb.LCD(skin_position)": "Construct an LCD object in the given skin position.    Parameters:  skin_position (string) -- can be \u2018X\u2019 or \u2018Y\u2019, and should match the position where  the LCD pyskin is plugged in.  ",
    // "pyb.LCD.command(instr_data, buf)": "Send an arbitrary command to the LCD controller.    Parameters:  instr_data (int) -- 0 for instr_data to send an instruction, otherwise pass 1  to send data  buf (int or buffer) -- a buffer with the instructions/data to send  ",
    // "pyb.LCD.contrast(value)": "Set the contrast of the LCD    Parameters:  value (int) -- the contrast value, valid values are between 0 and 47.  ",
    // "pyb.LCD.fill(color)": "Fill the screen with the given colour.    Parameters:  color (int) -- 0 or 1 for white or black respectively.  ",
    // "pyb.LCD.get(x, y)": "Get the pixel at the position (x, y)    Parameters:  x (int) -- the X coordinate  y (int) -- the Y coordinate    Returns: the pixel value, either 0 or 1.    Return type: int  ",
    // "pyb.LCD.light(value)": "Turn the backlight on/off.    Parameters:  value (int or bool) -- True or 1 turns it on, False or 0 turns it off.  ",
    // "pyb.LCD.pixel(x, y, colour)": "Set the pixel at (x, y) to the given colour (0 or 1).    Parameters:  x (int) -- the X coordinate  y (int) -- the Y coordinate  color (int) -- the color.  ",
    // "pyb.LCD.show()": "Show the hidden buffer on the screen.  ",
    // "pyb.LCD.text(str, x, y, colour)": "Draw the given text to the position (x, y) using the given colour (0 or 1).    Parameters:  str (string) -- the text to display.  x (int) -- the X coordinate  y (int) -- the Y coordinate  color (int) -- the color.  ",
    // "pyb.LCD.write(str)": "Write the string str to the screen. It will appear immediately.    Parameters:  str (string) -- the text to display.  ",
    "pyb.LED(id)": "Create an LED object associated with the given LED    Parameters:  id (int) -- the LED number, 1-4  ",
    "pyb.LED.intensity([value])": "Get or set the LED intensity. If no argument is given, return the LED intensity.    Parameters:  value (int) [optional] -- intensity value ranges between 0 (off) and 255 (full on)    Returns: None or LED intensity    Return type: None or int  ",
    "pyb.LED.off()": "Turn the LED off.  ",
    "pyb.LED.on()": "Turn the LED on.  ",
    "pyb.LED.toggle()": "Toggle the LED between on (maximum intensity) and off. If the LED is at non-zero  intensity then it is considered \u201con\u201d and toggle will turn it off.  ",
    "pyb.Pin(id, ...)": "Create a new Pin object associated with the id. If additional arguments are given,  they are used to initialise the pin. See pyb.Pin.init()    Parameters:  id (constant or string) -- the identifier of the pin to use  ",
    "pyb.Pin.debug([state])": "Get or set the debugging state    Parameters:  state (bool) [optional] -- the debugging state to set, if any.    Returns: whether the debugging state is set (if nothing is passed to the method)    Return type: bool  ",
    "pyb.Pin.init(mode, pull=Pin.PULL_NONE, af=-1)": "Initialise the pin    Parameters:  mode (constant) -- can be one of: Pin.IN, Pin.OUT_PP, Pin.OUT_OD, Pin.AF_PP, Pin.AF_OD, Pin.ANALOG  pull (constant) -- can be one of: Pin.PULL_NONE, Pin.PULL_UP, Pin.PULL_DOWN  af (int) -- when mode is Pin.AF_PP or Pin.AF_OD, then af can be the index or name  of one of the alternate functions associated with a pin  ",
    "pyb.Pin.value([value])": "Get or set the digital logic level of the pin    Parameters:  value (int or bool) [optional] -- if value converts to True, the pin is set high,  otherwise it is set low    Returns: with no argument, return 0 or 1 depending on the logic level of the pin    Return type: int  ",
    "pyb.Pin.af()": "Returns the currently configured alternate-function of the pin    Returns: one of the integer representations of the allowed constants for af    Return type: int  ",
    "pyb.Pin.af_list()": "Returns an array of alternate functions available for this pin.    Returns:array of alternate functions available    Return type: list  ",
    "pyb.Pin.gpio()": "Returns the base address of the GPIO block associated with this pin.    Returns: the base address of the GPIO block    Return type: int",
    "pyb.Pin.mode()": "Returns the currently configured mode of the pin.    Returns: integer returned will match one of the allowed constants for the mode    Return type: int",
    "pyb.Pin.name()": "Returns the pin name.    Returns: the name of the pin    Return type: string",
    "pyb.Pin.names()": "Returns the board and cpu names for the pin.    Returns: the names of the pin    Return type: list",
    "pyb.Pin.pin()": "Returns the CPU pin number.    Returns: the number of the pin    Return type: int",
    "pyb.Pin.port()": "Returns the CPU port number.    Returns: the number of the port    Return type: int",
    "pyb.Pin.pull()": "Returns the currently configured pull of the pin.    Returns: The integer returned will match one of the allowed constants for the pull    Return type: int",
    "pyb.RTC()": "Create an RTC object.  ",
    "pyb.RTC.datetime([datetimetuple])": "Get or set the date and time of the RTC. With no arguments, this method returns  an 8-tuple with the current date and time. With 1 argument (being an 8-tuple) it  sets the date and time    Parameters:  datetimetuple (tuple) [optional] -- The 8-tuple has the following format:  (year, month, day, weekday, hours, minutes, seconds, subseconds). All tuple  elements are integers    Returns: the current date and time    Return type: tuple (8 elements)  ",
    "pyb.RTC.wakeup(timeout, callback=None)": "Set the RTC wakeup timer to trigger repeatedly at every timeout milliseconds.  This trigger can wake the pyboard from both the sleep states: pyb.stop() and pyb.standby()    Parameters:  timeout (int or None) -- timeout in milliseconds or None to disable timer  callback (function or None) -- if callback is given then it is executed at every  trigger of the wakeup timer. callback must take exactly one argument  ",
    "pyb.RTC.info()": "Get information about the startup time and reset source    Returns: RTC info: lower 0xffff are the number of milliseconds the RTC took to  start up, bit 0x10000 is set if a power-on reset occurred, bit 0x20000 is set if  an external reset occurred    Return type: int  ",
    "pyb.RTC.calibration([cal])": "Get or set RTC calibration.    Parameters: cal (int) [optional] -- The usable calibration range is: (-511 * 0.954) ~= -487.5 ppm up to (512 * 0.954) ~= 488.5 ppm    Returns: with no arguments, the current calibration value, in the range [-511 : 512]    Return type: int  ",
    // "pyb.Servo(id)": "Create a servo object.    Paramaters:  id (int) -- can be 1-4, and corresponds to pins X1 through X4.  ",
    // "pyb.Servo.angle([angle, time=0])": "If arguments are given, sets the angle of the servo  If no arguments are given, gets the angle of the servo.    Parameters:  angle (float or int) [optional] -- the angle to move to in degrees.  time (int) -- the number of milliseconds to take to get to the specified angle.  If omitted, then the servo moves as quickly as possible to its new position.    Returns: the current angle of the servo (if no arguments are given)    Return type: float  ",
    // "pyb.Servo.speed([speed, time=0])": "If no arguments are given, returns the current speed.  If arguments are given, sets the speed of the servo.    Parameters:  speed (int) -- the speed to change to, between -100 and 100.  time (int) -- the number of milliseconds to take to get to the specified speed.  If omitted, then the servo accelerates as quickly as possible.    Returns: the current speed of the servo (if no arguments given)    Return type: int  ",
    // "pyb.Servo.pulse_width([value])": "If no arguments are given, returns the current raw pulse-width value.  If an argument is given, sets the raw pulse-width value.    Parameters: value (int) [optional] -- the desired pulse width value.    Returns: the current raw pulse-width value (if no arguments are given)    Return type: int  ",

    "pyb.SPI(bus, ...)": "Construct an SPI object on the given bus. With no additional parameters, the SPI  object is created but not initialised. If extra arguments are given, the bus is  initialised. See init for parameters of initialisation.    Parameters:  bus (int or string) -- can be 1 or 2, or \u2018X\u2019 or \u2018Y\u2019  SPI(1) is on the X position: (NSS, SCK, MISO, MOSI) = (X5, X6, X7, X8) = (PA4, PA5, PA6, PA7)  SPI(2) is on the Y position: (NSS, SCK, MISO, MOSI) = (Y5, Y6, Y7, Y8) = (PB12, PB13, PB14, PB15)  ",
    "pyb.SPI.deinit()": "Turn off the SPI bus.  ",
    "pyb.SPI.init(mode, baudrate=328125, *, prescaler, polarity=1, phase=0, bits=8, firstbit=SPI.MSB, ti=False, crc=None)": "Initialise the SPI bus with the given parameters    Parameters:  mode (constant) -- must be either SPI.MASTER or SPI.SLAVE.  baudrate (int) -- the SCK clock rate (only sensible for a master).  prescaler (int) -- the prescaler to use to derive SCK from the APB bus frequency, overrides baudrate.  polarity (int) -- can be 0 or 1, the level the idle clock line sits at.  phase (int) -- 0 or 1 to sample data on the first or second clock edge respectively.  bits (int) -- 8 or 16, and is the number of bits in each transferred word.  firstbit (constant) -- can be SPI.MSB or SPI.LSB  crc (None) -- can be None for no CRC, or a polynomial specifier.  ",
    "pyb.SPI.recv(recv, *, timeout=5000)": "Receive data on the bus    Parameters:  recv (int or buffer) -- can be the number of bytes to receive, or a mutable  buffer, which will be filled with received bytes.  timeout (int) -- the timeout in milliseconds to wait for the receive.    Returns: if recv is an integer then a new buffer of the bytes received, otherwise  the same buffer that was passed in to recv,    Return type: buffer  ",
    "pyb.SPI.send(send, *, timeout=5000)": "Send data on the bus    Parameters:  send (bytes) -- the data to send (an integer to send, or a buffer object)  timeout (int) -- the timeout in milliseconds to wait for the send  ",
    "pyb.SPI.send_recv(send, recv=None, *, timeout=5000)": "Send and receive data on the bus at the same time    Parameters:  send (bytes) -- the data to send (an integer to send, or a buffer object)  recv (buffer) -- a mutable buffer which will be filled with received bytes. It  can be the same as send, or omitted. If omitted, a new buffer will be created  timeout (int) -- the timeout in milliseconds to wait for the receive.    Returns: buffer with the received bytes.    Return type: bytes  ",
    "pyb.Switch()": "Create and return a switch object.    Returns: Switch object    Return type: Switch class  ",
    "pyb.Switch.value()": "Get the current switch state.    Returns: True if pressed down, False otherwise.    Return type: bool  ",
    "pyb.Switch.callback(fun)": "Register the given function to be called when the switch is pressed down    Parameters:  fun (function) -- the function to execute or None. If fun is None, then it disables the callback.  ",
    "pyb.Timer(id, ...)": "Construct a new timer object of the given id. If additional arguments are given,  then the timer is initialised by init(...).    Parameters:  id (int) -- can be 1 to 14.  ",
    "pyb.Timer.init(*, freq, prescaler, period)": "Initialise the timer. Initialisation must be either by frequency (in Hz) or by  prescaler and period    Parameters:  freq (int) -- specifies the periodic frequency of the timer.  prescaler (int) -- [0-0xffff] specifies the value to be loaded into the timer\u2019s Prescaler  Register (PSC). The timer clock source is divided by prescaler + 1  period (int) -- [0-0xffff] for timers 1, 3, 4, and 6-15. [0-0x3fffffff] for  timers 2 & 5. Specifies the value to be loaded into the timer\u2019s AutoReload Register (ARR)  ",
    "pyb.Timer.deinit()": "Deinitialises the timer, callback, and channel callbacks associated with the Timer  ",
    "pyb.Timer.counter([value])": "Get or set the timer counter.  ",
    "pyb.Timer.freq([value])": "Get or set the frequency for the timer (changes prescaler and period if set).  ",
    "pyb.Timer.period([value])": "Get or set the period of the timer.  ",
    "pyb.Timer.prescaler([value])": "Get or set the prescaler for the timer.  ",
    "pyb,Timer.source_freq()": "Get the frequency of the source of the timer.  ",
    "pyb.UART(bus, ...)": "Construct a UART object on the given bus.  With no additional parameters, the UART object is created but not initialised.  If extra arguments are given, the bus is initialised. See init for parameters  of initialisation.    Parameters:  bus (int or string) -- can be 1-6, or \u2018XA\u2019, \u2018XB\u2019, \u2018YA\u2019, or \u2018YB\u2019.  ",
    "pyb.UART.init(baudrate, bits=8, parity=None, stop=1, *, timeout=1000, flow=0, timeout_char=0, read_buf_len=64)": "Initialise the UART bus with the given parameters    Parameters:  baudrate (int) -- the clock rate  bits (int) -- the number of bits per character, 7, 8 or 9  parity (int) -- the parity, None, 0 (even) or 1 (odd)  stop (int) -- the number of stop bits, 1 or 2  flow (int) -- the flow control type. Can be 0, UART.RTS, UART.CTS or UART.RTS | UART.CTS  timeout (int) -- the timeout in milliseconds to wait for writing/reading the first character  timeout_char (int) -- the timeout in milliseconds to wait between characters  while writing or reading.  read_buf_len (int) -- the character length of the read buffer (0 to disable)  ",
    "pyb.UART.deinit()": "Turn off the UART bus.  ",
    "pyb.UART.any()": "Returns the number of bytes waiting (may be 0).  ",
    "pyb.UART.read([nbytes])": "Read characters. If nbytes is specified then read at most that many bytes.  If nbytes is not given then the method reads as much data as possible. It returns  after the timeout has elapsed.    Parameters:  nbytes (int) [optional] -- number of bytes to attempt to return    Returns: a bytes object containing the bytes read in, None on timeout.    Return type: bytes or None",
    "pyb.UART.readchar()": "Receive a single character on the bus.    Returns: the character read, as an integer, returns -1 on timeout.    Return type: int  ",
    "pyb.UART.readinto(buf[, nbytes])": "Read bytes into the buf    Parameters:  buf (buffer) -- buffer to store bytes in  nbytes (int) [optional] -- if specified then read at most that many bytes,  otherwise, read at most len(buf) bytes    Returns: number of bytes read and stored into buf or None on timeout    Return type: int  ",
    "pyb.UART.readline()": "Read a line, ending in a newline character. If such a line exists, return is  immediate. If the timeout elapses, all available data is returned regardless of  whether a newline exists.    Returns: the line read or None on timeout if no data is available    Return type: bytes  ",
    "pyb.UART.write(buf)": "Write the buffer of bytes to the bus.  Parameters:  buf (buffer) -- if characters are 7 or 8 bits wide then each byte is one character. If characters  are 9 bits wide then two bytes are used for each character (little endian and  buf must contain an even number of bytes    Returns: number of bytes written. If a timeout occurs and no bytes were written returns None    Return type: int  ",
    "pyb.UART.writechar(char)": "Write a single character on the bus    Parameters:  char (int) -- the integer to write  ",
    "pyb.UART.sendbreak()": "Send a break condition on the bus.  This drives the bus low for a duration of 13 bits.  ",
    "pyb.USB_HID()": "Create a new USB_HID object.  ",
    "pyb.USB_HID.recv(data, *, timeout=5000)": "Receive data on the bus    Parameters:  data can be an integer, which is the number of bytes to receive, or a mutable  buffer (int or buffer) -- which will be filled with received bytes.  timeout (int) -- the timeout in milliseconds to wait for the receive    Returns: if data is an integer then a new buffer of the bytes received, otherwise  the number of bytes read into data is returned    Return type: int or buffer  ",
    "pyb.USB_HID.send(data)": "Send data over the USB HID interface    Parameters:  data (multiple) -- the data to send (a tuple/list of integers, or a bytearray)  ",
    "pyb.USB_VCP()": "Create a new USB_VCP object  ",
    "pyb.USB_VCP.setinterrupt(chr)": "Set the character which interrupts running Python code, set to 3 (CTRL-C) by default.  ",
    "pyb.USB_VCP.isconnected()": "Whether USB is connected as a serial device    Returns: True if USB is connected as a serial device, else False    Return type: bool  ",
    "pyb.USB_VCP.any()": "Whether any characters are waiting    Returns: True if any characters waiting, else False    Return type: bool  ",
    "pyb.USB_VCP.close()": "This method does nothing. It exists so the USB_VCP object can act as a file.  ",
    "pyb.USB_VCP.read([nbytes])": "Read at most nbytes from the serial device and return them as a bytes object  ",
    "pyb.USB_VCP.readinto(buf[, maxlen])": "Read bytes from the serial device and store them into buf    Parameters:  buf (buffer) -- a buffer-like object to read into  maxlen (int) -- if maxlen is given and then at most min(maxlen, len(buf)) bytes are read    Returns: the number of bytes read and stored into buf or None if no pending data available    Return type: int  ",
    "pyb.USB_VCP.readline()": "Read a whole line from the serial device.    Returns: a bytes object containing the data    Return type: bytes  ",
    "pyb.USB_VCP.readlines()": "Read as much data as possible from the serial device, breaking it into lines    Returns: a list of bytes objects, each object being one of the lines    Return type: list  ",
    "pyb.USB_VCP.write(buf)": "Write the bytes from buf to the serial device.  ",
    "pyb.USB_VCP.recv(data, *, timeout=5000)": "Receive data on the bus    Parameters:  data (int or buffer) -- the number of bytes to receive, or a mutable buffer,  which will be filled with received bytes  timeout (int) -- the timeout in milliseconds to wait for the receive    Returns: if data is an integer then a new buffer of the bytes received, otherwise  the number of bytes read into data is returned  Return type: int or buffer  ",
    "pyb.USB_VCP.send(data, *, timeout=5000)": "Send data over the USB VCP:    Parameters:  data (int of buffer) -- the data to send  timeout (int) -- the timeout in milliseconds to wait for the send.    Returns: the number of bytes sent    Return type: int  ",
    "machine": "machine library.",
    "machine.reset()": "Resets the device in a manner similar to pushing the external RESET button",
    "machine.freq()": "Returns CPU frequency in hertz.",
    "machine.Pin(id [, mode, pull])": "Create a Pin-object. Only id is mandatory. mode (optional): specifies the pin mode (Pin.OUT or Pin.IN) pull (optional): specifies if the pin has a pull resistor attached pull can be one of: None, Pin.PULL_UP or Pin.PULL_DOWN.",
    "machine.Pin.value([x])": "This method allows to set and get the value of the pin, depending on whether the argument x is supplied or not. If the argument is omitted, the method returns the actual input value (0 or 1) on the pin. If the argument is supplied, the method sets the output to the given value.",
    "machine.Pin.OUT ": "",
    "machine.Pin.IN ": "",
    "machine.Pin.PULL_UP ": "",
    "machine.Pin.PULL_DOWN ": "",
    "machine.ADC(pin)": "Create an ADC object associated with the given pin.  This allows you to then read analog values on that pin. machine.ADC(machine.Pin(39))",
    "machine.ADC.read()": "Read the analog pin value.\\n\\nadc = machine.ADC(machine.Pin(39))\\nvalue = adc.read()",
    "random": "random library.",
    "random.getrandbits(n)": "Returns an integer with n random bits.",
    "random.seed(n)": "Initialise the random number generator with a known integer 'n'.",
    "random.randint(a, b)": "Returns a random whole number between a and b (inclusive).",
    "random.randrange(stop)": "Returns a random whole number between 0 and up to (but not including) stop.",
    "random.choice(seq)": "Returns a randomly selected element from a sequence of objects (such as a list).",
    "random.random()": "Returns a random floating point number between 0.0 and 1.0.",
    "random.uniform(a, b)": "Returns a random floating point number between a and b (inclusive).",
    "os": "os library.",
    "os.listdir()": "Returns a list of the names of all the files contained within the local\\non-device file system.",
    "os.remove(filename)": "Remove (delete) the file named filename.",
    "os.size(filename)": "Returns the size, in bytes, of the file named filename.",
    "os.uname()": "Returns information about MicroPython and the device.",
    "os.getcwd()": "Returns current working directory",
    "os.chdir(path)": "Change current working directory",
    "os.mkdir(path)": "Make new directory",
    "os.rmdir(path)": "Remove directory",
    "os.listdir(path='.')": "Returns list of directory. Defaults to current working directory.",
    "math": "math library.",
    "math.sqrt(x)": "Returns the square root of 'x'.",
    "math.pow(x, y)": "Returns 'x' raised to the power 'y'.",
    "math.exp(x)": "Returns math.e**'x'.",
    "math.log(x, base=math.e)": "With one argument, return the natural logarithm of 'x' (to base e).\\nWith two arguments, return the logarithm of 'x' to the given 'base'.",
    "math.cos(x)": "Returns the cosine of 'x' radians.",
    "math.sin(x)": "Returns the sine of 'x' radians.",
    "math.tan(x)": "Returns the tangent of 'x' radians.",
    "math.acos(x)": "Returns the arc cosine of 'x', in radians.",
    "math.asin(x)": "Returns the arc sine of 'x', in radians.",
    "math.atan(x)": "Returns the arc tangent of 'x', in radians.",
    "math.atan2(x, y)": "Returns atan(y / x) in radians.",
    "math.ceil(x)": "Returns the ceiling of 'x', the smallest integer greater than or equal to 'x'.",
    "math.copysign(x, y)": "Returns a float with the magnitude (absolute value) of 'x' but the sign of 'y'.",
    "math.fabs(x)": "Returns the absolute value of 'x'.",
    "math.floor(x)": "Returns the floor of 'x', the largest integer less than or equal to 'x'.",
    "math.fmod(x, y)": "Returns 'x' modulo 'y'.",
    "math.frexp(x)": "Returns the mantissa and exponent of 'x' as the pair (m, e).",
    "math.ldexp(x, i)": "Returns 'x' * (2**'i').",
    "math.modf(x)": "Returns the fractional and integer parts of x.\\nBoth results carry the sign of x and are floats.",
    "math.isfinite(x)": "Returns True if 'x' is neither an infinity nor a NaN, and False otherwise.",
    "math.isinf(x)": "Returns True if 'x' is a positive or negative infinity, and False otherwise.",
    "math.isnan(x)": "Returns True if 'x' is a NaN (not a number and False otherwise.",
    "math.trunc(x)": "Returns the Real value 'x' truncated to an Integral (usually an integer).",
    "math.radians(x)": "Convert angle 'x' from degrees to radians.",
    "math.degrees(x)": "Convert angle 'x' from radians to degrees.",
    "sys": "sys library.",
    "sys.version ": "Returns Python version as a string",
    "sys.version_info ": "Returns Python version as a tuple",
    "sys.implementation ": "Returns MicroPython version",
    "sys.platform ": "Returns hardware platform as string, e.g. 'esp8266' or 'esp32'",
    "sys.byteorder ": "Returns platform endianness. 'little' for least-significant byte first or 'big' for most-significant byte first.",
    "sys.print_exception(ex)": "Print to the REPL information about the exception 'ex'.",
    "time": "time library.",
    "time.sleep(seconds)": "Sleep the given number of seconds.",
    "time.sleep_ms(milliseconds)": "Sleep the given number of milliseconds.",
    "time.sleep_us(milliseconds)": "Sleep the given number of microseconds.",
    "time.ticks_ms()": "Returns number of milliseconds from an increasing counter. Wraps around after some value.",
    "time.ticks_us()": "Returns number of microseconds from an increasing counter. Wraps around after some value.",
    "time.ticks_diff()": "Compute difference between values ticks values obtained from time.ticks_ms() and time.ticks_us().",
    "time.time()  ": "Returns the number of seconds, as an integer, since the Epoch, assuming that underlying RTC is set and maintained. If an RTC is not set, this function returns number of seconds since a port-specific reference point in time (usually since boot or reset).",
    // "network": "network library.",
    // "network.WLAN(interface_id)": "Create a WLAN interface object. Supported interfaces are: network.STA_IF (station aka client, connects to upstream WiFi access points) and  network.AP_IF (access point mode, allows other WiFi clients to connect).",
    // "network.WLAN.STA_IF ": "",
    // "network.WLAN.AP_IF": "",
    // "network.WLAN.active([ is_active ])": "Activates or deactivates the network interface when given boolean argument. When argument is omitted the function returns the current state.",
    // "network.WLAN.connect(ssid, password)": "Connect to the specified wireless network using the specified password.",
    // "network.WLAN.disconnect()": "Disconnect from the currently connected wireless network.",
    // "network.WLAN.scan()": "Scan for the available wireless networks. Scanning is only possible on STA interface. Returns list of tuples with the information about WiFi access points: (ssid, bssid, channel, RSSI, authmode, hidden)",
    // "network.WLAN.status()": "Returns the current status of the wireless connection. Possible values: - STAT_IDLE (no connection and no activity) - STAT_CONNECTING (connecting in progress) - STAT_WRONG_PASSWORD (failed due to incorrect password - STAT_NO_AP_FOUND (failed because no access point replied - STAT_CONNECT_FAIL (failed due to other problems - STAT_GOT_IP (connection successful)",
    // "network.WLAN.isconnected()": "In case of STA mode, returns True if connected to a WiFi access point and has a valid IP address. In AP mode returns True when a station is connected. Returns False otherwise.",
    // "network.WLAN.ifconfig([ (ip, subnet, gateway, dns) ])": "Get/set IP-level network interface parameters: IP address, subnet mask, gateway and DNS server. When called with no arguments, this method returns a 4-tuple with the above information. To set the above values, pass a 4-tuple with the required information. For example: nic = network.WLAN(network.WLAN.AP_IF) nic.ifconfig(('192.168.0.4', '255.255.255.0', '192.168.0.1', '8.8.8.8'))",
    "utime": "utime library",
    "utime.localtime([secs])": "Convert a time expressed in seconds since the Epoch (see above) into an 8-tuple which contains: (year, month, mday, hour, minute, second, weekday, yearday)",
    "utime.mktime()": " It returns an integer which is the number of seconds since Jan 1, 2000.",
    "utime.sleep(seconds)": "Sleep for the given number of seconds.",
    "utime.sleep_ms(ms)": "Delay for given number of milliseconds, should be positive or 0.",
    "utime.sleep_us(us)": "Delay for given number of microseconds, should be positive or 0",
    "utime.ticks_ms()": "Returns an increasing millisecond counter with an arbitrary reference point, that wraps around after some value.",
    "utime.time()": "Returns the number of seconds, as an integer, since the Epoch, assuming that underlying RTC is set and maintained as described above",
    "ubluetooth": "bluetooth library",
    "ubluetooth.BLE": "Returns the singleton BLE object.",
    "ubluetooth.BLE.active([active, ]/)": "Optionally changes the active state of the BLE radio, and returns the current state.",
};

/**
 *  STM MicroPython libraries and metadata for descriptions (FRENCH)
 */
const STM32_TIPS_FR = {
    "pyb": "bibliothèque pyboard.",
    "pyb.delay(ms)": " Délai pour le nombre de millisecondes donné. Paramètres : ms (int) -- le nombre de millisecondes à retarder. ",
    "pyb.udelay(us)": " Délai pour le nombre de microsecondes donné. Paramètres : us (int) -- le nombre de microsecondes à retarder. ",
    "pyb.millis()": " Renvoie le nombre de millisecondes depuis la dernière réinitialisation de la carte. Renvoie : millisecondes depuis la réinitialisation. Type de retour : int ",
    "pyb.micros()": " Renvoie le nombre de microsecondes depuis la dernière réinitialisation de la carte. Renvoie : les microsecondes depuis la réinitialisation. Type de retour : int ",
    "pyb.elapsed_millis(start)": " Renvoie le nombre de millisecondes écoulées depuis le début. Paramètres : start (int) -- le nombre de millisecondes à partir duquel commencer le comptage. Renvoie : millisecondes depuis le début. Type de retour : int ",
    "pyb.elapsed_micros(start)": " Renvoie le nombre de microsecondes qui se sont écoulées depuis le début. Paramètres : start (int) -- le nombre de microsecondes à partir duquel commencer à compter. Renvoie : les microsecondes depuis le début. Type de retour : int ",
    "pyb.hard_reset()": " Réinitialise la carte d'une manière similaire à appuyer sur le bouton RESET externe. ",
    "pyb.bootloader()": "Activer le chargeur de démarrage sans broches BOOT*. ",
    "pyb.fault_debug(value)": "Activer ou désactiver le débogage des défauts matériels. Un défaut matériel se produit lorsqu'il y a une erreur fatale dans le système sous-jacent, comme un accès mémoire non valide. Paramètres : valeur (bool) -- False : la carte se réinitialisera automatiquement s'il y a un défaut dur True : lorsque la carte a un défaut dur, elle imprimera les registres et la pile \\ttrace, puis fera cycler les LED indéfiniment ",
    "pyb.disable_irq()": " Désactive les requêtes d'interruption. Renvoie : état précédent de l'IRQ. Type de retour : bool ",
    "pyb.enable_irq(state=True)": "Activer les requêtes d'interruption. Paramètres : state (bool) -- Si les IRQ sont activées ",
    "pyb.freq([sysclk[, hclk[, pclk1[, pclk2]]]])": "Si aucun argument n'est donné, renvoie un tuple de fréquences d'horloge : (sysclk, hclk, pclk1, pclk2). Sinon, définit le fréquence du processeur et des bus si des arguments supplémentaires sont fournis. Paramètres : sysclk (int) [optionnel] -- fréquence du processeur en MHz. hclk (int) [optionnel] -- fréquence du bus AHB, mémoire centrale et DMA. pclk1 (int) [facultatif] -- fréquence du bus APB1. pclk2 (int) [facultatif] -- fréquence du bus APB2. Renvoie : fréquences d'horloge. Type de retour : tuple ",
    "pyb.wfi()": " Attendre une interruption interne ou externe. Cette fonction se bloquera pendant au plus 1 ms. ",
    "pyb.stop()": "Mettre la carte dans un état \u201csleeping\u201d. Pour sortir de cet état de veille, il faut une interruption externe ou un événement d'horloge en temps réel. Au réveil, l'exécution continue là où elle s'était arrêtée. ",
    "pyb.standby()": "Mettre la carte dans un état \u201cdeep sleep\u201d. Pour sortir de cet état de sommeil, un événement d'horloge en temps réel ou une interruption externe sur X1 (PA0=WKUP) ou X18 ( PC13=TAMP1). Au réveil, le système subit une réinitialisation matérielle. ",
    "pyb.info([dump_alloc_table])": " Imprimez de nombreuses informations sur la carte. Paramètre : dump_alloc_table (bool) [facultatif] -- Si vous souhaitez vider la table d'allocation. ",
    "pyb.main(filename)": "Définir le nom de fichier du script principal pour qu'il s'exécute une fois que boot.py est terminé. Cela n'a de sens que d'appeler cette fonction depuis boot.py. Paramètre : filename (string) -- name of le fichier principal souhaité. ",
    "pyb.mount(device, mountpoint, *, readonly=False, mkfs=False)": "Monter un périphérique bloc et le rendre disponible dans le système de fichiers. Voir la documentation en ligne pour des instructions complètes. ",
    "pyb.repl_uart(uart)": "Obtenez ou définissez l'objet UART sur lequel le REPL est répété. Paramètre : uart (pyb.UART) -- L'uart à utiliser .",
    "pyb.rng()": " Renvoie un nombre aléatoire de 30 bits généré par le matériel. Renvoie : un nombre aléatoire de 30 bits. Valeur de retour : int ",
    "pyb.sync()": "Synchronisez tous les systèmes de fichiers. ",
    "pyb.unique_id()": " Renvoie une chaîne de 12 octets (96 bits qui est l'identifiant unique du MCU. Renvoie : l'identifiant unique du MCU. Valeur de retour : string ",
    "pyb.usb_mode([modestr, ]vid=0xf055, pid=0x9801, hid=pyb.hid_mouse)": "Si appelé sans arguments, renvoie le mode USB actuel sous forme de chaîne. Si appelé avec modestr fourni, tente de définir Mode USB. Cela ne peut être fait que lorsqu'il est appelé depuis boot.py avant que pyb.main() n'ait été appelé. Voir la documentation en ligne pour des instructions complètes. ",
    // "pyb.Accel()": "Créer un objet accéléromètre. ",
    // "pyb.Accel.filtered_xyz()": "Obtenir les valeurs filtrées x, y et z. Renvoie : valeurs x, y et z de l'accéléromètre. Type de retour : 3-tuple ",
    // "pyb.Accel.tilt()": " Récupère le registre d'inclinaison. Renvoie : contenu du registre d'inclinaison, Type de retour : int ",
    // "pyb.Accel.x()": " Récupère le registre de l'axe des X. Renvoie : le contenu du registre de l'axe des X, Type de retour : int ",
    // "pyb.Accel.y()": " Récupère le registre de l'axe des y. Renvoie : le contenu du registre de l'axe des y, Type de retour : int ",
    // "pyb.Accel.z()": " Récupère le registre de l'axe z. Renvoie : contenu du registre de l'axe z, Type de retour : int ",

    "pyb.ADC(pin)": "Un objet de conversion analogique-numérique associé au paramètre de broche donné : pin (pyb.Pin) -- la broche à partir de laquelle lire les valeurs",
    "pyb.ADC.read()": " Lire la valeur sur la broche analogique et la renvoyer. La valeur renvoyée sera comprise entre 0 et 4095. Renvoie : valeur analogique de la broche. Type de retour : int ",
    "pyb.ADC.read_timed(buf, timer)": "Lire les valeurs analogiques dans buf à une vitesse définie par l'objet timer. Paramètres : buf (bytearray ou array.array) -- Les valeurs ADC ont une résolution de 12 bits et sont stocké directement dans buf si sa taille d'élément est de 16 bits ou plus. Si buf n'a que des éléments de 8 bits (par exemple un tableau d'octets), la résolution de l'échantillon sera réduite à 8 bits. timer (pyb.Timer) -- un objet Timer, un échantillon est lu à chaque déclenchement du temporisateur.",
    // "pyb.CAN(bus, ...)": "Construire un objet CAN sur le bus donné. Sans paramètres supplémentaires, l'objet CAN est créé mais pas initialisé. Si des arguments supplémentaires sont fournis, le bus est initialisé. Voir CAN .init() pour les paramètres d'initialisation. Paramètres : bus peut être 1-2, ou 'YA' ou 'YB'.",
    // "pyb.CAN.init(mode, extframe=False, prescaler=100, *, sjw=1, bs1=6, bs2=8, auto_restart=False)": " Initialiser le bus CAN avec les paramètres donnés. Paramètres : mode (int) -- un parmi : NORMAL, LOOPBACK, SILENT, SILENT_LOOPBACK. Ceux-ci sont inclus dans la classe pyb.CAN en tant que variables de classe. extframe (bool) -- si extframe est True alors le bus utilise des identifiants étendus dans les trames (29 bits); sinon, il utilise des identificateurs standard de 11 bits. prescaler (int) -- utilisé pour définir la durée de 1 quanta de temps ; le quanta de temps sera l'horloge d'entrée divisée par le prescaler. sjw (int) -- est le saut de resynchronisation largeur en unités de quanta de temps ; il peut être 1, 2, 3, 4 bs1 (int) -- définit l'emplacement du point d'échantillonnage en unités de quanta de temps ; il peut être compris entre 1 et 1024 inclus. bs2 (int ) -- définit l'emplacement du point de transmission en unités de quanta de temps ; il peut être compris entre 1 et 16 inclus. auto_restart (bool) -- définit si le contrôleur essaiera automatiquement un nd redémarrer les communications après être entré dans l'état bus-off. ",
    // "pyb.CAN.deinit()": "Désactiver le bus CAN. ",
    // "pyb.CAN.restart()": " Forcer un redémarrage logiciel du contrôleur CAN sans réinitialiser sa configuration. ",
    // "pyb.CAN.state()": " Renvoie l'état du contrôleur. Renvoie : l'état du contrôleur. Peut être l'un des suivants : CAN.STOPPED, CAN.ERROR_ACTIVE, CAN.ERROR_WARNING, CAN.ERROR_PASSIVE, CAN .BUS_OFF. Type de retour : int ",
    // "pyb.CAN.info([list])": "Obtenez des informations sur les états d'erreur du contrôleur et les tampons TX et RX. Paramètres : liste (liste) [facultatif] -- Si la liste est fournie, ce devrait être une liste objet avec au moins 8 entrées, qui seront renseignées avec les informations. Retours : Si le paramètre liste n'est pas fourni, une nouvelle liste sera créée et renseignée.Type de retour: liste ",
    // "pyb.CAN.setfilter(bank, mode, fifo, params, *, rtr)": " Configurer une banque de filtres Paramètres : bank (int) -- la banque de filtres à configurer mode (int) -- le mode le filtre doit fonctionner. L'un des éléments suivants : CAN.LIST16, CAN.LIST32, CAN.MASK16, CAN.MASK32 fifo (int) -- dans quelle fifo (0 ou 1) un message doit être stocké, s'il est accepté par ce filtre params (array (int)) -- valeurs qui définissent le filtre. Le contenu du tableau dépend du mode argument rtr (array (bool)) [facultatif] -- tableau qui indique si un filtre doit accepter un message de demande de transmission. Si cet argument n'est pas fourni, sa valeur par défaut est False pour toutes les entrées.",
    // "pyb.CAN.clearfilter(bank)": " Efface et désactive une banque de filtres Paramètres : bank (int) -- la banque de filtres qui doit être supprimée. ",
    // "pyb.CAN.any(fifo)": " Si un message est en attente sur les paramètres FIFO : fifo (int) -- la FIFO à vérifier. Renvoie : Si un message est en attente Type de retour : bool ",

    "pyb.DAC(port, bits=8, *, buffering=None)": "Construire un nouvel objet DAC sur le port donné. Paramètres : port (pyb.Pin ou int) -- peut être un objet pin, ou un entier (1 ou 2). DAC(1) est sur la broche X5 et DAC(2) est sur la broche X6. bits (int) -- La résolution, et peut être 8 ou 12. La valeur maximale pour les méthodes write et write_timed sera une mise en mémoire tampon de 2 ** bits-1 (bool ou Aucun) -- Le paramètre de mise en mémoire tampon sélectionne le comportement du tampon de sortie de l'amplificateur opérationnel DAC, dont le but est de réduire l'impédance de sortie. Il peut être Aucun pour sélectionner la valeur par défaut, Faux pour désactiver complètement la mise en mémoire tampon, ou True pour activer la mise en mémoire tampon de sortie. ",
    "pyb.DAC.init(bits=8, *, buffering=None)": " Réinitialiser le DAC. Paramètres : bits (int) -- La résolution, et peut être 8 ou 12. La valeur maximale pour le write et write_timed les méthodes seront 2**bits-1 buffering (bool ou None) -- Le paramètre de buffering sélectionne le comportement du buffer de sortie de l'ampli-op DAC, dont le but est de réduire l'impédance de sortie.Il peut être None pour sélectionner la valeur par défaut, False pour désactiver complètement la mise en mémoire tampon, ou True pour activer la mise en mémoire tampon de sortie. ",
    "pyb.DAC.deinit()": "Dé-initialiser le DAC en rendant son pin disponible pour d'autres usages. ",
    "pyb.DAC.noise(freq)": "Génère un signal de bruit pseudo-aléatoire. Un nouvel échantillon aléatoire est écrit sur la sortie du DAC à la fréquence donnée. Paramètres : freq (int) -- la fréquence à laquelle générer du bruit. ",
    "pyb.DAC.triangle(freq)": "Génère une onde triangulaire. La valeur sur la sortie DAC change à la fréquence donnée, et la fréquence de l'onde triangulaire répétée elle-même est 2048 fois plus petite. Paramètres : freq (int) - - la fréquence à laquelle générer l'onde. ",
    "pyb.DAC.write(value)": "Accès direct à la sortie du DAC. La valeur minimale est 0. La valeur maximale est 2**bits-1. Paramètres : value (int) -- la valeur à écrire dans le CAD ",
    "pyb.DAC.write_timed(data, freq, *, mode=DAC.NORMAL)": " Lance une rafale de RAM vers le DAC à l'aide d'un transfert DMA. Les données d'entrée sont traitées comme un tableau d'octets en mode 8 bits, et un tableau de demi-mots non signés (tableau typecode \u2018H\u2019) en mode 12 bits. Paramètres : data (array) -- données à écrire dans le DAC. freq (int ou Timer) -- fréquence ou Timer à déterminer à quelle fréquence déclencher le mode d'échantillonnage DAC (constant) -- peut être DAC.NORMAL ou DAC.CIRCULAR.",
    "pyb.ExtInt(pin, mode, pull, callback)": "Créez un objet ExtInt. Paramètres : pin (pyb.Pin) -- la broche sur laquelle activer l'interruption. mode (constant) peut être l'un des suivants : ExtInt .IRQ_RISING - déclenchement sur front montant ; ExtInt.IRQ_FALLING - déclenchement sur front descendant ; ExtInt.IRQ_RISING_FALLING - déclenchement sur front montant ou descendant. pull (constant) -- peut être l'un des éléments suivants : - pyb.Pin.PULL_NONE - non résistances pull up ou down ; pyb.Pin.PULL_UP - active la résistance pull-up ; pyb.Pin.PULL_DOWN - active la résistance pull-down. callback (fonction) -- la fonction à appeler lorsque l'interruption se déclenche. La fonction de rappel doit accepter exactement 1 argument, qui est la ligne qui a déclenché l'interruption. ",
    "pyb.ExtInt.regs()": "Imprime les valeurs des registres EXTI. ",
    "pyb.ExtInt.disable()": " Désactive l'interruption associée à l'objet ExtInt. ",
    "pyb.ExtInt.enable()": "Activer une interruption désactivée. ",
    "pyb.ExtInt.line()": " Renvoie le numéro de ligne auquel la broche est mappée. Renvoie : le numéro de ligne auquel la broche est mappée Type de retour : int ",
    "pyb.ExtInt.swint()": " Déclencher le rappel depuis le logiciel. ",
    "pyb.I2C(bus, ...)": "Construire un objet I2C sur le bus donné. bus peut être 1 ou 2, \u2018X\u2019 ou \u2018Y\u2019. Sans paramètres supplémentaires, l'objet I2C est créé mais pas initialisé. Si des arguments supplémentaires sont fournis, le bus est initialisé. Voir init pour les paramètres d'initialisation. Paramètres : bus (int ou string) -- le bus auquel s'attacher. Peut être 1 ou 2, \u2018X\u2019 ou \ u2018Y\u2019. ",
    "pyb.I2C.deinit()": "Désactiver le bus I2C. ",
    "pyb.I2C.init(mode, *, addr=0x12, baudrate=400000, gencall=False, dma=False)": " Initialiser le bus I2C avec les paramètres donnés Paramètres : mode (constant) -- doit être soit I2C .MASTER ou I2C.SLAVE addr (int) -- l'adresse 7 bits (uniquement sensible pour un esclave) baudrate (int) -- la fréquence d'horloge SCL (uniquement sensible pour un maître) gencall (bool) -- s'il faut prendre en charge mode d'appel général dma (bool) -- s'il faut autoriser l'utilisation du DMA pour les transferts I2C ",
    "pyb.I2C.is_ready(addr)": "Vérifiez si un périphérique I2C répond à l'adresse donnée. Valide uniquement en mode maître. Paramètres : addr (int) -- l'adresse à vérifier Retours : si l'adresse répond Type de retour : bool ",
    "pyb.I2C.mem_read(data, addr, memaddr, *, timeout=5000, addr_size=8)": "Lire depuis la mémoire d'un périphérique I2C Paramètres : data (int ou buffer) -- nombre d'octets à lire ou un tampon à lire dans addr (int) -- l'adresse du périphérique I2C memaddr (int) -- l'emplacement mémoire dans le délai d'expiration du périphérique I2C (int) le délai d'attente en millisecondes pour attendre la lecture addr_size (int) -- largeur de memaddr : 8 ou 16 bits Renvoie : les données lues. Ceci n'est valable qu'en mode maître. Type de retour : octets ",
    "pyb.I2C.mem_write(data, addr, memaddr, *, timeout=5000, addr_size=8)": "Écrire dans la mémoire d'un périphérique I2C Paramètres : data (int ou buffer) -- nombre d'octets à écrire ou un tampon pour écrire dans addr (int) -- l'adresse du périphérique I2C memaddr (int) -- l'emplacement mémoire dans le délai d'expiration du périphérique I2C (int) le délai d'attente en millisecondes pour attendre l'écriture addr_size (int) -- largeur de memaddr : 8 ou 16 bits",
    "pyb.I2C.recv(recv, addr=0x00, *, timeout=5000)": "Recevoir les données sur le bus. Paramètres : recv (int ou buffer) -- peut être le nombre d'octets à recevoir, ou un mutable buffer, qui sera rempli avec les octets reçus addr (int) -- l'adresse à recevoir de (uniquement requise en mode maître) timeout (int) -- le timeout en millisecondes pour attendre la réception Retours : si recv est un entier alors un nouveau buffer des octets reçus Type de retour : octets ",
    "pyb.I2C.send(send, addr=0x00, *, timeout=5000)": "Envoie les données sur le bus. Paramètres : send (int ou buffer) -- les données à envoyer addr (int) l'adresse à envoyer to (uniquement requis en mode maître) timeout (int) -- le délai d'attente en millisecondes pour attendre l'envoi ",
    "pyb.I2C.scan()": " Scanne toutes les adresses I2C de 0x01 à 0x7f et retourne une liste de celles qui répondent. Valable uniquement en mode maître. Renvoie : adresses I2C valides sur le bus Type de retour : liste ",
    // "pyb.LCD(skin_position)": "Construire un objet LCD dans la position de peau donnée. Paramètres : skin_position (string) -- peut être \u2018X\u2019 ou \u2018Y\u2019, et doit correspondre à la position où se trouve le pyskin LCD branché.  ",
    // "pyb.LCD.command(instr_data, buf)": "Envoie une commande arbitraire au contrôleur LCD. Paramètres : instr_data (int) -- 0 pour instr_data pour envoyer une instruction, sinon passez 1 pour envoyer des données buf (int ou buffer ) -- un buffer avec les instructions/données à envoyer ",
    // "pyb.LCD.contrast(value)": "Définir le contraste des paramètres LCD : value (int) -- la valeur de contraste, les valeurs valides sont comprises entre 0 et 47. ",
    // "pyb.LCD.fill(color)": " Remplit l'écran avec la couleur donnée. Paramètres : color (int) -- 0 ou 1 pour le blanc ou le noir respectivement. ",
    // "pyb.LCD.get(x, y)": " Récupère le pixel à la position (x, y) Paramètres : x (int) -- la coordonnée X y (int) -- la coordonnée Y Renvoie : la valeur du pixel , soit 0, soit 1. Type de retour : int ",
    // "pyb.LCD.light(value)": " Activer/désactiver le rétroéclairage. Paramètres : valeur (int ou bool) -- True ou 1 l'active, False ou 0 l'éteint. ",
    // "pyb.LCD.pixel(x, y, color)": "Définit le pixel en (x, y) sur la couleur donnée (0 ou 1). Paramètres : x (int) -- la coordonnée X y (int) -- la couleur de la coordonnée Y (int) -- la couleur. ",
    // "pyb.LCD.show()": "Afficher le tampon caché à l'écran. ",
    // "pyb.LCD.text(str, x, y, color)": " Dessine le texte donné à la position (x, y) en utilisant la couleur donnée (0 ou 1). Paramètres : str (string) -- le texte à afficher. x (int) -- la coordonnée X y (int) -- la couleur de la coordonnée Y (int) -- la couleur. ",
    // "pyb.LCD.write(str)": " Ecrivez la chaîne str à l'écran. Elle apparaîtra immédiatement. Paramètres : str (string) -- le texte à afficher. ",
    "pyb.LED(id)": "Créez un objet LED associé aux paramètres LED donnés : id (int) -- le numéro de la LED, 1-4 ",
    "pyb.LED.intensity([value])": "Obtenir ou définir l'intensité de la LED. Si aucun argument n'est donné, renvoie l'intensité de la LED. Paramètres : value (int) [facultatif] -- la valeur d'intensité est comprise entre 0 (off ) et 255 (plein allumé) Retours : Aucun ou intensité LED Type de retour : Aucun ou int ",
    "pyb.LED.off()": "Éteignez la LED. ",
    "pyb.LED.on()": " Allumez la LED. ",
    "pyb.LED.toggle()": " Basculez la LED entre on (intensité maximale) et off. Si la LED est à une intensité non nulle, elle est considérée comme \u201con\u201d et la bascule l'éteint. ",
    "pyb.Pin(id, ...)": "Créez un nouvel objet Pin associé à l'id. Si des arguments supplémentaires sont donnés, ils sont utilisés pour initialiser le pin. Voir pyb.Pin.init() Paramètres : id ( constante ou chaîne) -- l'identifiant de la broche à utiliser ",
    "pyb.Pin.debug([state])": "Obtenir ou définir l'état de débogage Paramètres : state (bool) [facultatif] -- l'état de débogage à définir, le cas échéant. Renvoie : si l'état de débogage est défini (si rien n'est passé à la méthode) Type de retour : bool ",
    "pyb.Pin.init(mode, pull=Pin.PULL_NONE, af=-1)": "Initialiser les paramètres de la broche : mode (constant) -- peut être l'un des suivants : Pin.IN, Pin.OUT_PP, Pin.OUT_OD , Pin.AF_PP, Pin.AF_OD, Pin.ANALOG pull (constant) -- peut être l'un des suivants : Pin.PULL_NONE, Pin.PULL_UP, Pin.PULL_DOWN af (int) -- lorsque le mode est Pin.AF_PP ou Pin.AF_OD , alors af peut être l'index ou le nom de l'une des fonctions alternatives associées à une broche ",
    "pyb.Pin.value([value])": "Obtenir ou définir le niveau logique numérique de la broche Paramètres : valeur (int ou bool) [facultatif] -- si la valeur est convertie en True, la broche est définie sur un niveau haut, sinon il est mis bas Retours : sans argument, retourne 0 ou 1 selon le niveau logique de la broche Type de retour : int ",
    "pyb.Pin.af()": " Renvoie la fonction alternative actuellement configurée de la broche Renvoie : une des représentations entières des constantes autorisées pour af Type de retour : int ",
    "pyb.Pin.af_list()": " Renvoie un tableau de fonctions alternatives disponibles pour cette broche. Renvoie : tableau de fonctions alternatives disponibles Type de retour : liste ",
    "pyb.Pin.gpio()": " Renvoie l'adresse de base du bloc GPIO associé à cette broche. Renvoie : l'adresse de base du bloc GPIO Type de retour : int ",
    "pyb.Pin.mode()": " Renvoie le mode actuellement configuré de la broche. Renvoie : l'entier renvoyé correspondra à l'une des constantes autorisées pour le mode Type de retour : int ",
    "pyb.Pin.name()": " Renvoie le nom de la broche. Renvoie : le nom de la broche Type de retour : chaîne ",
    "pyb.Pin.names()": " Renvoie les noms de carte et de processeur pour la broche. Renvoie : les noms de la broche Type de retour : liste ",
    "pyb.Pin.pin()": " Renvoie le numéro de broche du CPU. Renvoie : le numéro de la broche Type de retour : int ",
    "pyb.Pin.port()": " Renvoie le numéro de port CPU. Renvoie : le numéro du port Type de retour : int ",
    "pyb.Pin.pull()": " Renvoie le pull actuellement configuré de la broche. Retour : L'entier renvoyé correspondra à l'une des constantes autorisées pour le pull Type de retour : int ",
    "pyb.RTC()": "Créer un objet RTC. ",
    "pyb.RTC.datetime([datetimetuple])": "Obtenir ou définir la date et l'heure du RTC. Sans arguments, cette méthode renvoie un 8-uplet avec la date et l'heure actuelles. Avec 1 argument (étant un 8 -tuple) il définit la date et l'heure Paramètres : datetimetuple (tuple) [facultatif] -- Le 8-tuple a le format suivant : (année, mois, jour, jour de la semaine, heures, minutes, secondes, sous-secondes). Tous les éléments de tuple sont des entiers Renvoie : la date et l'heure courantes Type de retour : tuple (8 éléments) ",
    "pyb.RTC.wakeup(timeout, callback=None)": "Définissez la minuterie de réveil RTC pour qu'elle se déclenche à plusieurs reprises à chaque expiration de millisecondes. Ce déclencheur peut sortir le pyboard des deux états de veille : pyb.stop() et pyb.standby () Paramètres : timeout (int ou None) -- timeout en millisecondes ou None pour désactiver le rappel du minuteur (fonction ou None) -- si le rappel est donné, il est exécuté à chaque déclenchement du minuteur de réveil. le rappel doit prendre exactement un argument ",
    "pyb.RTC.info()": "Obtenir des informations sur l'heure de démarrage et la source de réinitialisation Renvoie : Informations RTC : 0xffff inférieur correspond au nombre de millisecondes que le RTC a pris pour démarrer, le bit 0x10000 est défini si une réinitialisation à la mise sous tension s'est produite , le bit 0x20000 est activé si une réinitialisation externe s'est produite Type de retour : int ",
    "pyb.RTC.calibration([cal])": " Obtenez ou définissez l'étalonnage RTC. Paramètres : cal (int) [facultatif] -- La plage d'étalonnage utilisable est: (-511 * 0, 954) ~= -487, 5 ppm jusqu'à (512 * 0,954) ~= 488,5 ppm Renvoie : sans argument, la valeur d'étalonnage actuelle, dans la plage[-511 : 512]Type de retour: int ",
    // "pyb.Servo(id)": "Créez un objet servo. Paramètres : id (int) -- peut être compris entre 1 et 4 et correspond aux broches X1 à X4. ",
    // "pyb.Servo.angle([angle, time=0])": "Si des arguments sont donnés, définit l'angle du servo Si aucun argument n'est donné, obtient l'angle du servo. Paramètres : angle (float ou int) [optionnel] -- l'angle de déplacement en degrés. time (int) -- le nombre de millisecondes à prendre pour atteindre l'angle spécifié. S'il est omis, le servo se déplace le plus rapidement possible vers sa nouvelle position. Renvoie : l'angle actuel du servo (si aucun argument n'est donné) Type de retour : float ",
    // "pyb.Servo.speed([speed, time=0])": "Si aucun argument n'est donné, renvoie la vitesse actuelle. Si des arguments sont donnés, définit la vitesse du servo. Paramètres : speed (int) -- le vitesse à changer, entre -100 et 100. time (int) -- le nombre de millisecondes à prendre pour atteindre la vitesse spécifiée. S'il est omis, le servo accélère le plus rapidement possible. Renvoie : la vitesse actuelle du servo (si aucun argument n'est donné) Type de retour : int ",
    // "pyb.Servo.pulse_width([value])": "Si aucun argument n'est fourni, renvoie la valeur brute actuelle de la largeur d'impulsion. Si un argument est fourni, définit la valeur brute de la largeur d'impulsion. Paramètres : valeur (int) [ optionnel] -- la valeur de largeur d'impulsion souhaitée. Renvoie : la valeur brute actuelle de la largeur d'impulsion (si aucun argument n'est fourni) Type de retour : int ",
    "pyb.SPI(bus, ...)": "Construire un objet SPI sur le bus donné. Sans paramètres supplémentaires, l'objet SPI est créé mais pas initialisé. Si des arguments supplémentaires sont fournis, le bus est initialisé. Voir init pour les paramètres d'initialisation Paramètres : bus (int ou string) -- peut être 1 ou 2, ou \u2018X\u2019 ou \u2018Y\u2019 SPI(1) est sur la position X : (NSS, SCK, MISO, MOSI) = (X5, X6, X7, X8) = (PA4, PA5, PA6, PA7) SPI(2) est sur la position Y : (NSS, SCK, MISO, MOSI) = (Y5, Y6, Y7, Y8) = (PB12, PB13, PB14, PB15) ",
    "pyb.SPI.deinit()": "Désactiver le bus SPI. ",
    "pyb.SPI.init(mode, baudrate=328125, *, prescaler, polarity=1, phase=0, bits=8, firstbit=SPI.MSB, ti=False, crc=None)": " Initialiser le bus SPI avec les paramètres donnés Paramètres : mode (constant) -- doit être soit SPI.MASTER soit SPI.SLAVE. baudrate (int) -- la fréquence d'horloge SCK (uniquement sensible pour un maître). prescaler (int) -- le prescaler à utiliser pour dériver SCK de la fréquence du bus APB, outrepasse la vitesse de transmission. polarité (int) -- peut être 0 ou 1, le niveau auquel se trouve la ligne d'horloge inactive. phase (int) -- 0 ou 1 pour échantillonner les données sur le premier ou deuxième front d'horloge respectivement. bits (int) -- 8 ou 16, et est le nombre de bits dans chaque mot transféré. firstbit (constant) -- peut être SPI.MSB ou SPI.LSB crc (Aucun) -- peut être Aucun pour aucun CRC, ou un spécificateur polynomial. ",
    "pyb.SPI.recv(recv, *, timeout=5000)": " Recevoir des données sur le bus Paramètres : recv (int ou buffer) -- peut être le nombre d'octets à recevoir, ou un buffer mutable, qui sera rempli avec les octets reçus. timeout (int) -- le délai d'attente en millisecondes pour attendre la réception. Renvoie : si recv est un entier, alors un nouveau tampon des octets reçus, sinon le même tampon qui a été transmis à recv, Type de retour : amortir  ",
    "pyb.SPI.send(send, *, timeout=5000)": "Envoyer des données sur le bus Paramètres : envoyer (octets) -- les données à envoyer (un entier à envoyer ou un objet tampon) timeout (int) -- le timeout en millisecondes pour attendre l'envoi ",
    "pyb.SPI.send_recv(send, recv=None, *, timeout=5000)": "Envoie et reçoit des données sur le bus en même temps Paramètres : envoyer (octets) -- les données à envoyer (un entier à envoyer , ou un objet tampon) recv (buffer) -- un tampon mutable qui sera rempli avec les octets reçus. Il peut être identique à send, ou omis. S'il est omis, un nouveau tampon sera créé timeout (int) -- le timeout en millisecondes pour attendre la réception. Renvoie : buffer avec les octets reçus. Type de retour : octets ",
    "pyb.Switch()": "Créer et renvoyer un objet commutateur. Renvoie : objet commutateur Type de retour : classe commutateur ",
    "pyb.Switch.value()": " Récupère l'état actuel du commutateur. Renvoie : Vrai si enfoncé, False sinon. Type de retour : bool ",
    "pyb.Switch.callback(fun)": " Enregistre la fonction donnée à appeler lorsque le commutateur est enfoncé Paramètres : fun (function) -- la fonction à exécuter ou None. Si fun est None, alors il désactive le rappel . ",
    "pyb.Timer(id, ...)": " Construire un nouvel objet timer de l'identifiant donné. Si des arguments supplémentaires sont donnés, alors le timer est initialisé par init (...). Paramètres : id (int) - - peut être de 1 à 14. ",
    "pyb.Timer.init(*, freq, prescaler, period)": " Initialise le timer. L'initialisation doit être soit par fréquence (en Hz) soit par prescaler et period Paramètres : freq (int) -- spécifie la fréquence périodique de le timer. prescaler (int) -- [0-0xffff] spécifie la valeur à charger dans le timer\u2019s Prescaler Register (PSC). La source d'horloge du timer est divisée par prescaler + 1 période (int) -- [0- 0xffff] pour les temporisateurs 1, 3, 4 et 6 à 15. [0-0x3fffffff] pour les temporisateurs 2 et 5. Spécifie la valeur à charger dans le registre de rechargement automatique du temporisateur (ARR) ",
    "pyb.Timer.deinit()": " Désinitialise le timer, le callback et les callbacks de canal associés au Timer ",
    "pyb.Timer.counter([value])": "Obtenez ou définissez le compteur de la minuterie. ",
    "pyb.Timer.freq([value])": "Obtenir ou définir la fréquence de la minuterie (modifie le pré-échelonneur et la période si elle est définie). ",
    "pyb.Timer.period([value])": "Obtenir ou définir la période de la minuterie. ",
    "pyb.Timer.prescaler([value])": "Obtenir ou définir le prescaler pour la minuterie. ",
    "pyb,Timer.source_freq()": " Récupère la fréquence de la source du timer. ",
    "pyb.UART(bus, ...)": "Construire un objet UART sur le bus donné. Sans paramètres supplémentaires, l'objet UART est créé mais pas initialisé. Si des arguments supplémentaires sont fournis, le bus est initialisé. Voir init pour les paramètres d'initialisation. Paramètres : bus (int ou string) -- peut être 1-6, ou \u2018XA\u2019, \u2018XB\u2019, \u2018YA\u2019, ou \u2018YB\u2019. ",
    "pyb.UART.init(baudrate, bits=8, parity=None, stop=1, *, timeout=1000, flow=0, timeout_char=0, read_buf_len=64)": "Initialiser le bus UART avec les paramètres donnés Paramètres : baudrate (int) -- la fréquence d'horloge bits (int) -- le nombre de bits par caractère, 7, 8 ou 9 parité (int) -- la parité, None, 0 (pair) ou 1 (impair) stop (int) -- le nombre de bits d'arrêt, 1 ou 2 flow (int) -- le type de contrôle de flux. Peut être 0, UART.RTS, UART.CTS ou UART.RTS | UART.CTS timeout (int) -- le délai d'attente en millisecondes pour l'écriture/lecture du premier caractère timeout_char (int) -- le délai d'attente en millisecondes entre les caractères lors de l'écriture ou de la lecture. read_buf_len (int) -- la longueur de caractère du tampon de lecture (0 pour désactiver) ",
    "pyb.UART.deinit()": "Désactiver le bus UART. ",
    "pyb.UART.any()": " Renvoie le nombre d'octets en attente (peut être 0). ",
    "pyb.UART.read([nbytes])": "Lire les caractères. Si nbytes est spécifié, alors lire au plus autant d'octets. Si nbytes n'est pas donné, la méthode lit autant de données que possible. écoulé. Paramètres : nbytes (int) [optionnel] -- nombre d'octets à tenter de renvoyer Renvoie : un objet bytes contenant les octets lus, Aucun à l'expiration. Type de retour : octets ou Aucun",
    "pyb.UART.readchar()": " Reçoit un seul caractère sur le bus. Renvoie : le caractère lu, sous forme d'entier, renvoie -1 à l'expiration du délai. Type de retour : int ",
    "pyb.UART.readinto(buf[, nbytes])": "Lire les octets dans les paramètres buf : buf (buffer) -- tampon pour stocker les octets en noctets (int) [facultatif] -- si spécifié, lire au plus cela de nombreux octets, sinon, lisez au plus len(buf) octets Renvoie : nombre d'octets lus et stockés dans buf ou Aucun à l'expiration du délai Type de retour : int ",
    "pyb.UART.readline()": "Lire une ligne, se terminant par un caractère de nouvelle ligne. Si une telle ligne existe, le retour est immédiat. Si le délai d'attente s'écoule, toutes les données disponibles sont renvoyées, qu'une nouvelle ligne existe ou non. Renvoie : la ligne lue ou None sur timeout si aucune donnée n'est disponible Type de retour : bytes ",
    "pyb.UART.write(buf)": " Ecrit le tampon d'octets sur le bus. Paramètres : buf (buffer) -- si les caractères ont une largeur de 7 ou 8 bits alors chaque octet est un caractère. Si les caractères ont une largeur de 9 bits alors deux octets sont utilisés pour chaque caractère (petit endian et buf doivent contenir un nombre pair d'octets Renvoie : nombre d'octets écrits. Si un délai d'attente se produit et qu'aucun octet n'a été écrit, renvoie Aucun Type de retour : int ",
    "pyb.UART.writechar(char)": " Écrire un seul caractère sur le bus Paramètres : char (int) -- l'entier à écrire ",
    "pyb.UART.sendbreak()": "Envoie une condition de pause sur le bus. Cela entraîne le bus à l'état bas pendant une durée de 13 bits. ",
    "pyb.USB_HID()": "Créez un nouvel objet USB_HID. ",
    "pyb.USB_HID.recv(data, *, timeout=5000)": " Recevoir des données sur le bus Paramètres : les données peuvent être un entier, qui est le nombre d'octets à recevoir, ou un tampon mutable (int ou buffer) - - qui sera rempli avec les octets reçus timeout (int) -- le délai d'attente en millisecondes pour attendre la réception Retours : si data est un entier alors un nouveau buffer des octets reçus, sinon le nombre d'octets lus dans les données est retourné Type de retour : int ou buffer ",
    "pyb.USB_HID.send(data)": "Envoyer des données via les paramètres de l'interface USB HID : data (multiple) -- les données à envoyer (un tuple/une liste d'entiers ou un tableau d'octets) ",
    "pyb.USB_VCP()": "Créer un nouvel objet USB_VCP",
    "pyb.USB_VCP.setinterrupt(chr)": "Définir le caractère qui interrompt l'exécution du code Python, défini sur 3 (CTRL-C) par défaut. ",
    "pyb.USB_VCP.isconnected()": " Si l'USB est connecté en tant que périphérique série Renvoie : True si USB est connecté en tant que périphérique série, sinon False Type de retour : bool ",
    "pyb.USB_VCP.any()": " Si des caractères sont en attente Renvoie : True si des caractères attendent, sinon False Type de retour : bool ",
    "pyb.USB_VCP.close()": "Cette méthode ne fait rien. Elle existe donc l'objet USB_VCP peut agir comme un fichier. ",
    "pyb.USB_VCP.read([nbytes])": "Lire au plus nbytes à partir du périphérique série et les renvoyer en tant qu'objet bytes ",
    "pyb.USB_VCP.readinto(buf[, maxlen])": "Lire les octets du périphérique série et les stocker dans buf Paramètres : buf (buffer) -- un objet de type tampon à lire dans maxlen (int) -- si maxlen est donné, puis au plus min(maxlen, len(buf)) octets sont lus Renvoie : le nombre d'octets lus et stockés dans buf ou Aucun si aucune donnée en attente n'est disponible Type de retour : int ",
    "pyb.USB_VCP.readline()": " Lit une ligne entière depuis le périphérique série. Renvoie : un objet octets contenant les données Type de retour : octets ",
    "pyb.USB_VCP.readlines()": " Lire autant de données que possible à partir du périphérique série, en les divisant en lignes Renvoie : une liste d'objets octets, chaque objet étant l'une des lignes Type de retour : liste ",
    "pyb.USB_VCP.write(buf)": "Écrire les octets de buf vers le périphérique série. ",
    "pyb.USB_VCP.recv(data, *, timeout=5000)": "Recevoir les données sur le bus Paramètres : data (int ou buffer) -- le nombre d'octets à recevoir, ou un buffer mutable, qui sera rempli avec délai d'attente des octets reçus (int) -- le délai d'attente en millisecondes pour attendre la réception Retourne : si les données sont un entier alors un nouveau tampon des octets reçus, sinon le nombre d'octets lus dans les données est renvoyé Type de retour : int ou buffer ",
    "pyb.USB_VCP.send(data, *, timeout=5000)": "Envoyer des données sur le VCP USB : Paramètres : data (int of buffer) -- les données à envoyer timeout (int) -- le timeout en millisecondes vers attendre l'envoi. Renvoie : le nombre d'octets envoyés Type de retour : int ",
    "machine": "bibliothèque machine.",
    "machine.reset()": "Réinitialise l'appareil d'une manière similaire à appuyer sur le bouton RESET externe",
    "machine.freq()": "Renvoie la fréquence du processeur en hertz.",
    "machine.Pin(id [, mode, pull])": "Créer un objet Pin. Seul l'identifiant est obligatoire. mode (facultatif) : spécifie le mode de la broche (Pin.OUT ou Pin.IN) pull (facultatif) : spécifie si la broche a une résistance de tirage attachée, la traction peut être l'une des suivantes : Aucun, Pin.PULL_UP ou Pin.PULL_DOWN.",
    "machine.Pin.value([x])": "Cette méthode permet de définir et d'obtenir la valeur de la broche, selon que l'argument x est fourni ou non. Si l'argument est omis, la méthode renvoie l'entrée réelle valeur (0 ou 1) sur la broche. Si l'argument est fourni, la méthode définit la sortie sur la valeur donnée.",
    "machine.Pin.OUT ": "",
    "machine.Pin.IN ": "",
    "machine.Pin.PULL_UP ": "",
    "machine.Pin.PULL_DOWN ": "",
    "machine.ADC(pin)": "Créer un objet ADC associé à la broche donnée. Cela vous permet ensuite de lire des valeurs analogiques sur cette broche. machine.ADC(machine.Pin(39))",
    "machine.ADC.read()": "Lire la valeur de la broche analogique.\\n\\nadc = machine.ADC(machine.Pin(39))\\nvalue = adc.read()",
    "random": "bibliothèque random.",
    "random.getrandbits(n)": "Renvoyer un entier avec n bits aléatoires.",
    "random.seed(n)": "Initialiser le générateur de nombres aléatoires avec un entier connu 'n'.",
    "random.randint(a, b)": "Renvoyer un nombre entier aléatoire entre a et b (inclus).",
    "random.randrange(stop)": "Renvoyer un nombre entier aléatoire compris entre 0 et jusqu'à (mais sans inclure) stop.",
    "random.choice(seq)": "Renvoyer un élément sélectionné au hasard à partir d'une séquence d'objets (comme une liste).",
    "random.random()": "Renvoyer un nombre à virgule flottante aléatoire entre 0.0 et 1.0.",
    "random.uniform(a, b)": "Renvoyer un nombre à virgule flottante aléatoire entre a et b (inclus).",
    "os": "bibliothèque os.",
    "os.listdir()": "Renvoyer une liste des noms de tous les fichiers contenus dans le système de fichiers local\\non-périphérique.",
    "os.remove(filename)": "Supprimer (supprimer) le fichier nommé filename.",
    "os.size(filename)": "Renvoyer la taille, en octets, du fichier nommé filename.",
    "os.uname()": "Renvoyer des informations sur MicroPython et l'appareil.",
    "os.getcwd()": "Renvoyer le répertoire de travail courant",
    "os.chdir(path)": "Changer le répertoire de travail courant",
    "os.mkdir(path)": "Créer un nouveau répertoire",
    "os.rmdir(chemin)": "Supprimer le répertoire",
    "os.listdir(path='.')": "Renvoyer la liste des répertoires. Par défaut le répertoire de travail actuel.",
    "math": "bibliothèque de mathématiques.",
    "math.sqrt(x)": "Renvoyer la racine carrée de 'x'.",
    "math.pow(x, y)": "Renvoyer 'x' élevé à la puissance 'y'.",
    "math.exp(x)": "Retour math.e**'x'.",
    "math.log(x, base=math.e)": "Avec un argument, renvoie le logarithme népérien de 'x' (en base e).\\nAvec deux arguments, renvoie le logarithme de 'x' à la donnée 'base'.",
    "math.cos(x)": "Renvoyer le cosinus de 'x' radians.",
    "math.sin(x)": "Renvoyer le sinus de 'x' radians.",
    "math.tan(x)": "Renvoyer la tangente de 'x' radians.",
    "math.acos(x)": "Renvoyer l'arc cosinus de 'x', en radians.",
    "math.asin(x)": "Renvoyer l'arc sinus de 'x', en radians.",
    "math.atan(x)": "Renvoyer l'arc tangent de 'x', en radians.",
    "math.atan2(x, y)": "Renvoyer atan(y / x en radians.",
    "math.ceil(x)": "Renvoyer le plafond de 'x', le plus petit entier supérieur ou égal à 'x'.",
    "math.copysign(x, y)": "Renvoyer un flottant avec la magnitude (valeur absolue) de 'x' mais le signe de 'y'.",
    "math.fabs(x)": "Renvoyer la valeur absolue de 'x'.",
    "math.floor(x)": "Renvoyer le plancher de 'x', le plus grand entier inférieur ou égal à 'x'.",
    "math.fmod(x, y)": "Renvoyer 'x' modulo 'y'.",
    "math.frexp(x)": " Renvoie la mantisse et l'exposant de 'x' comme la paire (m, e).",
    "math.ldexp(x, i)": "Renvoyer 'x' * (2**'i').",
    "math.modf(x)": "Renvoyer les parties fractionnaire et entière de x.\\nLes deux résultats portent le signe de x et sont des nombres flottants.",
    "math.isfinite(x)": "Renvoyer True si 'x' n'est ni un infini ni un NaN, et False sinon.",
    "math.isinf(x)": "Renvoyer True si 'x' est un infini positif ou négatif, et False sinon.",
    "math.isnan(x)": "Renvoyer True si 'x' est un NaN (pas un nombre et False sinon.",
    "math.trunc(x)": "Renvoyer la valeur réelle 'x' tronquée à un Intégral (généralement un entier).",
    "math.radians(x)": "Convertir l'angle 'x' de degrés en radians.",
    "math.degrees(x)": "Convertir l'angle 'x' de radians en degrés.",
    "sys": "bibliothèque sys.",
    "sys.version": "Renvoyer la version Python sous forme de chaîne",
    "sys.version_info": "Renvoyer la version Python sous forme de tuple",
    "sys.implementation": "Renvoyer la version MicroPython",
    "sys.platform": "Renvoyer la plate-forme matérielle sous forme de chaîne, par exemple 'esp8266' ou 'esp32'",
    "sys.byteorder": "Renvoyer l'endian de la plate-forme. 'little' pour l'octet le moins significatif en premier ou 'big' pour l'octet le plus significatif en premier.",
    "sys.print_exception(ex)": "Imprimer dans le REPL les informations sur l'exception 'ex'.",
    "time": "bibliothèque time.",
    "time.sleep(seconds)": "Veuillez dormir le nombre de secondes indiqué.",
    "time.sleep_ms(milliseconds)": "Dormir le nombre de millisecondes indiqué.",
    "time.sleep_us(milliseconds)": "Dormir le nombre de microsecondes indiqué.",
    "time.ticks_ms()": " Renvoie le nombre de millisecondes à partir d'un compteur croissant. Reboucle après une certaine valeur. ",
    "time.ticks_us()": " Renvoie le nombre de microsecondes à partir d'un compteur croissant. Reboucle après une certaine valeur. ",
    "time.ticks_diff()": "Calculer la différence entre les valeurs des graduations obtenues à partir de time.ticks_ms() et time.ticks_us().",
    "time.time()": "Renvoie le nombre de secondes, sous forme d'entier, depuis l'époque, en supposant que le RTC sous-jacent est défini et maintenu. Si un RTC n'est pas défini, cette fonction renvoie le nombre de secondes depuis un port spécifique point de référence dans le temps (généralement depuis le démarrage ou la réinitialisation).",
    // "network": "bibliothèque réseau.",
    // "network.WLAN(interface_id)": "Créez un objet d'interface WLAN. Les interfaces prises en charge sont : network.STA_IF (station aka client, se connecte aux points d'accès WiFi en amont) et network.AP_IF (mode point d'accès, permet à d'autres clients WiFi de se connecter ).",
    // "network.WLAN.STA_IF ": "",
    // "network.WLAN.AP_IF": "",
    // "network.WLAN.active([ is_active ])": "Active ou désactive l'interface réseau lorsqu'un argument booléen est donné. Lorsque l'argument est omis, la fonction renvoie l'état actuel.",
    // "network.WLAN.connect(ssid, password)": "Connectez-vous au réseau sans fil spécifié à l'aide du mot de passe spécifié.",
    // "network.WLAN.disconnect()": "Déconnectez-vous du réseau sans fil actuellement connecté.",
    // "network.WLAN.scan()": " Recherche les réseaux sans fil disponibles. La recherche n'est possible que sur l'interface STA. Renvoie la liste des tuples avec les informations sur les points d'accès WiFi : (ssid, bssid, channel, RSSI, authmode, hidden )",
    // "network.WLAN.status()": "Renvoyer l'état actuel de la connexion sans fil. Valeurs possibles : - STAT_IDLE (pas de connexion et pas d'activité) - STAT_CONNECTING (connexion en cours) - STAT_WRONG_PASSWORD (échec en raison d'un mot de passe incorrect - STAT_NO_AP_FOUND ( a échoué car aucun point d'accès n'a répondu - STAT_CONNECT_FAIL (échec en raison d'autres problèmes - STAT_GOT_IP (connexion réussie)",
    // "network.WLAN.isconnected()": "En cas de mode STA, renvoie True si connecté à un point d'accès WiFi et possède une adresse IP valide. En mode AP renvoie True lorsqu'une station est connectée. Renvoie False sinon.",
    // "network.WLAN.ifconfig([ (ip, subnet, gateway, dns) ])": "Obtenir/définir les paramètres de l'interface réseau au niveau IP : adresse IP, masque de sous-réseau, passerelle et serveur DNS. Appelé sans argument, ce La méthode renvoie un tuple de 4 avec les informations ci-dessus. Pour définir les valeurs ci-dessus, transmettez un tuple de 4 avec les informations requises. Par exemple : nic = network.WLAN(network.WLAN.AP_IF) nic.ifconfig(('192.168. 0.4', '255.255.255.0', '192.168.0.1', '8.8.8.8'))",
    "utime": "bibliothèque utime",
    "utime.localtime([secs])": "Convertir un temps exprimé en secondes depuis l'époque (voir ci-dessus) en un tuple de 8 qui contient : (année, mois, mday, heure, minute, seconde, jour de la semaine, jour de l'année) ",
    "utime.mktime()": " Il renvoie un entier qui est le nombre de secondes depuis le 1er janvier 2000.",
    "utime.sleep(seconds)": "Veille pendant le nombre de secondes donné.",
    "utime.sleep_ms(ms)": "Le délai pour un nombre donné de millisecondes, doit être positif ou 0.",
    "utime.sleep_us(us)": "Délai pour un nombre donné de microsecondes, doit être positif ou 0",
    "utime.ticks_ms()": "Renvoie un compteur de millisecondes croissant avec un point de référence arbitraire, qui revient après une certaine valeur.",
    "utime.time()": "Renvoie le nombre de secondes, sous forme d'entier, depuis l'époque, en supposant que le RTC sous-jacent est défini et maintenu comme décrit ci-dessus",
    "ubluetooth": "bibliothèque bluetooth",
    "ubluetooth.BLE": "Retourne un object de type BLE.",
    "ubluetooth.BLE.active([ active ])": "Change l'état de l'activation de la radio BLE, retourne l'état courant.",
};

const ARDUINO_TIPS_FR = {
    "pinMode": "Définir le mode d'une broche.",
    "digitalRead": "Lire la broche numérique.",
    "digitalWrite": "Écrire sur la broche numérique.",
    "analogRead": "Lire la broche analogique.",
    "analogWrite": "Écrire sur la broche analogique.",
    "analogReference": "Configurer la tension de référence utilisée sur l'entrée analogique.",
    "tone": "Génère un signal carré à la fréquence spécifiée (à 50% du cycle) sur une broche.",
    "noTone": "Arrête la génération du signal carré déclenché par tone().",
    "random": "Génère un nombre aléatoire.",
    "randomSeed": "Initialise le générateur de nombre aléatoire.",
    "delay": "Effectue une pause dans le programme d'une certaine durée (en millisecondes).",
    "delayMicroseconds": "Effectue une pause dans le programme d'une certaine durée (en microsecondes).",
    "micros": "Renvoie la durée (en microsecondes) depuis que la carte Arduino a démarré l'exécution du programme.",
    "millis": "Renvoie la durée (en millisecondes) depuis que la carte Arduino a démarré l'exécution du programme."
};

const ARDUINO_TIPS_EN = {
    "pinMode": "Configures the specified pin to behave either as an input or an output.",
    "digitalRead": "Reads the value from a specified digital pin, either HIGH or LOW.",
    "digitalWrite": "Write a HIGH or a LOW value to a digital pin.",
    "analogRead": "Reads the value from the specified analog pin",
    "analogWrite": "Writes an analog value (PWM wave) to a pin.",
    "analogReference": "Configures the reference voltage used for analog input.",
    "tone": "Generates a square wave of the specified frequency (and 50% duty cycle) on a pin.",
    "noTone": "Stops the generation of a square wave triggered by tone().",
    "random": "The random function generates pseudo-random numbers.",
    "randomSeed": "Initializes the pseudo-random number generator",
    "delay": "Pauses the program for the amount of time (in milliseconds) specified as parameter.",
    "delayMicroseconds": "Pauses the program for the amount of time (in microseconds) specified by the parameter.",
    "micros": "Returns the number of microseconds since the Arduino board began running the current program.",
    "millis": "Returns the number of milliseconds passed since the Arduino board began running the current program."
};

/**
 *  ESP MicroPython libraries and metadata for descriptions (FRENCH)
 */
const MICROPYTHON_TIPS_FR = {
    "random": "bibliothèque random.",
    "random.getrandbits(n)": "Renvoyer un entier avec n bits aléatoires.",
    "random.seed(n)": "Initialiser le générateur de nombres aléatoires avec un entier connu 'n'.",
    "random.randint(a, b)": "Renvoyer un nombre entier aléatoire entre a et b (inclus).",
    "random.randrange(stop)": "Renvoyer un nombre entier aléatoire compris entre 0 et jusqu'à (mais sans inclure) stop.",
    "random.choice(seq)": "Renvoyer un élément sélectionné au hasard à partir d'une séquence d'objets (comme une liste).",
    "random.random()": "Renvoyer un nombre à virgule flottante aléatoire entre 0.0 et 1.0.",
    "random.uniform(a, b)": "Renvoyer un nombre à virgule flottante aléatoire entre a et b (inclus).",
    "os": "bibliothèque os.",
    "os.listdir()": "Renvoyer une liste des noms de tous les fichiers contenus dans le système de fichiers local\\non-périphérique.",
    "os.remove(filename)": "Supprimer (supprimer) le fichier nommé filename.",
    "os.size(filename)": "Renvoyer la taille, en octets, du fichier nommé filename.",
    "os.uname()": "Renvoyer des informations sur MicroPython et l'appareil.",
    "os.getcwd()": "Renvoyer le répertoire de travail courant",
    "os.chdir(path)": "Changer le répertoire de travail courant",
    "os.mkdir(path)": "Créer un nouveau répertoire",
    "os.rmdir(chemin)": "Supprimer le répertoire",
    "os.listdir(path='.')": "Renvoyer la liste des répertoires. Par défaut le répertoire de travail actuel.",
    "sys": "bibliothèque sys.",
    "sys.version": "Renvoyer la version Python sous forme de chaîne",
    "sys.version_info": "Renvoyer la version Python sous forme de tuple",
    "sys.implementation": "Renvoyer la version MicroPython",
    "sys.platform": "Renvoyer la plate-forme matérielle sous forme de chaîne, par exemple 'esp8266' ou 'esp32'",
    "sys.byteorder": "Renvoyer l'endian de la plate-forme. 'little' pour l'octet le moins significatif en premier ou 'big' pour l'octet le plus significatif en premier.",
    "sys.print_exception(ex)": "Imprimer dans le REPL les informations sur l'exception 'ex'.",
    "machine": "bibliothèque machine.",
    "machine.reset()": "Réinitialise l'appareil d'une manière similaire à appuyer sur le bouton RESET externe",
    "machine.freq()": "Renvoie la fréquence du processeur en hertz.",
    "machine.Pin(id [, mode, pull])": "Créer un objet Pin. Seul l'identifiant est obligatoire. mode (facultatif) : spécifie le mode de la broche (Pin.OUT ou Pin.IN) pull (facultatif) : spécifie si la broche a une résistance de tirage attachée, la traction peut être l'une des suivantes : Aucun, Pin.PULL_UP ou Pin.PULL_DOWN.",
    "machine.Pin.value([x])": "Cette méthode permet de définir et d'obtenir la valeur de la broche, selon que l'argument x est fourni ou non. Si l'argument est omis, la méthode renvoie l'entrée réelle valeur (0 ou 1) sur la broche. Si l'argument est fourni, la méthode définit la sortie sur la valeur donnée.",
    "machine.Pin.OUT ": "",
    "machine.Pin.IN ": "",
    "machine.Pin.PULL_UP ": "",
    "machine.Pin.PULL_DOWN ": "",
    "machine.ADC(pin)": "Créer un objet ADC associé à la broche donnée. Cela vous permet ensuite de lire des valeurs analogiques sur cette broche. machine.ADC(machine.Pin(39))",
    "machine.ADC.read()": "Lire la valeur de la broche analogique.\\n\\nadc = machine.ADC(machine.Pin(39))\\nvalue = adc.read()",
    "time": "bibliothèque time.",
    "time.sleep(seconds)": "Veille pendant le nombre de secondes donné.",
    "time.sleep_ms(ms)": "Délai pour un nombre donné de millisecondes, doit être positif ou 0.",
    "time.sleep_us(us)": "Délai pour un nombre donné de microsecondes, doit être positif ou 0",
    "time.ticks_ms()": " Renvoie le nombre de millisecondes à partir d'un compteur croissant. Reboucle après une certaine valeur. ",
    "time.ticks_us()": " Renvoie le nombre de microsecondes à partir d'un compteur croissant. Reboucle après une certaine valeur. ",
    "time.ticks_diff()": "Calculer la différence entre les valeurs des graduations obtenues à partir de time.ticks_ms() et time.ticks_us().",
    "time.time()": "Renvoie le nombre de secondes, sous forme d'entier, depuis l'époque, en supposant que le RTC sous-jacent est défini et maintenu. Si un RTC n'est pas défini, cette fonction renvoie le nombre de secondes depuis un port spécifique point de référence dans le temps (généralement depuis le démarrage ou la réinitialisation).",
    "network": "bibliothèque réseau.",
    "network.WLAN(interface_id)": "Créez un objet d'interface WLAN. Les interfaces prises en charge sont : network.STA_IF (station aka client, se connecte aux points d'accès WiFi en amont) et network.AP_IF (mode point d'accès, permet à d'autres clients WiFi de se connecter ).",
    "network.WLAN.STA_IF ": "",
    "network.WLAN.AP_IF": "",
    "network.WLAN.active([ is_active ])": "Active ou désactive l'interface réseau lorsqu'un argument booléen est donné. Lorsque l'argument est omis, la fonction renvoie l'état actuel.",
    "network.WLAN.connect(ssid, password)": "Connectez-vous au réseau sans fil spécifié à l'aide du mot de passe spécifié.",
    "network.WLAN.disconnect()": "Déconnectez-vous du réseau sans fil actuellement connecté.",
    "network.WLAN.scan()": " Recherche les réseaux sans fil disponibles. La recherche n'est possible que sur l'interface STA. Renvoie la liste des tuples avec les informations sur les points d'accès WiFi : (ssid, bssid, channel, RSSI, authmode, hidden )",
    "network.WLAN.status()": "Renvoyer l'état actuel de la connexion sans fil. Valeurs possibles : - STAT_IDLE (pas de connexion et pas d'activité) - STAT_CONNECTING (connexion en cours) - STAT_WRONG_PASSWORD (échec en raison d'un mot de passe incorrect - STAT_NO_AP_FOUND ( a échoué car aucun point d'accès n'a répondu - STAT_CONNECT_FAIL (échec en raison d'autres problèmes - STAT_GOT_IP (connexion réussie)",
    "network.WLAN.isconnected()": "En cas de mode STA, renvoie True si connecté à un point d'accès WiFi et possède une adresse IP valide. En mode AP renvoie True lorsqu'une station est connectée. Renvoie False sinon.",
    "network.WLAN.ifconfig([ (ip, subnet, gateway, dns) ])": "Obtenir/définir les paramètres de l'interface réseau au niveau IP : adresse IP, masque de sous-réseau, passerelle et serveur DNS. Appelé sans argument, ce La méthode renvoie un tuple de 4 avec les informations ci-dessus. Pour définir les valeurs ci-dessus, transmettez un tuple de 4 avec les informations requises. Par exemple : nic = network.WLAN(network.WLAN.AP_IF) nic.ifconfig(('192.168. 0.4', '255.255.255.0', '192.168.0.1', '8.8.8.8'))",
    "urequests": "bibliothèque urequests.",
    "urequests.get(url, headers={})": "Envoyer la requête HTTP GET à l'URL donnée. Un dictionnaire facultatif d'en-têtes HTTP peut être fourni. Renvoie un objet urequests.Response",
    "urequests.post(url, data=None, json=None, headers={})": "Envoie la requête HTTP POST à ​​l'URL donnée. Renvoie un objet urequests.Response. - data (facultatif) : octets à envoyer le corps de la requête. - json (facultatif) : données JSON à envoyer dans le corps de la requête. - headers (facultatif) : un dictionnaire facultatif d'en-têtes HTTP.",
    "urequests.Response()": "Objet renvoyé par",
    "urequests.Response.text": "Représentation sous forme de chaîne de réponse",
    "urequests.Response.json()": "Convertir la réponse du dictionnaire JSON en dictionnaire Python.",
    "neopixel": "bibliothèque néopixel.",
    "neopixel.NeoPixel(pin, n)": "Créer une liste représentant une bande de 'n' néopixels contrôlés à partir de la broche spécifiée (par exemple machine.Pin(0)). Utilisez l'objet résultant pour changer chaque pixel par position (en commençant à partir de 0). Les pixels individuels reçoivent des valeurs RVB (rouge, vert, bleu) comprises entre 0 et 255 sous forme de tuple. Par exemple, (255, 255, 255) est blanc : np = neopixel.NeoPixel(machine.Pin(0 8 )\\nnp[0] = (255, 0, 128) np.write()",
    "neopixel.NeoPixel.write()": "Afficher les pixels. Doit être appelé pour que toutes les mises à jour deviennent visibles.",
    "math": "bibliothèque de mathématiques.",
    "math.sqrt(x)": "Renvoyer la racine carrée de 'x'.",
    "math.pow(x, y)": "Renvoyer 'x' élevé à la puissance 'y'.",
    "math.exp(x)": "Retour math.e**'x'.",
    "math.log(x, base=math.e)": "Avec un argument, renvoie le logarithme népérien de 'x' (en base e).\\nAvec deux arguments, renvoie le logarithme de 'x' à la donnée 'base'.",
    "math.cos(x)": "Renvoyer le cosinus de 'x' radians.",
    "math.sin(x)": "Renvoyer le sinus de 'x' radians.",
    "math.tan(x)": "Renvoyer la tangente de 'x' radians.",
    "math.acos(x)": "Renvoyer l'arc cosinus de 'x', en radians.",
    "math.asin(x)": "Renvoyer l'arc sinus de 'x', en radians.",
    "math.atan(x)": "Renvoyer l'arc tangent de 'x', en radians.",
    "math.atan2(x, y)": "Renvoyer atan(y / x en radians.",
    "math.ceil(x)": "Renvoyer le plafond de 'x', le plus petit entier supérieur ou égal à 'x'.",
    "math.copysign(x, y)": "Renvoyer un flottant avec la magnitude (valeur absolue) de 'x' mais le signe de 'y'.",
    "math.fabs(x)": "Renvoyer la valeur absolue de 'x'.",
    "math.floor(x)": "Renvoyer le plancher de 'x', le plus grand entier inférieur ou égal à 'x'.",
    "math.fmod(x, y)": "Renvoyer 'x' modulo 'y'.",
    "math.frexp(x)": " Renvoie la mantisse et l'exposant de 'x' comme la paire (m, e).",
    "math.ldexp(x, i)": "Renvoyer 'x' * (2**'i').",
    "math.modf(x)": "Renvoyer les parties fractionnaire et entière de x.\\nLes deux résultats portent le signe de x et sont des nombres flottants.",
    "math.isfinite(x)": "Renvoyer True si 'x' n'est ni un infini ni un NaN, et False sinon.",
    "math.isinf(x)": "Renvoyer True si 'x' est un infini positif ou négatif, et False sinon.",
    "math.isnan(x)": "Renvoyer True si 'x' est un NaN (pas un nombre et False sinon.",
    "math.trunc(x)": "Renvoyer la valeur réelle 'x' tronquée à un Intégral (généralement un entier).",
    "math.radians(x)": "Convertir l'angle 'x' de degrés en radians.",
    "math.degrees(x)": "Convertir l'angle 'x' de radians en degrés."
};

/**
 *  ESP MicroPython libraries and metadata for descriptions (ENGLISH)
 */
const MICROPYTHON_TIPS_EN = {
    "random": "random library.",
    "random.getrandbits(n)": "Returns an integer with n random bits.",
    "random.seed(n)": "Initialise the random number generator with a known integer 'n'.",
    "random.randint(a, b)": "Returns a random whole number between a and b (inclusive).",
    "random.randrange(stop)": "Returns a random whole number between 0 and up to (but not including) stop.",
    "random.choice(seq)": "Returns a randomly selected element from a sequence of objects (such as a list).",
    "random.random()": "Returns a random floating point number between 0.0 and 1.0.",
    "random.uniform(a, b)": "Returns a random floating point number between a and b (inclusive).",
    "os": "os library.",
    "os.listdir()": "Returns a list of the names of all the files contained within the local\\non-device file system.",
    "os.remove(filename)": "Remove (delete) the file named filename.",
    "os.size(filename)": "Returns the size, in bytes, of the file named filename.",
    "os.uname()": "Returns information about MicroPython and the device.",
    "os.getcwd()": "Returns current working directory",
    "os.chdir(path)": "Change current working directory",
    "os.mkdir(path)": "Make new directory",
    "os.rmdir(path)": "Remove directory",
    "os.listdir(path='.')": "Returns list of directory. Defaults to current working directory.",
    "sys": "sys library.",
    "sys.version ": "Returns Python version as a string",
    "sys.version_info ": "Returns Python version as a tuple",
    "sys.implementation ": "Returns MicroPython version",
    "sys.platform ": "Returns hardware platform as string, e.g. 'esp8266' or 'esp32'",
    "sys.byteorder ": "Returns platform endianness. 'little' for least-significant byte first or 'big' for most-significant byte first.",
    "sys.print_exception(ex)": "Print to the REPL information about the exception 'ex'.",
    "machine": "machine library.",
    "machine.reset()": "Resets the device in a manner similar to pushing the external RESET button",
    "machine.freq()": "Returns CPU frequency in hertz.",
    "machine.Pin(id [, mode, pull])": "Create a Pin-object. Only id is mandatory. mode (optional): specifies the pin mode (Pin.OUT or Pin.IN) pull (optional): specifies if the pin has a pull resistor attached pull can be one of: None, Pin.PULL_UP or Pin.PULL_DOWN.",
    "machine.Pin.value([x])": "This method allows to set and get the value of the pin, depending on whether the argument x is supplied or not. If the argument is omitted, the method returns the actual input value (0 or 1) on the pin. If the argument is supplied, the method sets the output to the given value.",
    "machine.Pin.OUT ": "",
    "machine.Pin.IN ": "",
    "machine.Pin.PULL_UP ": "",
    "machine.Pin.PULL_DOWN ": "",
    "machine.ADC(pin)": "Create an ADC object associated with the given pin.  This allows you to then read analog values on that pin. machine.ADC(machine.Pin(39))",
    "machine.ADC.read()": "Read the analog pin value.\\n\\nadc = machine.ADC(machine.Pin(39))\\nvalue = adc.read()",
    "time": "time library.",
    "time.sleep(seconds)": "Sleep the given number of seconds.",
    "time.sleep_ms(milliseconds)": "Sleep the given number of milliseconds.",
    "time.sleep_us(milliseconds)": "Sleep the given number of microseconds.",
    "time.ticks_ms()": "Returns number of milliseconds from an increasing counter. Wraps around after some value.",
    "time.ticks_us()": "Returns number of microseconds from an increasing counter. Wraps around after some value.",
    "time.ticks_diff()": "Compute difference between values ticks values obtained from time.ticks_ms() and time.ticks_us().",
    "time.time()  ": "Returns the number of seconds, as an integer, since the Epoch, assuming that underlying RTC is set and maintained. If an RTC is not set, this function returns number of seconds since a port-specific reference point in time (usually since boot or reset).",
    "network": "network library.",
    "network.WLAN(interface_id)": "Create a WLAN interface object. Supported interfaces are: network.STA_IF (station aka client, connects to upstream WiFi access points) and  network.AP_IF (access point mode, allows other WiFi clients to connect).",
    "network.WLAN.STA_IF ": "",
    "network.WLAN.AP_IF": "",
    "network.WLAN.active([ is_active ])": "Activates or deactivates the network interface when given boolean argument. When argument is omitted the function returns the current state.",
    "network.WLAN.connect(ssid, password)": "Connect to the specified wireless network using the specified password.",
    "network.WLAN.disconnect()": "Disconnect from the currently connected wireless network.",
    "network.WLAN.scan()": "Scan for the available wireless networks. Scanning is only possible on STA interface. Returns list of tuples with the information about WiFi access points: (ssid, bssid, channel, RSSI, authmode, hidden)",
    "network.WLAN.status()": "Returns the current status of the wireless connection. Possible values: - STAT_IDLE (no connection and no activity) - STAT_CONNECTING (connecting in progress) - STAT_WRONG_PASSWORD (failed due to incorrect password - STAT_NO_AP_FOUND (failed because no access point replied - STAT_CONNECT_FAIL (failed due to other problems - STAT_GOT_IP (connection successful)",
    "network.WLAN.isconnected()": "In case of STA mode, returns True if connected to a WiFi access point and has a valid IP address. In AP mode returns True when a station is connected. Returns False otherwise.",
    "network.WLAN.ifconfig([ (ip, subnet, gateway, dns) ])": "Get/set IP-level network interface parameters: IP address, subnet mask, gateway and DNS server. When called with no arguments, this method returns a 4-tuple with the above information. To set the above values, pass a 4-tuple with the required information. For example: nic = network.WLAN(network.WLAN.AP_IF) nic.ifconfig(('192.168.0.4', '255.255.255.0', '192.168.0.1', '8.8.8.8'))",
    "urequests": "urequests library.",
    "urequests.get(url, headers={})": "Send HTTP GET request to the given URL.  An optional dictionary of HTTP headers can be provided. Returns a urequests.Response-object",
    "urequests.post(url, data=None, json=None, headers={})": "Send HTTP POST request to the given URL. Returns a urequests.Response-object. - data (optional): bytes to send in the body of the request. - json (optional): JSON data to send in the body of the Request. - headers (optional): An optional dictionary of HTTP headers.",
    "urequests.Response()": "Object returned by",
    "urequests.Response.text ": "String representation of response",
    "urequests.Response.json()": "Convert Response from JSON to Python dictionary.",
    "neopixel": "neopixel library.",
    "neopixel.NeoPixel(pin, n)": "Create a list representing a strip of 'n' neopixels controlled from the specified pin (e.g. machine.Pin(0)). Use the resulting object to change each pixel by position (starting from 0). Individual pixels are given RGB (red, green, blue) values between 0-255 as a tuple. For example, (255, 255, 255) is white: np = neopixel.NeoPixel(machine.Pin(0 8)\\nnp[0] = (255, 0, 128) np.write()",
    "neopixel.NeoPixel.write()": "Show the pixels. Must be called for any updates to become visible.",
    "math": "math library.",
    "math.sqrt(x)": "Returns the square root of 'x'.",
    "math.pow(x, y)": "Returns 'x' raised to the power 'y'.",
    "math.exp(x)": "Returns math.e**'x'.",
    "math.log(x, base=math.e)": "With one argument, return the natural logarithm of 'x' (to base e).\\nWith two arguments, return the logarithm of 'x' to the given 'base'.",
    "math.cos(x)": "Returns the cosine of 'x' radians.",
    "math.sin(x)": "Returns the sine of 'x' radians.",
    "math.tan(x)": "Returns the tangent of 'x' radians.",
    "math.acos(x)": "Returns the arc cosine of 'x', in radians.",
    "math.asin(x)": "Returns the arc sine of 'x', in radians.",
    "math.atan(x)": "Returns the arc tangent of 'x', in radians.",
    "math.atan2(x, y)": "Returns atan(y / x) in radians.",
    "math.ceil(x)": "Returns the ceiling of 'x', the smallest integer greater than or equal to 'x'.",
    "math.copysign(x, y)": "Returns a float with the magnitude (absolute value) of 'x' but the sign of 'y'.",
    "math.fabs(x)": "Returns the absolute value of 'x'.",
    "math.floor(x)": "Returns the floor of 'x', the largest integer less than or equal to 'x'.",
    "math.fmod(x, y)": "Returns 'x' modulo 'y'.",
    "math.frexp(x)": "Returns the mantissa and exponent of 'x' as the pair (m, e).",
    "math.ldexp(x, i)": "Returns 'x' * (2**'i').",
    "math.modf(x)": "Returns the fractional and integer parts of x.\\nBoth results carry the sign of x and are floats.",
    "math.isfinite(x)": "Returns True if 'x' is neither an infinity nor a NaN, and False otherwise.",
    "math.isinf(x)": "Returns True if 'x' is a positive or negative infinity, and False otherwise.",
    "math.isnan(x)": "Returns True if 'x' is a NaN (not a number and False otherwise.",
    "math.trunc(x)": "Returns the Real value 'x' truncated to an Integral (usually an integer).",
    "math.radians(x)": "Convert angle 'x' from degrees to radians.",
    "math.degrees(x)": "Convert angle 'x' from radians to degrees."
};


/**
 *  CyberPi MicroPython libraries and metadata for descriptions (FRENCH)
 */
const CYBERPI_TIPS_FR = {
    "random": "bibliothèque random.",
    "random.getrandbits(n)": "Renvoyer un entier avec n bits aléatoires.",
    "random.seed(n)": "Initialiser le générateur de nombres aléatoires avec un entier connu 'n'.",
    "random.randint(a, b)": "Renvoyer un nombre entier aléatoire entre a et b (inclus).",
    "random.randrange(stop)": "Renvoyer un nombre entier aléatoire compris entre 0 et jusqu'à (mais sans inclure) stop.",
    "random.choice(seq)": "Renvoyer un élément sélectionné au hasard à partir d'une séquence d'objets (comme une liste).",
    "random.random()": "Renvoyer un nombre à virgule flottante aléatoire entre 0.0 et 1.0.",
    "random.uniform(a, b)": "Renvoyer un nombre à virgule flottante aléatoire entre a et b (inclus).",
    "os": "bibliothèque os.",
    "os.listdir()": "Renvoyer une liste des noms de tous les fichiers contenus dans le système de fichiers local\\non-périphérique.",
    "os.ilistdir()": "",
    "os.urandom()": "",
    "os.dupterm()": "",
    "os.dupterm_notify()": "",
    "os.remove(filename)": "Supprimer (supprimer) le fichier nommé filename.",
    "os.size(filename)": "Renvoyer la taille, en octets, du fichier nommé filename.",
    "os.uname()": "Renvoyer des informations sur MicroPython et l'appareil.",
    "os.getcwd()": "Renvoyer le répertoire de travail courant.",
    "os.chdir(path)": "Changer le répertoire de travail courant.",
    "os.mkdir(path)": "Créer un nouveau répertoire.",
    "os.rmdir(path)": "Supprimer le répertoire.",
    "os.listdir(path='.')": "Renvoyer la liste des répertoires. Par défaut le répertoire de travail actuel.",
    "os.stat()": "",
    "os.statvfs()": "",
    "os.mount()": "",
    "os.unmount()": "",
    "os.VfsFat": "class",
    "sys": "bibliothèque sys.",
    "sys.version": "Renvoyer la version Python sous forme de chaîne",
    "sys.version_info": "Renvoyer la version Python sous forme de tuple",
    "sys.implementation": "Renvoyer la version MicroPython",
    "sys.platform": "Renvoyer la plate-forme matérielle sous forme de chaîne, par exemple 'esp8266' ou 'esp32'",
    "sys.byteorder": "Renvoyer l'endian de la plate-forme. 'little' pour l'octet le moins significatif en premier ou 'big' pour l'octet le plus significatif en premier.",
    "machine": "bibliothèque machine.",
    "machine.reset()": "Réinitialise l'appareil d'une manière similaire à appuyer sur le bouton RESET externe",
    "machine.freq()": "Renvoie la fréquence du processeur en hertz.",
    "machine.Pin(id [, mode, pull])": "Créer un objet Pin. Seul l'identifiant est obligatoire. mode (facultatif): spécifie le mode de la broche (Pin.OUT ou Pin.IN) pull (facultatif) : spécifie si la broche a une résistance de tirage attachée, la traction peut être l'une des suivantes : Aucun, Pin.PULL_UP ou Pin.PULL_DOWN.",
    "machine.Pin.value([x])": "Cette méthode permet de définir et d'obtenir la valeur de la broche, selon que l'argument x est fourni ou non. Si l'argument est omis, la méthode renvoie l'entrée réelle valeur (0 ou 1) sur la broche. Si l'argument est fourni, la méthode définit la sortie sur la valeur donnée.",
    "machine.Pin.OUT ": "",
    "machine.Pin.IN ": "",
    "machine.Pin.PULL_UP ": "",
    "machine.Pin.PULL_DOWN ": "",
    "machine.ADC(pin)": "Créer un objet ADC associé à la broche donnée. Cela vous permet ensuite de lire des valeurs analogiques sur cette broche. machine.ADC(machine.Pin(39))",
    "machine.ADC.read()": "Lire la valeur de la broche analogique.\\n\\nadc = machine.ADC(machine.Pin(39))\\nvalue = adc.read()",
    "utime": "bibliothèque time.",
    "utime.sleep(seconds)": "Veille pendant le nombre de secondes donné.",
    "utime.sleep_ms(ms)": "Délai pour un nombre donné de millisecondes, doit être positif ou 0.",
    "utime.sleep_us(us)": "Délai pour un nombre donné de microsecondes, doit être positif ou 0",
    "utime.ticks_ms()": " Renvoie le nombre de millisecondes à partir d'un compteur croissant. Reboucle après une certaine valeur. ",
    "utime.ticks_us()": " Renvoie le nombre de microsecondes à partir d'un compteur croissant. Reboucle après une certaine valeur. ",
    "utime.ticks_diff()": "Calculer la différence entre les valeurs des graduations obtenues à partir de time.ticks_ms() et time.ticks_us().",
    "utime.time()": "Renvoie le nombre de secondes, sous forme d'entier, depuis l'époque, en supposant que le RTC sous-jacent est défini et maintenu. Si un RTC n'est pas défini, cette fonction renvoie le nombre de secondes depuis un port spécifique point de référence dans le temps (généralement depuis le démarrage ou la réinitialisation).",
    "network": "bibliothèque réseau.",
    "network.WLAN(interface_id)": "Créez un objet d'interface WLAN. Les interfaces prises en charge sont : network.STA_IF (station aka client, se connecte aux points d'accès WiFi en amont) et network.AP_IF (mode point d'accès, permet à d'autres clients WiFi de se connecter ).",
    "network.WLAN.STA_IF ": "",
    "network.WLAN.AP_IF": "",
    "network.WLAN.active([ is_active ])": "Active ou désactive l'interface réseau lorsqu'un argument booléen est donné. Lorsque l'argument est omis, la fonction renvoie l'état actuel.",
    "network.WLAN.connect(ssid, password)": "Connectez-vous au réseau sans fil spécifié à l'aide du mot de passe spécifié.",
    "network.WLAN.disconnect()": "Déconnectez-vous du réseau sans fil actuellement connecté.",
    "network.WLAN.scan()": " Recherche les réseaux sans fil disponibles. La recherche n'est possible que sur l'interface STA. Renvoie la liste des tuples avec les informations sur les points d'accès WiFi : (ssid, bssid, channel, RSSI, authmode, hidden )",
    "network.WLAN.status()": "Renvoyer l'état actuel de la connexion sans fil. Valeurs possibles : - STAT_IDLE (pas de connexion et pas d'activité) - STAT_CONNECTING (connexion en cours) - STAT_WRONG_PASSWORD (échec en raison d'un mot de passe incorrect - STAT_NO_AP_FOUND ( a échoué car aucun point d'accès n'a répondu - STAT_CONNECT_FAIL (échec en raison d'autres problèmes - STAT_GOT_IP (connexion réussie)",
    "network.WLAN.isconnected()": "En cas de mode STA, renvoie True si connecté à un point d'accès WiFi et possède une adresse IP valide. En mode AP renvoie True lorsqu'une station est connectée. Renvoie False sinon.",
    "network.WLAN.ifconfig([ (ip, subnet, gateway, dns) ])": "Obtenir/définir les paramètres de l'interface réseau au niveau IP : adresse IP, masque de sous-réseau, passerelle et serveur DNS. Appelé sans argument, ce La méthode renvoie un tuple de 4 avec les informations ci-dessus. Pour définir les valeurs ci-dessus, transmettez un tuple de 4 avec les informations requises. Par exemple : nic = network.WLAN(network.WLAN.AP_IF) nic.ifconfig(('192.168. 0.4', '255.255.255.0', '192.168.0.1', '8.8.8.8'))",
    "urequests": "bibliothèque urequests.",
    "urequests.get(url, headers={})": "Envoyer la requête HTTP GET à l'URL donnée. Un dictionnaire facultatif d'en-têtes HTTP peut être fourni. Renvoie un objet urequests.Response",
    "urequests.post(url, data=None, json=None, headers={})": "Envoie la requête HTTP POST à ​​l'URL donnée. Renvoie un objet urequests.Response. - data (facultatif) : octets à envoyer le corps de la requête. - json (facultatif) : données JSON à envoyer dans le corps de la requête. - headers (facultatif) : un dictionnaire facultatif d'en-têtes HTTP.",
    "urequests.Response()": "Objet renvoyé par",
    "urequests.Response.text": "Représentation sous forme de chaîne de réponse",
    "urequests.Response.json()": "Convertir la réponse du dictionnaire JSON en dictionnaire Python.",
    "math": "bibliothèque de mathématiques.",
    "math.sqrt(x)": "Renvoyer la racine carrée de 'x'.",
    "math.pow(x, y)": "Renvoyer 'x' élevé à la puissance 'y'.",
    "math.exp(x)": "Retour math.e**'x'.",
    "math.log(x, base=math.e)": "Avec un argument, renvoie le logarithme népérien de 'x' (en base e).\\nAvec deux arguments, renvoie le logarithme de 'x' à la donnée 'base'.",
    "math.cos(x)": "Renvoyer le cosinus de 'x' radians.",
    "math.sin(x)": "Renvoyer le sinus de 'x' radians.",
    "math.tan(x)": "Renvoyer la tangente de 'x' radians.",
    "math.acos(x)": "Renvoyer l'arc cosinus de 'x', en radians.",
    "math.asin(x)": "Renvoyer l'arc sinus de 'x', en radians.",
    "math.atan(x)": "Renvoyer l'arc tangent de 'x', en radians.",
    "math.atan2(x, y)": "Renvoyer atan(y / x en radians.",
    "math.ceil(x)": "Renvoyer le plafond de 'x', le plus petit entier supérieur ou égal à 'x'.",
    "math.copysign(x, y)": "Renvoyer un flottant avec la magnitude (valeur absolue) de 'x' mais le signe de 'y'.",
    "math.fabs(x)": "Renvoyer la valeur absolue de 'x'.",
    "math.floor(x)": "Renvoyer le plancher de 'x', le plus grand entier inférieur ou égal à 'x'.",
    "math.fmod(x, y)": "Renvoyer 'x' modulo 'y'.",
    "math.frexp(x)": " Renvoie la mantisse et l'exposant de 'x' comme la paire (m, e).",
    "math.ldexp(x, i)": "Renvoyer 'x' * (2**'i').",
    "math.modf(x)": "Renvoyer les parties fractionnaire et entière de x.\\nLes deux résultats portent le signe de x et sont des nombres flottants.",
    "math.isfinite(x)": "Renvoyer True si 'x' n'est ni un infini ni un NaN, et False sinon.",
    "math.isinf(x)": "Renvoyer True si 'x' est un infini positif ou négatif, et False sinon.",
    "math.isnan(x)": "Renvoyer True si 'x' est un NaN (pas un nombre et False sinon.",
    "math.trunc(x)": "Renvoyer la valeur réelle 'x' tronquée à un Intégral (généralement un entier).",
    "math.radians(x)": "Convertir l'angle 'x' de degrés en radians.",
    "math.degrees(x)": "Convertir l'angle 'x' de radians en degrés.",
    "mbot2": "bibliothèque mbot2.",
    "mbot2.forward(speed, duration)": "Avancer à une certaine vitesse (en tr/min). L'argument 'duration', définit en seconde, est facultatif.",
    "mbot2.backward(speed, duration)": "Reculer à une certaine vitesse (en tr/min). L'argument 'duration', définit en seconde, est facultatif.",
    "mbot2.turn(angle, speed, motor)": "Tourner le moteur EM1 ou EM2 d'un certain angle (en °) à une certaine vitesse (en tr/min).",
    "mbot2.EM_set_speed(speed, motor)": "Appliquer une vitesse (en tr/min) au moteur encodeur EM1 ou EM2.",
    "mbot2.EM_get_speed(motor)": "Renvoyer la vitesse (en tr/min) du moteur encodeur EM1 ou EM2.",
    "mbot2.EM_set_power(power, motor)": "Appliquer une puissance (en %) au moteur encodeur EM1 ou EM2.",
    "mbot2.EM_get_power(motor)": "Renvoyer la puissance (en %) du moteur encodeur EM1 ou EM2.",
};

/**
 *  CyberPi MicroPython libraries and metadata for descriptions (ENGLISH)
 */
const CYBERPI_TIPS_EN = {
    "random": "random library.",
    "random.getrandbits(n)": "Return an integer with n random bits.",
    "random.seed(n)": "Initialize the random number generator with a known integer 'n'.",
    "random.randint(a, b)": "Return a random integer between a and b (inclusive).",
    "random.randrange(stop)": "Return a random integer between 0 and up to (but not including) stop.",
    "random.choice(seq)": "Return a randomly selected item from a sequence of objects (like a list).",
    "random.random()": "Return a random floating point number between 0.0 and 1.0.",
    "random.uniform(a, b)": "Return a random floating point number between a and b (inclusive).",
    "os": "os library.",
    "os.listdir()": "Return a list of the names of all files contained in the local\\non-device filesystem.",
    "os.ilistdir()": "",
    "os.urandom()": "",
    "os.dupterm()": "",
    "os.dupterm_notify()": "",
    "os.remove(filename)": "Remove (delete) the file named filename.",
    "os.size(filename)": "Return the size, in bytes, of the file named filename.",
    "os.uname()": "Return MicroPython and device information.",
    "os.getcwd()": "Return the current working directory.",
    "os.chdir(path)": "Change current working directory.",
    "os.mkdir(path)": "Create a new directory.",
    "os.rmdir(path)": "Delete directory.",
    "os.listdir(path='.')": "Return list of directories. Defaults to current working directory.",
    "os.stat()": "",
    "os.statvfs()": "",
    "os.mount()": "",
    "os.unmount()": "",
    "os.VfsFat": "class",
    "sys": "library sys.",
    "sys.version": "Return Python version as a string",
    "sys.version_info": "Return Python version as a tuple",
    "sys.implementation": "Return MicroPython Version",
    "sys.platform": "Return the hardware platform as a string, for example 'esp8266' or 'esp32'",
    "sys.byteorder": "Return the platform endian. 'little' for least significant byte first or 'big' for most significant byte first.",
    "machine": "library machine.",
    "machine.reset()": "Reset the device in a manner similar to pressing the external RESET button",
    "machine.freq()": "Return the CPU frequency in hertz.",
    "machine.Pin(id[, mode, pull])": "Create a Pin object. Only the id is required. mode (optional): specify the mode of the pin (Pin.OUT or Pin.IN) pull( optional): Specific if the pin has a pullup resistor attached, the pullup can be one of the following: None, Pin.PULL_UP or Pin.PULL_DOWN.",
    "machine.Pin.value([x])": "This method sets and gets the value of the pin, depending on whether the argument x is provided or not. If the argument is omitted, the method returns the actual value (0 or 1) input on the pin. If the argument is provided, the method sets the output to the given value.",
    "machine.Pin.OUT": "",
    "machine.Pin.IN": "",
    "machine.Pin.PULL_UP": "",
    "machine.Pin.PULL_DOWN": "",
    "machine.ADC(pin)": "Create an ADC object associated with the data pin. This then allows you to read analog values from that pin. machine.ADC(machine.Pin(39))",
    "machine.ADC.read()": "Read analog pin value.\\n\\nadc = machine.ADC(machine.Pin(39))\\nvalue = adc.read()",
    "utime": "library time.",
    "utime.sleep(seconds)": "Sleeps for the given number of seconds.",
    "utime.sleep_ms(ms)": "Delay for given number of milliseconds, must be positive or 0.",
    "utime.sleep_us(us)": "Delay for given number of microseconds, must be positive or 0",
    "utime.ticks_ms()": "Returns the number of milliseconds from an increasing counter. Loops after a certain value.",
    "utime.ticks_us()": "Returns the number of microseconds from an increasing counter. Loops after a certain value.",
    "utime.ticks_diff()": "Calculate the difference between tick values obtained from time.ticks_ms() and time.ticks_us().",
    "utime.time()": "Returns the number of seconds, as an integer, since the epoch, assuming the underlying RTC is set and held. If an RTC is not set, this function returns the number of seconds since a specific port reference point in time (usually since boot or reset).",
    "network": "network library.",
    "network.WLAN(interface_id)": "Create a WLAN interface object. Supported interfaces are: network.STA_IF (station aka client, connects to upstream WiFi access points) and network.AP_IF (mode access point, allows other WiFi clients to connect ).",
    "network.WLAN.STA_IF": "",
    "network.WLAN.AP_IF": "",
    "network.WLAN.active([ is_active ])": "Enables or disables the network interface when a boolean argument is given. When the argument is omitted, the function returns the current state.",
    "network.WLAN.connect(ssid, password)": "Connect to the specified wireless network using the specified password.",
    "network.WLAN.disconnect()": "Disconnect from the currently connected wireless network.",
    "network.WLAN.scan()": " Scans for available wireless networks. Scan is only possible on the STA interface. Returns the list of tuples with WiFi access point information: (ssid, bssid, channel, RSSI, authmode, hidden )",
    "network.WLAN.status()": "Return the current status of the wireless connection. Possible values: - STAT_IDLE (no connection and no activity) - STAT_CONNECTING (connection in progress) - STAT_WRONG_PASSWORD (failed due to incorrect password - STAT_NO_AP_FOUND (failed because no access point responded - STAT_CONNECT_FAIL (failed due to other problems - STAT_GOT_IP (connection successful)",
    "network.WLAN.isconnected()": "In case of STA mode, returns True if connected to a WiFi access point and has a valid IP address. In AP mode returns True when a station is connected. Returns False otherwise .",
    "network.WLAN.ifconfig([ (ip, subnet, gateway, dns) ])": "Get/set network interface parameters at IP level: IP address, subnet mask, gateway and DNS server. Called with no arguments, this method returns a tuple of 4 with the above information. To set the above values, pass a tuple of 4 with the required information. For example: nic = network.WLAN(network.WLAN. AP_IF)nic.ifconfig(('192.168.0.4', '255.255.255.0', '192.168.0.1', '8.8.8.8'))",
    "urequests": "urequests library.",
    "urequests.get(url, headers={})": "Send the HTTP GET request to the given URL. An optional dictionary of HTTP headers can be provided. Returns a urequests.Response object",
    "urequests.post(url, data=None, json=None, headers={})": "Sends the HTTP POST request to the given URL. Returns a urequests.Response object. -data (optional): bytes to send the request body. - json (optional): JSON data to send in the request body. - headers (optional): an optional dictionary of HTTP headers.",
    "urequests.Response()": "Object returned by",
    "urequests.Response.text": "Response String Representation",
    "urequests.Response.json()": "Convert response from JSON dictionary to Python dictionary.",
    "math": "math library.",
    "math.sqrt(x)": "Return the square root of 'x'.",
    "math.pow(x, y)": "Return 'x' raised to the power of 'y'.",
    "math.exp(x)": "Return math.e**'x'.",
    "math.log(x, base=math.e)": "With one argument, returns the natural logarithm of 'x' (in base e).\\nWith two arguments, returns the logarithm of 'x' to the data 'base'.",
    "math.cos(x)": "Return the cosine of 'x' radians.",
    "math.sin(x)": "Return the sine of 'x' radians.",
    "math.tan(x)": "Return the tangent of 'x' radians.",
    "math.acos(x)": "Return the arc cosine of 'x', in radians.",
    "math.asin(x)": "Return the arcsine of 'x', in radians.",
    "math.atan(x)": "Return the arctangent of 'x', in radians.",
    "math.atan2(x, y)": "Return atan(y / x in radians.",
    "math.ceil(x)": "Return the ceiling of 'x', the smallest integer greater than or equal to 'x'.",
    "math.copysign(x, y)": "Return a float with the magnitude (absolute value) of 'x' but the sign of 'y'.",
    "math.fabs(x)": "Return the absolute value of 'x'.",
    "math.floor(x)": "Return the floor of 'x', the largest integer less than or equal to 'x'.",
    "math.fmod(x, y)": "Return 'x' modulo 'y'.",
    "math.frexp(x)": " Returns the mantissa and exponent of 'x' as the pair (m, e).",
    "math.ldexp(x, i)": "Return 'x' * (2**'i').",
    "math.modf(x)": "Return the fractional and integer parts of x.\\nBoth results have the sign of x and are float numbers.",
    "math.isfinite(x)": "Return True if 'x' is neither infinity nor NaN, and False otherwise.",
    "math.isinf(x)": "Return True if 'x' is a positive or negative infinity, and False otherwise.",
    "math.isnan(x)": "Return True if 'x' is a NaN (not a number and False otherwise.",
    "math.trunc(x)": "Return the real value 'x' truncated to an Integral (usually an integer).",
    "math.radians(x)": "Convert angle 'x' from degrees to radians.",
    "math.degrees(x)": "Convert angle 'x' from radians to degrees.",
    "mbot2": "mbot2 library.",
    "mbot2.forward(speed, duration)": "Forward at a certain speed (in rpm). The 'duration' argument, defined in seconds, is optional.",
    "mbot2.backward(speed, duration)": "Backward at a certain speed (in rpm). The argument 'duration', defined in seconds, is optional.",
    "mbot2.turn(angle, speed, motor)": "Turn the EM1 or EM2 motor by a certain angle (in °) at a certain speed (in rpm).",
    "mbot2.EM_set_speed(speed, motor)": "Set a speed (in rpm) to the EM1 or EM2 encoder motor.",
    "mbot2.EM_get_speed(motor)": "Return the speed (in rpm) of the EM1 or EM2 encoder motor.",
    "mbot2.EM_set_power(power, motor)": "Apply a power (in %) to the EM1 or EM2 encoder motor.",
    "mbot2.EM_get_power(motor)": "Return the power (in %) of the EM1 or EM2 encoder motor.",
};

/**
 * Parses board names in the HTML and assigns a suggestion dictionary
 * @param {string} interfaceName
 * @returns {Object} tips
 */
function assignTips(interfaceName) {
    let navLang = navigator.language;
    var tips = null;
    if (interfaceName == "wb55" || interfaceName == "l476") {
        if (navLang == 'en' || navLang == 'en-US') {
            tips = STM_TIPS_EN;
        } else if (navLang == 'fr-FR' || navLang == 'fr') {
            tips = STM32_TIPS_FR;
        }
    } else if (interfaceName == "arduino" || interfaceName == "letsstartcoding" || interfaceName == "mBot") {
        if (navLang == 'en' || navLang == 'en-US') {
            tips = ARDUINO_TIPS_EN;
        } else if (navLang == 'fr-FR' || navLang == 'fr') {
            tips = ARDUINO_TIPS_FR;
        }
    } else if (interfaceName == "cyberpi") {
        if (navLang == 'en' || navLang == 'en-US') {
            tips = CYBERPI_TIPS_EN;
        } else if (navLang == 'fr-FR' || navLang == 'fr') {
            tips = CYBERPI_TIPS_FR;
        }
    }
    return tips;
}

// This function assigns a score "ranking in the suggestions" to the tip
// In order to primarily show libs and native keywords and keep suggestion simple (Keep methods, libs,
// and simple attributes first)
/**
 * assigns a score "ranking in the suggestions" to the tip
 * In order to primarily show libs and native keywords and keep suggestion simple 
 * (Keep methods, libs,and simple attributes first)
 * @param  libValue for example 'machine.Pin...' It is the completion
 * @param  libMeta for example 'Machine Library' It is the description of the completion
 * TODO: This method can be optimized to take in-line inputs and generate scores accordingly
 * 
 */

function generateScore(libValue, libMeta) {
    var score = 500; //median value to reference rankings
    if (libMeta.match(/(library|bibliothèque|keyword)/gi) != null) {
        score = 1000; //show first
    } else if (libValue.match(/(.*)\.(.*)\.(.*)/) != null) { // as in machine.Pin.OUT
        score = -1; //show last
    } else if (libValue.match(/(.*)\.(.*)\(/)) { // as in machine.reset() 
        score = 500; //show intermediate
    }
    return score;
};


/**
 * Composes the tips in the right format 
 * @param {*} tips: Tips dictionnary 
 */
function generateDictionary(tips) {
    var Keys = Object.keys(tips);
    var Values = Object.values(tips);
    var Dict = [];
    for (var i = 0; i < Keys.length; i++) {
        let score = generateScore(Keys[i], Values[i]);
        Dict.push({ value: Keys[i], score: score, meta: Values[i] });
    }
    return Dict;
};

