// main utils functions
import utils from '/openInterface/interfaces/assets/js/code2blocks/python/utils/utils.js';

import '/openInterface/interfaces/assets/js/code2blocks/python/ast/ast_math.js'; // math blocks
import '/openInterface/interfaces/assets/js/code2blocks/python/ast/ast_communication.js'; // communication blocks
import '/openInterface/interfaces/assets/js/code2blocks/python/ast/ast_variables.js'; // variables blocks
import '/openInterface/interfaces/assets/js/code2blocks/python/ast/ast_list.js'; // list blocks
import '/openInterface/interfaces/assets/js/code2blocks/python/ast/ast_text.js'; // text blocks
import '/openInterface/interfaces/assets/js/code2blocks/python/ast/ast_try_except.js'; // try except blocks
import '/openInterface/interfaces/assets/js/code2blocks/python/ast/ast_micropython.js'; // micropython blocks

//interceptors : may be specific to a certain interfaces. Need to refine the logic to be imported with the corresponding interface
import '/openInterface/interfaces/assets/js/code2blocks/python/blockInterceptor/list_blocks.js'; // list blocks
import '/openInterface/interfaces/assets/js/code2blocks/python/blockInterceptor/math_blocks.js'; // math blocks

// generic and prototype blocks
import '/openInterface/interfaces/assets/js/code2blocks/python/prototypeBlocks/call_expression.js'; // call expression blocks definitions

// constants
const authorizedConnectors = ['procedures_defnoreturn', 'procedures_defreturn', 'forever', 'on_start', 'scratch_on_start', 'scratch_forever'];

// retreive all necessary basic python functions => used in all python interfaces
const basicPythonFunctions = FUNCTIONS;

// retreive all necessary functions defined for each interfaces
// used to exlude functions generated by the bloc itself from the translation
let pythonFunctions;
switch (INTERFACE_NAME) {
	case 'microbit':
		pythonFunctions = FUNCTIONS_MICROBIT;
		break;
	case 'esp32':
		pythonFunctions = { ...FUNCTIONS_ESP32, ...FUNCTIONS_ESP32_MICROCHIP };
		break;
	case 'galaxia':
		pythonFunctions = { ...FUNCTIONS_GALAXIA, ...FUNCTIONS_ESP32_MICROCHIP };
		break;
	case 'm5stack':
		pythonFunctions = { ...FUNCTIONS_M5STACK, ...FUNCTIONS_ESP32_MICROCHIP };
		break;
	case 'pico':
		pythonFunctions = { ...FUNCTIONS_PICO };
		break;
	case 'wb55':
		pythonFunctions = FUNCTIONS_WB55;
		break;
	case 'l476':
		pythonFunctions = FUNCTIONS_L476;
		break;
	case 'thymio':
		pythonFunctions = {};
		break;
	case 'buddy':
		pythonFunctions = FUNCTIONS_BUDDY;
		break;
	case 'lotibot':
		pythonFunctions = FUNCTIONS_LOTIBOT;
		break;
	case 'sphero':
		pythonFunctions = FUNCTIONS_SPHERO;
		break;
	default:
		pythonFunctions = {};
		break;
}

const PYTHON_BUILTIN_LIST_METHODS = ['append', 'find', 'rfind', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'replace', 'sort', 'split', 'join', 'format', 'upper', 'lower', 'title', 'strip', 'lstrip', 'rstrip'];

/**
 * The purpose of this class is to convert python code to xml and then Blockly blocks. It is mainly used for the Python Vittascience interfaces and its associated blockly toolbox.
 */

/**
 * @fileoverview pythonCode2Blocks.js
 * @author: Nixoals (Nicolas G.)
 */
export default class Python2Blocks {
	static instance;

	/**
	 * @param {workspace} workspace - The workspace to convert
	 * @param {object} Parser - The parser instance
	 * @param {boolean} initialized - The initialization state of the parser
	 * @param {object} declarationEntities - The declaration entities
	 * @param {object} _variableNodes - The variable nodes xml => if a variable is declared in the code, it will be stored in this object and appended to the workspace
	 * @param {object} _variables - The blockly variables defined in the code (id, type, name)
	 * @param {object} _functions - The functions defined in the code
	 * @param {object} _classes - The classes defined in the code
	 * @param {object} vittaFunctions - The vitta functions (custom functions) used in the code. Should not be translated
	 * @param {object} codeManager - The code manager instance. Used to get the code from the editor
	 * @param {object} instance - The instance of the class. Used to check if the class is already instantiated => singleton pattern
	 */
	constructor() {
		if (Python2Blocks.instance) {
			return Python2Blocks.instance;
		}

		this.Parser = window.TreeSitter;
		this.workspace = null;
		this.initialized = false;
		this.declarationEntities = [];
		this._variableNodes = null;
		this._variables = {};
		this._functions = {};
		this._functionsOrder = new Set();
		this._imports = new Set();
		this._importFullNames = new Set();
		this._storedExcludedComments = new Set();
		this._storedExcludedDocstrings = new Set();
		this._classes = {};
		this._dictionary = {};
		this.vittaFunctions = new Set();
		this.pinModes = {};
		this.isWithinSetup = false;
		this.codeManager = null;
		this.utils = utils;
		this.interface_specific = null;
		this.interface_specific_end = {};
		this.requireLastBlockId = false;
		this.blockToRemove = [];
		this.currentXml = null;
		this.specificBlocsInfo = [];
		this.storedDisabledBlocks = [];
		this.debounceTimeout = null;
		this.blocksArray = {};
		this.modifiedColorBlocks = [];
		this.debug = false;
		this.previousXml = [];
		this.indexPreviousXml = null;

		Python2Blocks.instance = this;
	}

	/**
	 * Compare the workspace tree with the AST (only for debug purpose)
	 * @returns {void}
	 **/
	compareTreeWorkspace() {
		const workspace = Blockly.getMainWorkspace();
		const xml = Blockly.Xml.workspaceToDom(workspace);
		const parsedCode = this.parseCode();

		console.log(xml);
		console.log(parsedCode);
	}

	/**
	 * Initialize the parser (Tree-sitter with the corresponding language)
	 * @description The parser is initialized asynchronously in ProjectManager in _setupPythonInterfaceParameters(). The function will wait until the parser is initialized
	 * @returns {Promise<void>}
	 **/
	async initParser() {

		//hide popup if in debug mode
		if (this.debug) {
			const popUpContainer = document.getElementById('popup-container');
			if (popUpContainer) {
				popUpContainer.style.display = 'none';
			}
		}

		return new Promise(async (resolve, reject) => {
			const workspace = Blockly.getMainWorkspace();
			if (workspace === null) {
				setTimeout(() => {
					this.initParser();
				}, 100);
			} else {
				this.workspace = workspace;
				this.codeManager = CodeManager.getSharedInstance();
				await this.Parser.init();
				this.parserTS = new this.Parser();
				const Lang = await this.Parser.Language.load('/openInterface/interfaces/assets/js/external/tree-sitter/tree-sitter-python.wasm');
				this.parserTS.setLanguage(Lang);
				this.debug && console.log('Python2Blocks initialized');
				this.initialized = true;
				this.interface_specific = { ...utils.SPECIFIC_INIT };
				// worst way to access python2Blocks in the utils file (circular dependency) => need to find a better way
				utils.python2Blocks = this;
				// retreive all blocks from the toolbox and warn the user if a block is not included for translation
				this.retreive_all_blocks();
				resolve();
			}
		});
	}

	/**
	 * Retrieve all blocks from the toolbox and add the ones that are not in the authorized blocks to the excluded blocks for traduction
	 */
	retreive_all_blocks = () => {
		const toolboxContent = Main.getToolboxManager().getToolboxBase().content;
		const allCat = Object.keys(toolboxContent);
		for (const cat of allCat) {
			if (!excludedCategories.includes(cat)) {
				const catContent = toolboxContent[cat];
				for (const cat of catContent) {
					if (cat.blocks) {
						EXCLUDED_BLOCKS_FOR_TRADUCTION.push(...cat.blocks.filter((block) => !AUTHORIZED_BLOCKS.includes(block)));
					} else if (cat.subCategoryId){
						// in case of subcategories like in robots for microbit
						const catSubContent = cat.contents;
						for (const blocks in catSubContent){
							EXCLUDED_BLOCKS_FOR_TRADUCTION.push(...catSubContent[blocks].blocks.filter((block) => !AUTHORIZED_BLOCKS.includes(block)));
						}
					}
				}
			}
		}

		// check if the editor need to be locked
		const allBlocks = Main.getWorkSpace().getAllBlocks()
		for (let i = 0; i < allBlocks.length; i++) {
			if (typeof EXCLUDED_BLOCKS_FOR_TRADUCTION !== 'undefined' && EXCLUDED_BLOCKS_FOR_TRADUCTION.includes(allBlocks[i].type)) {
				if (!allBlocks[i].disabled) {
					Main.lockEditor(true);
				}
			}
		}
	};

	/**
	 * Get text code from the code manager (only for debug purpose)
	 * @returns {string}
	 * */
	getTextCode() {
		// old methode to get the code
		// const code = this.codeManager.getTextCode();
		// try to get the code from the editor directly
		const code = Main.getCodeEditor().container.getSession().getValue();

		return code;
	}

	storeXml() {
		this.previousXml.push(Blockly.Xml.workspaceToDom(this.workspace));
		if (this.previousXml.length > 30) {
			this.previousXml.shift();
		}
	}

	/**
	 * Parse the code and reconstrut the AST recursively
	 * @returns {object} - The AST in json format
	 * */
	parseCode() {
		this.code = this.getTextCode();
		const time = new Date().getTime();
		let tree;
		try {
			tree = this.parserTS.parse(this.code);
		} catch (error) {
			console.error('Error parsing code:', error);
			return null;
		}

		function nodeToJson(node) {
			return {
				type: node.type,
				text: node.text,
				children: node.children ? node.children.map((child) => nodeToJson(child)) : [],
				start: {
					row: node.startPosition.row,
					column: node.startPosition.column,
				},
				end: {
					row: node.endPosition.row,
					column: node.endPosition.column,
				},
			};
		}
		const astJson = nodeToJson(tree.rootNode);
		this.debug && console.log(`Parsing time: ${new Date().getTime() - time}ms`); // for debug purpose
		return astJson;
	}

	/**
	 * @description Create a new xml node and recursively serialize the AST inside the node if needed
	 * @param {object} node - The node to create
	 * @param {string} type - The type of the node
	 * @param {object} fields - The fields of the block
	 * @param {object} values - The values of the block (if null the child block will be serialized as a statementsNode)
	 * @param {object} mutations - The mutations of the block
	 * @param {object} statementNode - The child node of the block that correspond to the value (if any)
	 * @param {string} element - The element to create // unused for now
	 * @param {object} statements - The statements of the block (if any) ex: DO statement (void loop, void setup, functions, if while statements, etc)
	 * @returns {object} - The block xml node appended to the parent node
	 * */
	createBlocklyBlockXml(node, type, fields, values, mutations, statementNode, element = 'block', statements = null) {
		let statement = null;
		let blockXml = utils.newNode(element, { type: type }, null, node);
		this.requireLastBlockId = false;
		if (fields !== null) {
			for (const key in fields) {
				// ! check if this regex change do not break other VAR fields
				if (key.match(/VAR/g)) {
					const multiKey = key.split('_');
					const field = utils.newNode('field', { name: multiKey.length > 1 ? multiKey[1] : key, id: fields[key].id }, fields[key].value, node);
					blockXml.append(field);
				} else {
					const field = utils.newNode('field', { name: key }, fields[key], node);
					blockXml.append(field);
				}
			}
		}

		if (values !== null) {
			for (const key in values) {
				const valueKey = values[key];
				const value = utils.newNode('value', { name: key }, valueKey, node);

				if (statementNode !== null) {
					const nodeValue = this.serializeNode(statementNode[key], node);
					if (nodeValue) {
						value.append(nodeValue);
					}
				}
				blockXml.append(value);
			}
		}
		// Function mutator
		if (mutations !== null && (type === 'procedures_defnoreturn' || type === 'procedures_defreturn')) {
			const mutationNode = utils.newNode('mutation', { name: fields.NAME }, null, node);
			blockXml.append(mutationNode);
			// maybe useless now - need to check
			for (const mutation of mutations) {
				const argName = mutation.name;

				const variableId = this.declareBlocklyVariable(argName, null);
				const argNode = utils.newNode('arg', { name: argName, varid: variableId, paramId: variableId }, null, node);
				mutationNode.append(argNode);
			}
		} else if (mutations !== null) {
			const attributes = {};
			let args = [];
			for (const key in mutations) {
				if (key === 'args') {
					args = [...mutations[key]];
				} else {
					attributes[key] = mutations[key];
				}
			}
			const mutationNode = utils.newNode('mutation', attributes, null, node);
			if (args.length > 0) {
				for (const arg of args) {
					const argNode = utils.newNode('arg', { name: arg }, null, node);
					mutationNode.append(argNode);
				}
			}
			blockXml.append(mutationNode);
		}

		if (statements !== null) {
			for (const key in statements) {
				let statementName = key;
				const statement = utils.newNode('statement', { name: statementName }, null, node);

				const statementNode = statements[key];

				this.parent = { type: 'statement', parent: statement };
				const parent = { type: 'statement', parent: statement };
				const childXml = this.serializeNode(statementNode, parent, type);
				if (childXml) {
					statement.append(childXml);
				}
				blockXml.append(statement);
			}
			return blockXml;
		}

		if (node.children && node.children.length > 0 && authorizedConnectors.includes(type)) {
			const statementName = type === 'procedures_defnoreturn' || type === 'procedures_defreturn' ? 'STACK' : 'DO';
			if (type === 'scratch_on_start') {
				// skip the first child (on_start)
				const parent = { type: 'block', parent: blockXml };
				const childXml = this.serializeMultipleNodes(node.children[1].children, parent, type, blockXml);
				if (childXml) {
					blockXml.append(childXml);
					return blockXml;
				}
			} else {
				statement = utils.newNode('statement', { name: statementName }, null, node);
				node.children.forEach((child) => {
					this.parent = { type: 'statement', parent: statement };
					const parent = { type: 'statement', parent: statement };
					const childXml = this.serializeNode(child, parent, type);
					if (childXml) {
						statement.append(childXml);
					}
				});
				blockXml.append(statement);
				return blockXml;
			}
		}

		// check first if the node has start and end position (not all nodes have start and end position ex: bypass node)
		if (this.blocksArray[node.start]) {
			if (this.blocksArray[node.start.row] === undefined) {
				this.blocksArray[node.start.row] = [];
				this.blocksArray[node.start.row].push({ id: blockXml.getAttribute('id'), type: blockXml.getAttribute('type') });
			} else {
				this.blocksArray[node.start.row].push({ id: blockXml.getAttribute('id'), type: blockXml.getAttribute('type') });
			}
		}
		return blockXml;
	}

	/**
	 * Serialize function block type
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineFunctionBlockType(node, parent = null) {
		// Check first if the block is a function declaration

		let declarator = '';
		let args = [];
		let primiType = '';
		for (const elements of node.children) {
			if (elements.type === 'identifier') {
				declarator = elements.text;
			} else if (elements.type === 'parameters') {
				for (const param of elements.children) {
					const getArgs = utils.getParameterList(param);
					if (getArgs.name !== undefined) {
						if (this._variables[getArgs.name] === undefined) {
							args.push(getArgs);
							this._variables[getArgs.name] = { id: getArgs.id, type: getArgs.type, name: getArgs.name };
							if (this._variableNodes === null) {
								const variableNode = utils.newNode('variables', {}, null, null);
								this._variableNodes = variableNode;
								this.xml.prepend(variableNode);
							}

							const newVariable = utils.newNode('variable', { id: getArgs.id }, getArgs.name, null);
							this._variableNodes.appendChild(newVariable);
						} else {
							args.push(getArgs);
						}
					}
				}
			}
		}

		let returnFirstNode = null;
		let returnNode = false;

		const checkForReturn = (node, firstPass = true) => {
			if (firstPass) {
				for (let i = 0; i < node.children.length; i++) {
					const child = node.children[i];
					if (child.type === 'return_statement') {
						returnFirstNode = child.children[1];
						node.children.splice(i, 1);
						return child.children[1];
					}
				}
			}

			for (const child of node.children) {
				if (child.type === 'return_statement') {
					returnNode = true;
					return;
				} else if (child.type === 'block') {
					const check = checkForReturn(child, false);
					if (check) {
						returnNode = true;
						return;
					}
				} else if (child.children.length > 0) {
					const check = checkForReturn(child, false);
					if (check) {
						returnNode = true;
						return;
					}
				}
			}
			return null;
		};

		this._functions[declarator] = { args, type: 'simple', return: false };

		// the 2 next checks cost a lot of ressources => need to find a better way to check the untranslatable functions (maybe directly with the fonction names if possible and not the object)
		for (const func in pythonFunctions) {
			if (declarator !== 'on_start' && declarator !== 'scratch_on_start' && utils.rmSpaces(pythonFunctions[func]) === utils.rmSpaces(node.text)) {
				this.vittaFunctions.add(declarator);
				return '';
			}
		}

		for (const func in basicPythonFunctions) {
			if (declarator !== 'on_start' && declarator !== 'scratch_on_start' && utils.rmSpaces(basicPythonFunctions[func]) === utils.rmSpaces(node.text)) {
				this.vittaFunctions.add(declarator);
				return '';
			}
		}

		if (utils.prototypeBlocks[`specific_function_${declarator}`]) {
			const blockFunc = node.children.filter((child) => child.type === 'block')[0];
			const prototypeBlock = utils.prototypeBlocks[`specific_function_${declarator}`](declarator, blockFunc, args);
			if (prototypeBlock !== null) {
				return prototypeBlock;
			}
		}

		if (declarator !== 'on_start' && declarator !== 'scratch_on_start') {
			returnFirstNode = checkForReturn(node.children.filter((child) => child.type === 'block')[0]);
			if (returnFirstNode !== null || returnNode) {
				// returnFirstNode.type = returnFirstNode.type + '_for_return';
				this._functions[declarator].return = true;
			}
		}

		if (declarator === 'on_start' || declarator === 'scratch_on_start') {
			const toolboxMode = Blockly.Constants.getToolboxStyle();
			if (toolboxMode === 'scratch') {
				return {
					type: 'scratch_on_start',
					fields: null,
					values: {},
					mutations: null,
					statementsNode: {},
					statement: null,
				};
			} else {
				return {
					type: 'on_start',
					fields: null,
					values: {},
					mutations: null,
					statementsNode: null,
					statement: null,
				};
			}
		} else if (returnFirstNode !== null || returnNode) {
			return {
				type: 'procedures_defreturn',
				fields: { NAME: declarator },
				values: { RETURN: null },
				mutations: args,
				statementsNode: { RETURN: returnFirstNode !== null ? returnFirstNode : { type: 'string', text: '' } },
				statement: null,
			};
		} else {
			return {
				type: 'procedures_defnoreturn',
				fields: { NAME: declarator },
				values: {},
				mutations: args,
				statementsNode: null,
				statement: null,
			};
		}
	}

	/**
	 * Serialize expression statement block type (manipulate this node with caution due to the possibility of nested blocks => hard to understand easy to break)
	 * @description Expression statement can generate multiple in case of generic call expressions (2 levels of nested expression_fields)
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineCallExpressionBlockType(node, parent = null) {
		let identifier = '';
		let statementsNode;
		let callEditable = true;
		let mutations = {};
		let mutationValues = {};
		let mutationStatementNodes = {};
		let nestedFieldExpressionNode = null;
		let needNestedFieldExpression = false;
		let newNode = {};
		let editableReturn = false;
		// add chain of arguments in case of call_expression_editable
		const addChain = (args) => {
			const argzNumber = args !== undefined ? args.length : 0;
			mutations = { items: argzNumber };
			for (let i = 0; i < argzNumber; i++) {
				mutationValues[`items${i}`] = null;
				mutationStatementNodes[`items${i}`] = args[i];
			}
		};
		// generate a nested field expression block by creating a new custom node with a cutstom type => {type: "nestedFieldExpression"}
		const addNestedFieldExpression = () => {
			newNode = {
				type: 'call',
				children: [],
			};
			identifier = '';
			for (const child of nestedFieldExpressionNode.children) {
				if ((child.type === 'identifier' || child.type === 'string' || child.type === 'parenthesized_expression' || child.type == 'call' || child.type === 'subscript') && identifier === '') {
					if (child.type === 'string' || child.type === 'parenthesized_expression' || child.type === 'call') {
						identifier = child;
					} else {
						identifier = child.text;
					}
				} else if (child.type === 'identifier') {
					// shortcut for builtin functions (ex: list.append, list.clear, etc) or specific interface functions (ex: write_digital, write_analog for microbite etc)
					if (PYTHON_BUILTIN_LIST_METHODS.includes(child.text) || utils.PYTHON_MICROCONTROLER_BUILTIN.includes(child.text)) {
						if (PYTHON_BUILTIN_LIST_METHODS.includes(child.text)) {
							const builtInMethod = utils.prototypeBlocks['list_built_in'](child.text, identifier, statementsNode, parent);
							if (builtInMethod !== null) {
								return builtInMethod;
							}
						} else {
							if (utils.prototypeBlocks[child.text]) {
								const microControlerMethod = utils.prototypeBlocks[child.text](child.text, identifier, statementsNode, parent);
								if (microControlerMethod !== null) {
									return microControlerMethod;
								}
							}
						}
						//fallback to nested call expression block
					} else if (typeof utils.prototypeBlocks[child.text] !== 'undefined') {
						// prototype Blocks => ex. utime.sleep(1) where utime is the identifier (the prototypeblock will also checks imports statements when necessary and generate the block accordingly or a generic call expression block)
						/**
						 * examples : utime.sleep(1)
						 * identifier = utime
						 * child.text = sleep
						 * statementsNode = 1 => number
						 * example 2 : np_0.show() => set the led matrix
						 * identifier = np_0 => variable with the stored class declaration
						 * child.text = show
						 * statementsNode = null
						 */
						const prototypeBlock = utils.prototypeBlocks[child.text](child.text, identifier, null, null, statementsNode, null, parent);
						if (prototypeBlock !== null) {
							return prototypeBlock;
						}
					}
					newNode.children.push({ type: 'identifier', text: child.text });
				}
			}
			newNode.children.push({ type: 'argument_list', children: statementsNode });
			newNode.children.push({ type: 'nestedFieldExpression' });
		};

		for (const child of node.children) {
			if (child.type === 'argument_list') {
				statementsNode = utils.getArgumentList(child.children, true);
				const text = child.text;
				if (text && text.match(/@Graph/g)) {
					try {
						const strings = utils.checkForStringLiteralOnly(child.children.filter((childEl) => childEl.type === 'binary_operator')[0]);
						const graphSerial = utils.prototypeBlocks['serial_graph'](identifier, null, null, null, strings, null, parent);
						if (graphSerial !== null) {
							return graphSerial;
						}
					} catch (error) {
						console.error('Error parsing graph:', error);
					}
				} else if (text && text.match(/@music:/g)) {
					try {
						const musicNoteFunc = utils.prototypeBlocks[`music_note_${INTERFACE_NAME}`]
						if (musicNoteFunc !== null) {
							const music = utils.prototypeBlocks[`music_note_${INTERFACE_NAME}`](identifier, null, null, null, statementsNode, null, parent);
							if (music !== null) {
								return music;
							}
						}
					} catch (error) {
						console.error('Error parsing music:', error);
					}
				}
			} else if (child.type === 'identifier') {
				identifier = child.text;
				needNestedFieldExpression = false;
			} else if (child.type === 'attribute') {
				identifier = child.text;
				callEditable = false;
				nestedFieldExpressionNode = child;
				needNestedFieldExpression = true;
			} else if (child.type === 'nestedFieldExpression') {
				needNestedFieldExpression = false;
				callEditable = true;
				editableReturn = true;
			}
		}
		if (utils.prototypeBlocks[identifier]) {
			if (identifier === 'str') {
				for (const child of statementsNode) {
					if (child.type === 'call') {
						return this.determineCallExpressionBlockType(child, node);
					}
				}
			}
			// avoid forcing the type of the variable in case of print, maybe redondant with the previous condition - need to check - also dosent work for nested parent inside the print function
			if (statementsNode.length > 0 && identifier === 'str' && (parent.text.match(/print/g) || parent.type === 'binary_operator')) {
				return this.getBlockType(statementsNode[0], node);
			}

			const isPrototype = utils.prototypeBlocks[identifier](identifier, null, null, null, statementsNode, null, parent);
			if (isPrototype !== null) {
				return isPrototype;
			}
		}
		if (callEditable) {
			addChain(statementsNode);
		}
		if (needNestedFieldExpression) {
			const needBypass = addNestedFieldExpression();
			if (needBypass) {
				return needBypass;
			}
		}

		if (Object.keys(this._functions).includes(identifier)) {
			if (this.vittaFunctions.has(identifier)) return;
			this._functionsOrder.add(identifier);
			const functionToCall = this._functions[identifier];
			const procedureCallBlock = {
				type: '',
				fields: {},
				values: {},
				mutations: {},
				statementsNode: {},
				statement: null,
			};
			procedureCallBlock.mutations = { name: identifier, args: [] };
			if (functionToCall.args.length > 0) {
				for (let i = 0; i < functionToCall.args.length; i++) {
					const argType = functionToCall.args[i].type;
					const argReturn = argType === 'int' ? { type: 'number_literal', text: '0' } : { type: 'string_literal', text: '' };
					procedureCallBlock.values[`ARG${i}`] = null;
					procedureCallBlock.statementsNode[`ARG${i}`] = statementsNode[i] !== undefined ? statementsNode[i] : argReturn;
					procedureCallBlock.mutations.args.push(functionToCall.args[i].name);
				}
			}
			if (this._functions[identifier].return === false) {
				procedureCallBlock.type = 'procedures_callnoreturn';
				return procedureCallBlock;
			} else {
				procedureCallBlock.type = 'procedures_callreturn';
				return procedureCallBlock;
			}
		}
		// to rework => maybe unnecessary for python (need to check)
		// console.log("editableReturn: ", editableReturn);
		if (callEditable) {
			// console.log('parent of editable: ', parent, 'editableReturn: ', editableReturn);
			if (editableReturn || (parent !== null && (node.type.match(/_for_return/gi) || parent.type === 'call' || parent.type === 'bypass' || parent.type === 'expression_statement' || parent.type === 'if_statement' || parent.type === 'keyword_argument' || parent.type === 'declaration' || parent.type === 'binary_operator' || parent.type === 'comparison_operator' || parent.type === 'not_operator'))) {
				return {
					type: 'call_expression_editable_return',
					fields: { NAME: identifier },
					values: mutationValues,
					mutations: mutations,
					statementsNode: mutationStatementNodes,
					statement: null,
				};
			} else {
				return {
					type: 'call_expression_editable',
					fields: { NAME: identifier },
					values: mutationValues,
					mutations: mutations,
					statementsNode: mutationStatementNodes,
					statement: null,
				};
			}
		} else {
			// console.log('parent of call: ', parent);
			if (parent !== null && (node.type.match(/_for_return/gi) || parent.type === 'call' || parent.type === 'expression_statement' || parent.type === 'if_statement' || parent.type === 'while_statement' || parent.type === 'unary_expression' || parent.type === 'binary_operator' || parent.type === 'comparison_operator' || parent.type === 'for_statement' || parent.type === 'not_operator' || parent.type === 'return_statement')) {
				return {
					type: 'call_expression_return',
					fields: { NAME: identifier },
					values: { chain: null },
					mutations: null,
					statementsNode: { chain: newNode },
					statement: null,
				};
			}
			return {
				type: 'call_expression',
				fields: { NAME: identifier },
				values: { chain: null },
				mutations: null,
				statementsNode: { chain: newNode },
				statement: null,
			};
		}
	}

	/**
	 * @description Shortcut to get the prototype block of simple functions if not intercepted before (ex: math.sin, math.cos, math.pi, etc) attributes contains identifier
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 */
	determineAttributeBlockType(node, parent = null) {
		if (utils.prototypeBlocks[node.text]) {
			return utils.prototypeBlocks[node.text](node, null, null, null, null, null, parent);
		}
		// case if the attribute is a methode from a class within declared variable (ex: sprite.deleted )
		if (node.children[0].type === 'identifier' && this.utils._variables[node.children[0].text] !== undefined) {
			const variable = node.children[0].text;
			if (node.children[2].type === 'identifier' && this.utils.prototypeBlocks[node.children[2].text]) {
				return this.utils.prototypeBlocks[node.children[2].text](node.children[2].text, variable, node);
			}
		}
	}

	/**
	 * Serialize Number literal block type
	 * @description Number literal return a simple math_number block with the value of the number literal
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineIntegerFloatBlockType(node) {
		return {
			type: 'math_number',
			fields: { NUM: node.text },
			values: {},
			mutations: null,
			statementNode: null,
		};
	}

	/**
	 * Serialize Binary expression block type
	 * @description Binary expression can generate multiple blocks and may need interceptors to avoid simple math_arithmetic blocks (ex: string concatenation, array length, M_PI and constants, etc)
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineBinaryExpressionBlockType(node) {
		const operatorType = {
			'+': 'ADD',
			'-': 'MINUS',
			'*': 'MULTIPLY',
			'**': 'POWER',
			'/': 'DIVIDE',
			'%': 'MODULO',
			'==': 'EQ',
			'!=': 'NEQ',
			'>': 'GT',
			'<': 'LT',
			'>=': 'GTE',
			'<=': 'LTE',
			'and': 'AND',
			'or': 'OR',
		};

		const operatorText = node.children[1].text;
		const operator = operatorType[operatorText];
		if (operator === 'ADD') {
			let stringNodes = utils.checkForStringLiteralOnly(node);
			if (stringNodes.length > 0) {
				return utils.prototypeBlocks['text_join_simple']('text_join', null, null, null, stringNodes, null);
			}
		}
		const checkType = ['integer', 'identifier', 'subscript_expression', 'binary_operator', 'float', 'call', 'attribute'];
		let left = node.children[0];
		if (left.type === 'parenthesized_expression') {
			left = utils.checkForNested('parenthesized_expression', checkType, node.children[0]);
		}
		let right = node.children[2];
		if (right.type === 'parenthesized_expression') {
			right = utils.checkForNested('parenthesized_expression', checkType, node.children[2]);
		}

		const comparisonOperators = ['EQ', 'NEQ', 'GT', 'LT', 'GTE', 'LTE', 'AND', 'OR'];
		const interceptorResult = utils.checkBinaryInterceptor(left, operator, right);
		if (interceptorResult) {
			return interceptorResult;
		}

		// not the best way to handle list multiplication but it works for now
		if (operator === 'MULTIPLY' && ((left.type === 'list' && right.type !== 'list') || (right.type === 'list' && left.type !== 'list'))) {
			return utils.interceptors['list_repeat'](left, right);
		}

		if (left.type === 'subscript') {
			if (left.children[0].type === 'identifier' && utils.prototypeBlocks[left.children[0].text]) {
				return utils.prototypeBlocks[left.children[0].text](left, right, operatorText);
			}
		}

		const checkEvenOddInteger = (left, right) => {
			if (left.type === 'binary_operator' && right.type === 'integer') {
				if (left.children.length === 3 && left.children[1].text === '%') {
					if (left.children[2].text === '2' && right.text === '0') {
						return {
							type: 'math_number_property',
							fields: { PROPERTY: 'EVEN' },
							values: {
								NUMBER_TO_CHECK: null,
							},
							mutations: null,
							statementsNode: { NUMBER_TO_CHECK: left.children[0] },
							statement: null,
						};
					} else if (left.children[2].text === '2' && right.text === '1') {
						return {
							type: 'math_number_property',
							fields: { PROPERTY: 'ODD' },
							values: {
								NUMBER_TO_CHECK: null,
							},
							mutations: null,
							statementsNode: { NUMBER_TO_CHECK: left.children[0] },
							statement: null,
						};
					} else if (left.children[2].text === '1' && right.text === '0') {
						return {
							type: 'math_number_property',
							fields: { PROPERTY: 'WHOLE' },
							values: {
								NUMBER_TO_CHECK: null,
							},
							mutations: null,
							statementsNode: { NUMBER_TO_CHECK: left.children[0] },
							statement: null,
						};
					} else if (right.text === '0') {
						return {
							type: 'math_number_property',
							fields: { PROPERTY: 'DIVISIBLE_BY' },
							values: {
								NUMBER_TO_CHECK: null,
								DIVISOR: null,
							},
							mutations: null,
							statementsNode: { NUMBER_TO_CHECK: left.children[0], DIVISOR: left.children[2] },
							statement: null,
						};
					}
				}
			}
			return null;
		};

		if (comparisonOperators.includes(operator)) {
			if (operator === 'AND' || operator === 'OR') {
				return {
					type: 'logic_operation',
					fields: { OP: operator },
					values: {
						A: null,
						B: null,
					},
					mutations: null,
					statementsNode: { A: left, B: right },
					statement: null,
				};
			} else {
				const specialBlocks = checkEvenOddInteger(left, right);
				if (specialBlocks) {
					return specialBlocks;
				} else {
					return {
						type: 'logic_compare',
						fields: { OP: operator },
						values: {
							A: null,
							B: null,
						},
						mutations: null,
						statementsNode: { A: left, B: right },
						statement: null,
					};
				}
			}
		} else if (operator === 'MODULO') {
			return {
				type: 'math_modulo',
				fields: {},
				values: {
					DIVIDEND: null,
					DIVISOR: null,
				},
				mutations: null,
				statementsNode: { DIVIDEND: left, DIVISOR: right },
				statement: null,
			};
		} else {
			return {
				type: 'math_arithmetic',
				fields: { OP: operator },
				values: {
					A: null,
					B: null,
				},
				mutations: null,
				statementsNode: { A: left, B: right },
				statement: null,
			};
		}
	}

	/**
	 * Serialize Unary expression block type - only used for for statement, increment, decrement, not, etc
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineUnaryExpressionBlockType(node, parent = null) {
		let negate = false;
		let number = false;
		let argument;
		for (const child of node.children) {
			if (child.type === '-') {
				negate = true;
			} else if (child.type === 'integer' || child.type === 'float') {
				argument = '-' + child.text;
				number = true;
			}
		}

		if (negate && number) {
			return {
				type: 'math_number',
				fields: { NUM: argument },
				values: null,
				mutations: null,
				statementNode: null,
				statement: null,
			};
		}
	}

	/**
	 * Serialize if statement block type
	 * @description If statement may need a lot of recursive call to serialize nested if statements inside else clauses in order to get if statement inside if statements inside if statements, etc
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	detectIfStatementBlockType(node) {
		const ifBlock = {
			type: 'controls_if',
			fields: {},
			values: {},
			mutations: {
				elseif: 0,
				else: 0,
			},
			statementsNode: {},
			statements: {},
		};

		let conditionIndex = 0;
		let doIndex = 0;
		ifBlock.values[`IF${conditionIndex}`] = null;
		// remove parenthesis if any
		ifBlock.statementsNode[`IF${conditionIndex}`] = node.children[1].type === 'parenthesized_expression' ? node.children[1].children[1] : node.children[1];
		// console.log(ifBlock.statementsNode[`IF${conditionIndex}`]);

		conditionIndex++;

		for (const child of node.children) {
			if (child.type === 'block') {
				ifBlock.statements[`DO${doIndex}`] = child;
				doIndex++;
			} else if (child.type === 'elif_clause') {
				ifBlock.values[`IF${conditionIndex}`] = null;
				ifBlock.statementsNode[`IF${conditionIndex}`] = child.children[1];
				conditionIndex++;

				for (const elifChild of child.children) {
					if (elifChild.type === 'block') {
						ifBlock.statements[`DO${doIndex}`] = elifChild;
						doIndex++;
						ifBlock.mutations.elseif += 1;
					}
				}
			} else if (child.type === 'else_clause') {
				for (const elseChild of child.children) {
					if (elseChild.type === 'block') {
						ifBlock.statements['ELSE'] = elseChild;
						ifBlock.mutations.else += 1;
					}
				}
			}
		}

		// DO not remove for now
		// const nodeCheck = ifBlock.statementsNode['IF0'];
		// if (nodeCheck.children[0] && nodeCheck.children[0].type === 'identifier' && utils.prototypeBlocks[nodeCheck.children[0].text]) {
		// 	for (const child of nodeCheck.children) {
		// 		if (child.type === 'argument_list') {
		// 			child.children.push(ifBlock.statements['DO0']);
		// 		}
		// 	}
		// 	return this.getBlockType(nodeCheck, node);
		// }

		// if you want to chech for specific string in the if condition clause to avoid classical if block (ex if buttun_a.was/is_pressed(): ...) you need to add "_string" in the utils.prototypeBlocks name to avoid conflicts with other prototype blocks that may have the same name
		if (utils.prototypeBlocks[`${utils.rmSpaces(node.children[1].text)}_string`]) {
			const check = utils.prototypeBlocks[`${utils.rmSpaces(node.children[1].text)}_string`](node.children[1], null, null, null, ifBlock.statements['DO0'], null, null);
			if (check !== null) {
				return check;
			}
		}

		// console.log(ifBlock);
		return ifBlock;
	}

	/**
	 * Basic implementation of the for statement block type - need to be improved (range() etc)
	 * Serialize for statement block type
	 * @description For statement need to be handled with caution as it may contain multiple statements
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	detectForStatementBlockType(node) {
		const forBlock = {
			type: 'controls_for',
			fields: {},
			values: {},
			mutations: null,
			statementsNode: {},
			statements: {},
		};

		let variableElement = {
			name: null,
			id: null,
			value: null,
		};

		for (const child of node.children) {
			if (child.type === 'identifier' && variableElement.name === null) {
				const varID = this.getVariableID(child.text) || this.declareBlocklyVariable(child.text, null);

				variableElement = { name: 'VAR', id: varID, value: child.text };
			} else if (child.type === 'call') {
				let args;
				for (const callChild of child.children) {
					if (callChild.type === 'argument_list') {
						args = utils.getArgumentList(callChild.children);
					}
				}
				if (args.length > 2) {
					forBlock.fields['VAR'] = variableElement;
					forBlock.values['FROM'] = null;
					forBlock.statementsNode['FROM'] = args[0];
					forBlock.values['TO'] = null;
					forBlock.statementsNode['TO'] = args[1];
					forBlock.values['BY'] = null;
					forBlock.statementsNode['BY'] = args[2];
				} else if (args.length === 1) {
					forBlock.values['TIMES'] = null;
					forBlock.statementsNode['TIMES'] = args[0];
					forBlock.type = 'controls_repeat';
				}
			} else if (child.type === 'list' || child.type === 'identifier') {
				forBlock.type = 'controls_forEach';
				forBlock.fields['VAR'] = variableElement;
				forBlock.values['LIST'] = null;
				forBlock.statementsNode['LIST'] = child;
			} else if (child.type === 'block') {
				forBlock.statements['DO'] = child;
			}
		}
		// console.log(forBlock);
		return forBlock;
	}

	/**
	 * Serialize declaration block type
	 * @description declaration block can generate multiple blocks especially in case of nested filed expressions, and may or may not return something
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @param {object} standalone - standalone flag (ex : for declaration block)
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineDeclarationBlockType(node, parent = null, standalone = true) {
		// Logique pour déterminer le type de bloc pour une déclaration
		if (this._variableNodes === null) {
			const variableNode = utils.newNode('variables', {}, null, null);
			this._variableNodes = variableNode;
			this.xml.prepend(variableNode);
		}

		let identifier = null;
		let childNode = null;
		if (node.children) {
			for (const child of node.children) {
				if (child.type === 'identifier') {
					identifier = child.text;
				}
			}
		}

		const variableID = Blockly.utils.genUid();

		return { variableID, identifier, node: childNode };
	}

	/**
	 * Serialize subscript expression block type
	 * @description Subscript expression used to get an element from an array
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineSubscriptExpressionBlockType(node) {
		let identifier = null;
		let index = null;
		let textBlock = false;

		for (const child of node.children) {
			if (identifier === null && (child.type === 'identifier' || child.type === 'string' || (child.type === 'call' && child.text.match(/str\(\s*/g)))) {
				identifier = child;
				if (this._variables[identifier.text] && this._variables[identifier.text].type === 'string') {
					textBlock = true;
				}
			} else if (child.type === 'integer' || child.type === 'identifier') {
				index = child;
			} else if (child.type === 'unary_operator') {
				index = child;
			} else if (child.type === 'slice') {
				// reverse node
				if (child.text === '::-1') return utils.prototypeBlocks['text_reverse'](null, null, null, null, identifier, null);
				// in that case we should extract the slice block to put it in the prototypeBlocks => TODO
				return utils.prototypeBlocks['list_slice'](identifier, child);
			} else if (child.type === 'call') {
				identifier = child;
			}
		}

		// specific case for subscript to a predefined function in the prototypeBlocks ex : photon.get_line_sensors()[0] => retrieve the index and the identifier
		if (identifier && utils.prototypeBlocks[identifier.text]) {
			return utils.prototypeBlocks[identifier.text](identifier, index);
		}

		for (const child of node.children) {
			if (child.type === 'call' && index !== null) {
				for (const callChild of child.children) {
					if (callChild.type === 'argument_list') {
						callChild.children.push(index);
						return this.getBlockType(child, node);
					}
				}
			}
		}

		if (textBlock) {
			return utils.prototypeBlocks['text_charAt'](identifier, index);
		} else {
			return utils.prototypeBlocks['lists_getIndex'](identifier, index);
		}
	}

	/**
	 * Serialize initializer list block type
	 * @description Initializer list block
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineInitializerListBlockType(node) {
		const initializerListBlock = {
			type: 'lists_create_with',
			fields: {},
			values: {},
			mutations: {},
			statementsNode: {},
			statement: null,
		};

		let index = 0;

		for (let i = 0; i < node.children.length; i++) {
			const child = node.children[i];
			if (child.type === 'integer' || child.type === 'string' || child.type === 'identifier' || child.type === 'list') {
				initializerListBlock.values[`ADD${index}`] = null;
				initializerListBlock.statementsNode[`ADD${index}`] = child;
				index++;
			} else {
				// unused for now but may be interesting to handle the case
				// return {
				// 	type: 'untranslatable_block',
				// 	fields: { CODE: node.text.replace('//', '') },
				// 	values: {},
				// 	mutations: null,
				// 	statementsNode: null,
				// 	statement: null,
				// };
			}
		}

		const addMutations = () => {
			initializerListBlock.mutations = { items: Object.keys(initializerListBlock.values).length };
		};

		addMutations();
		// console.log(initializerListBlock);
		return initializerListBlock;
	}

	/**
	 * Serialize string literal block type
	 * @description String literal block => return a simple text block with the value of the string literal
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineStringLiteralBlockType(node) {
		const beautifyString = (str) => {
			return str.replaceAll('"', '').replaceAll("'", '');
		};

		const newString = beautifyString(node.text);
		const checkEscape = newString.match(/^(\\n)+$/); // Supprimer le modificateur 'g' ici

		// new line block if the string is only composed of escape sequences, otherwise classical text block
		if (checkEscape) {
			const occurrences = (newString.match(/\\n/g) || []).length;
			return {
				type: 'text_newline',
				fields: {},
				values: { N: null },
				mutations: null,
				statementsNode: { N: { type: 'integer', text: occurrences.toString() } },
				statement: null,
			};
		} else {
			return {
				type: 'text',
				fields: { TEXT: newString },
				values: {},
				mutations: null,
				statementsNode: null,
				statement: null,
			};
		}
	}

	/**
	 * @description Get the id of a Blockly variable => to put in utils if possible but requires constants from the current class
	 * @param {string} variableName - The name of the variable
	 * @param {object} node - The node to serialize
	 * @returns {string} - The id of the variable
	 * */
	getVariableID(variableName, node = null) {
		if (this._variableNodes === null) {
			if (node === null) {
				return null;
			} else {
				let type;
				for (const child of node.children) {
					if (child.type === 'number_literal' || child.type === 'string_literal') {
						switch (child.type) {
							case 'number_literal':
								type = 'int';
								break;
							case 'string_literal':
								type = 'String';
								break;
							case 'char_literal':
								type = 'CHARACTER';
								break;
						}
					}
				}
				this.declareBlocklyVariable(variableName, type);
			}
		}
		const variablesID = this._variableNodes.querySelectorAll('variable');
		for (const variable of variablesID) {
			if (variable.textContent === variableName) {
				return variable.getAttribute('id');
			}
		}
		return null;
	}

	/**
	 * @description Declare a Blockly variable
	 * @param {string} variableName - The name of the variable
	 * @param {string} variableType - The type of the variable
	 * @returns {string} - The id of the variable
	 * */
	declareBlocklyVariable(variableName, variableType, value = null) {
		if (this._variableNodes === null) {
			const variableNode = utils.newNode('variables', {}, null, null);
			this._variableNodes = variableNode;
			this.xml.prepend(variableNode);
		}

		if (Object.keys(this._variables).includes(variableName)) {
			return this._variables[variableName].id;
		}

		const variableID = Blockly.utils.genUid();
		const newVariable = utils.newNode('variable', { id: variableID }, variableName, null);
		this._variableNodes.appendChild(newVariable);
		this._variables[variableName] = { type: variableType, id: variableID, value: value };
		return variableID;
	}

	/**
	 * Serialize assignment block type
	 * @description Assignment block can generate either variables_set block or variables_increment block (in case of increment)
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineAssignmentBlockType(node, parent = null) {
		let left,
			right,
			type = null;
		let operator = null;

		let errorDetected = false;

		const typeMappings = {
			identifier: 'identifier',
			pattern_list: 'pattern_list',
			none: 'all',
			integer: 'integer',
			string: 'string',
			call: 'function',
			list: 'array',
			tuple: 'array',
			float: 'float',
			attribute: 'attribute',
			not_operator: 'not_operator',
			binary_operator: 'binary_operator',
			comparison_operator: 'all',
			boolean_operator: 'all',
			subscript: 'array',
			unary_operator: 'all',
			parenthesized_expression: 'all',
			cast_expression: 'all',
			dictionary: 'dictionary',
			true: 'boolean',
			false: 'boolean',
		};

		for (const child of node.children) {
			if (child.type === 'identifier' || child.type === 'subscript' || child.type === 'pattern_list') {
				if (left === undefined) {
					left = child;
				} else {
					right = child;
				}
			} else if (Object.keys(typeMappings).includes(child.type)) {
				right = child;
				type = typeMappings[child.type] || type;
			} else if (child.type === '+=' || child.type === '-=' || child.type === '*=' || child.type === '/=') {
				operator = child.text;
			} else if (child.type === 'ERROR' || (left !== undefined && child.type === ':') || child.type === 'set') {
				errorDetected = true;
			}
		}

		if (errorDetected) {
			return {
				type: 'untranslatable_block',
				fields: { CODE: node.text.replace('//', '') },
				values: {},
				mutations: null,
				statementsNode: null,
				statement: null,
			};
		}

		const checkClasses = utils.storeVariable(left, right);

		if (checkClasses !== null) {
			if (checkClasses.type === 'call') {
				return this.getBlockType(checkClasses, node);
			} else {
				return checkClasses;
			}
		}

		// check if righ is identifier and check the original type
		if (right.type === 'identifier') {
			const rightType = this._variables[right.text]?.type || undefined;
			if (rightType !== undefined) {
				type = rightType;
			}
		}
		const varID = this.getVariableID(left.text) || this.declareBlocklyVariable(left.text, type === null ? left.type : type, right);

		// update the value && type of the variable if already declared
		if (this._variables[left.text] && right.type !== 'identifier') {
			this._variables[left.text].value = right.text;
			this._variables[left.text].type = type;
		}

		if (utils.interceptors[utils.rmSpaces(node.text)]) {
			return utils.interceptors[utils.rmSpaces(node.text)](node);
		}

		if (left.type === 'subscript') {
			return utils.prototypeBlocks['list_subscript'](left, right);
		}

		if (right.type === 'binary_operator' && right.children[0].text === left.text && right.children[1].text === '+') {
			return {
				type: 'variables_increment',
				fields: { VAR: { name: 'VAR', id: varID, value: left.text } },
				values: { DELTA: null },
				mutations: null,
				statementsNode: { DELTA: right.children[2] },
				statement: null,
			};
		} else {
			return {
				type: 'variables_set',
				fields: { VAR: { name: 'VAR', id: varID, value: left.text } },
				values: { VALUE: null },
				mutations: null,
				statementsNode: { VALUE: right },
				statement: null,
			};
		}
	}

	/**
	 * Serialize expression statement block type
	 * @description Expression statement block can generate either call expression block or assignment block
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineExpressionStatementBlockType(node, parent = null) {
		if (node.children.length === 1 && node.children[0].type === 'string') {
			let start = false;
			let comment = '';
			for (const child of node.children[0].children) {
				if (child.type === 'string_start' && child.text === '"""') {
					start = true;
				} else if (child.type === 'string_content') {
					comment += child.text;
				} else if (child.type === 'string_end' && child.text === '"""') {
					if (start && comment.length > 0) {

						for(const com of utils.EXCLUDED_DOCSTRINGS) {
							if (comment.match(com)) {
								this._storedExcludedDocstrings.add(comment);
								return '';
							}
						}

						return {
							type: 'comment_docstrings',
							fields: { COMMENT: comment },
							values: {},
							mutations: null,
							statementsNode: null,
							statement: null,
						};
					}
				}
			}
		}
		for (const child of node.children) {
			if (child.type === 'call') {
				const callExpressionBlock = this.determineCallExpressionBlockType(child, parent);
				return callExpressionBlock;
			} else if (child.type === 'assignment') {
				return this.determineAssignmentBlockType(child);
			}
		}
	}

	/**
	 * Serialize identifier block type
	 * @description Identifier block are used to get the value of a variable and create it if not already declared
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineIdentifierBlockType(node) {
		let varId;
		varId = this.getVariableID(node.text, node);
		if (varId === null) {
			const declaration = this.determineDeclarationBlockType(node, null, false);
			varId = declaration.variableID;
		}

		// add variable to variableNodes if not already declared
		if (this._variables[node.text] === undefined) {
			this.declareBlocklyVariable(node.text, node.type);
		}

		// forBlock.fields['VAR'] = { name: 'VAR', id: varId, value: varValue };
		// if (utils.prototypeBlocks[node.text]) {
		// 	return utils.prototypeBlocks[node.text](node.text, null, null, null, null, null);
		// }
		return {
			type: 'variables_get',
			fields: { VAR: { name: 'VAR', id: varId, value: node.text } },
			values: {},
			mutations: null,
			statementsNode: null,
			statement: null,
		};
	}

	/**
	 * Serialize Comment block type
	 * @description Comment block are used to add comments to the code (not in the original toolbox)
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineCommentBlockType(node, parent = null) {
		const excludedComments = utils.EXCLUDED_COMMENTS;

		for (const com of excludedComments) {
            if (node.text.match(com)) {
                this._storedExcludedComments.add(node.text);
                return '';
            }
        }

		return {
			type: 'text_comment',
			fields: { TEXT: node.text.replace('#', '') },
			values: {},
			mutations: null,
			statementsNode: null,
			statement: null,
		};
	}

	/**
	 * Serialize While statement block type
	 * @description While statement block are used to create while loops in the code. It may contain nested blocks in the condition clause and the compound statement
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	detectWhileStatementBlockType(node, parent = null) {
		const whileBlock = {
			type: 'controls_whileUntil',
			fields: {},
			values: {},
			mutations: null,
			statementsNode: {},
			statements: {},
		};

		const conditionType = ['unary_expression', 'parenthesized_expression', 'binary_operator', 'identifier', 'call', 'comparison_operator'];

		for (const child of node.children) {
			if (child.type === 'not_operator') {
				whileBlock.fields['MODE'] = 'UNTIL';
				whileBlock.values['BOOL'] = null;
				for (const notChild of child.children) {
					if (notChild.type === 'parenthesized_expression') {
						whileBlock.statementsNode['BOOL'] = utils.checkForNested('parenthesized_expression', ['unary_operator', 'binary_operator', 'comparison_operator', 'identifier'], notChild);
					} else {
						whileBlock.statementsNode['BOOL'] = conditionType.includes(notChild.type) ? notChild : null;
					}
				}
			} else if (conditionType.includes(child.type)) {
				whileBlock.fields['MODE'] = 'WHILE';
				whileBlock.values['BOOL'] = null;
				if (child.type === 'parenthesized_expression') {
					whileBlock.statementsNode['BOOL'] = utils.checkForNested('parenthesized_expression', ['unary_operator', 'binary_operator', 'comparison_operator', 'identifier'], child);
				} else {
					whileBlock.statementsNode['BOOL'] = conditionType.includes(child.type) ? child : null;
				}
			} else if (child.type === 'block') {
				whileBlock.statements['DO'] = child;
			}
		}
		// console.log('whileBlock: ', whileBlock);
		return whileBlock;
	}

	/**
	 * Serialize Return statement block type
	 * @description Return statement block are used to return a value from a function. If a return statement is found at the first level of the function, it will return a procedures_defnoreturn block, otherwise it will return a procedures_simple_return block. This block is not present in the toolbox but can be generated by the code
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineReturnStatementBlockType(node, parent = null) {
		let returnNode;
		for (const child of node.children) {
			if (child.type === 'identifier' || child.type === 'integer' || child.type === 'string' || child.type === 'call' || child.type === 'binary_operator') {
				returnNode = child;
			}
		}
		return {
			type: 'procedures_simple_return',
			fields: {},
			values: { VALUE: null },
			mutations: null,
			statementsNode: { VALUE: returnNode },
			statement: null,
		};
	}

	/**
	 * Serialize Switch case statement block type
	 * @description Switch case statement block are used to create switch case statements in the code. It is not présent in the toolbox but can be generated by the code
	 * @param {object} node - The node to serialize
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineSwitchStatementBlockType(node) {
		const switchBlock = {
			type: 'switch_case',
			fields: {},
			values: {},
			mutations: null,
			statementsNode: {},
			statements: {},
		};

		let caseIndex = 0;
		let defaultIndex = 0;
		const checkType = ['number_literal', 'identifier', 'subscript_expression', 'binary_expression', 'string_literal', 'call_expression'];

		function createCompoundStatement(children) {
			const compoundStatement = { type: 'compound_statement', children };
			return compoundStatement;
		}

		function parseSwitchStatement(node) {
			for (const child of node.children) {
				if (child.type === 'condition_clause') {
					switchBlock.values['SWITCH_VAR'] = null;
					switchBlock.statementsNode['SWITCH_VAR'] = child.children.filter((child) => checkType.includes(child.type))[0];
				} else if (child.type === 'compound_statement') {
					for (const compoundChild of child.children) {
						if (compoundChild.type === 'case_statement') {
							switchBlock.values[`CASE${caseIndex}`] = null;
							switchBlock.statementsNode[`CASE${caseIndex}`] = compoundChild.children[1];
							switchBlock.statements[`DO${caseIndex}`] = createCompoundStatement(compoundChild.children.slice(2));
							caseIndex++;
						}
					}
				}
			}
		}
		parseSwitchStatement(node);
		switchBlock.mutations = { case: caseIndex };
		// console.log(switchBlock);
		return switchBlock;
	}

	/**
	 * Boolean block type
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineBooleanBlockType = (node, parent) => {
		return {
			type: 'logic_boolean',
			fields: { BOOL: node.text.toUpperCase() },
			values: {},
			mutations: null,
			statementsNode: null,
			statement: null,
		};
	};

	/**
	 * Determine while True statement block type
	 * @description While True statement block are used to create infinite loops in the code ad "forever" block in Blockly.
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	detectForeverStatementBlockType = (node, parent) => {
		const toolboxMode = Blockly.Constants.getToolboxStyle();
		let foreverBlock;
		if (toolboxMode === 'scratch') {
			foreverBlock = {
				type: 'scratch_forever',
				fields: {},
				values: {},
				mutations: null,
				statementsNode: {},
				statement: null,
			};
		} else {
			foreverBlock = {
				type: 'forever',
				fields: {},
				values: {},
				mutations: null,
				statementsNode: {},
				statement: null,
			};
		}

		for (const child of node.children) {
			if (child.type === 'block') {
				foreverBlock.statement = { DO: child };
			}
		}
		return foreverBlock;
	};

	/**
	 * Break and continue statement block type for loops
	 * @description Break and continue statement block are used to break or continue a loop. It will check the grand parent node to determine if the block is authorized => should not be used outside of a loop
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @param {object} grandParent - The grand parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineContinueBreakStatementBlockType = (node, parent, grandParent) => {
		const grandParentAuthorised = ['forever', 'controls_repeat', 'controls_whileUntil', 'controls_for', 'controls_forEach', 'controls_flow_statements'];

		if (!grandParentAuthorised.includes(grandParent)) return;

		let statementType = '';
		for (const child of node.children) {
			if (child.type === 'continue') {
				statementType = 'CONTINUE';
			} else if (child.type === 'break') {
				statementType = 'BREAK';
			}
		}

		return {
			type: 'controls_flow_statements',
			fields: { FLOW: statementType },
			values: {},
			mutations: null,
			statementsNode: null,
			statement: null,
		};
	};

	/**
	 * Determine the block type for global variables
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineGlobalBlockType = (node, parent) => {
		let global;
		const checkType = ['identifier'];
		for (const child of node.children) {
			if (checkType.includes(child.type)) {
				global = child;
			}
		}

		const varID = this.getVariableID(global.text) || this.declareBlocklyVariable(global.text, null);

		const globalBlock = {
			type: 'variables_global',
			fields: { VAR: { name: 'VAR', id: varID, value: global.text } },
			values: {},
			mutations: null,
			statementsNode: null,
			statement: null,
		};
		return globalBlock;
	};

	/**
	 * Determine the block type for untranslatable block
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineErrorBlockType = (node, parent) => {
		return {
			type: 'untranslatable_block',
			fields: { CODE: node.text.replace('//', '') },
			values: {},
			mutations: null,
			statementsNode: null,
			statement: null,
		};
	};

	/**
	 * Serialize Not operator block type
	 * @description Not operator block are used to negate a precedent expression.
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineNotOperatorBlockType = (node, parent) => {
		if (node.children && node.children.length > 1 && node.children[1].type === 'call') {
			// cheks only for not len('') or not len([]) or not len({}) => should be improved and not hardcoded
			if (node.children[1].children[0].text === 'len') {
				const call = node.children[1];
				let args = null;
				for (const child of call.children) {
					if (child.type === 'argument_list') {
						args = utils.getArgumentList(child.children);
					}
				}
				const checkKnownKey = utils.prototypeBlocks[node.children[1].children[0].text](node.children[1], null, null, null, args, null, node);
				if (checkKnownKey !== null) {
					return checkKnownKey;
				}
			}
		}
		return {
			type: 'logic_negate',
			fields: {},
			values: { BOOL: null },
			mutations: null,
			statementsNode: { BOOL: node.children[1] },
			statement: null,
		};
	};

	/**
	 * Check import and add the import block to the class imports
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {void} - Add the import block to the class imports
	 * */
	determineImportBlockType = (node, parent) => {
		const importLibs = utils.checkImportStatement(node.text);
		let libName = null;
		let library = null;
		if (importLibs) {
			if (node.type === 'import_statement') {
				for (const child of node.children) {
					if (child.type === 'dotted_name') {
						libName = child.text;
					}
				}
			} else if (node.type === 'import_from_statement') {
				for (const child of node.children) {
					if (child.type === 'dotted_name' && library === null) {
						library = child.text;
					} else if (child.type === 'dotted_name') {
						libName = child.text;
					} else if (child.type === 'wildcard_import') {
						libName = library;
					}
				}
			}
			// const libToAdd = importLibs.replace('IMPORT_', '').toLowerCase();
			Blockly.Python.addImport(libName, node.text);
			this._imports.add(libName);
			this._importFullNames.add(`${library ? library + '.' : ''}${libName}`);
		}
	};

	// TODO: handle tuple
	determineTupleBlockType = (node, parent) => {};

	/**
	 * Shortcut to determine the block type of a bypass node witch is a custom node that can be used to bypass the serialization of a node and pass directly to the next node
	 * example: the method write_digital can call the bypass node to pass directly io_digital_signal that should normally be serialized as an integer (0 or 1) but instead call the state block HIGHT or LOW => pin0.write_digital(1)
	 * example 2: music.play will call music_note_single which will be called as mutator block instead of a text block
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineBypassBlockType = (node, parent) => {
		// Maybe add the possibility to add children to the bypass node
		if (utils.prototypeBlocks[node.block]) {
			return utils.prototypeBlocks[node.block](node.text, parent);
		} else {
			return '';
		}
	};

	/**
	 * Serialize the block 'None' node type
	 * @description None block are used to represent the None value in Python
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineNoneBlockType(node, parent) {
		return {
			type: 'logic_null',
			fields: {},
			values: {},
			mutations: null,
			statementsNode: null,
			statement: null,
		};
	}

	/**
	 * Serialize the block type of try_statement
	 * @description Try statement block are used to handle exceptions in the code. It may contain nested blocks in the try clause and the except clause
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineTryStatementBlockType(node, parent) {
		// check the statement inside the children block and return the appropriate block (try/except are also used in pin declaration)
		for (const child of node.children) {
			if (child.type === 'block') {
				const checkPinDeclaration = child.children.filter((childTest) => {
					return childTest.type === 'expression_statement';
				});
				if (checkPinDeclaration.length > 0) {
					// retrieve class declaration => to improve
					if (Object.keys(this._classes).includes(checkPinDeclaration[0].children[0]?.children[0]?.children[0]?.text)) {
						return this.getBlockType(checkPinDeclaration[0], node);
					}
				}
			}
		}

		// Otherwise return the try statement block
		return utils.prototypeBlocks['try_statement'](node, parent);
	}

	/**
	 * @description Serialize the block raise statement
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineRaiseBlockType(node, parent) {
		if (parent.type === 'block' || parent.type === 'statement') {
			for (const child of node.children) {
				if (child.type === 'identifier' || child.type === 'call') {
					return utils.prototypeBlocks['raise_statement'](child, parent);
				}
			}
		}
	}

	/**
	 * @description Serialize the block keyword argument (ex func(arg=1))
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determineKeywordArgumentBlockType(node, parent) {
		let identifier = null;
		let key = null;
		for (const child of node.children) {
			if (child.type === 'identifier') {
				identifier = child.text;
			} else {
				key = child;
			}
		}
		if (utils.prototypeBlocks[identifier]) {
			const checkKnownKey = utils.prototypeBlocks[identifier](identifier, key, parent);
			if (checkKnownKey !== null) {
				return checkKnownKey;
			}
		}
		return {
			type: 'keyword_argument',
			fields: { NAME: identifier },
			values: { VALUE: null },
			mutations: null,
			statementsNode: { VALUE: key },
			statement: null,
		};
	}

	/**
	 * Serialize the block type of a function definition
	 * @description return what's inside the parenthese expression
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - bypass the loop and call getBlockType with the appropriate node
	 * */
	determineParenthesizedExpressionBlockType(node, parent) {
		// to securize
		return this.getBlockType(node.children[1], parent);
	}

	/**
	 * Serialize the on event functions block type
	 * @description On event functions block are used to create event listeners in the code. It may contain nested blocks in the event clause. Only used for thymio for now
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - The block xml node with child nodes (if any)
	 * */
	determinedecoratedFunctionBlockType(node, parent) {
		let decorator = null;
		let functionDef = null;
		let functionBlock = null;
		let args = [];

		for (const child of node.children) {
			if (child.type === 'decorator') {
				decorator = child;
			} else if (child.type === 'function_definition') {
				for (const functionChild of child.children) {
					if (functionChild.type === 'identifier') {
						functionDef = functionChild;
					} else if (functionChild.type === 'block') {
						functionBlock = functionChild;
					} else if (functionChild.type === 'parameters'){
						for (const param of functionChild.children) {
							if (param.type === 'identifier') {
								args.push(utils.getParameterList(param));
							}
						}
					}
				}
			}
		}
		
		if (utils.prototypeBlocks[`${decorator.text.split('(')[0]}_${functionDef.text}`]) {
			return utils.prototypeBlocks[`${decorator.text.split('(')[0]}_${functionDef.text}`](decorator, functionDef, functionBlock, parent, args);
		}
	}

	/**
	 * Get the block type of a node depending on the type of the node from the AST. Kind of the crossroad of the serialization
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {func} - Call the appropriate function to serialize the node
	 * */
	getBlockType(node, parent = null, grandParent = null) {
		switch (node.type) {
			case 'block':
				return 'multiNode';
			case 'decorated_definition':
				return this.determinedecoratedFunctionBlockType(node, parent);
			case 'function_definition':
				return this.determineFunctionBlockType(node, parent);
			case 'expression_statement':
				return this.determineExpressionStatementBlockType(node, parent);
			case 'call':
				return this.determineCallExpressionBlockType(node, parent);
			case 'attribute':
				return this.determineAttributeBlockType(node, parent);
			case 'integer':
			case 'float':
				return this.determineIntegerFloatBlockType(node, parent);
			case 'not_operator':
				return this.determineNotOperatorBlockType(node, parent);
			case 'string':
				return this.determineStringLiteralBlockType(node, parent);
			case 'binary_operator':
			case 'boolean_operator':
			case 'comparison_operator':
				return this.determineBinaryExpressionBlockType(node, parent);
			case 'parenthesized_expression':
				return this.determineParenthesizedExpressionBlockType(node, parent);
			case 'unary_operator':
				return this.determineUnaryExpressionBlockType(node, parent);
			case 'if_statement':
				return this.detectIfStatementBlockType(node, parent);
			case 'for_statement':
				return this.detectForStatementBlockType(node, parent);
			case 'identifier':
				if (node.text === 'on_start' || Object.keys(this._functions).includes(node.text)) return;
				return this.determineIdentifierBlockType(node, parent);
			case 'keyword_argument':
				return this.determineKeywordArgumentBlockType(node, parent);
			// TODO: handle tuple
			case 'tuple':
				return this.determineTupleBlockType(node, parent);
			case 'comment':
				return this.determineCommentBlockType(node, parent);
			case 'list':
				return this.determineInitializerListBlockType(node, parent);
			case 'subscript':
				return this.determineSubscriptExpressionBlockType(node, parent);
			case 'while_statement':
				return this.detectWhileStatementBlockType(node, parent);
			case 'while_statement_forever':
				return this.detectForeverStatementBlockType(node, parent);
			case 'continue_statement':
			case 'break_statement':
				return this.determineContinueBreakStatementBlockType(node, parent, grandParent);
			case 'return_statement':
				return this.determineReturnStatementBlockType(node, parent);
			case 'false':
			case 'true':
				return this.determineBooleanBlockType(node, parent);
			case 'try_statement':
				return this.determineTryStatementBlockType(node, parent);
			case 'import_from_statement':
			case 'import_statement':
				return this.determineImportBlockType(node, parent);
			case 'global_statement':
				return this.determineGlobalBlockType(node, parent);
			case 'color_picker':
				return this.determineColorPickerBlockType(node, parent);
			case 'bypass':
				return this.determineBypassBlockType(node, parent);
			case 'raise_statement':
				return this.determineRaiseBlockType(node, parent);
			case 'none':
				return this.determineNoneBlockType(node, parent);
			case 'ERROR':
				return this.determineErrorBlockType(node, parent);
			default:
				return '';
		}
	}

	/**
	 * Serialize multiple nodes
	 * @param {object} nodes - The nodes to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - xml node with child nodes (if any) and next statements if in block statement
	 * */
	serializeMultipleNodes(nodes, parent, grandParent = null, skipNext = null) {
		let previousBlock = skipNext;
		let parentNode = null;
		let next = null;

		nodes.forEach((node) => {
			this.requireLastBlockId = true;

			const xml = this.serializeNode(node, parent, grandParent);

			// this part of the code is used to handle previous block suppression (array this.blockToRemove) if needed. For example in the case multi lines instructions that generates only one block => i.e robot Thymio => motors_left_target = 100\n motors_right_target = 100 should generate a forward block with speed 100 instead of two separated blocks
			const blockElement = parent.parent.querySelector('block');
			const nextBlockElement = next?.querySelector('block');
			if (blockElement) {
				const blockId = blockElement.getAttribute('id');
				if (this.blockToRemove.includes(blockId)) {
					blockElement.remove();
					parent.parent.append(xml);
					previousBlock = xml;
					parent.type = 'block';
					return;
				}
			}

			if (nextBlockElement) {
				const blockId = nextBlockElement.getAttribute('id');
				if (this.blockToRemove.includes(blockId)) {
					nextBlockElement.remove();

					next.append(xml);

					previousBlock = xml;
					parent.type = 'block';

					return;
				}
			}
			// end of the block suppression

			if (xml) {
				if (parent.type === 'statement') {
					parent.parent.append(xml);
					this.currentXml = parent.parent;
					previousBlock = xml;
					parent.type = 'block';
				} else if (parent.type === 'block') {
					if (previousBlock) {
						next = utils.newNode('next', {}, null, null);
						previousBlock.append(next);
						next.append(xml);
						this.currentXml = next;
						previousBlock = xml;
					}
				}
				parentNode = node;
			}
		});
	}

	/**
	 * Serialize a node
	 * @param {object} node - The node to serialize
	 * @param {object} parent - The parent node
	 * @returns {object} - xml node with child nodes (if any)
	 * */
	serializeNode(node, parent = null, type = null, skipNext = null) {
		try {
			const blockType = this.getBlockType(node, parent, type);
			if (blockType === 'multiNode') {
				return this.serializeMultipleNodes(node.children, parent, type, skipNext);
			} else if (typeof blockType === 'object' && blockType.type !== undefined) {
				return this.createBlocklyBlockXml(node, blockType.type, blockType.fields, blockType.values, blockType.mutations, blockType.statementsNode, blockType.element, blockType.statements);
			}
			return '';
		} catch (error) {
			console.error('Error serializing node:', error);
			if (typeof node?.start !== 'undefined' && node.start?.row !== 'undefined') {
				console.error(`Error serializing node (line ${node.start.row + 1}):`, error);
			} else {
				console.error(`Error serializing node:`, error);
			}
			return '';
		}
	}

	/**
	 * To update in a future version. Need to select the strok instead of the fill block color
	 * @description function to highlight the block in the workspace in debug mode - this.blocksArray is an array of id blocks to highlight (retrieved from conversion of the AST)
	 * @param {number} line - The line number to highlight
	 * */
	highlightBlock(line) {
		const blocksToHighlight = this.blocksArray[line];
		if (blocksToHighlight) {
			if (this.modifiedColorBlocks.length > 0) {
				for (let i = 0; i < this.modifiedColorBlocks.length; i++) {
					const blockElement = this.workspace.getBlockById(this.modifiedColorBlocks[i].id);
					if (blockElement) {
						blockElement.setColour(this.modifiedColorBlocks[i].color);
					}
				}
			}
			this.modifiedColorBlocks = [];
			for (let i = 0; i < blocksToHighlight.length; i++) {
				const blockElement = this.workspace.getBlockById(blocksToHighlight[i].id);
				if (blockElement) {
					this.modifiedColorBlocks.push({ id: blocksToHighlight[i].id, color: blockElement.getColour() });
					blockElement.setColour('#F9D142');
				}
			}
		}
	}

	/**
	 * Create the AST from the code
	 * @param {string} firstPass - Flag to indicate if it is the first pass and retreive the functions name from the code
	 * @param {object} ast - The AST to serialize
	 * @returns {object} - The AST in json format
	 * */
	convertAstToXml(firstPass = true, ast = null) {
		let astJson;

		if (firstPass) {
			astJson = this.parseCode();
			try {
				// doesn't work for now but need something more efficient than parsing the entire AST to get functions names 😅
				// this.collectFunctionDefinitions(astJson);
				return this.convertAstToXml(false, astJson);
			} catch (error) {
				console.error('Error collecting function definitions:', error);
			}
		} else {
			astJson = ast;
		}
		const reworkAst = (astJson) => {
			const onStart = [];
			const imports = [];
			const other = [];
			const whiles = [];
			const toolboxMode = Blockly.Constants.getToolboxStyle();
			for (const child of astJson.children) {
				if (child.type === 'while_statement') {
					if (child.children[1].type === 'true') {
						const newWile = { type: 'while_statement_forever', children: child.children.filter((child) => child.type !== 'true') };
						if (toolboxMode === 'scratch') {
							// with scratch, the forever block should be connected to the onStart block
							onStart.push(newWile);
						} else {
							whiles.push(newWile);
						}
					} else if (child.children[1].type === 'import_statement' || child.children[1].type === 'import_from_statement') {
						imports.push(child);
					} else {
						onStart.push(child);
					}

					// to rework in an object for exclusion
				} else if (child.type !== 'function_definition' && child.type !== 'decorated_definition') {
					onStart.push(child);
				} else {
					other.push(child);
				}
			}
			astJson.children = [];
			astJson.children = [
				...imports,
				{
					type: 'function_definition',
					children: [
						{ type: 'identifier', text: 'on_start' },
						{ type: 'block', children: onStart },
					],
				},
				...other,
				...whiles,
			];
		};
		reworkAst(astJson);
		this.debug && console.log('final ast', astJson);
		this.xml = utils.newNode('xml', { xmlns: 'https://developers.google.com/blockly/xml' }, null, null);
		astJson.children.forEach((node) => {
			const blockXml = this.serializeNode(node, astJson);
			if (blockXml) {
				this.xml.append(blockXml);
			}
		});

		let xmlString = new XMLSerializer().serializeToString(this.xml);
		// remove default xmlns
		xmlString = xmlString.replace(/a0:/g, '');
		xmlString = xmlString.replace(/xmlns(:\w+)?="http:\/\/www.w3.org\/1999\/xhtml"/g, '');
		return xmlString;
	}

	// will do it in the future if necessary. We need to check the pros and cons of this method => it will be more practicle but less efficient
	reorderFunctions(node) {
		const newOrder = {};
		const functions = {};
		for (const child of node) {
			if (child.type === 'function_definition') {
				functions[child.children[0].text] = child;
			}
		}
	}

	/**
	 * Collect function definitions - unused for now
	 * @param {object} astJson - The AST in json format
	 * */
	collectFunctionDefinitions(astJson) {
		this._functions = {}; // Reset function definitions

		function traverse(node) {
			if (node.type === 'function_definition') {
				let functionName = node.children[1].text.replace('(', '').replace(')', '');
				if (functionName === 'setup' || functionName === 'loop') {
					this._functions[functionName] = node;
				}
			}

			if (node.children) {
				node.children.forEach((child) => traverse.call(this, child));
			}
		}
		traverse.call(this, astJson);
	}

	/**
	 * Reset all properties in the class when typing new code in the editor
	 * @returns {void}
	 * */
	resetBlocks() {
		this._variableNodes = null;
		this._variables = {};
		this._imports.clear();
		this._importFullNames.clear();
		this._storedExcludedComments.clear();
		this._storedExcludedDocstrings.clear();
		this._classes = {};
		this._dictionary = {};
		this.specificBlocsInfo = [];
		utils.resetVariables();
		this.blocksArray = {};
		this.modifiedColorBlocks = [];
		this.blockToRemove = [];
		this.interface_specific = { ...utils.SPECIFIC_INIT };
		this.interface_specific_end = {};
	}

	/**
	 * Organize prototype blocks
	 * @description Organize the blocks in the workspace by moving them to the best readable position. Void setup and loop blocks are moved to the top of the workspace. Custom function blocks are moved to the right of the workspace. Define and include blocks are moved to the top of the workspace (if any) and before the setup block
	 * @returns {void}
	 * */
	organizePrototypeBlocks() {
		try {
			const workspace = this.workspace;
			let x = 10;
			let y = 10;
			let functionX = 350;
			let functionY = 0;
			const allBlocks = workspace.getAllBlocks();
			const untranslatableBlocks = allBlocks.filter((block) => block.type === 'untranslatable_block');
			const onStart = allBlocks.find((block) => block.type === 'on_start' || block.type === 'scratch_on_start');
			const loopBlock = allBlocks.find((block) => block.type === 'forever' || block.type === 'scratch_forever');
			const functionBlocks = allBlocks.filter((block) => block.type === 'procedures_defnoreturn' || block.type === 'procedures_defreturn');
			const oneventBlocks = allBlocks.filter((block) => block.type.match(/io_on/g));
			const callBackBlocks = allBlocks.filter((block) => block.type.match(/callback_decorated/g));
			const toolboxMode = Blockly.Constants.getToolboxStyle();
			// get setup block height
			let onStartHeight = 0;

			// callback blocks (should be moved to the top of the workspace)
			if (callBackBlocks.length > 0) {
				callBackBlocks.forEach((block) => {
					block.moveBy(x, y);
					y += block.height + 10;
				});
			}

			if (onStart) {
				onStart.moveBy(x, y);
				onStartHeight = onStart.height + y;
			}
			if (loopBlock && toolboxMode !== 'scratch') {
				loopBlock.moveBy(0, onStartHeight + 10);
			}

			if (functionBlocks.length > 0) {
				functionBlocks.forEach((block) => {
					block.moveBy(functionX, functionY);
					functionY += block.height + 10;
				});
			}

			if (oneventBlocks.length > 0) {
				oneventBlocks.forEach((block) => {
					if (block.parentBlock_ !== null) return
					block.moveBy(functionX, functionY);
					functionY += block.height + 10;
				});
			}

			
		} catch (error) {
			console.error('Error organizing blocks:', error);
		}
	}

	/**
	 * Store disabled blocks in an array
	 * @returns {void}
	 * */
	setBlockStore() {
		try {
			const ALL_DISABLED_BLOCKS = this.workspace.getAllBlocks().filter((block) => block.disabled === true);
			this.storedDisabledBlocks = ALL_DISABLED_BLOCKS.filter((block) => !block.getParent()).map((block) => Blockly.Xml.blockToDomWithXY(block));
		} catch (error) {
			console.error('Error storing blocks:', error);
		}
	}

	/**
	 * Retrieve stored disabled blocks
	 * @returns {void}
	 * */
	retrieveBlocksStored() {
		try {
			if (this.storedDisabledBlocks.length > 0) {
				this.storedDisabledBlocks.forEach((blockXml) => {
					let block = Blockly.Xml.domToBlock(blockXml, this.workspace);
					let x = parseInt(blockXml.getAttribute('x'), 10);
					let y = parseInt(blockXml.getAttribute('y'), 10);
					if (!isNaN(x) && !isNaN(y)) {
						block.moveBy(x, y);
					}
				});
			}
		} catch (error) {
			console.error('Error restoring blocks:', error);
		}
	}

	/**
	 * Debounce function
	 * @param {function} func - The function to debounce
	 * @param {number} wait - The time to wait before calling the function (ms)
	 * @param {boolean} immediate - Flag to indicate if the function should be called immediately
	 * @returns {function} - The debounced function
	 * */
	debounceFunction(func, wait, immediate) {
		return () => {
			const context = this,
				args = arguments;

			const later = () => {
				this.debounceTimeout = null;
				if (!immediate) func.apply(context, args);
			};

			const callNow = immediate && !this.debounceTimeout;
			clearTimeout(this.debounceTimeout);

			this.debounceTimeout = setTimeout(later, wait);
			if (callNow) func.apply(context, args);
		};
	}

	/**
	 * Prepare the injection of the blocks
	 * @description Prepare the injection of the blocks by checking the length of the code and calling the appropriate debounce function with timeout
	 * @returns {void} => call the injectBlocks function
	 * */
	prepareInjection() {
		const code = this.getTextCode();
		try {
			if (code.length > 400) {
				this.debounceFunction(this.injectBlocks.bind(this), 500)();
			} else if (code.length > 800) {
				this.debounceFunction(this.injectBlocks.bind(this), 1000)();
			} else if (code.length > 1200) {
				this.debounceFunction(this.injectBlocks.bind(this), 1500)();
			} else {
				this.injectBlocks();
			}
		} catch (error) {
			console.error('Error preparing injection:', error);
		}
	}

	/**
	 * Inject blocks in the workspace
	 * @description The main function of the class. It converts the code to an AST (first pass to retreive function names, reset all other objects) and then convert AST to xml blocks. It then injects the blocks (main XML) in the workspace and organizes them properly
	 * @returns {void}
	 * */
	injectBlocks() {
		this.setBlockStore();
		this.resetBlocks();
		this.vittaFunctions.clear();
		this._functions = {};
		this._functionsOrder.clear();

		const time = new Date().getTime();

		let xmlCode;
		try {
			// first pass to get all the functions
			xmlCode = this.convertAstToXml();
			//only reset relevant objects
			this.resetBlocks();

			xmlCode = this.convertAstToXml();
		} catch (error) {
			this.codeManager.updateTextCode(this.code);
			this.codeManager.setXml();
			console.error(error);
			return;
		}

		Blockly.Events.disable();
		const workspace = Blockly.getMainWorkspace();

		// Convert the string to a DOM object
		const xml = Blockly.Xml.textToDom(xmlCode);
		this.debug && console.log(xml);

		this.indexPreviousXml = null;
		this.storeXml();
		// Clear workspace
		workspace.clear();
		try {
			Blockly.Xml.domToWorkspace(xml, workspace);
		} catch (error) {
			// Blockly error here if the xml is not correct
			console.error('Error injecting blocks:', error);
		}
		this.codeManager.updateTextCode(this.code);
		this.codeManager.setGeneratedCode(this.code);
		this.codeManager.setXml();

		const endFunctions = Object.keys(this.interface_specific_end);
		for (const key of endFunctions) {
			if (typeof this.interface_specific_end[key] === 'function') {
				this.interface_specific_end[key]();
			}
		}
		this.organizePrototypeBlocks();

		this.retrieveBlocksStored();
		this.storedDisabledBlocks = [];

		Blockly.Events.enable();

		this.debug && console.log(`Injection time: ${new Date().getTime() - time}ms`);
	}
}

window.Python2Blocks = new Python2Blocks();
