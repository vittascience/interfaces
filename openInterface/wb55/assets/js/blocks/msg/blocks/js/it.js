/**
 * @fileoverview English messages for STM32. (EN)
 */
'use strict';
// Notes
Blockly.Msg['NOTE_C'] = 'Do';
Blockly.Msg['NOTE_C_SHARP'] = 'Do#';
Blockly.Msg['NOTE_D'] = 'Ré';
Blockly.Msg['NOTE_D_SHARP'] = 'Ré#';
Blockly.Msg['NOTE_E'] = 'Mi';
Blockly.Msg['NOTE_F'] = 'Fa';
Blockly.Msg['NOTE_F_SHARP'] = 'Fa#';
Blockly.Msg['NOTE_G'] = 'Sol';
Blockly.Msg['NOTE_G_SHARP'] = 'Sol#';
Blockly.Msg['NOTE_A'] = 'La';
Blockly.Msg['NOTE_A_SHARP'] = 'La#';
Blockly.Msg['NOTE_B'] = 'Si';
Blockly.Msg['MUSIC_SILENCE'] = 'Silenzio';
// Display - STM32
Blockly.Msg['DISPLAY_STM32_CONTROL_COLOR_LED_TITLE'] = 'controlla il LED %1 stato %2';
Blockly.Msg['DISPLAY_STM32_CONTROL_COLOR_LED_TOOLTIP'] = 'Controlla lo stato dei LED di colore rosso, verde e blu della scheda STM32.';
Blockly.Msg['DISPLAY_STM32_TOGGLE_LED_STATE_TITLE'] = 'inverti lo stato del %1';
Blockly.Msg['DISPLAY_STM32_TOGGLE_LED_STATE_TOOLTIP'] = 'Inverti lo stato dei LED colorati della scheda STM32.';
Blockly.Msg['LED_BLUE'] = 'LED1 (blu)';
Blockly.Msg['LED_GREEN'] = 'LED2 (verde)';
Blockly.Msg['LED_RED'] = 'LED3 (rosso)';
// Display - LCD
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD1602] visualizza il testo %1 sulla riga %2 posizione %3';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Visualizza un testo su una delle due righe del display LCD1602 grove. Collega il modulo a una porta I2C';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD1602] cancella display';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Permette di cancellare tutti i caratteri del display LCD. Collegare il modulo a una porta I2C.';
Blockly.Msg['DISPLAY_LCD_SETRGBCOLOR_TITLE'] = '[LCD1602] illumina il display LCD di colore R %1 G %2 B %3';
Blockly.Msg['DISPLAY_LCD_SETRGBCOLOR_TOOLTIP'] = IMG_MODULE_LCD_RGB + Blockly.Tooltip.SEP + 'Blocco che controlla la retroilluminazione del modulo Grove LCD 16x2. Assegnare un valore da 0 a 255 per rosso, verde e blu. Collega il modulo a una porta I2C.';
Blockly.Msg['DISPLAY_LCD_SETPALETTERGBCOLOR_TITLE'] = '[LCD1602] illumina il display LCD di colore %1';
Blockly.Msg['DISPLAY_LCD_SETPALETTERGBCOLOR_TOOLTIP'] = IMG_MODULE_LCD_RGB + Blockly.Tooltip.SEP + 'Blocco che controlla la retroilluminazione del modulo Grove LCD 16x2. Scegliere il colore desiderato dalla tavolozza. Collega il modulo a una porta I2C.';
// Display - OLED
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[OLED] visualizza il testo %1 nella posizione x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permette di scrivere un testo su un display OLED 128x64. Collegare il display a una porta I2C.';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TITLE'] = '[OLED] controlla il pixel x %1 y %2 stato %3';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permette di controllare ogni pixel del display OLED 128x64. Collegare il display a una porta I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TITLE'] = '[OLED] disegna una linea da (%1, %2) a (%3, %4)';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permette di disegnare una linea tra due punti del display OLED 128x64. Collegare il display a una porta I2C.';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TITLE'] = '[OLED] imposta lo sfondo su %1';
Blockly.Msg['DISPLAY_OLED_WHITE'] = 'bianco';
Blockly.Msg['DISPLAY_OLED_BLACK'] = 'nero';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permette di invertire la retroilluminazione del display. Collegare il display a una porta I2C.';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[OLED] cancella display';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permette di cancellare il contenuto del display OLED. Collegare il display a una porta I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[OLED] visualizza l\'icona %1 posizione x %2 y %3';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permette di visualizzare un\'icona della libreria Immagini di STM32 nella posizione (x,y) sul display grove OLED. Collegare il display a una porta I2C.';
//Display - LED MATRIX
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_TITLE'] = '[Matrice LED RGB] visualizza l\'icona %1 %2';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_TOOLTIP'] = IMG_MODULE_RGB_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Visualizza un\'icona sulla matrice LED RGB 8x8.';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_STOPDISPLAY_TITLE'] = '[Matrice LED RGB] eliminare la matrice';
Blockly.Msg['DISPLAY_RGB_LED_MATRIX_STOPDISPLAY_TOOLTIP'] = IMG_MODULE_RGB_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Spegne tutti i LED della matrice';
Blockly.Msg['DISPLAY_LED_MATRIX_DURATION'] = 'durante';
Blockly.Msg['DISPLAY_LED_MATRIX_DURATION_UNIT'] = 'ms';
//Display - RGB LED MATRIX
Blockly.Msg['DISPLAY_LED_MATRIX_TITLE'] = '[Matrice LED] visualizza l\'icona %1 %2';
Blockly.Msg['DISPLAY_LED_MATRIX_TOOLTIP'] = IMG_MODULE_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Visualizza un\'icona sulla matrice LED monocromatica 8x8.';
Blockly.Msg['DISPLAY_LED_MATRIX_CLEAR_TITLE'] = '[Matrice LED] eliminare la matrice';
Blockly.Msg['DISPLAY_LED_MATRIX_CLEAR_TOOLTIP'] = IMG_MODULE_LED_MATRIX_8_8 + Blockly.Tooltip.SEP + 'Spegne tutti i LED della matrice';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] controlla il LED %1 sul pin %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Permette di attivare o disattivare il LED Grove (0 o 1) sui pin digitali.';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] regola la luminosità a %1 (%) sul pin %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Permette di regolare la luminosità di un LED da 0 a 100% sui pin PWM.';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[Variable Color LED] regola la luminosità a %1 (%) sul pin %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Permette di regolare la luminosità di un LED da 0 a 100% sui pin PWM. Al primo utilizzo i valori RGB sono impostati su 0. Servirsi di un cacciavite per regolare i colori R, G e B dietro il modulo.';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[Display a 4 cifre] visualizza %1 %2 sui pin CLK %3 DIO %4';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permette di visualizzare un numero, una temperatura o l\'orologio sul display a 4 cifre Grove con i pin digitali.';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[Display a 4 cifre] l\'orologio sui pin CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permette di visualizzare l\'orologio sul display a 4 cifre Grove con i pin digitali. Attenzione, l\'acquisizione dell\'ora reale avviene solo se la scheda microbit rimane accesa.';
Blockly.Msg['DISPLAY_4DIGIT_NUMBER'] = 'il numero intero';
Blockly.Msg['DISPLAY_4DIGIT_TEMPERATURE'] = 'la temperatura';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[Modulo LED Bar] visualizza il livello di %1 sui pin DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permette di visualizzare il livello del valore in ingresso sul modulo LED Bar con i pin digitali.';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TITLE'] = '[Modulo LED Bar] inverte display %1 pin DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permette di invertire i 10 LED del modulo MY9221 con i pin digitali.';
// Display - Neopixel
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] definisci %1 LED sul pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permette di definire il numero di LED del neopixel. Questo blocco deve essere utilizzato nel blocco "All\'avvio".';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] controlla il LED %1 a R %2 G %3 B %4 sul pin %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permette di controllare il colore di ciascun LED del modulo neopixel come (R,G,B) da 0 a 255.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] controlla il LED %1 a %2 sul pin %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permette di controllare il colore di ciascun LED del modulo neopixel. Per cambiare colore utilizzare la tavolozza.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] controlla tutti i LED a R %1 G %2 B %3 sul pin %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permette di controllare tutti i LED del modulo neopixel impostandoli sul colore selezionato come (R,G,B) oppure su un valore da 0 a 255.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] controlla tutti i LED a %1 sul pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permette di controllare tutti i LED del modulo neopixel impostandoli sul colore selezionato. Per cambiare colore utilizzare la tavolozza.';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] Arcobaleno sul pin %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Visualizza lo spettro dei colori sui LED RGB. È possibile modificare il pin e il numero di LED del modulo neopixel.';
// Display - Chainable LED RGB
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TITLE'] = '[Chainable LED] definisci %1 LED sui pin CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Permette di impostare la catena di LED RGB definendo il numero di moduli in serie sui pin digitali da D0 a D13.';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TITLE'] = '[Chainable LED] controlla il LED %1 a R %2 G %3 B %4 sui pin CIN %5 DIN %6';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Blocco che controlla il colore del LED RGB, assegnare un valore tra 0 e 255 per Rosso, Verde e Blu.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TITLE'] = '[Chainable LED] controlla il LED %1 a %2 sui pin CIN %3 DIN %4';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Blocco che controlla il colore del LED RGB, scegliere un colore dalla tavolozza.';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TITLE'] = '[Chainable LED] controlla tutti i LED a R %1 G %2 B %3 sui pin CIN %4 DIN %5';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Blocco che controlla il colore dei LED RGB, assegnare un valore tra 0 e 255 per Rosso, Verde e Blu.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE'] = '[Chainable LED] controlla tutti i LED a %1 sui pin CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Blocco che controlla il colore dei LED RGB, scegliere un colore dalla tavolozza.';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TITLE'] = '[Chainable LED] spegni sui pin CIN %1 DIN %2';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Blocco che spegne tutti i LED RGB.';
// Input/Output - STM32
Blockly.Msg['IO_WAIT_TITLE'] = 'attendi %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Effettua una pausa nell\'esecuzione del codice.';
Blockly.Msg['IO_WAIT_SECOND'] = 'secondo/i';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'millisecondo/i';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microsecondo/i';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'attendere fino a %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Ferma l\'esecuzione del codice finché la condizione non è soddisfatta.';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'inizializza il cronometro';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Inizializza un cronometro su 0 (in secondi).';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'valore del cronometro in %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Restituisce il valore del cronometro a partire dall\'inizializzazione (in secondi o millisecondi).';
Blockly.Msg['IO_STM32_GETSWITCHSTATE_TITLE'] = 'leggi lo stato del pulsante %1';
Blockly.Msg['IO_STM32_GETSWITCHSTATE_TOOLTIP'] = 'Permette di leggere lo stato dei pulsanti integrati nella scheda STM32 (SW1, SW2, SW3).';
Blockly.Msg['IO_STM32_ONSWITCHBUTTONPRESSED_TITLE'] = 'se pulsante %1 %2 allora';
Blockly.Msg['IO_STM32_ONSWITCHBUTTONPRESSED_TOOLTIP'] = 'Permette di eseguire alcune istruzione a seconda dello stato dei pulsanti integrati nella scheda STM32 (SW1, SW2, SW3).';
Blockly.Msg['IO_STM32_PRESSED'] = 'premuto';
Blockly.Msg['IO_STM32_RELEASED'] = 'rilasciato';
// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Tastierino numerico] cifra sul bus UART %1';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Permette di acquisire il tasto premuto del tastierino numerico Grove sui pin TX e RX. Quando colleghi il modulo, assicurati che i pin siano "incrociati": RX della scheda con TX del modulo e viceversa.';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Modulo joystick] valore dell\'asse %1 sui pin X %2 Y %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Restituisce il valore dell\'asse X o Y (da 0 a 1023) del joystick Grove sui pin analogici da p34 a p36, o p39 (da A2 a A4 su shield Grove).';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TITLE'] = '[Modulo pulsante colorato] stato sul pin SIG2 %1';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Restituisce lo stato del pulsante colorato grove (0 o 1) sui pin digitali.';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TITLE'] = '[Modulo pulsante colorato] controlla il LED allo stato %1 sul pin SIG1 %2';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Permette di accendere o spegnere il LED (0 o 1) sui pin digitali.';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Potenziometro rotativo] valore sul pin %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Restituisce l\'angolo (da 0 a 1023) del potenziometro rotativo Grove sui pin analogici da p34 a p36, o p39 (da A2 a A4 su shield Grove).';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Potenziometro lineare] valore sul pin %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Restituisce la posizione (da 0 a 1023) del potenziometro lineare Grove sui pin analogici da p34 a p36, o p39 (da A2 a A4 su shield Grove).';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Sensore tattile] stato sul pin %1';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Restituisce il valore del sensore tattile Grove (0 o 1) sui pin digitali.';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Modulo pulsante] stato sul pin %1';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Restituisce il valore del pulsante Grove (0 o 1) sui pin digitali.';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Modulo interruttore] stato sul pin %1';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Restituisce il valore dell\'interruttore Grove (0 o 1) sui pin digitali.';
// Input/Output - Pins
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'ALTO (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BASSO (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Restituisce un valore booleano (1 se ALTO, 0 se BASSO).';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'leggi il pin digitale %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Permette di leggere il valore di un ingresso digitale (0 o 1).';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'scrivi lo stato %1 sul pin digitale %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Permette di scrivere un valore su un ingresso digitale (0 o 1).';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'leggi il pin analogico %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Permette di leggere il valore di un ingresso analogico (0-4096), che corrisponde a una tensione compresa tra 0 e 3,6 V.';
Blockly.Msg['IO_WRITEPWMPIN_TITLE'] = 'scrivi il valore %1 sul pin PWM %2';
Blockly.Msg['IO_WRITEPWMPIN_TOOLTIP'] = 'Permette di applicare un segnale PWM con una frequenza impostata su 500 Hz variando il ciclo da 0 a 255. Il valore 128 corrisponderà al 50% del ciclo.';
Blockly.Msg['IO_SETPWM_TITLE'] = 'applica un segnale di onda quadra %1 (Hz) sul pin %2';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Permette di applicare un segnale di onda quadra (PWM) con ciclo impostato sul 50% su un pin. Questo blocco permette di cambiare la frequenza del segnale.';
Blockly.Msg['IO_STOPPWM_TITLE'] = 'interrompi il segnale PWM del pin %1';
Blockly.Msg['IO_STOPPWM_TOOLTIP'] = 'Permette di interrompere il segnale PWM applicato su un pin.';
Blockly.Msg['IO_GETVOLTAGE_TITLE'] = 'converti %1 su %2 in tensione';
Blockly.Msg['IO_GETVOLTAGE_TOOLTIP'] = 'Permette di convertire un valore analogico in una tensione, con risoluzione (12-bit: 4096 o 16-bit: 65536) e fino a un massimo di 3,3 V.';
Blockly.Msg['IO_GETVOLTAGE_12BIT'] = '12 bit';
Blockly.Msg['IO_GETVOLTAGE_16BIT'] = '16 bit';
// Communication - UART Blocks
Blockly.Msg['COMMUNICATION_UART_INIT_TITLE'] = 'reindirizza il collegamento seriale verso RX %2 TX %3 Baud rate %1';
Blockly.Msg['COMMUNICATION_UART_INIT_TOOLTIP'] = 'Permette di reindirizzare il collegamento seriale della scheda STM32. Quando colleghi il modulo, assicurati che i pin siano "incrociati": RX della scheda con TX del modulo e viceversa.';
Blockly.Msg['COMMUNICATION_UART_INIT_TITLE'] = '[uart] initialize serial connectin on bus %1 Baudrate %2';
Blockly.Msg['COMMUNICATION_UART_INIT_TOOLTIP'] = 'Initialize serial connection on the UART port';
Blockly.Msg['COMMUNICATION_UART_WRITE_TITLE'] = '[uart] scrivi il dato %1 sul bus %2';
Blockly.Msg['COMMUNICATION_UART_WRITE_TOOLTIP'] = 'Permette di scrivere alcuni dati nella porta UART.';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'scrivi nella console %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Permette di scrivere alcuni dati nella porta seriale.';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'insieme a';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'interruzioni di riga';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE then'] = 'on serial data received in %1 then';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permette di eseguire alcune istruzioni se viene ricevuto un dato dalla porta seriale nella variabile "serialData".';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'suona la nota %1 sul computer';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Suona la nota selezionata fino all\'esecuzione del blocco "Fine della nota".';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'riproduci la frequenza %1 (Hz) sul computer';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Questo blocco permette di riprodurre una frequenza data sul computer';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'termina la nota sul computer';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Interrompe la nota in corso.';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'disegna il grafico';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Questo blocco permette di scrivere dati (numerici) che saranno visibili nel plotter. Può essere utilizzato con uno o più blocchi in formato "Nome" e "Dati". Per visualizzare i grafici, fai clic sull\'icona "Modalità grafica" nella console.';
Blockly.Msg['COMMUNICATION_DATA'] = 'Dato';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nome %1 Dati %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Questo blocco va utilizzato con il blocco "Disegna il grafico". Deve contenere a sua volta il nome del valore da visualizzare (testo) e il valore in questione (numero).';
// Communication - STM32
Blockly.Msg['COMMUNICATION_STM32_RTC_SETTIME_TITLE'] = '[Orologio RTC] inizializza a %1 data %2 ora %3 minuto %4 secondo %5';
Blockly.Msg['COMMUNICATION_STM32_RTC_SETTIME_TOOLTIP'] = 'Permette di inizializzare il modulo orologio RTC integrato nella scheda STM32 per poter leggere la data e l\'ora precisa con il blocco "Leggi il modulo orologio". Inserire nel blocco "All\'avvio".';
Blockly.Msg['COMMUNICATION_STM32_RTC_READTIME_TITLE'] = '[Orologio RTC] leggi %1';
Blockly.Msg['COMMUNICATION_STM32_RTC_READTIME_TOOLTIP'] = 'Permette di leggere la data e l\'ora del modulo orologio RTC integrato nella scheda STM32. Per un risultato corretto, utilizzare prima i due blocchi "Inizializza il modulo orologio".';
Blockly.Msg['CLOCK_ALL_DATA'] = 'time';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'giorno del mese';
Blockly.Msg['CLOCK_MONTH'] = 'mese';
Blockly.Msg['CLOCK_YEAR'] = 'anno';
Blockly.Msg['CLOCK_SECOND'] = 'secondo';
Blockly.Msg['CLOCK_MINUTE'] = 'minuto';
Blockly.Msg['CLOCK_HOUR'] = 'ora';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'giorno della settimana';
Blockly.Msg['DAY_MONDAY'] = 'lunedì';
Blockly.Msg['DAY_TUESDAY'] = 'martedì';
Blockly.Msg['DAY_WEDNESDAY'] = 'mercoledì';
Blockly.Msg['DAY_THURSDAY'] = 'giovedì';
Blockly.Msg['DAY_FRIDAY'] = 'venerdì';
Blockly.Msg['DAY_SATURDAY'] = 'sabato';
Blockly.Msg['DAY_SUNDAY'] = 'domenica';
Blockly.Msg['COMMUNICATION_BLE_STSENSORAPP_SEND_TITLE'] = '[ST BLE Sensor] inviare dati in app';
Blockly.Msg['COMMUNICATION_BLE_STSENSORAPP_SEND_TOOLTIP'] = IMG_MODULE_BLE_SENSOR + Blockly.Tooltip.SEP + 'Questo blocco viene utilizzato per inviare le misurazioni del sensore all\'applicazione ST BLE Sensor utilizzando il Bluetooth BLE integrato nella scheda STM32. Può essere utilizzato con uno o più blocchi "Servizio" e "Valore".<br> Passaggi per visualizzare i dati: 1. Scaricare l\'applicazione ST BLE Sensor. 2. Caricare il codice sulla scheda STM32. 3. Una volta trasferito il codice, fare clic su "Collega un dispositivo" nell\'applicazione. 4. Se la scheda viene rilevata, fare clic su "WB55-MPY".';
Blockly.Msg['COMMUNICATION_BLE_STSENSORAPP_SERVICE_VALUE'] = 'Valore';
Blockly.Msg['COMMUNICATION_BLE_STSENSORAPP_SERVICE_TITLE'] = '[ST BLE Sensor] servizio %1';
Blockly.Msg['COMMUNICATION_BLE_STSENSORAPP_SERVICE_TOOLTIP'] = IMG_MODULE_BLE_SENSOR + Blockly.Tooltip.SEP + 'Questo blocco viene utilizzato come servizio nel blocco "Invia dati di servizio". Seleziona un servizio e aggiungi la misura. Nota: puoi utilizzare qualsiasi servizio una sola volta per trasmissione dati.';
Blockly.Msg['COMMUNICATION_BLE_STSENSORAPP_SERVICE_FIRST_TEMPERATURE'] = 'Temperatura 1 (°C)';
Blockly.Msg['COMMUNICATION_BLE_STSENSORAPP_SERVICE_SECOND_TEMPERATURE'] = 'Temperatura 2 (°C)';
Blockly.Msg['COMMUNICATION_BLE_STSENSORAPP_SERVICE_HUMIDITY'] = 'Umidità (%)';
Blockly.Msg['COMMUNICATION_BLE_STSENSORAPP_SERVICE_PRESSURE'] = 'Pressione (hPa o mBar)';
Blockly.Msg['COMMUNICATION_BLE_STSENSORAPP_SERVICE_LUMINOSITY'] = 'Luminosità (lux)';
Blockly.Msg['COMMUNICATION_BLE_STSENSORAPP_SERVICE_ACCELEROMETER'] = 'Accelerometro (mg.s-²)';
Blockly.Msg['COMMUNICATION_BLE_STSENSORAPP_SERVICE_CO_SENSOR'] = 'Monossido di carbonio (CO) (ppm)';
Blockly.Msg['COMMUNICATION_BLE_SEND_DATA_TITLE'] = '[Bluetooth] invia i dati %1 ';
Blockly.Msg['COMMUNICATION_BLE_SEND_DATA_TOOLTIP'] = IMG_MODULE_BLE_SENSOR + Blockly.Tooltip.SEP + 'Invia dati tramite Bluetooth (BLE).';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TITLE'] = '[Bluetooth] se il messaggio è stato ricevuto in %1 allora';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TOOLTIP'] = IMG_MODULE_BLE_SENSOR + Blockly.Tooltip.SEP + 'Utilizzato per eseguire istruzioni se i dati vengono ricevuti tramite Bluetooth (BLE).';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TITLE'] = '[Bluetooth Fizziq App] invia %1 %2';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TOOLTIP'] = IMG_MODULE_FIZZIQ + Blockly.Tooltip.SEP + 'Invia dati (Temperatura, Umidità ecc.) tramite Bluetooth a Fizziq App.';
Blockly.Msg['FIZZ_TEMP'] = 'Temperatura';
Blockly.Msg['FIZZ_HUM'] = 'Umidità';
Blockly.Msg['FIZZ_VOLTAGE'] = 'Tensione';
Blockly.Msg['FIZZ_WEIGHT'] = 'Peso';
Blockly.Msg['FIZZ_PRESSURE'] = 'Pressione';
Blockly.Msg['FIZZ_CONCENTRATION'] = 'Concentrazione';
Blockly.Msg['FIZZ_MAGNETIC'] = 'Campo magnetico';
Blockly.Msg['FIZZ_BRIGHTNESS'] = 'Luminosità';
Blockly.Msg['FIZZ_ACCELERATION'] = 'Accelerazione';
Blockly.Msg['FIZZ_COMPASS'] = 'Bussola';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] scrivi nella scheda SD %1 sui pin RX %2 TX %3 %4 Dati %5';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'Permette di scrivere dati nella scheda micro SD con il modulo Openlog. Funzionamento in trasmissione UART.';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] invia sui pin RX %1 TX %2 messaggio %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permette di inviare dati tramite il modulo Bluetooth HC05 sui pin RX/TX.';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] se messaggio ricevuto sui pin RX %1 TX %2 in %3 allora';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permette di eseguire alcune istruzioni se viene ricevuto un dato tramite modulo Bluetooth HC05 nella variabile "bluetoothData" sui pin RX/TX.';
// Communication - GPS
Blockly.Msg['COMMUNICATION_GPS_INFO_TYPE'] = 'tipo di cornice';
Blockly.Msg['COMMUNICATION_GPS_INFO_CLOCK'] = 'ora (h, m, s)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LATITUDE'] = 'latitudine (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LONGITUDE'] = 'longitudine (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_SATELLITE'] = 'numero di satelliti utilizzati';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALTITUDE'] = 'altitudine (m)';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TITLE'] = '[GPS] frame NMEA sulla porta UART %1';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Restituisce l\'elenco dei frame NMEA letto con il modulo GPS Grove SIM28 o Air530 sulla porta UART 1 (D2/D14) o sulla porta UART 2 (D0/D1). Sul Grove shield, la porta UART (RX/TX) corrisponde per impostazione predefinita alla porta UART 2.';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TITLE'] = '[GPS] ottiene %2 sulla porta UART %1';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Restituisce i dati selezionati da (tipo di frame, orologio, latitudine, longitudine, altitudine) analizzati dal frame NMEA (GNGGA o GPGGA) letto con il modulo Grove SIM28 o Air530 GPS acceso Porta UART 1 (D2/D14) o porta UART 2 (D0/D1). Sul Grove shield, la porta UART (RX/TX) predefinita è la porta UART 2.';
// Communication - NFC
Blockly.Msg['COMMUNICATION_M24SR64_NFC_READ_TITLE'] = '[NFC M24SR64] leggi dato dal tag';
Blockly.Msg['COMMUNICATION_M24SR64_NFC_READ_TOOLTIP'] = IMG_MODULE_NFC + Blockly.Tooltip.SEP + 'Leggi il dato dal tag NFC tramite I2C.';
Blockly.Msg['COMMUNICATION_M24SR64_NFC_ERASE_TITLE'] = '[NFC M24SR64] cancella i dati sul tag';
Blockly.Msg['COMMUNICATION_M24SR64_NFC_ERASE_TOOLTIP'] = IMG_MODULE_NFC + Blockly.Tooltip.SEP + 'Cancella i messaggi presenti sul tag NFC tramite I2C.';
Blockly.Msg['COMMUNICATION_M24SR64_WRITE_NFC_TITLE'] = '[NFC M24SR64] scrivi %1 sul tag';
Blockly.Msg['COMMUNICATION_M24SR64_WRITE_NFC_TOOLTIP'] = IMG_MODULE_NFC + Blockly.Tooltip.SEP + 'Scrivi dati sul tag NFC tramite I2C (capacità massima 8.000 caratteri).';
// Communication - LoRa
Blockly.Msg['COMMUNICATION_LORA_INIT_TITLE'] = '[LoRa E5] inizializzare il modulo con la appEui %1 con la appKey %2';
Blockly.Msg['COMMUNICATION_LORA_INIT_TOOLTIP'] = IMG_MODULE_LORA + Blockly.Tooltip.SEP + 'Inizializza e ottiene le informazioni di identificazione del modulo LoRa collegato alla porta UART.';
Blockly.Msg['COMMUNICATION_LORA_INIT'] = 'con la devAddr :';
Blockly.Msg['COMMUNICATION_LORA_SEND_TITLE'] = '[LoRa E5] inviare il dati';
Blockly.Msg['COMMUNICATION_LORA_SEND_TOOLTIP'] = IMG_MODULE_LORA + Blockly.Tooltip.SEP + 'Invio di dati dai sensori attraverso il modulo LoRa.';
Blockly.Msg['COMMUNICATION_LORA_RECEIVE_TITLE'] = '[LoRa E5] ricevere un messaggio';
Blockly.Msg['COMMUNICATION_LORA_RECEIVE_TOOLTIP'] = IMG_MODULE_LORA + Blockly.Tooltip.SEP + 'Consente di ricevere dati tramite il modulo LoRa.';
// Sensors - Expansion board
Blockly.Msg['SENSORS_ACCELEROMETER_INTEGRATED_LIS2DW12_TITLE'] = '[Accelerometro LIS2DW12] accelerazione lungo l\'asse %1';
Blockly.Msg['SENSORS_ACCELEROMETER_INTEGRATED_LIS2DW12_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Restituisce l\'accelerazione lungo gli assi X, Y o Z (in mg).';
Blockly.Msg['X_AXIS'] = 'x';
Blockly.Msg['Y_AXIS'] = 'y';
Blockly.Msg['Z_AXIS'] = 'z';
Blockly.Msg['SENSORS_INCLINOMETER_INTEGRATED_LIS2DW12_TITLE'] = '[Inclinometro LIS2DW12] inclinazione tra l\'asse %1 e il piano orizzontale';
Blockly.Msg['SENSORS_INCLINOMETER_INTEGRATED_LIS2DW12_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Restituisce l\'inclinazione tra gli assi X, Y o Z e il piano orizzontale.';
Blockly.Msg['SENSORS_ACCELEROMETER_INTEGRATED_LSM6DSO_TITLE'] = '[Accelerometro LSM6DSO] accelerazione lungo l\'asse %1';
Blockly.Msg['SENSORS_ACCELEROMETER_INTEGRATED_LSM6DSO_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Restituisce l\'accelerazione lungo gli assi X, Y o Z (in mg).';
Blockly.Msg['SENSORS_GYROSCOPE_INTEGRATED_LSM6DSO_TITLE'] = '[Giroscopio LSM6DSO] velocità angolare lungo l\'asse %1';
Blockly.Msg['SENSORS_GYROSCOPE_INTEGRATED_LSM6DSO_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Restituisce la velocità angolare lungo gli assi X, Y o Z (in rad/s).';
Blockly.Msg['SENSORS_MAGNETOSCOPE_INTEGRATED_LIS2MDL_TITLE'] = '[Magnetoscopio LIS2MDL] campo magnetico lungo %1';
Blockly.Msg['SENSORS_MAGNETOSCOPE_INTEGRATED_LIS2MDL_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Returns the magnetic field following X, Y or Z (in gauss).';
Blockly.Msg['SENSORS_THERMOMETER_INTEGRATED_LPS22HH_TITLE'] = '[Termometro LPS22HH] temperatura';
Blockly.Msg['SENSORS_THERMOMETER_INTEGRATED_LPS22HH_TOOLTIP'] = IMG_X_NUCLEO_IKS01A3 + Blockly.Tooltip.SEP + 'Restituisce la temperatura (in °C)';
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[Sensore SGP30] gas %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Restituisce la quantità di CO2 (in ppm) o di TVOC (in ppb) presente nell\'aria per mezzo del sensore SGP30. Collegare il sensore a una porta I2C.';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'Anidride carbonica (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'Composti organici volatili (TVOC) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Sensore di gas multicanale] gas %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Restituisce la quantità di gas misurata nell\'aria (in ppm) per mezzo del sensore di gas multicanale. Collegare il sensore a una porta I2C.';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Sensore di gas multicanale v2] gas %1 (V)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Restituisce la quantità di gas misurata nell\'aria (in V) per mezzo del sensore di gas multicanale V2 grove. Collegare il sensore a una porta I2C.';
Blockly.Msg['GAS_CO'] = 'Monossido di carbonio (CO)';
Blockly.Msg['GAS_NO2'] = 'Biossido d\'azoto (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'Etanolo (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'Idrogeno (H2)';
Blockly.Msg['GAS_NH3'] = 'Ammoniaca (NH3)';
Blockly.Msg['GAS_CH4'] = 'Metano (CH4)';
Blockly.Msg['GAS_C3H8'] = 'Propano (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'Butano (C4H10)';
Blockly.Msg['GAS_VOC'] = 'Composti organici volatili (COV)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Sensore di ossigeno] O2 (%) sul pin %1';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Restituisce la concentrazione di ossigeno (O2) nell\'aria (in %) per mezzo del sensore di gas O2 grove sui pin analogici da p34 a p36, o p39 (da A2 a A4 su shield Grove).';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[Sensore SCD30] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Restituisce la concentrazione di CO2 nell\'aria (in ppm), l\'umidità (in %) o la temperatura in Celsius (°C), Fahrenheit (°F) o Kelvin (K) rilevata dal sensore grove SCD30. Collegare il sensore a una porta I2C.';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'anidride carbonica (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = 'temperatura';
Blockly.Msg['SENSORS_SCD30_HUM'] = 'umidità (%)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[Sensore SCD30] forzare la ricalibrazione a %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Forza la calibrazione del sensore SCD30 al valore dato (in ppm). Andare all\'esterno (dove la concentrazione è di circa 420 ppm, cioè aria pulita), riavviare la scheda, quindi attendere 2 minuti. Consiglio: Utilizzare i pulsanti SW1, SW2 o SW3 della scheda STM32 NUCLEO per controllare l\'avvio della calibrazione. In caso contrario, ricollegando la scheda, il programma si avvia ed esegue nuovamente una calibrazione non necessariamente voluta.';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Sensore di qualità dell\'aria] valore sul pin %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Returns value of air quality (from 0 to 4095) on analog pins p34 through p36, or p39 (as A2 to A4 on shield Grove).';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[Sensore HM330X] concentrazione di particolato fine %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Detect the density of particles in the air with the HM330X sensor. Connect sensor on I2C port.';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
// Sensors - Climate
Blockly.Msg['SENSORS_TEMPERATURE'] = 'temperatura';
Blockly.Msg['SENSORS_HUMIDITY'] = 'umidità (%)';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'in';
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[Sensore BMP280 %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Restituisce la temperatura ambiente in gradi Celsius (°C), Fahrenheit (°F) o Kelvin (K), la pressione (in Pascal) o l\'altitudine (in m). L\'altitudine è calcolata con la pressione ed è inizializzata a 0 all\'inizio del programma. Il blocco necessita del sensore Grove BMP280 (indirizzo I2C: 0x77, colore: blu) o del sensore HW-611 280 (indirizzo I2C: 0x76, colore: viola). Collegare il sensore a una porta I2C.';
Blockly.Msg['SENSORS_BMP280_TEMP'] = 'temperatura';
Blockly.Msg['SENSORS_BMP280_PRESS'] = 'pressure (Pa)';
Blockly.Msg['SENSORS_BMP280_ALT'] = 'altitudine (m)';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = '[Sensore H.T°] temperatura in %1 sui pin A0 %2 A1 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Restituisce la temperatura della termocoppia in gradi Celsius (da 50 a 600 °C), Fahrenheit (°F) o Kelvin (K) per mezzo del sensore grove di alta temperatura su .';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Sensore di umidità] umidità del suolo sul pin %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Restituisce l\'umidità (da 0 a 1023) misurata per mezzo del sensore di umidità grove sui pin analogici IO34, IO35, IO36 e IO39.';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Sensore di T°] temperatura in %1 sul pin %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Restituisce la temperatura in gradi Celsius (°C), Fahrenheit (°F) o Kelvin (K) del sensore di temperatura Grove sui pin analogici da p34 a p36, o p39 (da A2 a A4 su shield Grove).';
Blockly.Msg['SENSORS_DHT11_READDATA_TITLE'] = '[Sensore DHT11] %1 sul pin %2';
Blockly.Msg['SENSORS_DHT11_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Restituisce la temperatura in gradi Celsius (°C), Fahrenheit (°F) o Kelvin (K), o l\'umidità (in %) per mezzo del sensore DHT11 grove sui pin digitali.';
Blockly.Msg['SENSORS_DHT22_READDATA_TITLE'] = '[Sensore DHT22] %1 sul pin %2';
Blockly.Msg['SENSORS_DHT22_READDATA_TOOLTIP'] = IMG_MODULE_DHT22 + Blockly.Tooltip.SEP + 'Restituisce con estrema precisione la temperatura in gradi Celsius (°C), Fahrenheit (°F) o Kelvin (K), o l\'umidità (in %) per mezzo del sensore DHT22 grove sui pin digitali.';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[Sensore TH02] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Restituisce la temperatura in gradi Celsius (°C), Fahrenheit (°F) o Kelvin (K), o l\'umidità (in %) per mezzo del sensore TH02. Collegare il sensore a una porta I2C.';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Sensore SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Restituisce la temperatura in gradi Celsius (°C), Fahrenheit (°F) o Kelvin (K), o l\'umidità (in %) per mezzo del sensore SHT31. Collegare il sensore a una porta I2C.';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TITLE'] = '[Sensore DS18X20] temperatura in %1 sul pin %2';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + 'Restituisce la temperatura in Celsius (°C), Fahrenheit (°F) o Kelvin (K) del sensore impermeabile DS18X20.';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Sensore rilevatore di acqua] quantità di acqua sul pin %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Restituisce la quantità di acqua (da 0 a 255) misurata per mezzo del sensore rilevatore di acqua grove sui pin analogici da p34 a p36, o p39 (da A2 a A4 su shield Grove).';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Sensore di pioggia] stato sul pin %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Restituisce lo stato del sensore di pioggia (1 se piove, 0 se non piove) sui pin digitali.';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anemometro] stato sul pin %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Restituisce lo stato dell\'anemometro (due volte lo stato HIGH ad ogni rotazione) sui pin digitali.';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Sensore di luce] luminosità sul pin %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Restituisce la luminosità (da 0 a 1023) del sensore di luce Grove sui pin analogici IO34, IO35, IO36 e IO39.';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[Sensore SI1145] luminosità %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Restituisce l\'indice ultravioletto, la luminosità visibile (in lumen) o infrarossa (in lumen) per mezzo del sensore Grove Sunlight o del sensore GY1145. Collegare il sensore a una porta I2C.';
Blockly.Msg['SENSORS_SI1145_UV'] = 'indice UV';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visibile (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrarossa (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Sensore ultravioletti] indice UV sul pin %1';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Restituisce l\'indice ultravioletto per lunghezze d\'onda comprese tra 240 e 380 nm tramite il sensore Grove sui pin analogici da p34 a p36, o p39 (da A2 a A4 su shield Grove).';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Sensore di suono] livello sonoro sul pin %1';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Restituisce il livello sonoro (da 0 a 1023) con il sensore di suono Grove sui pin digitali.';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Sensore di colori] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Permette di leggere il livello di uno dei tre colori primari con il sensore di colori grove; il livello è compreso tra 0 e 255. Collegare il sensore a una porta I2C.';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Sensore a ultrasuoni %1] %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Restituisce la distanza (in cm) misurata per mezzo del sensore grove a ultrasuoni sui pin digitali. Attenzione, se il sensore è un modello grove, TRIG ed ECHO sono sullo stesso pin SIG.';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distanza (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'tempo di andata e ritorno (µs)';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = '[Sensore di gesti] tipo di gesto';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Restituisce il tipo di gesto analizzato ("right", "left", "up", "down", "forward", "backward", "clockwise", "anticlockwise") per mezzo del sensore di gesti grove. Collegare il sensore a una porta I2C.';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Sensore di gesti] se il gesto %1 viene rilevato';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Esegue alcune istruzioni se il gesto selezionato viene rilevato dal sensore di gesti grove. Collegare il sensore a una porta I2C.';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'destra';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'sinistra';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'alto';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'basso';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'avanti';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'indietro';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'orario';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'antiorario';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'onda';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Line Finder Sensor] line finder state on pin %1';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Restituisce il valore del sensore tattile Grove (0 o 1) sui pin digitali.';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[Sensore di movimento] stato sul pin %1';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Restituisce il valore del sensore di movimento Grove PIR Motion (0 o 1) sui pin digitali.';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Sensore di vibrazioni] stato sul pin %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Restituisce lo stato della vibrazione (0 o 1) per mezzo del sensore di vibrazioni piezoelettrico sui pin digitali.';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Modulo inclinazione] stato sul pin %1';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Restituisce il valore dell\'inclinazione del modulo Grove (0 o 1) sui pin digitali.';
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TITLE'] = '[Time Of Flight] Distanza in %1';
Blockly.Msg['SENSORS_VL53L0X_GETRANGEMILLIMETERS_TOOLTIP'] = IMG_MODULE_VL53L0X + Blockly.Tooltip.SEP + 'Restituisce le misure di distanza provenienti dal sensore Time Of Flight sulla porta I2C.';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TITLE'] = '[Modulo pulsante] %1 sul pin %2';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Restituisce il valore numerico del pulsante Grove (0/1 o 0V/3,3V) sui pin digitali.';
Blockly.Msg['SENSORS_GETGROVEBUTTON_VOLTAGE'] = 'tensione';
Blockly.Msg['SENSORS_GETGROVEBUTTON_STATE'] = 'stato';
// Actuators - Motors
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servomotore] controlla l\'angolo a %1 sul pin %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permette di controllare l\'angolo di un servomotore (da 0 a 180) sui pin digitali. Attenzione, il gruppo deve essere alimentato da una batteria in modo da fornire una corrente sufficiente al servomotore.';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Servomotore continuo] controlla la velocità a %1 (%) direzione %2 sul pin %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Permette di controllare la velocità (da 0 a 100%) di un servomotore continuo sui pin PWM.';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Motore] controlla la potenza a %1 (%) sul pin %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permette di controllare la potenza di un motore (da 0 a 100 %) su un pin PWM. Attenzione, il gruppo deve essere alimentato da una batteria in modo da fornire una corrente sufficiente al motore.';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Motore a vibrazione] controlla il motore allo stato %1 sul pin %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Permette di attivare o disattivare il motore a vibrazione grove (0 o 1) sui pin digitali.';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Modulo relè] controlla il relè allo stato %1 sul pin %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Permette di controllare il valore del relè (0 o 1) sui pin digitali.';
// Actuators - MOSFET
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TITLE'] = '[MOSFET] controlla allo stato %1 sul pin %2';
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permette di controllare lo stato del transistor MOSFET (0 o 1) su un pin PWM.';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TITLE'] = '[MOSFET] controlla la potenza a %1 (%) sul pin %2';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permette di controllare la potenza di uscita del transistor MOSFET (da 0 a 100%) su un pin PWM.';
Blockly.Msg['ACTUATORS_MOSFET_SETFREQUENCY_TITLE'] = '[MOSFET] controlla la frequenza del ciclo a %1 (Hz) sul pin %2';
Blockly.Msg['ACTUATORS_MOSFET_SETFREQUENCY_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permette di controllare la frequenza ciclica (Hz) del transistor MOSFET su un pin PWM.';
Blockly.Msg['ACTUATORS_MOSFET_PULL'] = 'pull';
// Actuators - Music
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TITLE'] = '[Buzzer/Speaker] riproduci musica %1 su %2';
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permette di riprodurre musica con il modulo buzzer o speaker grove sui pin digitali.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TITLE'] = '[Buzzer/Speaker] suonare le note';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Consente di riprodurre note con un modulo cicalino (o altoparlante) Grove sui pin digitali.';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TITLE'] = 'note %1 à l\'octave %2 durée %3';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Consente di impostare una nota a una determinata ottava per una durata specifica.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TITLE'] = '[Buzzer/Speaker] frequenza di riproduzione %1 per %2 (ms) su %3';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Consente di riprodurre una frequenza con un modulo buzzer (o altoparlante) Grove sui pin digitali.';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TITLE'] = '[Buzzer/Speaker] interrompi la musica su %1';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Consente di interrompere la musica corrente dal modulo buzzer (o altoparlante) Grove sui pin digitali.';
// Robots - Alphabot
Blockly.Msg['ROBOTS_ALPHABOT_RIGHT'] = 'destra';
Blockly.Msg['ROBOTS_ALPHABOT_LEFT'] = 'sinistra';
Blockly.Msg['ROBOTS_ALPHABOT_ULTRASONICRANGER_TITLE'] = '[Alphabot - Sensore a ultrasuoni] distanza (cm)';
Blockly.Msg['ROBOTS_ALPHABOT_ULTRASONICRANGER_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Restituisce la distanza (in cm) tra un oggetto e il robot Alphabot per mezzo del sensore di distanza a ultrasuoni.';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_CALIBRATE_TITLE'] = '[Alphabot] calibra l\'inseguitore di linea';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_CALIBRATE_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di calibrare l\'inseguitore di linea del robot Alphabot v2. Fa girare il robot a sinistra e a destra per calibrare i sensori di linea a infrarossi.';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_READSENSORS_TITLE'] = '[Alphabot] valori dei sensori di linea nera %1';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_READSENSORS_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di leggere i valori dei sensori inseguitori di linea nell\'intervallo da 0-500 (nero) a 500-1000 (bianco) per la normale calibrazione del robot Alphabot v2. L\'opzione "tutti" del blocco permette di restituire la tabella con i valori dei 5 sensori.';
Blockly.Msg['ROBOTS_ALPHABOT_ALL_SENSORS'] = 'tutti';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_GETSENSORABOVELINE_TITLE'] = '[Alphabot] sensore sopra la linea nera';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_GETSENSORABOVELINE_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di ottenere il nome del sensore che è più vicino alla linea nera. (IR1/IR2/IR3/IR4/IR5 da sinistra a destra)';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ISSENSORABOVELINE_TITLE'] = '[Alphabot] sensore %1 sopra la linea nera';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ISSENSORABOVELINE_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Restituisce "Vero" se il sensore selezionato è sopra la linea nera, altrimenti il blocco restituisce "Falso". (IR1/IR2/IR3/IR4/IR5 da sinistra a destra)';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_LIMIT_VALUE'] = 'valore limite';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_TITLE'] = '[Alphabot] se sensore %1';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_SENSOR_THEN'] = 'sopra la linea';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_ELSEIF'] = 'altrimenti se sensore';
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_THEN'] = Blockly.Msg['CONTROLS_IF_MSG_THEN'];
Blockly.Msg['ROBOTS_ALPHABOT_LINEFINDER_ONABOVEANYSENSOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di eseguire alcune istruzioni se il sensore selezionato (IR1/IR2/IR3/IR4/IR5 da sinistra a destra) del robot Alphabot v2 si trova sopra la linea nera.';
Blockly.Msg['ROBOTS_ALPHABOT_READOBSTACLEDETECTOR_TITLE'] = '[Alphabot - IR frontali] ostacolo rilevato da IR';
Blockly.Msg['ROBOTS_ALPHABOT_READOBSTACLEDETECTOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di leggere l\'ostacolo rilevato (sensori IR su LEDL & LEDR) con il robot Alphabot v2. Valori: ["R", "L", "B", "N"]';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_TITLE'] = '[Alphabot - IR frontali] se ostacolo rilevato %1';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_BY_IR_THEN'] = 'da IR allora';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_ELSEIF'] = 'altrimenti se rilevato';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_THEN'] = 'allora';
Blockly.Msg['ROBOTS_ALPHABOT_ONOBSTACLEDETECTED_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di eseguire alcune istruzioni se viene rilevato un ostacolo davanti al robot dai sensori IR su LEDL & LEDR del robot Alphabot.';
Blockly.Msg['ROBOTS_ALPHABOT_BY_RIGHT'] = 'a destra (LEDR)';
Blockly.Msg['ROBOTS_ALPHABOT_BY_LEFT'] = 'a sinistra (LEDL)';
Blockly.Msg['ROBOTS_ALPHABOT_BOTH_SIDES'] = 'da entrambi i lati (LEDL & LEDR)';
Blockly.Msg['ROBOTS_ALPHABOT_GO_TITLE'] = '[Alphabot] controlla il robot %1 velocità %2 (%)';
Blockly.Msg['ROBOTS_ALPHABOT_GO_FORWARD'] = 'vai avanti';
Blockly.Msg['ROBOTS_ALPHABOT_GO_REVERSE'] = 'vai indietro';
Blockly.Msg['ROBOTS_ALPHABOT_GO_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di controllare il movimento (AVANTI/INDIETRO) e la velocità (da 0 a 100%) del robot Alphabot v2.';
Blockly.Msg['ROBOTS_ALPHABOT_TURNTO_TITLE'] = '[Alphabot] gira a %1 velocità %2 (%)';
Blockly.Msg['ROBOTS_ALPHABOT_TURNTO_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di girare a destra o a sinistra a una certa velocità (da 0 a 100%) con il robot Alphabot v2.';
Blockly.Msg['ROBOTS_ALPHABOT_RIGHT_BIS'] = Blockly.Msg['ROBOTS_ALPHABOT_RIGHT'];
Blockly.Msg['ROBOTS_ALPHABOT_CONTROLMOTOR_TITLE'] = '[Alphabot] controlla il motore %1 direzione %2 velocità %3 (%)';
Blockly.Msg['ROBOTS_ALPHABOT_CONTROLMOTOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di controllare i motori destro e sinistro cambiando la direzione (↻: AVANTI, ↺: INDIETRO) e la velocità (da 0 a 100%) del robot Alphabot v2.';
Blockly.Msg['ROBOTS_ALPHABOT_STOPMOTORS_TITLE'] = '[Alphabot] arresta il motore %1';
Blockly.Msg['ROBOTS_ALPHABOT_STOPMOTORS_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di arrestare il motore destro o sinistro del robot Alphabot v2.';
Blockly.Msg['ROBOTS_ALPHABOT_RIGHT&LEFT'] = 'destro & sinistro';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_TITLE'] = '[Alphabot] se il comando %1';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_RECEIVED_THEN'] = 'è ricevuto allora';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_DETECTED_THEN'] = 'è ricevuto dal telecomando NEC nero allora';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_TOOLTIP'] = IMG_MODULE_BASIC_BLACK_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permette di eseguire alcune istruzioni se uno dei comandi viene ricevuto da un telecomando NEC tramite trasmissione a infrarossi.';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_CAR_MP3_GRAY_DETECTED_THEN'] = 'è ricevuto dal telecomando grigio Car mp3 NEC quindi';
Blockly.Msg['ROBOTS_ALPHABOT_REMOTECONTROL_ONCOMMANDRECEIVED_CAR_MP3_GRAY_TOOLTIP'] = IMG_MODULE_CAR_MP3_GRAY_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Consente di eseguire istruzioni se uno dei comandi viene ricevuto da un telecomando grigio di tipo NEC C_ar mp3 tramite trasmissione a infrarossi.';
Blockly.Msg['REMOTE_NEC_BUTTON'] = 'tasto';
Blockly.Msg['REMOTE_NEC_BUTTON_UP'] = 'alto';
Blockly.Msg['REMOTE_NEC_BUTTON_DOWN'] = 'basso';
Blockly.Msg['REMOTE_NEC_BUTTON_LEFT'] = 'sinistra';
Blockly.Msg['REMOTE_NEC_BUTTON_RIGHT'] = 'destra';
Blockly.Msg['REMOTE_NEC_BUTTON_BACK'] = 'ritorna';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_ADDTEXT_TITLE'] = '[Alphabot] visualizza il testo %1 nella posizione x %2 y %3 sul display';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di scrivere un testo su un display OLED 128x64.';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_SETBACKGROUND_TITLE'] = '[Alphabot] imposta lo sfondo del display su %1';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_SETBACKGROUND_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Enable to invert the Grove OLED display.';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_YELLOW_BLUE'] = 'giallo & blu';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_BLACK'] = 'nero';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_CLEARSCREEN_TITLE'] = '[Alphabot] cancella display';
Blockly.Msg['ROBOTS_ALPHABOT_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di cancellare il contenuto del display OLED.';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETCOLOR_TITLE'] = '[Alphabot] controlla il LED %1 a R %2 G %3 B %4';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETCOLOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di controllare il colore di ciascun LED del neopixel del robot Alphabot (pin15) in modo che i valori R,G,B siano compresi tra 0 e 255. Il neopixel è collegato al pin P15 sul robot.';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Alphabot] controlla il LED %1 a %2';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di controllare il colore di ciascun LED del modulo neopixel. Per cambiare colore utilizzare la tavolozza.';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETRAINBOW_TITLE'] = '[Alphabot] Arcobaleno';
Blockly.Msg['ROBOTS_ALPHABOT_NEOPIXEL_SETRAINBOW_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Visualizza lo spettro dei colori sui LED RGB (pin15).';
Blockly.Msg['ROBOTS_ALPHABOT_BUZZER_CONTROLSTATE_TITLE'] = '[Alphabot] controlla il buzzer allo stato %1';
Blockly.Msg['ROBOTS_ALPHABOT_BUZZER_CONTROLSTATE_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di controllare lo stato del buzzer (cicalino) del robot Alphabot. (0 o 1)';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_TITLE'] = '[Alphabot] se pulsante %1';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_DETECTED_THEN'] = 'del joystick è premuto allora';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_ELSEIF'] = 'altrimenti se pulsante';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_RECEIVED_THEN'] = 'premuto allora';
Blockly.Msg['ROBOTS_ALPHABOT_JOYSTICK_ONCOMMANDRECEIVED_TOOLTIP'] = IMG_MODULE_ALPHABOT + Blockly.Tooltip.SEP + 'Permette di eseguire alcune istruzioni se viene ricevuto un comando dal joystick del robot Alphabot.';
Blockly.Msg['JOYSTICK_BUTTON_UP'] = 'alto';
Blockly.Msg['JOYSTICK_BUTTON_DOWN'] = 'basso';
Blockly.Msg['JOYSTICK_BUTTON_LEFT'] = 'sinistra';
Blockly.Msg['JOYSTICK_BUTTON_RIGHT'] = 'destra';
Blockly.Msg['JOYSTICK_BUTTON_CENTER'] = 'centrale';