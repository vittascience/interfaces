/**
 * @fileoverview Spanish messages for ESP32. (EN)
 */

'use strict';

// Display - Esp32
Blockly.Msg['DISPLAY_CONTROL_BUILTIN_LED_TITLE'] = '[Esp32] controlar el LED incorporado (p2) en estado %1';
Blockly.Msg['DISPLAY_CONTROL_BUILTIN_LED_TOOLTIP'] = 'Permite controlar el estado del LED conectado al pin p2 de la placa Esp32';
// Display - Screen
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD] mostrar texto %1 en la línea %2 posición %3';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Mostrar texto en una de las dos líneas de la arboleda LCD1602. Conecte el módulo a un puerto I2C';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD] limpiar pantalla';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Permite borrar todos los caracteres de la pantalla LCD. Conecte el módulo a un puerto I2C';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[OLED] mostrar texto %1 en la posición x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permite escribir texto en una pantalla OLED de 128x64. Conecta la pantalla a un puerto I2C';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TITLE'] = '[OLED] controlar píxel x %1 y %2 estado %3';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Le permite controlar cada píxel de la pantalla OLED de tamaño 128x64. Conecte la pantalla a un puerto I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TITLE'] = '[OLED] dibuja una línea desde (%1, %2) hasta (%3, %4)';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permite dibujar una línea entre dos puntos de la pantalla OLED de tamaño 128x64. Conecta la pantalla a un puerto I2C';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TITLE'] = '[OLED] establece el fondo en %1';
Blockly.Msg['DISPLAY_OLED_WHITE'] = 'blanco';
Blockly.Msg['DISPLAY_OLED_BLACK'] = 'negro';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Invierte la retroiluminación de la pantalla. Conecta la pantalla a un puerto I2C';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[OLED] limpiar pantalla';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permite borrar el contenido de la pantalla OLED. Conecta la pantalla a un puerto I2C';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[OLED] mostrar icono %1 posición x %2 y %3';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Muestra un icono de la biblioteca de imágenes ESP32 en la posición (x,y) de la pantalla OLED de la arboleda. Conecte la pantalla a un puerto I2C';
// Display - Neopixel
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] establece %1 LED en el pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite definir el número de LEDs del neopixel. Este bloque debe utilizarse en el bloque "Al inicio"';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] controla el LED %1 a R %2 G %3 B %4 en el pin %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar el color de cada LED como (R,G,B) de 0 a 255 del módulo neopixel';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] controla el LED %1 a %2 en el pin %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar el color de cada LED del módulo neopixel. Utilice la paleta para cambiar el color';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] controla todos los LEDs en R %1 G %2 B %3 en el pin %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar todos los LEDs del módulo neopixel al color elegido tal que (R,G,B) esté entre 0 y 255';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] controla todos los LEDs en %1 en el pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar todos los LEDs del módulo neopixel al color elegido. Utilice la paleta para cambiar el color';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] Arco iris en el pin %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Mostrar el espectro de colores en el LED RGB. Es posible cambiar el pin y el número de LEDs del módulo neopixel';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] controla el LED %1 en el pin %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Activar o desactivar el LED Grove (0 o 1) en los pines digitales';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] establece el brillo a %1 (%) en el pin %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Permite ajustar el brillo de un LED de 0 a 100% en los pines PWM';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[LED de color variable] establece el brillo a %1 (%) en el pin %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Permite establecer el brillo de un LED de 0 a 100% en los pines PWM. Cuando se utiliza por primera vez, los valores RGB se establecen en 0. Utilice un destornillador para ajustar los colores R, G y B detrás del módulo';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[Pantalla de 4 dígitos] muestra %1 %2 en los pines CLK %3 DIO %4';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permite mostrar un número, una temperatura o el reloj en la pantalla de 4 dígitos de la arboleda (TM1637) con los pines digitales';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[Pantalla de 4 dígitos] reloj en pines CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permite mostrar el reloj en la pantalla de 4 dígitos de la arboleda (TM1637) con pines digitales. Cuidado, el tiempo real se recupera sólo cuando la tarjeta microbit está encendida';
Blockly.Msg['DISPLAY_4DIGIT_NUMBER'] = 'el número entero';
Blockly.Msg['DISPLAY_4DIGIT_TEMPERATURE'] = 'la temperatura';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[Módulo de barras LED] muestra el nivel de %1 en los pines DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permite mostrar el nivel del valor de entrada en el módulo de la barra de LEDs (MY9221) con los pines digitales';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TITLE'] = '[Módulo de barras LED] invierte la pantalla %1 DI pins %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permite invertir los 10 LEDs del módulo MY9221 con los pines digitales P0 a P20';
// Display - Chainable LED
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TITLE'] = '[LED encadenable] establecer %1 LED en pines CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Permite configurar la cadena de LEDs RGB definiendo el número de módulos en serie en los pines digitales.';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TITLE'] = '[LED encadenable] controla el LED %1 a R %2 G %3 B %4 en los pines CIN %5 DIN %6';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color del LED RGB, da un valor entre 0 y 255 para el Rojo, el Verde y el Azul';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TITLE'] = '[LED encadenable] controla el LED %1 a %2 en los pines CIN %3 DIN %4';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color del LED RGB, elige un color de la paleta';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TITLE'] = '[LED encadenable] controla todos los LEDs en R %1 G %2 B %3 en los pines CIN %4 DIN %5';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color de los LEDs RGB, da un valor entre 0 y 255 para el Rojo, Verde y Azul';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE'] = '[LED encadenable] controla todos los LEDs en %1 en los pines CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color de los LEDs RGB, elige un color de la paleta';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TITLE'] = '[LED encadenable] se apaga en los pines CIN %1 DIN %2';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloquea el apagado de todos los LEDs RGB';

// Input/Output - Esp32
Blockly.Msg['IO_WAIT_TITLE'] = 'wait %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Pausa en la ejecución del código';
Blockly.Msg['IO_WAIT_SECOND'] = 'segundo(s)';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milisegundo(s)';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microsegundo(s)';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'espera hasta %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Detiene la ejecución del código hasta que se cumpla la condición';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'iniciar el temporizador';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Inicializar un temporizador a 0 (en segundos)';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'Valor del cronómetro en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Devuelve el valor del temporizador de la inicialización (en segundos o milisegundos)';
// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Teclado numérico] dígito en pines RX %1 TX %2';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Permite obtener el teclado numérico de Grove pulsado en los pines TX y RX. Al conectar el módulo, asegúrate de que los pines están cruzados: RX en la placa con TX en el módulo y viceversa';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Módulo joystick] valor %1 del eje del joystick en los pines A0 %2 A1 %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Devuelve el valor del eje X o Y del joystick de Grove (0 a 1023) en los pines analógicos p34 a p36, o p39 (A2 a A4 en la pantalla de Grove)';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TITLE'] = '[Módulo de botones de colores] estado en el pin SIG2 %1';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el estado del botón coloreado de Grove (0 o 1) en los pines digitales';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TITLE'] = '[Módulo de botones de colores] controlan el estado del LED %1 en el pin SIG1 %2';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Enciende o apaga el LED (0 o 1) de los pines digitales';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Módulo de ángulo giratorio] ángulo en el pin %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Devuelve el ángulo (de 0 a 1023) del potenciómetro rotativo Grove en los pines analógicos p34 a p36, o p39 (A2 a A4 en la pantalla Grove)';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Potenciómetro lineal] valor en el pin %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Devuelve la posición (de 0 a 1023) del potenciómetro lineal Grove en los pines analógicos p34 a p36, o p39 (A2 a A4 en la pantalla Grove)';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Sensor táctil] estado en el pin %1';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor táctil Grove (0 o 1) en los pines digitales';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Módulo de botones] estado en el pin %1';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el valor del botón Grove (0 o 1) en los pines digitales';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Módulo de conmutación] estado en el pin %1';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Devuelve el valor del interruptor Grove (0 o 1) en los pines digitales';
// Input/Output - Pins
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'ALTO (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAJO (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Devuelve un valor booleano (1 si es HIGH o 0 si es LOW)';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'leer pin digital %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Leer el valor de una entrada digital (0 o 1)';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'escribe el estado %1 en el pin digital %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Escribir un valor en una entrada digital (0 o 1)';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'leer pin analógico %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Lee el valor de una entrada analógica (0-1023), que corresponde a una tensión entre 0 y 3,6V';
Blockly.Msg['IO_WRITEPWMPIN_TITLE'] = 'escribe el valor %1 en el pin PWM %2';
Blockly.Msg['IO_WRITEPWMPIN_TOOLTIP'] = 'Permite aplicar una señal PWM con una frecuencia fija de 10kH y cambiando el ciclo de 0 a 1023. El valor 512 corresponderá al 50% del ciclo, es decir, a unos 1,66V';
Blockly.Msg['IO_WRITEANALOGPIN_TITLE'] = 'escribe el valor %1 en el pin analógico %2 (DAC)';
Blockly.Msg['IO_WRITEANALOGPIN_TOOLTIP'] = 'Permite aplicar una tensión analógica a los pines DAC p25 y p26 (de 0 a 255). El Esp32 utiliza un convertidor digital-analógico (DAC) para aplicar una tensión entre 0 y 3,3V';
Blockly.Msg['IO_SETPWM_TITLE'] = 'aplicar una señal de onda cuadrada de frecuencia %1 (Hz) al pin %2';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Aplicar una señal de onda cuadrada (PWM) con un ciclo fijo del 50% a un pin. Este bloque permite cambiar la frecuencia de la señal';
Blockly.Msg['IO_STOPPWM_TITLE'] = 'detener la señal PWM del pin %1';
Blockly.Msg['IO_STOPPWM_TOOLTIP'] = 'Detener la señal PWM aplicada a un pin';
Blockly.Msg['IO_GETVOLTAGE_TITLE'] = 'convertir %1 en %2 en voltaje';
Blockly.Msg['IO_GETVOLTAGE_TOOLTIP'] = 'Convierte un valor analógico a voltaje eligiendo la resolución (10 bits: 1024, 12 bits: 4096, 9 bits: 512, 11 bits: 2048) y un máximo de 3,6V';

// Communication - Internal Bluetooth
Blockly.Msg['COMMUNICATION_START_BT_TITLE'] = '[ESP32 Bluetooth UART] inicializar bluetooth %1';
Blockly.Msg['COMMUNICATION_START_BT_TOOLTIP'] = 'Permite inicializar el servicio Bluetooth de ESP32 con un nombre asignado';
Blockly.Msg['COMMUNICATION_SEND_BT_TITLE'] = '[ESP32 Bluetooth UART] enviar datos %1';
Blockly.Msg['COMMUNICATION_SEND_BT_TOOLTIP'] = 'Permite enviar datos a través del Bluetooth del ESP32';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TITLE'] = '[Bluetooth] si el mensaje se recibe en %1 entonces';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TOOLTIP'] = 'Permite ejecutar instrucciones si se reciben datos por Bluetooth (BLE)';
Blockly.Msg['COMMUNICATION_BLE_APP_INVENTOR_READ_DATA_TITLE'] = '[Bluetooth] si el mensaje se recibe en %1 entonces';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TITLE'] = '[Aplicación Bluetooth Fizziq] enviar %1 %2';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TOOLTIP'] = IMG_MODULE_FIZZIQ + Blockly.Tooltip.SEP + 'Enviar datos (Temperatura, Humedad, etc) vía Bluetooth a la aplicación Fizziq';
Blockly.Msg['FIZZ_TEMP'] = 'Temperatura';
Blockly.Msg['FIZZ_HUM'] = 'Humedad';
Blockly.Msg['FIZZ_VOLTAGE'] = 'Tensión';
Blockly.Msg['FIZZ_WEIGHT'] = 'Peso';
Blockly.Msg['FIZZ_PRESSURE'] = 'Presión';
Blockly.Msg['FIZZ_CONCENTRATION'] = 'Concentración';
Blockly.Msg['FIZZ_MAGNETIC'] = 'Campo magnético';
Blockly.Msg['FIZZ_BRIGHTNESS'] = 'Brillo';
Blockly.Msg['FIZZ_ACCELERATION'] = 'Aceleración';
Blockly.Msg['FIZZ_COMPASS'] = 'Brújula';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'escribir en la consola %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Permite escribir datos en el puerto serie';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'con';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'avance de línea(s)';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE then'] = 'on serial data received in %1 then';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones si se reciben datos del puerto serie en la variable \'serialData\'';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'reproduce la nota %1 en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Toca la nota seleccionada hasta que se ejecuta el bloque "Fin de nota".';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'reproduce la frecuencia %1 (Hz) en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Este bloque reproduce una frecuencia determinada en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'terminar la nota en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Detener la nota actual';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'trazar gráfico';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Este bloque permite escribir datos (numéricos) que serán visibles en el trazador. Puede utilizarse con uno o varios bloques con formato "Nom" y "Datos". Para ver los gráficos, haga clic en el icono "Modo gráfico" de la consola';
Blockly.Msg['COMMUNICATION_DATA'] = 'Datos';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nombre %1 Valor %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Este bloque debe utilizarse junto con el bloque "Plot Graph". Debe contener a su vez el nombre del valor a mostrar (texto), y el valor en cuestión (número)';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] escribe en la tarjeta SD %1 baudrate %2 en los pines RXI %3 TXO %4 %5 Data %6';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'Permite escribir datos en la tarjeta micro SD con el módulo Openlog. Funciona con transmisión UART';
Blockly.Msg['COMMUNICATION_ESP32_FS_SAVE_DATA_TITLE'] = '[ESP32] guardar datos %1 en el archivo %2';
Blockly.Msg['COMMUNICATION_ESP32_FS_SAVE_DATA_TOOLTIP'] = 'Le permite guardar datos en un archivo de texto en el sistema de archivos ESP32. Si utiliza el mismo nombre de archivo, los datos se agregarán al final del archivo. También puedes presionar el botón + para cambiar la extensión del archivo.';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] enviar en los pines RX %1 TX %2 mensaje %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permite enviar datos a través del módulo BLuetooth HC05 en los pines RX/TX';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] si el mensaje se recibe en los pines RX %1 TX %2 en %3 entonces';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones si se reciben datos por un módulo Bluetooth HC05 en la variable \'bluetoothData\' en los pines RX/TX';
// Communication - Infrared
Blockly.Msg['COMMUNICATION_INFRARED_ONDATARECEIVED_TITLE'] = '[IR] si se recibe %1 en %2 %3pin %4 con el protocolo %5 entonces';
Blockly.Msg['COMMUNICATION_INFRARED_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones si se reciben datos por el receptor infrarrojo Grove en la variable en el pin Digital, con un protocolo específico (NEC_8 o NEC16).';
// Communication - Tracking modules
Blockly.Msg['COMMUNICATION_GPS_INFO_TYPE'] = 'el tipo de marco';
Blockly.Msg['COMMUNICATION_GPS_INFO_CLOCK'] = 'la hora (h, m, s)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LATITUDE'] = 'latitud (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LONGITUDE'] = 'la longitud (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_SATELLITE'] = 'el número de satélites utilizados';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALTITUDE'] = 'altitud (m)';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALL_FRAME'] = 'todo el marco';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TITLE'] = '[GPS] Tramas NMEA en los pines RX %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Devuelve la lista de tramas NMEA leídas con el módulo GPS Grove SIM28 o Air530 en los pines RX/TX. No es necesario invertir los cables entre los pines del módulo y los indicados en el bloque. Nota: Si utiliza la consola para visualizar los datos del GPS, conecte su tarjeta a la interfaz antes de enviar el programa haciendo clic en el botón [>_ REPL]. A continuación, cargue su programa mediante el botón [Descargar .hex]';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TITLE'] = '[GPS] get %3 on RX pins %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Devuelve los datos seleccionados de (tipo de trama, reloj, latitud, longitud, altitud) analizados de la trama NMEA (GNGGA o GPGGA) leída con el módulo GPS Grove SIM28 o Air530 en los pines RX/TX. No es necesario invertir los cables entre los pines del módulo y los indicados en el bloque. Nota: Si utiliza la consola para visualizar los datos del GPS, conecte su tarjeta a la interfaz antes de enviar el programa haciendo clic en el botón [>_ REPL]. A continuación, cargue su programa mediante el botón [Descargar .hex]';
Blockly.Msg['COMMUNICATION_RTC_MODULE_PCF85063TP'] = 'Alta precisión (0x51)';
Blockly.Msg['COMMUNICATION_RTC_MODULE_DS1307'] = 'v1.2 (0x68)';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TITLE'] = '[Reloj RTC %1] ajustado a %2 fecha %3';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Inicialice el módulo de reloj de alta precisión Grove RTC (PCF85063TP) o el módulo RTC v1.2 (DS1307), para poder leer la fecha y la hora precisas con el bloque \'Leer módulo de reloj\'. Colóquelo en el bloque "Al inicio". Conecte el módulo RTC a un puerto I2C. Nota: Para que funcione, el módulo DS1307 debe tener una pila de botón';
Blockly.Msg['DAY_MONDAY'] = 'Lunes';
Blockly.Msg['DAY_TUESDAY'] = 'Martes';
Blockly.Msg['DAY_WEDNESDAY'] = 'Miércoles';
Blockly.Msg['DAY_THURSDAY'] = 'Jueves';
Blockly.Msg['DAY_FRIDAY'] = 'Viernes';
Blockly.Msg['DAY_SATURDAY'] = 'Sábado';
Blockly.Msg['DAY_SUNDAY'] = 'Domingo';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TITLE'] = '[Reloj RTC %1] ajustado a la hora %2 minuto %3 segundo %4';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permite inicializar el módulo de reloj de alta precisión Grove RTC (PCF85063TP) o el módulo RTC v1.2 (DS1307), para poder leer la fecha y la hora precisas con el bloque \'Leer módulo de reloj\'. Colóquelo en el bloque "Al inicio". Conecte el módulo a un puerto I2C. Nota: El módulo DS1307 debe tener una pila de botón para funcionar';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TITLE'] = '[Reloj RTC %1] leído %2';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Lee la fecha y la hora del módulo de reloj Grove RTC de alta precisión (PCF85063TP) o del módulo RTC v1.2 (DS1307). Para obtener el resultado correcto, utilice primero los dos bloques "Inicializar módulo de reloj". Conecte el módulo a un puerto I2C. Nota: Para que funcione, el módulo DS1307 debe tener una pila de botón';
Blockly.Msg['CLOCK_ALL_DATA'] = 'el reloj';
Blockly.Msg['CLOCK_YEAR'] = 'año';
Blockly.Msg['CLOCK_MONTH'] = 'mes';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'día del mes';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'día de la semana';
Blockly.Msg['CLOCK_HOUR'] = 'hora';
Blockly.Msg['CLOCK_MINUTE'] = 'minuto';
Blockly.Msg['CLOCK_SECOND'] = 'segundo';
// Communication - UART
Blockly.Msg['COMMUNICATION_UART_INIT_TITLE'] = '[uart %1] establece la conexión serie a RX %2 TX %3 Baudrate %4';
Blockly.Msg['COMMUNICATION_UART_INIT_TOOLTIP'] = 'Configurar la conexión serie de la tarjeta ESP32 al puerto UART (1 o 2). El puerto 0 está reservado para REPL';
Blockly.Msg['COMMUNICATION_UART_WRITE_TITLE'] = '[uart %1] escribe datos %2';
Blockly.Msg['COMMUNICATION_UART_WRITE_TOOLTIP'] = 'Permite escribir datos en el puerto UART (1 o 2). Por defecto, los pines son los siguientes: UART 1 (tx=10, rx=9) y UART 2 (tx=17, rx=16). En caso contrario, utilice el bloque \'Configurar la conexión serie a la velocidad de transmisión RX ...\'';
Blockly.Msg['COMMUNICATION_UART_READ_TITLE'] = '[uart %1] leer datos';
Blockly.Msg['COMMUNICATION_UART_READ_TOOLTIP'] = 'Permite leer datos del puerto UART (1 o 2). Por defecto, los pines son los siguientes: UART 1 (tx=10, rx=9) y UART 2 (tx=17, rx=16). En caso contrario, utilice el bloque \'Configurar la conexión serie a la velocidad de transmisión RX ...\'';
Blockly.Msg['COMMUNICATION_UART_READ_SIZE'] = 'tamaño de los datos';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TITLE'] = '[uart %1] data available';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TOOLTIP'] = 'Returns the size of data available on the UART port (1 or 2). By default, the pins are as: UART 1 (tx=10, rx=9) and UART 2 ( tx=17, rx=16). Otherwise, use the \'Set serial connection to RX TX Baudrate...\' block.';

// Sensors - ESP32
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TITLE'] = 'leer sensor Hall';
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TOOLTIP'] = 'Devuelve el valor del sensor Hall de la placa';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TITLE'] = 'temperatura del procesador en %1';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TOOLTIP'] = 'Devuelve la temperatura del procesador';
// ESP32-CAM
Blockly.Msg['ESP32_CAM_GET_CAPTURED_DATA_TITLE'] = '[ESP32-CAM] captura una foto, tipo de datos %1';
Blockly.Msg['ESP32_CAM_GET_CAPTURED_DATA_TOOLTIP'] = IMG_ESP32_CAM + Blockly.Tooltip.SEP + 'Le permite tomar una foto con la cámara del módulo ESP32-CAM. Devuelve datos hexadecimales o datos base64 (necesarios en una página web por ejemplo).';
Blockly.Msg['ESP32_CAM_SET_IMAGE_SIZE_TITLE'] = '[ESP32-CAM] configurar el tamaño %1';
Blockly.Msg['ESP32_CAM_SET_IMAGE_SIZE_TOOLTIP'] = IMG_ESP32_CAM + Blockly.Tooltip.SEP + 'Permite configurar el tamaño de las capturas realizadas por el ESP32-CAM. Este bloque debe usarse en la instrucción \'Al inicio\'.';
Blockly.Msg['ESP32_CAM_CONTROL_FLASH_LED_TITLE'] = '[ESP32-CAM] controla el flash incorporado en el estado %1';
Blockly.Msg['ESP32_CAM_CONTROL_FLASH_LED_TOOLTIP'] = IMG_ESP32_CAM + Blockly.Tooltip.SEP + 'Permite controlar el flash LED conectado al pin p4 del ESP32-CAM. Te permite iluminar la escena que desees y así obtener fotos de mejor calidad.';
Blockly.Msg['ESP32_CAM_SDCARD_SAVE_PIC_TITLE'] = '[ESP32-CAM] guardar foto %1 tipo de datos %2';
Blockly.Msg['ESP32_CAM_SDCARD_SAVE_PIC_TOOLTIP'] = IMG_ESP32_CAM + Blockly.Tooltip.SEP + 'Permite guardar una foto en la tarjeta SD ESP32-CAM en formato .jpg.';
Blockly.Msg['ESP32_CAM_SDCARD_SAVE_DATA_TITLE'] = '[ESP32-CAM] guarda datos %1 en el archivo %2';
Blockly.Msg['ESP32_CAM_SDCARD_SAVE_DATA_TOOLTIP'] = IMG_ESP32_CAM + Blockly.Tooltip.SEP + 'Le permite guardar datos en un archivo de texto en la tarjeta SD ESP32-CAM. Si usa el mismo nombre de archivo, los datos se agregarán al final del archivo.';
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[sensor SGP30] gas %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Devuelve la cantidad de CO2 (en ppm) o TVOC (en ppb) contenida en el aire por el sensor SGP30. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'Dióxido de carbono (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'Compuestos orgánicos volátiles (TVOC) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Sensor de gas multicanal] gas %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Devuelve la cantidad de gas medida en el aire (en ppm) utilizando el sensor de gas multicanal. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Sensor de gas multicanal v2] gas %1 (V)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Devuelve la cantidad de gas medida en el aire (en V) utilizando el sensor de gas multicanal V2. Conecte el sensor a un puerto I2C';
Blockly.Msg['GAS_CO'] = 'Monóxido de carbono (CO)';
Blockly.Msg['GAS_NO2'] = 'Dióxido de nitrógeno (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'Etanol (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'Dihidrógeno (H2)';
Blockly.Msg['GAS_NH3'] = 'Amoníaco (NH3)';
Blockly.Msg['GAS_CH4'] = 'Metano (CH4)';
Blockly.Msg['GAS_C3H8'] = 'Propano (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'Iso-propane (C4H10)';
Blockly.Msg['GAS_VOC'] = 'Compuestos orgánicos volátiles (COV)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Sensor de oxígeno] O2 (%) en el pin %1';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Devuelve la concentración de oxígeno (O2) en el aire (en %) del sensor de gas O2 del surco en los pines analógicos p34 a p36, o p39 (A2 a A4 en el escudo del surco)';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[Sensor SCD30] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Devuelve la concentración de CO2 en el aire (en ppm), la humedad (en %), o la temperatura en Celsius (°C), Fahrenheit (°F), o Kelvin (K) del sensor SCD30 de Grove. Coloca el sensor en un puerto I2C';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'dióxido de carbono (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = 'temperatura';
Blockly.Msg['SENSORS_SCD30_HUM'] = 'humedad (%)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[Sensor SCD30] forzar recalibración a %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Forzar la calibración del sensor SCD30 al valor dado (en ppm). Salga al exterior (donde la concentración es de unas 420 ppm, es decir, aire limpio), reinicie la placa y espere 2 minutos. Consejo: Utilice los botones SW1, SW2 o SW3 de la placa NUCLEO STM32 para controlar el inicio de la calibración. De lo contrario, al volver a enchufar la placa, el programa se inicia y vuelve a realizar una calibración, lo cual no es necesariamente deseado';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Sensor de calidad del aire] valor en el pin %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Devuelve el valor de la calidad del aire (0 a 1023) en los pines analógicos p34 a p36, o p39 (A2 a A4 en el escudo Grove)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[Sensor HM330X] concentración de partículas finas %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Detecta la densidad de las partículas en el aire con el sensor HM330X. Banquear el sensor en un puerto I2C';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
// Sensors - Climate
Blockly.Msg['SENSORS_TEMPERATURE'] = 'la temperatura';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humedad (%)';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'es';
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[Sensor BMP280 %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), presión (en Pascal) o altitud (en m). La altitud se calcula con la presión y se pone a 0 al principio del programa. El bloque necesita el sensor Grove BMP280 (dirección I2C: 0x77, color: azul) o el sensor HW-611 280 (dirección I2C: 0x76, color: morado). Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_BMP280_TEMP'] = 'temperatura';
Blockly.Msg['SENSORS_BMP280_PRESS'] = 'presión (Pa)';
Blockly.Msg['SENSORS_BMP280_ALT'] = 'altitud (m)';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = '[Sensor H.T°] temperatura en %1 en los pines A0 %2 A1 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Devuelve la temperatura del termopar en grados Celsius (50 a 600 °C), Fahrenheit (°F) o Kelvin (K) utilizando el sensor de alta temperatura de la arboleda en ';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Sensor de humedad] humedad del suelo en el pin %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Devuelve la humedad (de 0 a 1023) medida por el sensor de humedad de la arboleda en los pines analógicos IO34, IO35, IO36 e IO39';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Sensor T°] temperatura en %1 en el pin %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F), o Kelvin (K) del sensor de temperatura Grove en los pines analógicos p34 a p36, o p39 (A2 a A4 en la pantalla Grove)';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TITLE'] = '[Sensor DS18B20] temperatura en %1 en el pin %2';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K) del sensor de temperatura resistente al agua DS18B20 en los pines digitales';
Blockly.Msg['SENSORS_DHT11_READDATA_TITLE'] = '[Sensor DHT11] %1 en pin %2';
Blockly.Msg['SENSORS_DHT11_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad (en %) del sensor dht11 en los pines digitales';
Blockly.Msg['SENSORS_DHT22_READDATA_TITLE'] = '[Sensor DHT22] %1 en pin %2';
Blockly.Msg['SENSORS_DHT22_READDATA_TOOLTIP'] = IMG_MODULE_DHT22 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad (en %) con gran precisión gracias al sensor grove dht22 en los pines digitales';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[Sensor TH02] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad (en %) del sensor TH02. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Sensor SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad (en %) del sensor SHT31. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Sensor de agua] cantidad de agua en el pin %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Devuelve la cantidad de agua (de 0 a 255) medida por el sensor de agua del bosquecillo en los pines analógicos p34 a p36, o p39 (A2 a A4 en el escudo del bosquecillo)';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Sensor de lluvia] estado en el pin %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Devuelve el estado del sensor de lluvia (1 si está lloviendo o 0 si no lo está) en los pines digitales';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anemómetro] estado en el pin %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Devuelve el estado del anemómetro (dos veces el estado HIGH en cada rotación) en los pines digitales';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Sensor de luz] brillo en el pin %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Devuelve el brillo (de 0 a 1023) del sensor de luz Grove en los pines analógicos IO34, IO35, IO36 e IO39';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[Sensor SI1145] brillo %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Devuelve el índice de luz ultravioleta, el brillo visible (en lumen) o el brillo infrarrojo (en lumen) utilizando el sensor Grove Sunlight o el sensor GY1145. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_SI1145_UV'] = 'Índice UV';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visible (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrarrojos (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Sensor ultravioleta] Índice UV en el pin %1';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Devuelve el índice de luz ultravioleta para ondas entre 240 y 380 nm del sensor Grove en los pines analógicos p34 a p36, o p39 (A2 a A4 en el escudo Grove)';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Sensor de color] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Permite leer el nivel de uno de los tres colores primarios con el sensor de color Grove, el nivel está entre 0 y 255. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Sensor de sonido] nivel de sonido en el pin %1';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Devuelve el nivel de sonido (0 a 1023) con el sensor de sonido Grove en los pines digitales';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Sensor ultrasónico %1] %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Devuelve la distancia (en cm) medida con el sensor ultrasónico de ranura en los pines digitales. Tenga en cuenta que si el sensor es un modelo de ranura, TRIG y ECHO están en el mismo pin SIG';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distancia (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'tiempo de ida y vuelta (µs)';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = '[Sensor gestual] tipo de gesto';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Devuelve el tipo de gesto analizado (\'derecha\', \'izquierda\', \'arriba\', \'abajo\', \'hacia delante\', \'hacia atrás\', \'en el sentido de las agujas del reloj\', \'en el sentido contrario\') utilizando el sensor de gestos de Grove. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Sensor de gestos] si se detecta el gesto %1';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Ejecuta las instrucciones si el gesto seleccionado es detectado por el sensor de gestos Grove. Conecte el sensor a un puerto I2C';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'derecho';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'izquierda';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'top';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'bottom';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'front';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'atrás';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'tiempo';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'en sentido contrario a las agujas del reloj';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'wave';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Sensor de línea negra] estado en el pin %1';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de línea negra grove (0 o 1) los pines digitales';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[Sensor de movimiento] estado en el pin %1';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor Grove PIR Motion (0 o 1) en los pines digitales';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Sensor de vibración] estado en el pin %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Devuelve el estado de vibración (0 o 1) del sensor de vibración piezoeléctrico en los pines digitales';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Módulo de inclinación] estado en el pin %1';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Devuelve el valor de la inclinación del módulo Grove (0 o 1) en los pines digitales';
Blockly.Msg['SENSORS_GY521_GETDATA_TITLE'] = '[Sensor de movimiento GY-521] %1';
Blockly.Msg['SENSORS_GY521_GETDATA_TOOLTIP'] = 'Devuelve el valor de la aceleración, la velocidad angular o la temperatura usando el sensor GY-521 conectado al puerto I2C.';
Blockly.Msg['SENSORS_GY521_ACC'] = 'aceleración';
Blockly.Msg['SENSORS_GY521_GYR'] = 'giroscopio';
Blockly.Msg['SENSORS_GY521_TEMP'] = 'temperatura';
Blockly.Msg['SENSORS_GY521_AXIS'] = 'eje';
// Other sensors
Blockly.Msg['SENSORS_GETGROVEBUTTON_TITLE'] = '[Módulo de botones] %1 en el pin %2';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el valor numérico del botón Grove (0/1 o 0V/3.3V) en los pines digitales';
Blockly.Msg['SENSORS_GETGROVEBUTTON_VOLTAGE'] = 'voltaje';
Blockly.Msg['SENSORS_GETGROVEBUTTON_STATE'] = 'state';
Blockly.Msg['SENSORS_GET_WATER_LEVEL_TITLE'] = '[Nivel de agua] valor';
Blockly.Msg['SENSORS_GET_WATER_LEVEL_TOOLTIP'] = 'Mide el nivel de agua en porcentaje (de 0 a 100%) en el puerto I2C.';
Blockly.Msg['SENSORS_VOLTAGE_DIVIDER_GETDATA_TITLE'] = '[Divisor de tensión] divide la tensión por %1 en el pin %2';
Blockly.Msg['SENSORS_VOLTAGE_DIVIDER_GETDATA_TOOLTIP'] = IMG_MODULE_VOLTAGE_DIVDER + Blockly.Tooltip.SEP + 'Devuelve el valor de la tensión en los pines analógicos. El selector permite especificar el rango de medición: 3 para una tensión entre 0,3V y 12,9V, 10 para una tensión entre 1V y 43V.';
// Actuators - Motors
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Actuador] ángulo de control en %1 en el husillo %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permite controlar el ángulo de un servomotor (de 0 a 180) en los pines digitales. Tenga en cuenta que el conjunto debe ser alimentado por una batería para proporcionar suficiente corriente al servomotor';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Servo continuo] controla la velocidad en %1 (%) dirección %2 en el husillo %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Permite controlar la velocidad (de 0 a 100%) de un servomotor continuo en los pines PWM';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Motor] controla la potencia en %1 en el pin %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permite controlar la potencia de un motor (de 0 a 1023) en los pines digitales. Tenga cuidado, el conjunto debe ser alimentado por una batería para proporcionar suficiente corriente al motor';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Módulo de relé] controla el relé en estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Permite controlar el valor del relé (0 o 1) en los pines digitales';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Motor de vibración] controla el motor en el estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Activa o desactiva el motor de vibración del surco (0 o 1) en los pines digitales';
// Actuators - Music
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TITLE'] = '[Zumbador/altavoz] reproducir música %1 en %2';
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Activar la reproducción de la música elegida en el módulo zumbador Grove (o altavoz) en los pines digitales';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TITLE'] = '[Buzzer/Speaker] reproducir notas en';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Activar la reproducción de notas en el módulo Grove buzzer (o altavoz) en los pines digitales';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TITLE'] = 'nota %1 en la octava %2 con duración %3';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Define una nota con octava y duración';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TITLE'] = '[Zumbador/Parlante] reproducir frecuencia %1 durante %2 (ms) en %3';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Activar la reproducción de la frecuencia entera en el módulo zumbador (o altavoz) Grove en los pines digitales';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TITLE'] = '[Zumbador/Parlante] detener la música en %1';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Activar para detener la música del módulo zumbador (o altavoz) Grove en los pines digitales';
// Notes
Blockly.Msg['NOTE_C'] = 'C';
Blockly.Msg['NOTE_C_SHARP'] = 'C#';
Blockly.Msg['NOTE_D'] = 'D';
Blockly.Msg['NOTE_D_SHARP'] = 'D#';
Blockly.Msg['NOTE_E'] = 'E';
Blockly.Msg['NOTE_F'] = 'F';
Blockly.Msg['NOTE_F_SHARP'] = 'F#';
Blockly.Msg['NOTE_G'] = 'G';
Blockly.Msg['NOTE_G_SHARP'] = 'G#';
Blockly.Msg['NOTE_A'] = 'A';
Blockly.Msg['NOTE_A_SHARP'] = 'A#';
Blockly.Msg['NOTE_B'] = 'B';
Blockly.Msg['MUSIC_SILENCE'] = 'Silencio';
// Robot Ilo
Blockly.Msg['ROBOTS_ILO_SET_LED_COLOR_RGB_TITLE'] = '[Ilo] LEDs R %1 V %2 A %3';
Blockly.Msg['ROBOTS_ILO_SET_LED_COLOR_RGB_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permite controlar el color de los LEDs del robot Ilo en formato RGB.';
Blockly.Msg['ROBOTS_ILO_SET_LED_COLOR_TITLE'] = '[Ilo] LEDs %1';
Blockly.Msg['ROBOTS_ILO_SET_LED_COLOR_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permite controlar el color de los LEDs del robot Ilo en formato RGB.';
Blockly.Msg['ROBOTS_ILO_SET_LED_SHAPE_TITLE'] = '[Ilo] LEDs mostrar icono %1';
Blockly.Msg['ROBOTS_ILO_SET_LED_SHAPE_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permite controlar el color de los LEDs del robot Ilo usando una forma predefinida.';
Blockly.Msg['ROBOTS_ILO_SET_LED_ANIM_TITLE'] = '[Ilo] animación de LEDs %1';
Blockly.Msg['ROBOTS_ILO_SET_LED_ANIM_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permite controlar el color de los LEDs del robot Ilo usando una animación predefinida.';
Blockly.Msg['ROBOTS_ILO_WAVE'] = 'ola';
Blockly.Msg['ROBOTS_ILO_SET_LED_SINGLE_TITLE'] = '[Ilo] LED n°%1 %2 en %3';
Blockly.Msg['ROBOTS_ILO_SET_LED_SINGLE_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permite controlar el color de los LEDs del robot Ilo usando una animación predefinida.';
Blockly.Msg['ROBOTS_ILO_MATRIX'] = 'de la matriz';
Blockly.Msg['ROBOTS_ILO_CIRCLE'] = 'del círculo';
Blockly.Msg['ROBOTS_ILO_MOVE_TITLE'] = '[Ilo] controlar el robot %1 velocidad %2 %';
Blockly.Msg['ROBOTS_ILO_MOVE_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permite controlar la dirección y la velocidad del robot Ilo.';
Blockly.Msg['ROBOTS_ILO_MOVE_BY_STEPS_TITLE'] = '[Ilo] controlar el robot %1 por %2 unidad(es)';
Blockly.Msg['ROBOTS_ILO_MOVE_BY_STEPS_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permite controlar la dirección y la distancia recorrida por el robot Ilo. 1 unidad = 1 longitud del robot Ilo, es decir, 20 cm.';
Blockly.Msg['ROBOTS_ILO_MOVE_FRONT'] = 'hacia adelante';
Blockly.Msg['ROBOTS_ILO_MOVE_BACK'] = 'hacia atrás';
Blockly.Msg['ROBOTS_ILO_MOVE_RIGHT'] = 'hacia la derecha';
Blockly.Msg['ROBOTS_ILO_MOVE_LEFT'] = 'hacia la izquierda';
Blockly.Msg['ROBOTS_ILO_MOVE_ROT_TRIGO'] = 'girar a la izquierda';
Blockly.Msg['ROBOTS_ILO_MOVE_ROT_CLOCK'] = 'girar a la derecha';
Blockly.Msg['ROBOTS_ILO_MOVE_MOTOR_TITLE'] = '[Ilo] controlar el motor %1 dirección %2 velocidad %3 %';
Blockly.Msg['ROBOTS_ILO_MOVE_MOTOR_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permite controlar un motor específico del robot Ilo.';
Blockly.Msg['ROBOTS_ILO_FRONT_LEFT'] = 'frontal izquierdo';
Blockly.Msg['ROBOTS_ILO_FRONT_RIGHT'] = 'frontal derecho';
Blockly.Msg['ROBOTS_ILO_BACK_RIGHT'] = 'trasero derecho';
Blockly.Msg['ROBOTS_ILO_BACK_LEFT'] = 'trasero izquierdo';
Blockly.Msg['ROBOTS_ILO_ROTATE_TITLE'] = '[Ilo] girar el robot en la dirección %1 por %2 °';
Blockly.Msg['ROBOTS_ILO_ROTATE_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permite girar el robot Ilo en la dirección y ángulo deseados (en grados).';
Blockly.Msg['ROBOTS_ILO_MOVE_ONE_SQUARE_FORWARD_TITLE'] = '[Ilo] avanzar una casilla';
Blockly.Msg['ROBOTS_ILO_MOVE_ONE_SQUARE_FORWARD_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Avanza el robot Ilo una casilla.';
Blockly.Msg['ROBOTS_ILO_MOVE_ONE_SQUARE_BACKWARD_TITLE'] = '[Ilo] retroceder una casilla';
Blockly.Msg['ROBOTS_ILO_MOVE_ONE_SQUARE_BACKWARD_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Retrocede el robot Ilo una casilla.';
Blockly.Msg['ROBOTS_ILO_TURN_LEFT_TITLE'] = '[Ilo] girar a la izquierda';
Blockly.Msg['ROBOTS_ILO_TURN_LEFT_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Gira el robot Ilo 90° hacia la izquierda.';
Blockly.Msg['ROBOTS_ILO_TURN_RIGHT_TITLE'] = '[Ilo] girar a la derecha';
Blockly.Msg['ROBOTS_ILO_TURN_RIGHT_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Gira el robot Ilo 90° hacia la derecha.';
Blockly.Msg['ROBOTS_ILO_STOP_ROBOT_TITLE'] = '[Ilo] detener el robot';
Blockly.Msg['ROBOTS_ILO_STOP_ROBOT_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Detiene los motores del robot Ilo.';
Blockly.Msg['ROBOTS_ILO_GET_DISTANCE_TITLE'] = '[Ilo] distancia en el sensor %1';
Blockly.Msg['ROBOTS_ILO_GET_DISTANCE_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Devuelve la distancia (en mm) al obstáculo más cercano en la dirección indicada.';
Blockly.Msg['ROBOTS_ILO_FRONT'] = 'frontal';
Blockly.Msg['ROBOTS_ILO_BACK'] = 'trasero';
Blockly.Msg['ROBOTS_ILO_RIGHT'] = 'derecha';
Blockly.Msg['ROBOTS_ILO_LEFT'] = 'izquierda';
Blockly.Msg['ROBOTS_ILO_LINE_DETECTOR_TITLE'] = '[Ilo] estado del sensor de línea %1';
Blockly.Msg['ROBOTS_ILO_LINE_DETECTOR_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Devuelve el estado del sensor de línea (derecha/izquierda) del robot Ilo.';
Blockly.Msg['ROBOTS_ILO_SET_LINE_DETECTOR_THRESHOLD_TITLE'] = '[Ilo] umbral del sensor de línea %1';
Blockly.Msg['ROBOTS_ILO_SET_LINE_DETECTOR_THRESHOLD_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Establece el umbral para el sensor de línea (derecha/izquierda) del robot Ilo.';
Blockly.Msg['ROBOTS_ILO_LINE_DETECTOR_RIGHT'] = 'derecha';
Blockly.Msg['ROBOTS_ILO_LINE_DETECTOR_MIDDLE'] = 'centro';
Blockly.Msg['ROBOTS_ILO_LINE_DETECTOR_LEFT'] = 'izquierda';
Blockly.Msg['ROBOTS_ILO_COLOR_DETECTOR_TITLE'] = '[Ilo] detectar el color debajo del %1 sensor';
Blockly.Msg['ROBOTS_ILO_COLOR_DETECTOR_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permite detectar qué color está debajo del robot Ilo.';
Blockly.Msg['ROBOTS_ILO_COLOR_DETECTOR_RGB_TITLE'] = '[Ilo] detectar la intensidad de %1 debajo del %2 sensor';
Blockly.Msg['ROBOTS_ILO_COLOR_DETECTOR_RGB_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permite detectar qué color está debajo del robot Ilo y devuelve la intensidad de rojo, verde o azul.';
Blockly.Msg['ROBOTS_ILO_RED'] = 'rojo';
Blockly.Msg['ROBOTS_ILO_GREEN'] = 'verde';
Blockly.Msg['ROBOTS_ILO_BLUE'] = 'azul';
Blockly.Msg['ROBOTS_ILO_GET_INTERNAL_SENSORS_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Devuelve el valor del cabeceo, balanceo o guiñada del robot Ilo.';
Blockly.Msg['ROBOTS_ILO_GET_INTERNAL_SENSORS_TITLE'] = '[Ilo] %1';
Blockly.Msg['ROBOTS_ILO_PITCH'] = 'cabeceo';
Blockly.Msg['ROBOTS_ILO_ROLL'] = 'balanceo';
Blockly.Msg['ROBOTS_ILO_YAW'] = 'guiñada';
Blockly.Msg['ROBOTS_ILO_SET_ACC_TITLE'] = '[Ilo] ajustar la aceleración a %1';
Blockly.Msg['ROBOTS_ILO_SET_ACC_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Ajusta la aceleración del robot Ilo.';
Blockly.Msg['ROBOTS_ILO_SET_TEMPO_TITLE'] = '[Ilo] demora entre movimientos %1 (ms)';
Blockly.Msg['ROBOTS_ILO_SET_TEMPO_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Ajusta la demora entre los movimientos del robot Ilo.';
Blockly.Msg['ROBOTS_ILO_GET_LUMINOSITY_TITLE'] = '[Ilo] nivel de luz bajo el sensor %1';
Blockly.Msg['ROBOTS_ILO_GET_LUMINOSITY_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Devuelve el nivel de luz medido por el sensor de luz del robot Ilo.';
Blockly.Msg['ROBOTS_ILO_LINE_DETECTOR_ALL'] = 'todos';
Blockly.Msg['ROBOTS_ILO_FINISH_STATE'] = '¿esperar al final del movimiento?';
Blockly.Msg['ROBOTS_ILO_FINISH_STATE_YES'] = 'sí';
Blockly.Msg['ROBOTS_ILO_FINISH_STATE_NO'] = 'no';

Blockly.Msg['SENSORS_PRESSURE'] = 'presión';
Blockly.Msg['SENSORS_ALTITUDE'] = 'altitud';
Blockly.Msg['IO_GETMAGNETICSWITCH_TITLE'] = '[Módulo interruptor magnético] estado en el pin %1';
Blockly.Msg['IO_GETMAGNETICSWITCH_TOOLTIP'] = IMG_MODULE_MAGNETIC_SWITCH + Blockly.Tooltip.SEP + 'Devuelve el valor del interruptor magnético Grove (0 o 1) en los pines digitales.';
Blockly.Msg['SENSORS_SHT35_READDATA_TITLE'] = '[Sensor SHT35] %1';
Blockly.Msg['SENSORS_SHT35_READDATA_TOOLTIP'] = IMG_MODULE_SHT35 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), o la humedad (en %) usando el sensor SHT35. Conectar el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_BAROMETER_READDATA_TITLE'] = '[Barómetro] %1';
Blockly.Msg['SENSORS_BAROMETER_READDATA_TOOLTIP'] = IMG_MODULE_SHT35 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (°C), Fahrenheit (°F) o Kelvin (K), la presión (en hPa) o la altitud (en m) usando el barómetro. Conectar el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_FSR402_GETFORCE_TITLE'] = '[Sensor de fuerza] valor en el pin %1';
Blockly.Msg['SENSORS_FSR402_GETFORCE_TOOLTIP'] = IMG_MODULE_FORCE + Blockly.Tooltip.SEP + 'Devuelve la fuerza aplicada en el sensor redondo usando el sensor FSR402 en los pines analógicos.';
Blockly.Msg['SENSORS_EMG_DETECTOR_TITLE'] = '[Detector EMG] valor en el pin %1';
Blockly.Msg['SENSORS_EMG_DETECTOR_TOOLTIP'] = IMG_MODULE_EMG_DETECTOR + Blockly.Tooltip.SEP + 'Mide las corrientes eléctricas que acompañan la actividad muscular en los pines analógicos.';
Blockly.Msg['SENSORS_GET_DISSOLVED_OXYGEN_PROBE_TITLE'] = '[Sonda de oxígeno disuelto] valor en el pin %1';
Blockly.Msg['SENSORS_GET_DISSOLVED_OXYGEN_PROBE_TOOLTIP'] = 'Mide el oxígeno disuelto en el agua en los pines analógicos.';
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TITLE'] = '[Electroimán] controlar a estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TOOLTIP'] = IMG_MODULE_ELECTROMAGNET + Blockly.Tooltip.SEP + 'Permite activar o desactivar el electroimán (ALTO o BAJO) en los pines digitales.';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TITLE'] = '[Atomizador de agua] controlar a estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TOOLTIP'] = IMG_MODULE_WATER_ATOMIZER + Blockly.Tooltip.SEP + 'Permite activar o desactivar el atomizador de agua (ALTO o BAJO) en los pines digitales.';