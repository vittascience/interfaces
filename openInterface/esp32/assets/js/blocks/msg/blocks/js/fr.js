/**
 * @fileoverview English messages for ESP32. (EN)
 */

'use strict';

// Display - Esp32
Blockly.Msg['DISPLAY_CONTROL_BUILTIN_LED_TITLE'] = '[Esp32] contrôler la LED intégrée (p2) à l\'état %1';
Blockly.Msg['DISPLAY_CONTROL_BUILTIN_LED_TOOLTIP'] = 'Permet de contrôler l\'état de la LED connectée à la broche p2 sur la carte Esp32.';
// Display - Screen
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD] afficher le texte %1 sur la ligne %2 position %3';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Affiche du texte sur l\'une des deux lignes de l\'écran LCD1602 grove. Brancher le module sur un port I2C';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD] nettoyer l\'écran';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_3V3 + Blockly.Tooltip.SEP + 'Permet d\'effacer tous les caractères de l\'écran LCD. Brancher le module sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[OLED] afficher le texte %1 à la position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'écrire du texte sur un écran OLED de taille 128x64. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TITLE'] = '[OLED] contrôler le pixel x %1 y %2 état %3';
Blockly.Msg['DISPLAY_OLED_SETPIXEL_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de contrôler chaque pixel de l\'écran OLED de taille 128x64. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TITLE'] = '[OLED] dessiner une ligne de (%1, %2) à (%3, %4)';
Blockly.Msg['DISPLAY_OLED_DRAWLINE_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de dessiner une ligne entre deux points de l\'écran OLED de taille 128x64. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TITLE'] = '[OLED] définir le fond en %1';
Blockly.Msg['DISPLAY_OLED_WHITE'] = 'blanc';
Blockly.Msg['DISPLAY_OLED_BLACK'] = 'noir';
Blockly.Msg['DISPLAY_OLED_SETBACKGROUND_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'inverser le rétroélcairage de l\'écran. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[OLED] effacer l\'écran';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'effacer le contenu de l\'écran OLED. Brancher l\'écran sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[OLED] afficher l\'icône %1 position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'afficher une icône de la librairie Image de ESP32, à la position (x,y) sur l\'écran grove OLED. Brancher l\'afficheur sur un port I2C.';
// Display - Neopixel
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] définir %1 LED sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de définir le nombre de LED du neopixel. Ce bloc doit être utilisé dans le bloc \'Au démarrage\'.';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] contrôler la LED %1 à R %2 G %3 B %4 sur la broche %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED tel que (R,G,B) de 0 à 255 du module neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] contrôler la LED %1 à %2 sur la broche %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du module neopixel. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] contrôler toutes les LED à R %1 G %2 B %3 sur la broche %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie telle que (R,G,B) soit de 0 à 255.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] contrôler toutes les LED à %1 sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] Arc-en-ciel sur la broche %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB. Il est possible de modifier la broche et le nombre de LED du module neopixel.';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] contrôler la LED %1 sur la broche  %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Permet d\'activer ou désactiver la LED Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] régler la luminosité à %1 (%) sur la broche %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 100% sur les broches PWM.';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[Variable Color LED] régler la luminosité à %1 (%) sur la broche %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 100 % sur les broches PWM. A la premièe utilisation, les valeurs RGB sont fixées à 0. Utiliser un tournevis pour régler les couleurs R, G et B derrière le module.';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[Afficheur 4-digit] afficher %1 %2 sur les broches CLK %3 DIO %4';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher un nombre, une température ou l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales.';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[Afficheur 4-digit] l\'horloge sur les broches CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales. Attention, l\'heure réelle est récupérée seulement la carte microbit reste allumée.';
Blockly.Msg['DISPLAY_4DIGIT_NUMBER'] = 'le nombre entier';
Blockly.Msg['DISPLAY_4DIGIT_TEMPERATURE'] = 'la température';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[Module LED Bar] afficher le niveau de %1 sur les broches DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permet d\'afficher le niveau de la valeur en entrée sur le module LED Bar (MY9221) avec les broches digitales.';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TITLE'] = '[Module LED Bar] inverser l\'afficheur %1 les broches DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_REVERSE_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permet d\'inverser les 10 LED du module LED Bar (MY9221) avec les broches digitales.';
// Display - Chainable LED
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TITLE'] = '[Chainable LED] definir %1 LED sur les broches CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Permet de paramétrer la chaîne de LED RGB en définissant le nombre de modules en série sur les broches digitales D0 à D13.';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TITLE'] = '[Chainable LED] contrôler la LED %1 à R %2 G %3 B %4 sur les broches CIN %5 DIN %6';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la DEL RGB, donner une valeur entre 0 et 255 pour Rouge, Vert et Bleu.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TITLE'] = '[Chainable LED] contrôler la LED %1 à %2 sur les broches CIN %3 DIN %4';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la DEL RGB, choisir une couleur dans la palette.';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TITLE'] = '[Chainable LED] contrôler toutes les LED à R %1 G %2 B %3 sur les broches CIN %4 DIN %5';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur des DEL RGB, donner une valeur entre 0 et 255 pour Rouge, Vert et Bleu.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE'] = '[Chainable LED] contrôler toutes les LED à %1 sur les broches CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur des DEL RGB, choisir une couleur dans la palette.';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TITLE'] = '[Chainable LED] éteindre sur les broches CIN %1 DIN %2';
Blockly.Msg['DISPLAY_CHAINABLE_RESETALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc éteignant toutes les DEL RGB.';

// Input/Output - Esp32
Blockly.Msg['IO_WAIT_TITLE'] = 'attendre %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Effectue une pause dans l\'exécution du code.';
Blockly.Msg['IO_WAIT_SECOND'] = 'seconde(s)';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milliseconde(s)';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microseconde(s)';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'attendre jusqu\'à %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Arrête l\'excution du code jusqu\'à ce que la condition soit satisfaite.';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'démarrer le chronomètre';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Initialise un chronomètre à 0 (en secondes).';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'valeur du chronomètre en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Renvoie la valeur du chronomètre à partir de l\'initialisation (en secondes ou millisecondes).';
// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Clavier numérique] chiffre sur les broches RX %1 TX %2';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Permet d\'obtenir la touche appuyée du clavier numérique grove sur les broches TX et RX. Quand vous connectez le module, s\'assurer que les broches sont \'croisées\' : RX de la carte avec TX du module et inversement.';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Module joytsick] valeur de l\'axe %1 sur les broches X %2 Y %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'axe X ou Y (de 0 à 1023) du joystick Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TITLE'] = '[Module bouton coloré] état sur la broche SIG2 %1 ';
Blockly.Msg['IO_GROVECOLOREDBUTTON_GET_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Renvoie l\'état du bouton coloré grove (0 or 1) sur les broches digitales.';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TITLE'] = '[Module bouton coloré] contrôler la LED à l\'état %1 sur la broche SIG1 %2';
Blockly.Msg['IO_GROVECOLOREDBUTTON_SETLED_TOOLTIP'] = IMG_MODULE_LED_BUTTON + Blockly.Tooltip.SEP + 'Permet d\'allumer ou éteindre la LED (0 or 1) sur les broches digitales.';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Potentiomètre rotatif] valeur sur la broche %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Renvoie l\'angle (de 0 à 1023) du potentiomètre rotatif Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Potentiomètre linéaire] valeur sur la broche %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Renvoie la position (de 0 à 1023) du potentiomètre linéaire Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Capteur tactile] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur tactile Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Module bouton] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Renvoie la valeur du bouton Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Module interrupteur] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'interrupteur Grove (0 ou 1) sur les broches digitales.';
Blockly.Msg['IO_GETMAGNETICSWITCH_TITLE'] = '[Module interrupteur mag.] état sur la broche %1 ';
Blockly.Msg['IO_GETMAGNETICSWITCH_TOOLTIP'] = IMG_MODULE_MAGNETIC_SWITCH + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'interrupteur magnétique Grove (0 ou 1) sur les broches digitales.';
// Input/Output - Pins
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'HAUT (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAS (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Retourne une valeur booléenne (1 si HAUT ou 0 si BAS).';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'état de la broche numérique %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée digitale (0 ou 1).';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'écrire l\'état %1 sur la broche numérique %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Permet d\'écrire une valeur sur une entrée digitale (0 ou 1).';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'lire la broche analogique %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée analogique (0-1023), ce qui correspond à une tensio entre 0 et 3.6V.';
Blockly.Msg['IO_WRITEPWMPIN_TITLE'] = 'écrire la valeur %1 sur la broche PWM %2';
Blockly.Msg['IO_WRITEPWMPIN_TOOLTIP'] = 'Permet d\'appliquer un signal PWM avec une fréquence fixée à 10kH et en changeant le cycle de 0 à 1023. La valeur 512 correspondra à 50% du cycle, donc environ 1.66V.';
Blockly.Msg['IO_WRITEANALOGPIN_TITLE'] = 'écrire la valeur %1 sur la broche analogique %2 (DAC)';
Blockly.Msg['IO_WRITEANALOGPIN_TOOLTIP'] = 'Permet d\'appliquer une tension analogique sur les broches DAC p25 et p26 (de 0 à 255). L\'Esp32 utilise un convertisseur Numérique-Analogique (DAC) pour appliquer une tension comprise entre 0 et 3.3V.';
Blockly.Msg['IO_SETPWM_TITLE'] = 'appliquer un signal carré de fréquence %1 (Hz) sur la broche %2';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Permet d\'appliquer un signal carré (PWM) avec un cycle fixé à 50% sur une broche. Ce bloc permet de changer la fréquence du signal.';
Blockly.Msg['IO_STOPPWM_TITLE'] = 'arrêter le signal PWM de la broche %1';
Blockly.Msg['IO_STOPPWM_TOOLTIP'] = 'Permet d\'arrêter le signal PWM appliqué sur une broche.';
Blockly.Msg['IO_GETVOLTAGE_TITLE'] = 'convertir %1 sur %2 en tension';
Blockly.Msg['IO_GETVOLTAGE_TOOLTIP'] = 'Permet de convertir une valeur analogique en tension en choisissant la résolution (10-bit: 1024, 12-bit: 4096, 9-bit: 512, 11-bit: 2048) et un maximum de 3.6V.';

// Communication - Internal Bluetooth
Blockly.Msg['COMMUNICATION_START_BT_TITLE'] = '[ESP32 Bluetooth UART] initialiser le bluetooth %1';
Blockly.Msg['COMMUNICATION_START_BT_TOOLTIP'] = 'Permet d\'intialiser le service Bluetooth de l\'ESP32 avec un nom attribué.';
Blockly.Msg['COMMUNICATION_SEND_BT_TITLE'] = '[ESP32 Bluetooth UART] envoyer donnée %1';
Blockly.Msg['COMMUNICATION_SEND_BT_TOOLTIP'] = 'Permet d\'envoyer des données via le Bluetooth de l\'ESP32.';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TITLE'] = '[Bluetooth] si message reçu dans %1 alors';
Blockly.Msg['COMMUNICATION_BLE_READ_DATA_TOOLTIP'] = 'Permet d\'exécuter des instructions si une donnée est reçue par Bluetooth (BLE).';
Blockly.Msg['COMMUNICATION_BLE_APP_INVENTOR_READ_DATA_TITLE'] = '[Bluetooth App Inventor] si message reçu dans %1 alors';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TITLE'] = '[Bluetooth Fizziq App] envoyer %1 %2';
Blockly.Msg['COMMUNICATION_FIZZIQ_BT_TOOLTIP'] = IMG_MODULE_FIZZIQ + Blockly.Tooltip.SEP + 'Envoyer des données (Température, Humidité, etc) via Bluetooth à Fizziq App.';
Blockly.Msg['FIZZ_TEMP'] = 'Température';
Blockly.Msg['FIZZ_HUM'] = 'Humidité';
Blockly.Msg['FIZZ_VOLTAGE'] = 'Tension';
Blockly.Msg['FIZZ_WEIGHT'] = 'Poids';
Blockly.Msg['FIZZ_PRESSURE'] = 'Pression';
Blockly.Msg['FIZZ_CONCENTRATION'] = 'Concentration';
Blockly.Msg['FIZZ_MAGNETIC'] = 'Champ magnétique';
Blockly.Msg['FIZZ_BRIGHTNESS'] = 'Luminosité';
Blockly.Msg['FIZZ_ACCELERATION'] = 'Accélération';
Blockly.Msg['FIZZ_COMPASS'] = 'Boussole';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'écrire dans la console %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Permet d\'écrire des données dans le port série.';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'avec';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'saut(s) de ligne';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE then'] = 'on serial data received in %1 then';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si une donnée est reçue par le port série dans la variable \'serialData\'.';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'jouer la note %1 sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Joue la note selectionnée jusqu\'à l\'exécution du bloc "Fin de la note".';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'jouer la fréquence %1 (Hz) sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Ce bloc permet de jouer une fréquence donnée sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'terminer la note sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Arrête la note en cours.';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'tracer le graphe';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Ce bloc permet d\'écrire des données (numériques) qui seront visibles dans le traceur. Il peut être utilisé avec un ou plusieurs blocs au format "Nom" et "Données". Pour visualiser les graphiques, cliquer sur l\'icone \'Mode Graphique\' dans la console.';
Blockly.Msg['COMMUNICATION_DATA'] = 'Donnée';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nom %1 Valeur %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Ce bloc est à utiliser avec le bloc "Tracer le graphique". Il doit lui-même contenir le nom de la valeur à afficher (texte), et la valeur en question (nombre).';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] écrire dans la carte SD %1 baudrate %2 sur les broches RXI %3 TXO %4 %5 Données %6';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'Permet d\'écrire des données dans la carte micro SD avec le module Openlog. Fonctionnement en transmission UART.';
Blockly.Msg['COMMUNICATION_ESP32_FS_SAVE_DATA_TITLE'] = '[ESP32] enregistrer les données %1 dans le fichier %2';
Blockly.Msg['COMMUNICATION_ESP32_FS_SAVE_DATA_TOOLTIP'] = 'Permet d\'enregistrer des données dans un fichier texte dans le système de fichier de l\'ESP32. Si vous utilisez le même nom de fichier, les données seront ajoutées à la fin du fichier. Vous pouvez également appuyer sur le bouton + pour modifier l\'extension du fichier.';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] envoyer sur les broches RX %1 TX %2 message %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permet d\'envoyer des données via le module BLuetooth HC05 sur les broches RX/TX.';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] si message reçu sur les broches RX %1 TX %2 dans %3 alors';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HC05 + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par un module Bluetooth HC05 dans la variable \'bluetoothData\' sur les broches RX/TX.';
// Communication - Infrared
Blockly.Msg['COMMUNICATION_INFRARED_ONDATARECEIVED_TITLE'] = '[IR] si %1 est reçu dans %2 %3broche %4 avec le protocol %5 alors';
Blockly.Msg['COMMUNICATION_INFRARED_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par un module infrarouge dans une variable sur la broche digitale avec un protocol NEC_8 ou NEC_16.';
// Communication - Tracking modules
Blockly.Msg['COMMUNICATION_GPS_INFO_TYPE'] = 'le type de la trame';
Blockly.Msg['COMMUNICATION_GPS_INFO_CLOCK'] = 'l\'heure (h, m, s)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LATITUDE'] = 'la latitude (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_LONGITUDE'] = 'la longitude (°)';
Blockly.Msg['COMMUNICATION_GPS_INFO_SATELLITE'] = 'le nombre de satellites utilisés';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALTITUDE'] = 'l\'altitude (m)';
Blockly.Msg['COMMUNICATION_GPS_INFO_ALL_FRAME'] = 'toute la trame';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TITLE'] = '[GPS] trames NMEA sur les broches RX %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GET_NMEA_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Renvoie la liste des trames NMEA lues avec le module GPS Grove SIM28 ou Air530 sur les broches RX/TX. Les fils n\'ont pas besoin d\'être inversée entre les broches du module et celles indiquées dans le bloc. L\'inversion se fait automatiquement dans le code python.\nAttention: Si vous utilisez la console pour afficher les données du GPS, connecter votre carte à l\'interface avant d\'envoyer le programme en cliquant sur le bouton [>_ REPL]. Ensuite, transférer votre programme en utilisant le bouton [Télécharger .hex].';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TITLE'] = '[GPS] obtenir %3 sur les broches RX %1 TX %2';
Blockly.Msg['COMMUNICATION_GPS_GGA_GETINFORMATIONS_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Renvoie la donnée sélectionnée parmi (le type de trame, l\'horloge, la latitude, la longitude, l\'altitude) annalysée de la trame NMEA (GNGGA ou GPGGA) lue avec le module GPS Grove SIM28 ou Air530 sur les broches RX/TX. Les fils n\'ont pas besoin d\'être inversée entre les broches du module et celles indiquées dans le bloc. L\'inversion se fait automatiquement dans le code python.\nAttention: Si vous utilisez la console pour afficher les données du GPS, connecter votre carte à l\'interface avant d\'envoyer le programme en cliquant sur le bouton [>_ REPL]. Ensuite, transférer votre programme en utilisant le bouton [Télécharger .hex].';
Blockly.Msg['COMMUNICATION_RTC_MODULE_PCF85063TP'] = 'Haute Précision (0x51)';
Blockly.Msg['COMMUNICATION_RTC_MODULE_DS1307'] = 'v1.2 (0x68)';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TITLE'] = '[Horloge RTC %1] initialiser à %2 date %3';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet d\'initialiser le module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307), pour pouvoir lire la date et l\'heure précise avec le bloc \'Lire le module horloge\'. Placer dans le bloc \'Au démarrage\'. Brancher le module RTC sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['DAY_MONDAY'] = 'lundi';
Blockly.Msg['DAY_TUESDAY'] = 'mardi';
Blockly.Msg['DAY_WEDNESDAY'] = 'mercredi';
Blockly.Msg['DAY_THURSDAY'] = 'jeudi';
Blockly.Msg['DAY_FRIDAY'] = 'vendredi';
Blockly.Msg['DAY_SATURDAY'] = 'samedi';
Blockly.Msg['DAY_SUNDAY'] = 'dimanche';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TITLE'] = '[Horloge RTC %1] initialiser à heure %2 minute %3 seconde %4';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet d\'initialiser le module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307), pour pouvoir lire la date et l\'heure précise avec le bloc \'Lire le module horloge\'. Placer dans le bloc \'Au démarrage\'. Brancher le module sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TITLE'] = '[Horloge RTC %1] lire %2';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet de lire la date et l\'heure du module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307). Pour avoir un résultat correct, utiliser au préalable les deux blocs \'Initialiser le module horloge\'. Brancher le module sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['CLOCK_ALL_DATA'] = 'l\'horloge';
Blockly.Msg['CLOCK_YEAR'] = 'année';
Blockly.Msg['CLOCK_MONTH'] = 'mois';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'jour du mois';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'jour de la semaine';
Blockly.Msg['CLOCK_HOUR'] = 'heure';
Blockly.Msg['CLOCK_MINUTE'] = 'minute';
Blockly.Msg['CLOCK_SECOND'] = 'seconde';
// Communication - UART
Blockly.Msg['COMMUNICATION_UART_INIT_TITLE'] = '[uart %1] définir la connexion série sur RX %2 TX %3 Baudrate %4';
Blockly.Msg['COMMUNICATION_UART_INIT_TOOLTIP'] = 'Permet de définir la connexion série de la carte ESP32 sur le port UART (1 ou 2). Le port 0 est réservé au REPL.';
Blockly.Msg['COMMUNICATION_UART_WRITE_TITLE'] = '[uart %1] écrire la donnée %2';
Blockly.Msg['COMMUNICATION_UART_WRITE_TOOLTIP'] = 'Permet d\'écrire des données dans le port UART (1 ou 2). Par défaut, les broches sont telles que: UART 1 (tx=10, rx=9) et UART 2 (tx=17, rx=16). Sinon, utilisez le bloc \'Définir la connexion série sur RX TX Baudrate ...\'.';
Blockly.Msg['COMMUNICATION_UART_READ_TITLE'] = '[uart %1] lire les données';
Blockly.Msg['COMMUNICATION_UART_READ_TOOLTIP'] = 'Permet de lire des données depuis le port UART (1 ou 2). Par défaut, les broches sont telles que: UART 1 (tx=10, rx=9) et UART 2 (tx=17, rx=16). Sinon, utilisez le bloc \'Définir la connexion série sur RX TX Baudrate ...\'.';
Blockly.Msg['COMMUNICATION_UART_READ_SIZE'] = 'taille des données';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TITLE'] = '[uart %1] données disponibles';
Blockly.Msg['COMMUNICATION_UART_DATA_AVAILABLE_TOOLTIP'] = 'Retourne la taille des données disponibles sur le port UART (1 ou 2). Par défaut, les broches sont telles que: UART 1 (tx=10, rx=9) et UART 2 (tx=17, rx=16). Sinon, utilisez le bloc \'Définir la connexion série sur RX TX Baudrate ...\'.';

// Sensors - ESP32
Blockly.Msg['SENSORS_PRESSURE'] = 'pression';
Blockly.Msg['SENSORS_ALTITUDE'] = 'altitude';
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TITLE'] = 'lire le capteur à effet Hall';
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TOOLTIP'] = 'Renvoie la valeur du capteur à effet Hall de la carte.';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TITLE'] = 'température du processeur en %1';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TOOLTIP'] = 'Retourne la température du processeur.';
// ESP32-CAM
Blockly.Msg['ESP32_CAM_GET_CAPTURED_DATA_TITLE'] = '[ESP32-CAM] prendre une photo, type des données %1';
Blockly.Msg['ESP32_CAM_GET_CAPTURED_DATA_TOOLTIP'] = IMG_ESP32_CAM + Blockly.Tooltip.SEP + 'Permet de prendre une photo avec la caméra du module ESP32-CAM. Retourne les données hexadécimales ou les données en base64 (nécessaire dans une page web par exemple).';
Blockly.Msg['ESP32_CAM_SET_IMAGE_SIZE_TITLE'] = '[ESP32-CAM] configurer la taille %1';
Blockly.Msg['ESP32_CAM_SET_IMAGE_SIZE_TOOLTIP'] = IMG_ESP32_CAM + Blockly.Tooltip.SEP + 'Permet de configurer la taille des captures faites par l`\'ESP32-CAM. Ce bloc doit être utilisé dans l\'instruction \'Au démarrage\'.';
Blockly.Msg['ESP32_CAM_CONTROL_FLASH_LED_TITLE'] = '[ESP32-CAM] contrôler le flash intégré à l\'état %1';
Blockly.Msg['ESP32_CAM_CONTROL_FLASH_LED_TOOLTIP'] = IMG_ESP32_CAM + Blockly.Tooltip.SEP + 'Permet de contrôler le flash LED connecté à la broche p4 de l\'ESP32-CAM. Il permet d\'éclairer la scène que vous souhaitez et ainsi obtenir des photos de meilleure qualité.';
Blockly.Msg['ESP32_CAM_SDCARD_SAVE_PIC_TITLE'] = '[ESP32-CAM] enregistrer la photo %1 type des données %2';
Blockly.Msg['ESP32_CAM_SDCARD_SAVE_PIC_TOOLTIP'] = IMG_ESP32_CAM + Blockly.Tooltip.SEP + 'Permet d\'enregistrer une photo dans la carte SD de l\'ESP32-CAM au format .jpg.';
Blockly.Msg['ESP32_CAM_SDCARD_SAVE_DATA_TITLE'] = '[ESP32-CAM] enregistrer les données %1 dans le fichier %2';
Blockly.Msg['ESP32_CAM_SDCARD_SAVE_DATA_TOOLTIP'] = IMG_ESP32_CAM + Blockly.Tooltip.SEP + 'Permet d\'enregistrer des données dans un fichier texte dans la carte SD de l\'ESP32-CAM. Si vous utilisez le même nom de fichier, les données seront ajoutées à la fin du fichier.';
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[Capteur SGP30] gaz %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Renvoie la quantité de CO2 (en ppm) ou de TVOC (en ppb) contenu dans l\'air grâce au capteur SGP30. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'Dioxyde de carbone (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'Composés organiques volatiles (TVOC) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Capteur de gaz multicanal] gaz %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Renvoie la quantité du gaz mesuré dans l\'air (en ppm) grâce au capteur de gaz multicanal. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Capteur de gaz multicanal v2] gaz %1 (V)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Renvoie la quantité du gaz mesuré dans l\'air (en V) grâce au capteur de gaz multicanal V2 grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['GAS_CO'] = 'Monoxyde de carbone (CO)';
Blockly.Msg['GAS_NO2'] = 'Dioxyde d\'azote (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'Ethanol (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'Dihydrogène (H2)';
Blockly.Msg['GAS_NH3'] = 'Ammoniac (NH3)';
Blockly.Msg['GAS_CH4'] = 'Méthane (CH4)';
Blockly.Msg['GAS_C3H8'] = 'Propane (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'Iso-propane (C4H10)';
Blockly.Msg['GAS_VOC'] = 'Composés organiques volatiles (COV)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Capteur de dioxygène] O2 (%) sur la broche %1';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Renvoie la concentration de dioxygène (O2) dans l\'air (en %) grâce au capteur de gas O2 grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove)..';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[Capteur SCD30] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Renvoie la concentration de CO2 dans l\'air (en ppm), l\'humidité (en %) ou la température en Celsius (°C), Fahrenheit (°F) ou Kelvin (K) from the grove SCD30 sensor. Bancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'dioxyde de carbone (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = 'température';
Blockly.Msg['SENSORS_SCD30_HUM'] = 'humidité (%)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[Capteur SCD30] forcer la recalibration à %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Forcer la calibration du capteur SCD30 à la valeur donnée (in ppm). Se placer en extérieur (là où la concentration est autour de 420 ppm environ, soit un air pur), redémarrer la carte, puis attendre 2 minutes. Conseil: Utiliser les boutons SW1, SW2 ou SW3 de la carte STM32 NUCLEO pour contrôler le lancement de la calibration. Sinon, en rebranchant la carte, le programme se lance et effectue de nouveau une calibration pas forcément souhaitée.';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Capteur de qualité d\'air] valeur sur la broche %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Renvoie la valeur de la qualité de l\'air (de 0 à 1023) sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[Capteur HM330X] concentration de particules fines %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Détecte la densité de particules dans l\'air avec le capteur HM330X. Bancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
// Sensors - Climate
Blockly.Msg['SENSORS_TEMPERATURE'] = 'température';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humidité (%)';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'en';
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[Capteur BMP280 %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), la pression (en Pascal) ou l\'altitude (en m). L\'altitude est calculée avec la pression et est initialisée à 0 au début du programme. Le bloc a besoin du capteur Grove BMP280 (adresse I2C: 0x77, couleur: bleu) ou le capteur HW-611 280 (adresse I2C: 0x76, couleur: violet). Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_BMP280_TEMP'] = 'température';
Blockly.Msg['SENSORS_BMP280_PRESS'] = 'pression (Pa)';
Blockly.Msg['SENSORS_BMP280_ALT'] = 'l\'altitude (m)';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = '[Capteur H.T°] température en %1 sur les broches A0 %2 A1 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température du thermocouple en degré Celsius (50 à 600 °C), Fahrenheit (°F) ou Kelvin (K) grâce au capteur grove de haute température sur .';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Capteur d\'humidité] humidité du sol sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Renvoie l\'humidité (de 0 à 1023) mesurée grâce au capteur d\'humidité grove sur les broches analogiques IO34, IO35, IO36 et IO39.';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Capteur de T°] température en %1 sur la broche %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) du capteur de température Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TITLE'] = '[Capteur DS18B20] température en %1 sur la broche %2';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) du capteur de température étanche DS18B20 sur les broches digitales.';
Blockly.Msg['SENSORS_DHT11_READDATA_TITLE'] = '[Capteur DHT11] %1 sur la broche %2';
Blockly.Msg['SENSORS_DHT11_READDATA_TOOLTIP'] = IMG_MODULE_DHT11 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur dht11 grove sur les broches digitales.';
Blockly.Msg['SENSORS_DHT22_READDATA_TITLE'] = '[Capteur DHT22] %1 sur la broche %2';
Blockly.Msg['SENSORS_DHT22_READDATA_TOOLTIP'] = IMG_MODULE_DHT22 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) avec une grande précision grâce au capteur dht22 grove sur les broches digitales.';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[Capteur TH02] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur TH02. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Capteur SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur SHT31. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SHT35_READDATA_TITLE'] = '[Capteur SHT35] %1';
Blockly.Msg['SENSORS_SHT35_READDATA_TOOLTIP'] = IMG_MODULE_SHT35 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur SHT35. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Capteur d\'eau] quantité d\'eau sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Renvoie la quantité d\'eau (de 0 à 255) mesurée grâce au capteur d\'eau grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Capteur de pluie] état sur la broche %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Renvoie l\'état du capteur de pluie (1 s\'il pleut ou 0 sinon) sur les broches digitales.';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anémomètre] état sur la broche %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Renvoie l\'état de l\'anémomètre (deux fois état HAUT à chaque rotation) sur les broches digitales.';
Blockly.Msg['SENSORS_BAROMETER_READDATA_TITLE'] = '[Baromètre] %1';
Blockly.Msg['SENSORS_BAROMETER_READDATA_TOOLTIP'] = IMG_MODULE_SHT35 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), la pression (en hPa) ou l\'altitude (en m) grâce au baromètre. Brancher le capteur sur un port I2C.';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Capteur de lumière] luminosité sur la broche %1';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Renvoie la luminosité (de 0 à 1023) du capteur de lumière Grove sur les broches analogiques IO34, IO35, IO36 et IO39.';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[Capteur SI1145] luminosité %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Renvoie l\'indice de lumière ultraviolette, la luminosité visible (en lumen) ou infrarouge (en lumen) grâce au capteur Grove Sunlight ou le capteur GY1145. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SI1145_UV'] = 'indice UV';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visible (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrarouge (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Capteur ultraviolet] indice UV sur la broche %1';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Renvoie l\'indice de la lumière ultraviolette pour des ondes entre 240 et 380 nm du capteur Grove sur les broches analogiques p34 à p36, ou p39 (A2 à A4 sur shield Grove).';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Capteur de couleurs] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Permet de lire le niveau d\'une des trois couleurs primaires avec le capteur de couleur grove, le niveau est compris entre 0 et 255. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Capteur de son] niveau sonore sur la broche %1';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Renvoie le niveau sonore (0 à 1023) avec le capteur de son Grove sur les broches digitales.';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Capteur à ultrasons %1] %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Renvoie la distance (in cm) mesurée grâce au capteur grove à ultrasons sur les broches digitales. Attention, si le capteur est un modèle grove, TRIG et ECHO sont sur la même broche SIG.';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distance (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'durée de l\'aller-retour (µs)';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = '[Capteur de gestes] type de geste';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Renvoie le type de geste analysé (\'right\', \'left\', \'up\', \'down\', \'forward\', \'backward\', \'clockwise\', \'anticlockwise\') grâce au capteur de gestes grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Capteur de gestes] si le geste %1 est détecté';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Exécute des instructions si le geste selectionné est détecté par le capteur de gestes grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'droit';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'gauche';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'haut';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'bas';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'avant';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'arrière';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'horaire';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'antihoraire';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'onde';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Capteur de ligne noire] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur de ligne noire grove (0 ou 1) les broches digitales.';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[Capteur de mouvement] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur de mouvement Grove PIR Motion (0 ou 1) les broches digitales.';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Capteur de vibrations] état sur la broche %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Renvoie l\'état de la vibration (0 ou 1) grâce au capteur de vibration piezoélectrique les broches digitales.';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Module inclinaison] état sur la broche %1';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'inclinaison du module Grove (0 ou 1) les broches digitales.';
Blockly.Msg['SENSORS_GY521_GETDATA_TITLE'] = '[Capteur de mouvements GY-521] %1';
Blockly.Msg['SENSORS_GY521_GETDATA_TOOLTIP'] = 'Renvoie la valeur de l\'accélération, la vitesse angulaire ou la température grâce au capteur GY-521 branché sur le port I2C.';
Blockly.Msg['SENSORS_GY521_ACC'] = 'accélération';
Blockly.Msg['SENSORS_GY521_GYR'] = 'gyroscope';
Blockly.Msg['SENSORS_GY521_TEMP'] = 'température';
Blockly.Msg['SENSORS_GY521_AXIS'] = 'axe';
// Other sensors
Blockly.Msg['SENSORS_GETGROVEBUTTON_TITLE'] = '[Module bouton] %1 sur la broche %2';
Blockly.Msg['SENSORS_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Renvoie la valeur numérique du bouton Grove (0/1 ou 0V/3.3V) les broches digitales.';
Blockly.Msg['SENSORS_GETGROVEBUTTON_VOLTAGE'] = 'tension';
Blockly.Msg['SENSORS_GETGROVEBUTTON_STATE'] = 'état';
Blockly.Msg['SENSORS_FSR402_GETFORCE_TITLE'] = '[Détecteur de force] valeur sur la broche %1';
Blockly.Msg['SENSORS_FSR402_GETFORCE_TOOLTIP'] = IMG_MODULE_FORCE + Blockly.Tooltip.SEP + 'Renvoie la force exercée sur le détecteur rond grâce au capteur FSR402 sur les broches analogiques.';
Blockly.Msg['SENSORS_EMG_DETECTOR_TITLE'] = '[Détecteur EMG] valeur sur la broche %1';
Blockly.Msg['SENSORS_EMG_DETECTOR_TOOLTIP'] = IMG_MODULE_EMG_DETECTOR + Blockly.Tooltip.SEP + 'Mesure les courants électriques qui accompagnent l\'activité musculaire sur les broches analogiques.';
Blockly.Msg['SENSORS_GET_DISSOLVED_OXYGEN_PROBE_TITLE'] = '[Sonde oxygène dissous] valeur sur la broche %1';
Blockly.Msg['SENSORS_GET_DISSOLVED_OXYGEN_PROBE_TOOLTIP'] = 'Mesure l\'oxygène dissous dans l\'eau sur les broches analogiques.';
Blockly.Msg['SENSORS_GET_WATER_LEVEL_TITLE'] = '[Niveau d\'eau] valeur';
Blockly.Msg['SENSORS_GET_WATER_LEVEL_TOOLTIP'] = 'Mesure le niveau d\'eau en pourcentage (de 0 à 100%) sur le port I2C.';
Blockly.Msg['SENSORS_VOLTAGE_DIVIDER_GETDATA_TITLE'] = '[Diviseur de tension] diviser la tension par %1 sur la broche %2';
Blockly.Msg['SENSORS_VOLTAGE_DIVIDER_GETDATA_TOOLTIP'] = IMG_MODULE_VOLTAGE_DIVDER + Blockly.Tooltip.SEP + 'Retourne la valeur de la tension sur les broches analogiques. Le sélecteur permet d\'indiquer la plage de mesure : 3 pour une tension entre 0,3V et 12,9V, 10 pour une tension entre 1V et 43V.';
// Actuators
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servomoteur] contrôler l\'angle à %1 sur la broche %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler l\'angle d\'un servomoteur (de 0 à 180) sur les broches digitales. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au servomoteur.';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Servomoteur continu] contrôler la vitesse à %1 (%) direction %2 sur la broche %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler la vitesse (de 0 à 100 %) d\'un servomoteur continu sur les broches PWM.';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TITLE'] = '[Moteur] contrôler la puissance à %1 sur la broche %2';
Blockly.Msg['ACTUATORS_MOTOR_SETPOWER_TOOLTIP'] = IMG_MODULE_MOTOR + Blockly.Tooltip.SEP + 'Permet de contrôler la puissance d\'un moteur (de 0 à 1023) sur les broches digitales. Attention, le montage doit être alimenté par une batterie pour fournir assez de courant au moteur.';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Module relais] contrôler le relais à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Permet de contrôler la valeur du relais (0 ou 1) sur les broches digitales.';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Moteur à vibration] contrôler le moteur à l\'état %1 sur la broche  %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver le moteur à vibration grove (0 ou 1) sur les broches digitales.';
// Actuators - Music
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TITLE'] = '[Buzzer/Speaker] jouer la musique %1 sur %2';
Blockly.Msg['ACTUATORS_MUSIC_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une musique avec un module Grove buzzer (ou speaker) sur les broches digitales.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TITLE'] = '[Buzzer/Speaker] jouer les notes sur';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_NOTES_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer des notes avec un module Grove buzzer (ou speaker) sur les broches digitales.';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TITLE'] = 'note %1 à l\'octave %2 durée %3';
Blockly.Msg['ACTUATORS_MUSIC_NOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de définir une note à une certaine octave pendant une durée déterminée.';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TITLE'] = '[Buzzer/Speaker] jouer la fréquence %1 pendant %2 (ms) sur %3';
Blockly.Msg['ACTUATORS_MUSIC_PLAY_FREQUENCY_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une fréquence avec un module Grove buzzer (ou speaker) sur les broches digitales.';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TITLE'] = '[Buzzer/Speaker] arrêter la musique sur %1';
Blockly.Msg['ACTUATORS_MUSIC_STOP_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet d\'arrêter la musique en cours du module Grove buzzer (ou speaker) sur les broches digitales.';
// Actuators - Others
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TITLE'] = '[Electroaimant] contrôler à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TOOLTIP'] = IMG_MODULE_ELECTROMAGNET + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver l\'électroaimant (HAUT ou BAS) sur les broches digitales.';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TITLE'] = '[Atomiseur d\'eau] contrôler à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TOOLTIP'] = IMG_MODULE_WATER_ATOMIZER + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver l\'atomiseur d\'eau (HAUT ou BAS) sur les broches digitales.';
// Notes
Blockly.Msg['NOTE_C'] = 'Do';
Blockly.Msg['NOTE_C_SHARP'] = 'Do#';
Blockly.Msg['NOTE_D'] = 'Ré';
Blockly.Msg['NOTE_D_SHARP'] = 'Ré#';
Blockly.Msg['NOTE_E'] = 'Mi';
Blockly.Msg['NOTE_F'] = 'Fa';
Blockly.Msg['NOTE_F_SHARP'] = 'Fa#';
Blockly.Msg['NOTE_G'] = 'Sol';
Blockly.Msg['NOTE_G_SHARP'] = 'Sol#';
Blockly.Msg['NOTE_A'] = 'La';
Blockly.Msg['NOTE_A_SHARP'] = 'La#';
Blockly.Msg['NOTE_B'] = 'Si';
Blockly.Msg['MUSIC_SILENCE'] = 'Silence';
// Robot Ilo
Blockly.Msg['ROBOTS_ILO_SET_LED_COLOR_RGB_TITLE'] = '[Ilo] LEDs R %1 V %2 B %3';
Blockly.Msg['ROBOTS_ILO_SET_LED_COLOR_RGB_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur des LEDs du robot Ilo au format rvb.';
Blockly.Msg['ROBOTS_ILO_SET_LED_COLOR_TITLE'] = '[Ilo] LEDs %1';
Blockly.Msg['ROBOTS_ILO_SET_LED_COLOR_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur des LEDs du robot Ilo au format rvb.';
Blockly.Msg['ROBOTS_ILO_SET_LED_SHAPE_TITLE'] = '[Ilo] LEDs afficher l\'icône %1';
Blockly.Msg['ROBOTS_ILO_SET_LED_SHAPE_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur des LEDs du robot Ilo en utilisant une forme prédifinie.';
Blockly.Msg['ROBOTS_ILO_SET_LED_ANIM_TITLE'] = '[Ilo] animation des LEDs %1';
Blockly.Msg['ROBOTS_ILO_SET_LED_ANIM_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur des LEDs du robot Ilo en utilisant une animation prédifinie.';
Blockly.Msg['ROBOTS_ILO_WAVE'] = 'vague';
Blockly.Msg['ROBOTS_ILO_SET_LED_SINGLE_TITLE'] = '[Ilo] LED n°%1 %2 en %3';
Blockly.Msg['ROBOTS_ILO_SET_LED_SINGLE_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur des LEDs du robot Ilo en utilisant une animation prédifinie.';
Blockly.Msg['ROBOTS_ILO_MATRIX'] = 'de la matrice';
Blockly.Msg['ROBOTS_ILO_CIRCLE'] = 'du cercle';
Blockly.Msg['ROBOTS_ILO_MOVE_TITLE'] = '[Ilo] contrôler le robot %1 vitesse %2 %';
Blockly.Msg['ROBOTS_ILO_MOVE_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permet de contrôler la direction ainsi que la vitesse du robot Ilo.';
Blockly.Msg['ROBOTS_ILO_MOVE_BY_STEPS_TITLE'] = '[Ilo] contrôler le robot %1 de %2 unité(s)';
Blockly.Msg['ROBOTS_ILO_MOVE_BY_STEPS_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permet de contrôler la direction ainsi que la distance parcourue du robot Ilo. 1 unités = 1 longueur de robot Ilo, soit 20 cm.';
Blockly.Msg['ROBOTS_ILO_MOVE_FRONT'] = 'vers l\'avant';
Blockly.Msg['ROBOTS_ILO_MOVE_BACK'] = 'vers l\'arrière';
Blockly.Msg['ROBOTS_ILO_MOVE_RIGHT'] = 'vers la droite';
Blockly.Msg['ROBOTS_ILO_MOVE_LEFT'] = 'vers la gauche';
Blockly.Msg['ROBOTS_ILO_MOVE_ROT_TRIGO'] = 'pivoter à gauche';
Blockly.Msg['ROBOTS_ILO_MOVE_ROT_CLOCK'] = 'pivoter à droite';
Blockly.Msg['ROBOTS_ILO_MOVE_MOTOR_TITLE'] = '[Ilo] contrôler le moteur %1 direction %2 vitesse %3 %';
Blockly.Msg['ROBOTS_ILO_MOVE_MOTOR_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permet de contrôler un moteur spécifique du robot Ilo.';
Blockly.Msg['ROBOTS_ILO_FRONT_LEFT'] = 'avant gauche';
Blockly.Msg['ROBOTS_ILO_FRONT_RIGHT'] = 'avant droit';
Blockly.Msg['ROBOTS_ILO_BACK_RIGHT'] = 'arière droit';
Blockly.Msg['ROBOTS_ILO_BACK_LEFT'] = 'arrière gauche';
Blockly.Msg['ROBOTS_ILO_ROTATE_TITLE'] = '[Ilo] pivoter le robot dans le sens %1 de %2 °';
Blockly.Msg['ROBOTS_ILO_ROTATE_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permet de faire pivoter le robot Ilo dans le sens et sur l\'angle (en degrès) désiré.';
Blockly.Msg['ROBOTS_ILO_MOVE_ONE_SQUARE_FORWARD_TITLE'] = '[Ilo] avancer d\'une case';
Blockly.Msg['ROBOTS_ILO_MOVE_ONE_SQUARE_FORWARD_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Avance le robot Ilo d\'une case.';
Blockly.Msg['ROBOTS_ILO_MOVE_ONE_SQUARE_BACKWARD_TITLE'] = '[Ilo] reculer d\'une case';
Blockly.Msg['ROBOTS_ILO_MOVE_ONE_SQUARE_BACKWARD_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Recule le robot Ilo d\'une case.';
Blockly.Msg['ROBOTS_ILO_TURN_LEFT_TITLE'] = '[Ilo] pivoter à gauche';
Blockly.Msg['ROBOTS_ILO_TURN_LEFT_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Pivote le robot Ilo de 90° vers la gauche.';
Blockly.Msg['ROBOTS_ILO_TURN_RIGHT_TITLE'] = '[Ilo] pivoter à droite';
Blockly.Msg['ROBOTS_ILO_TURN_RIGHT_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Pivote le robot Ilo de 90° vers la droite.';
Blockly.Msg['ROBOTS_ILO_STOP_ROBOT_TITLE'] = '[Ilo] arrêter le robot';
Blockly.Msg['ROBOTS_ILO_STOP_ROBOT_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Arrête les moteurs du robot Ilo.';
Blockly.Msg['ROBOTS_ILO_GET_DISTANCE_TITLE'] = '[Ilo] distance sur le capteur %1';
Blockly.Msg['ROBOTS_ILO_GET_DISTANCE_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Renvoie la distance (en mm) de l\'obstacle le plus proche dans la direction donnée.';
Blockly.Msg['ROBOTS_ILO_FRONT'] = 'avant';
Blockly.Msg['ROBOTS_ILO_BACK'] = 'arrière';
Blockly.Msg['ROBOTS_ILO_RIGHT'] = 'droite';
Blockly.Msg['ROBOTS_ILO_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_ILO_LINE_DETECTOR_TITLE'] = '[Ilo] état du capteur de ligne %1';
Blockly.Msg['ROBOTS_ILO_LINE_DETECTOR_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Renvoie l\'état du capteur de ligne (droit/gauche) du robot Ilo.';
Blockly.Msg['ROBOTS_ILO_SET_LINE_DETECTOR_THRESHOLD_TITLE'] = '[Ilo] seuil du capteur de suivi de ligne %1';
Blockly.Msg['ROBOTS_ILO_SET_LINE_DETECTOR_THRESHOLD_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Règle le seuil du capteur de ligne (droit/gauche) du robot Ilo.';
Blockly.Msg['ROBOTS_ILO_LINE_DETECTOR_RIGHT'] = 'droit';
Blockly.Msg['ROBOTS_ILO_LINE_DETECTOR_MIDDLE'] = 'central';
Blockly.Msg['ROBOTS_ILO_LINE_DETECTOR_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_ILO_COLOR_DETECTOR_TITLE'] = '[Ilo] détecter la couleur du capteur %1';
Blockly.Msg['ROBOTS_ILO_COLOR_DETECTOR_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permet de détecter quelle couleur au format RVB se trouve sous le robot Ilo.';
Blockly.Msg['ROBOTS_ILO_COLOR_DETECTOR_RGB_TITLE'] = '[Ilo] détecter l\'intensité de %1 du capteur %2';
Blockly.Msg['ROBOTS_ILO_COLOR_DETECTOR_RGB_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Permet de détecter quelle couleur se trouve sous le robot Ilo et retourne l\'intensité de rouge, de vert ou de bleu.';
Blockly.Msg['ROBOTS_ILO_RED'] = 'rouge';
Blockly.Msg['ROBOTS_ILO_GREEN'] = 'vert';
Blockly.Msg['ROBOTS_ILO_BLUE'] = 'bleu';
Blockly.Msg['ROBOTS_ILO_GET_INTERNAL_SENSORS_TITLE'] = '[Ilo] %1';
Blockly.Msg['ROBOTS_ILO_GET_INTERNAL_SENSORS_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Retourne la valeur du tangage, roulis ou lacet du robot Ilo.';
Blockly.Msg['ROBOTS_ILO_PITCH'] = 'tangage';
Blockly.Msg['ROBOTS_ILO_ROLL'] = 'roulis';
Blockly.Msg['ROBOTS_ILO_YAW'] = 'lacet';
Blockly.Msg['ROBOTS_ILO_SET_ACC_TITLE'] = '[Ilo] régler l\'accélération à %1';
Blockly.Msg['ROBOTS_ILO_SET_ACC_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Règle l\'accélération du robot Ilo.';
Blockly.Msg['ROBOTS_ILO_SET_TEMPO_TITLE'] = '[Ilo] temporisation entre les déplacements %1 (ms)';
Blockly.Msg['ROBOTS_ILO_SET_TEMPO_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Règle la temporisation entre les déplacements du robot Ilo.';
Blockly.Msg['ROBOTS_ILO_GET_LUMINOSITY_TITLE'] = '[Ilo] luminosité sous le capteur %1';
Blockly.Msg['ROBOTS_ILO_GET_LUMINOSITY_TOOLTIP'] = IMG_ROBOT_ILO + Blockly.Tooltip.SEP + 'Renvoie la valeur de la luminosité mesurée par le capteur de luminosité du robot Ilo.';
Blockly.Msg['ROBOTS_ILO_LINE_DETECTOR_ALL'] = 'tous';
Blockly.Msg['ROBOTS_ILO_FINISH_STATE'] = 'attendre la fin du mouvement ?';
Blockly.Msg['ROBOTS_ILO_FINISH_STATE_YES'] = 'oui';
Blockly.Msg['ROBOTS_ILO_FINISH_STATE_NO'] = 'non';