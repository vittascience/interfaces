/**
 * @fileoverview English messages for Arduino. (EN)
 */
'use strict';
//COMMENT - Arduino
Blockly.Msg['CALL_EXPRESSION_COMMENT_TITLE'] = "comentario %1";
Blockly.Msg['CALL_EXPRESSION_COMMENT_TOOLTIP'] = "Permite agregar un comentario en el código.";
// Display - Arduino
Blockly.Msg['DISPLAY_CONTROL_BUILTIN_LED_TITLE'] = '[Arduino] controlar el LED integrado (D13) al estado %1';
Blockly.Msg['DISPLAY_CONTROL_BUILTIN_LED_TOOLTIP'] = 'Permite controlar el estado del LED conectado al pin D13 en la placa Arduino.';
// Display - Screens
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD] dirección %1 mostrar texto %2 en línea %3 posición %4';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_I2C + Blockly.Tooltip.SEP + 'Muestra texto de hasta 16 caracteres en cualquier línea de la pantalla LCD1602 Grove. Conecte el módulo a un puerto I2C. 0x3e corresponde a la dirección I2C del módulo Grove. 0x3f y 0x27 usan el módulo convertidor PCF8574 I2C.';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD] dirección %1 borrar pantalla';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_I2C + Blockly.Tooltip.SEP + 'Borra todos los caracteres de la pantalla LCD. Conecte el módulo a un puerto I2C. 0x3e corresponde a la dirección I2C del módulo Grove. 0x3f y 0x27 usan el módulo convertidor PCF8574 I2C.';
Blockly.Msg['DISPLAY_LCD_SET_DISPLAY_TITLE'] = '[LCD] dirección %1 %2 la pantalla';
Blockly.Msg['DISPLAY_LCD_SET_DISPLAY_TOOLTIP'] = IMG_MODULE_LCD_I2C + Blockly.Tooltip.SEP + 'Enciende o apaga la retroiluminación de la pantalla LCD. Conecte el módulo a un puerto I2C. 0x3e corresponde a la dirección I2C del módulo Grove. 0x3f y 0x27 usan el módulo convertidor PCF8574 I2C.';
Blockly.Msg['DISPLAY_LCD_SET_DISPLAY_ON'] = 'encender';
Blockly.Msg['DISPLAY_LCD_SET_DISPLAY_OFF'] = 'apagar';
Blockly.Msg['DISPLAY_LCD_SETRGBCOLOR_TITLE'] = '[LCD] iluminar la pantalla LCD a color R %1 G %2 B %3';
Blockly.Msg['DISPLAY_LCD_SETRGBCOLOR_TOOLTIP'] = IMG_MODULE_LCD_RGB + Blockly.Tooltip.SEP + 'Bloque que controla la retroiluminación del módulo Grove LCD 16x2. Dé un valor entre 0 y 255 para rojo, verde y azul. Conectar el módulo a un puerto I2C.';
Blockly.Msg['DISPLAY_LCD_SETPALETTERGBCOLOR_TITLE'] = '[LCD] iluminar la pantalla LCD a color %1';
Blockly.Msg['DISPLAY_LCD_SETPALETTERGBCOLOR_TOOLTIP'] = IMG_MODULE_LCD_RGB + Blockly.Tooltip.SEP + 'Bloque que controla la retroiluminación del módulo Grove LCD 16x2. Elija el color deseado de la paleta. Conecte el módulo a un puerto I2C.';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[Ecran OLED] mostrar el texto %1 en la posición x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Le permite escribir texto en una pantalla OLED de 128x64 px. Conecte la pantalla a un puerto I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[Ecran OLED] mostrar el icono %1 en la posición x %2 y %3';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Muestra un ícono, en la posición (x, y) en la pantalla OLED de 128x64 px. Conecte la pantalla a un puerto I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWBITMAPLOGO_TITLE'] = '[Ecran OLED] mostrar logo %1';
Blockly.Msg['DISPLAY_OLED_DRAWBITMAPLOGO_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Le permite mostrar un logo en la pantalla grove OLED de 128x64 px. Conecte la pantalla a un puerto I2C.';
Blockly.Msg['LOGO_VITTASCIENCE'] = 'Vittascience';
Blockly.Msg['LOGO_ARDUINO'] = 'Arduino';
Blockly.Msg['LOGO_SEEED'] = 'Seeed';
Blockly.Msg['LOGO_MICROBIT'] = 'Micro:bit';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[Ecran OLED] borrar pantalla';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permite limpiar la pantalla OLED. Conecte el módulo a un puerto I2C.';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] controlar un LED en el estado %1 en el pin %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Activa o desactiva el LED Grove (0 o 1) en los pines digitales D0 a D13.';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] establecer el brillo en %1 en el pin %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Permite ajustar el brillo de un LED de 0 a 255 en los pines PWM.';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[Variable Color LED] establecer el brillo a %1 (%) en el pin %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Le permite ajustar el brillo de un LED de 0 a 100% en los pines PWM. En el primer uso, los valores RGB se fijan en 0. Use un destornillador para ajustar los colores R, G y B detrás del módulo.';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TITLE'] = '[LED encadenable] establecer %1 LED en pines CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Permite configurar la cadena de LEDs RGB definiendo el número de módulos en serie en los pines digitales.';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TITLE'] = '[LED encadenable] controla el LED %1 a R %2 G %3 B %4 en los pines CIN %5 DIN %6';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color del LED RGB, da un valor entre 0 y 255 para el Rojo, el Verde y el Azul';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TITLE'] = '[LED encadenable] controla el LED %1 a %2 en los pines CIN %3 DIN %4';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color del LED RGB, elige un color de la paleta';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TITLE'] = '[LED encadenable] controla todos los LEDs en R %1 G %2 B %3 en los pines CIN %4 DIN %5';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color de los LEDs RGB, da un valor entre 0 y 255 para el Rojo, Verde y Azul';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE'] = '[LED encadenable] controla todos los LEDs en %1 en los pines CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloque que controla el color de los LEDs RGB, elige un color de la paleta';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel]establecer %1 LED en el pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Le permite definir la cantidad de LED del neopíxel en los pines digitales D0 a D13. Este bloque debe ser utilizado en la configuración.';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] controlar la LED %1 a  R %2 G %3 B %4 en el pin %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Le permite controlar el color de cada LED como (R,G,B) de 0 a 255 del módulo de neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] controlar el LED %1 a %2 en el pin %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Le permite controlar el color de cada LED del módulo neopixel. Usa la paleta para cambiar el color.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] controlar todos los LED a R %1 G %2 B %3 en el pin %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Le permite controlar todos los LED del módulo neopixel con el color elegido de modo que (R,G,B) sea de 0 a 255.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] controlar todos los LED a %1 en el pin %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permite controlar todos los LED del módulo neopixel con el color elegido. Usa la paleta para cambiar el color..';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] Arcoiris en el pin %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Mostrar el espectro de color de pantalla en los LED RGB en pines digitales D0 a D13.';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[Pantalla de 4 dígitos] muestra el número %1 en los pines CLK %2 DIO %3';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permite ver un número, temperatura o reloj en la pantalla Grove de 4 dígitos (TM1637) con pines digitales D0 a D13.';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[Pantalla de 4 dígitos] el reloj en los pines CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permite mostrar el reloj en la pantalla Grove de 4 dígitos (TM1637) con pines digitales D0 a D13. Tenga en cuenta que el tiempo se recupera cuando se agrega el bloque. Además, continúa mostrándose correctamente solo si la placa arduino permanece encendida.';
Blockly.Msg['DISPLAY_4DIGIT_SETTEMP_TITLE'] = '[Pantalla de 4 dígitos] muestra la temperatura %1 en los pines CLK %2 DIO %3';
Blockly.Msg['DISPLAY_4DIGIT_SETTEMP_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permite mostrar el reloj en la pantalla Grove de 4 dígitos (TM1637) con pines digitales D0 a D13. Tenga en cuenta que el tiempo se recupera cuando se agrega el bloque. Además, continúa mostrándose correctamente solo si la placa arduino permanece encendida.';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[Module LED Bar] muestra el nivel de %1 en los pines DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Enable to show level of input value on grove LED bar display (MY9221) on digital pins from D0 up through D13.';
Blockly.Msg['DISPLAY_MY9221_SET_GREEN_TO_RED_TITLE'] = '[Módulo de Barra LED] Mostrar el nivel de %1 en los pines DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_RED_TO_GREEN'] = 'rojo a verde';
Blockly.Msg['DISPLAY_MY9221_GREEN_TO_RED'] = 'verde a rojo';
Blockly.Msg['DISPLAY_MY9221_SET_GREEN_TO_RED_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permite cambiar la orientación de los LEDs en el módulo de barra gráfica Grove (MY9221), de verde a rojo o de rojo a verde.';
Blockly.Msg['DISPLAY_MY9221_SET_LED_TITLE'] = '[Módulo de Barra LED] Estado del LED n°%1 %2 en los pines DI %3 DCKI %4';
Blockly.Msg['DISPLAY_MY9221_SET_LED_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permite controlar cada LED en el módulo de barra gráfica Grove (MY9221) en los pines D0 a D13.';
// Input/Output - Arduino
Blockly.Msg['IO_WAIT_TITLE'] = 'esperar %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Hace une pausa en la ejecución del código.';
Blockly.Msg['IO_WAIT_SECOND'] = 'segundo(s)';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milisegundo(s)';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microsegundo(s)';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'esperar hasta %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Detiene la ejecución del código hasta que se cumple la condición.';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'poner en marcha el cronómetro';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Inicializa un cronómetro a 0 (en segundos).';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'valor del cronómetro en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Devuelve el valor del cronómetro desde la inicialización (en segundos o milisegundos).';
Blockly.Msg['IO_GETCHRONOMETER_SIMPLE_TITLE'] = 'valor del cronómetro';
Blockly.Msg['IO_GETCHRONOMETER_SIMPLE_TOOLTIP'] = 'Devuelve el valor del cronómetro desde la inicialización (en segundos).';

// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Teclado numérico] número en pines RX %1 TX %2';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Permite obtener la tecla presionada del teclado numérico en los pines RX y TX. Cuando conecte el módulo, asegúrese de que los pines estén \'cruzados\': RX de la tarjeta con TX del módulo y viceversa.';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Módulo joytsick] Valor de eje %1 en los pines X %2 Y %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Devuelve el valor del eje X o Y (de 0 a 1023) del joystick Grove en los pines analógicos A0 a A5.';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Potenciómetro lineal] Valor en el pin %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Devuelve la posición (de 0 a 1023) del potenciómetro lineal Grove en los pines analógicos A0 a A5.';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Potenciómetro giratorio] valor en pin %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Devuelve el ángulo (de 0 a 1023) del potenciómetro giratorio Grove en los pines A0 a A5.';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Sensor tactil] estado del pin %1 ';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor táctil Grove (0 o 1) en los pines digitales D0 a D13.';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Modulo botón] estado del pin %1 ';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Devuelve el valor del botón Grove (0 o 1) en los pines digitales D0 a D13.';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Módulo interruptor] estado del pin %1 ';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Devuelve el valor del interruptor Grove (0 o 1) en los pines digitales D0 a D13.';
Blockly.Msg['IO_GROVEMP3_INIT_TITLE'] = '[Módulo MP3 v3] inicializar en el pin RX %1 TX %2';
Blockly.Msg['IO_GROVEMP3_INIT_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Inicializa el módulo Grove MP3 v3.0 en los pines RX/TX';
Blockly.Msg['IO_GROVEMP3_PLAY_PAUSE_TITLE'] = '[Módulo MP3 v3] poner en reproducción/pausa';
Blockly.Msg['IO_GROVEMP3_PLAY_PAUSE_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Permite poner en reproducción/pausa';
Blockly.Msg['IO_GROVEMP3_NEXT_TITLE'] = '[Módulo MP3 v3] ir a la siguiente pista';
Blockly.Msg['IO_GROVEMP3_NEXT_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Va a la siguiente pista';
Blockly.Msg['IO_GROVEMP3_PLAY_SD_SONG_TITLE'] = '[Módulo MP3 v3] reproducir pista %1';
Blockly.Msg['IO_GROVEMP3_PLAY_SD_SONG_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Te permite reproducir una pista proporcionando el nombre del archivo.';
Blockly.Msg['IO_GROVEMP3_PLAY_SD_DIRECTORY_SONG_TITLE'] = '[Módulo MP3 v3] reproducir la pista de la carpeta %1 índice %2';
Blockly.Msg['IO_GROVEMP3_PLAY_SD_DIRECTORY_SONG_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Te permite reproducir una pista en una carpeta especificando su índice.';
Blockly.Msg['IO_GROVEMP3_GET_VOLUME_TITLE'] = '[Módulo MP3 v3] volumen actual';
Blockly.Msg['IO_GROVEMP3_GET_VOLUME_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Devuelve el nivel de volumen actual';
Blockly.Msg['IO_GROVEMP3_SET_VOLUME_TITLE'] = '[Módulo MP3 v3] establecer volumen %1';
Blockly.Msg['IO_GROVEMP3_SET_VOLUME_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Establece el nivel de volumen';
// Input/Output - Pins
Blockly.Msg['IO_LED_BUILTIN_TITLE'] = 'LED integrado';
Blockly.Msg['IO_LED_BUILTIN_TOOLTIP'] = "Permite controlar el estado del LED integrado en la placa Arduino.";
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'ALTO (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAJO (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Devuelve un valor booleano (ALTO o BAJO).';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'leer pin digital %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Permite leer el valor de una entrada digital (0 ou 1).';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'escribir en pin digital %1 estado %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Permite escribir un valor en una entrada digital (0 o 1).';
Blockly.Msg['IO_WRITEANALOGPIN_TITLE'] = 'escribir en el pin analógico %1 el valor %2';
Blockly.Msg['IO_WRITEANALOGPIN_TOOLTIP'] = 'Permite escribir un valor en una entrada analógica (0-255).';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'leer el pin analógico %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Permite leer el valor de una entrada analógica (0-1023).';
Blockly.Msg['IO_SETPWM_TITLE'] = 'aplica una señal PWM de ciclo de trabajo de %1 (%) al pin %2 ';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Se utiliza para aplicar una señal PWM a un pin pwm (~) configurando el ciclo de trabajo (en %). Para los pines D3, D9, D10 y D11, la frecuencia de la señal es de 490 Hz (o 2,04 ms). Para los pines D5 y D6, es de 980 Hz (es decir, 1,02 ms).';
Blockly.Msg['IO_READPULSEIN_TITLE'] = 'Leer el pulso (μs) del estado %1 en el pin %2';
Blockly.Msg['IO_READPULSEIN_TOOLTIP'] = 'Devuelve la duración del pulso ALTO o BAJO entrante (en μs). Funciona para pulsos de 10 μs a 3 min.';
Blockly.Msg['IO_ATTACH_INTERRUPT_TITLE'] = 'si se detecta %1 en el pin %2, entonces';
Blockly.Msg['IO_ATTACH_INTERRUPT_TOOLTIP'] = 'Le permite crear un evento en los pines 2 y 3. Este bloque ejecuta instrucciones en cualquier momento tan pronto como se detecta un flanco ascendente/descendente o ambos en los pines 2 y 3..';
Blockly.Msg['IO_RISING_EDGE'] = 'flanco ascendente';
Blockly.Msg['IO_FALLING_EDGE'] = 'flanco descendente';
Blockly.Msg['IO_BOTH_EDGE'] = 'cambio de estado';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_BEGIN_TITLE'] = 'iniciar la comunicación serie a %1 baudios';
Blockly.Msg['COMMUNICATION_SERIAL_BEGIN_TOOLTIP'] = 'Permite iniciar la comunicación serie a una velocidad de transmisión de datos (en baudios).';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'escribir en la consola %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Este bloque se utiliza para escribir cualquier tipo de datos en el puerto serie. Luego se mostrarán en la consola cuando se ejecute el programa.';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'con';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'salto(s) de línea';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE'] = 'si se reciben datos del puerto serie en %1, entonces';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones si el puerto serie recibe un dato en la variable \'serialData\'.';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'dibujar el gráfico';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Este bloque se utiliza para escribir datos (numéricos) que serán visibles en el trazador. Se puede utilizar con uno o más bloques en formato "Nombre" y "Datos". Para visualizar los gráficos, haga clic en el icono \'Modo gráfico\' en la consola.';
Blockly.Msg['COMMUNICATION_DATA'] = 'Datos';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nombre %1 Valor %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Este bloque se utilizará con el bloque "Dibujar el gráfico". Debe contener el nombre del valor a mostrar (texto) y el valor en cuestión (número).';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'Reproducir la nota %1 en la computadora';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Reproduce la nota seleccionada hasta la ejecución del bloque "Fin de nota".';
Blockly.Msg['NOTE_C'] = 'Do';
Blockly.Msg['NOTE_C_SHARP'] = 'Do#';
Blockly.Msg['NOTE_D'] = 'Ré';
Blockly.Msg['NOTE_D_SHARP'] = 'Ré#';
Blockly.Msg['NOTE_E'] = 'Mi';
Blockly.Msg['NOTE_F'] = 'Fa';
Blockly.Msg['NOTE_F_SHARP'] = 'Fa#';
Blockly.Msg['NOTE_G'] = 'Sol';
Blockly.Msg['NOTE_G_SHARP'] = 'Sol#';
Blockly.Msg['NOTE_A'] = 'La';
Blockly.Msg['NOTE_A_SHARP'] = 'La#';
Blockly.Msg['NOTE_B'] = 'Si';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'Reproducir la frecuencia %1 (Hz) en la computadora';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Este bloque te permite reproducir una frecuencia dada en la computadora';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'terminar la nota en computadora';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Detener la reproducción de la nota actual.';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] escribir en la tarjeta SD %1 baudrate %2 en pines RXI %3 TXO %4 %5 datos %6';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'Permite escribir datos en la tarjeta micro SD con el módulo Openlog. Operación en transmisión UART.';
Blockly.Msg['COMMUNICATION_SDSPI_WRITE_TITLE'] = '[Módulo SD SPI] escribir en la tarjeta SD %1 en el pin CS %2 %3 Datos %4';
Blockly.Msg['COMMUNICATION_SDSPI_WRITE_TOOLTIP'] = IMG_MODULE_SD_SPIMODULE + Blockly.Tooltip.SEP + 'Este bloque se utiliza para escribir datos en la tarjeta SD con un módulo SPI. Con una placa Arduino UNO, la transmisión SPI utiliza los pines ICSP o ISP. Debe especificar el pin CS (por ejemplo, D4 para el Shield Grove).';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SETTINGS_TITLE'] = '[Bluetooth] configurar: Nombre %1 Modo %2 Código pin %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SETTINGS_TOOLTIP'] = IMG_MODULE_SERIAL_BT + Blockly.Tooltip.SEP + 'Le permite configurar el módulo serie Bluetooth ingresando el nombre, el modo (\'S\' para esclavo y \'M\' para maestro) y el código pin.';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] enviar en los pines RX %1 TX %2 mensaje %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_SERIAL_BT + Blockly.Tooltip.SEP + 'Permite enviar datos a través del módulo serie Bluetooth en los pines digitales D0 a D13.';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] si el mensaje se recibió en los pines RX %1 TX %2 en %3 entonces';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_SERIAL_BT + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones si un módulo serie Bluetooth recibe datos en la variable \'bluetoothData\' en los pines digitales D0 a D13.';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_SENDDATA_TITLE'] = '[HM10 BT] enviar en pines RX %1 TX %2 mensaje %3';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HM10_BT + Blockly.Tooltip.SEP + 'Permite enviar datos a través del módulo serie Bluetooth HM10 en los pines digitales D0 a D13.';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[HM10 BT] si el mensaje se recibió en los pines RX %1 TX %2 en %3 entonces';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HM10_BT + Blockly.Tooltip.SEP + 'Le permite ejecutar instrucciones si un módulo serie Bluetooth HM10 recibe datos en la variable \'HM10Data\' en los pines digitales D0 a D13. Por defecto, el módulo se llama MLT-BT05.';
Blockly.Msg['COMMUNICATION_RADIONRF24_SENDDATA_TITLE'] = '[Radio nRF24L01] enviar a la Dirección %1 Canal %2 en los pines CE %3 CSN %4 el mensaje %5';
Blockly.Msg['COMMUNICATION_RADIONRF24_SENDDATA_TOOLTIP'] = IMG_MODULE_NRF24L01 + Blockly.Tooltip.SEP + 'Permite que los datos inalámbricos sean enviados por el módulo nRF24L01 a otro módulo similar. El módulo opera en la banda de frecuencia de 2,4 GHz. Con una placa Arduino UNO, la transmisión SPI utiliza los pines ICSP o ISP. Atención, este módulo debe ser alimentado con una tensión de 3,3 V.';
Blockly.Msg['COMMUNICATION_RADIONRF24_DATARECEIVER_TITLE'] = '[Radio nRF24L01] si hay datos disponibles Dirección %1 Canal %2 en pines CE %3 CSN %4 en %5 entonces';
Blockly.Msg['COMMUNICATION_RADIONRF24_DATARECEIVER_TOOLTIP'] = IMG_MODULE_NRF24L01 + Blockly.Tooltip.SEP + 'Se utiliza para leer los datos recibidos por el módulo nRF24L01. Vea el tutorial (haga clic con el botón derecho en el bloque y luego en Ayuda).';
Blockly.Msg['COMMUNICATION_GROVE_433MHZ_TRANSMITTER'] = '[Radio 315/433MHz] enviar en PIN %1 Mensaje %2';
Blockly.Msg['COMMUNICATION_GROVE_433MHZ_TRANSMITTER_TOOLTIP'] = IMG_MODULE_RF433_TRANSMITTER + Blockly.Tooltip.SEP + 'Le permite enviar un mensaje de radio usando el módulo Grove Radio 433MHz o 315MHz conectado a un pin digital.';
Blockly.Msg['COMMUNICATION_GROVE_433MHZ_RECEIVER'] = '[Radio 315/433MHz] si el mensaje se recibió en el pin %1 en %2, entonces';
Blockly.Msg['COMMUNICATION_GROVE_433MHZ_RECEIVER_TOOLTIP'] = IMG_MODULE_RF433_RECEIVER + Blockly.Tooltip.SEP + 'Se utiliza para leer los datos recibidos por el módulo Grove Radio 433MHz o 315MHz. El bloque devuelve el mensaje de texto recibido, o bien \'No message\'.';
Blockly.Msg['COMMUNICATION_IRRECEIVER_ONDATARECEIVED_TITLE'] = '[Recepteur IR] si donnée reçue sur la broche %1 dans %2 alors';
Blockly.Msg['COMMUNICATION_IRRECEIVER_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par transmission infrarouge dans la variable \'IRData\'. Connecter le récepteur infrarouge sur les broches digitales D0 à D13.';
Blockly.Msg['COMMUNICATION_REMOTECONTROL_ONCOMMANDRECEIVED_TITLE'] = '[Control Remoto NEC] si se recibe el comando %1 con el dato %2 entonces';
Blockly.Msg['COMMUNICATION_REMOTECONTROL_ONCOMMANDRECEIVED_TOOLTIP'] = IMG_MODULE_BASIC_BLACK_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Le permite ejecutar instrucciones si uno de los comandos se recibe desde un control remoto NEC por transmisión de infrarrojos en la variable \'IRData\'. Utilice el bloque con el receptor de infrarrojos para operar la transmisión.';
Blockly.Msg['REMOTE_NEC_BUTTON'] = 'botón ';
Blockly.Msg['REMOTE_NEC_BUTTON_UP'] = 'alto';
Blockly.Msg['REMOTE_NEC_BUTTON_DOWN'] = 'bajo';
Blockly.Msg['REMOTE_NEC_BUTTON_LEFT'] = 'izquierda';
Blockly.Msg['REMOTE_NEC_BUTTON_RIGHT'] = 'derecha';
Blockly.Msg['REMOTE_NEC_BUTTON_BACK'] = 'retorno';
// Communication - External modules
Blockly.Msg['COMMUNICATION_GPS_ONDATARECEIVED_TITLE'] = '[GPS] si se reciben datos en los pines TX %1 RX %2 en %3, entonces';
Blockly.Msg['COMMUNICATION_GPS_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Permite ejecutar instrucciones si el GPS recibe datos en la variable \'gpsData\' en los pines RX/TX.';
Blockly.Msg['COMMUNICATION_RTC_MODULE_PCF85063TP'] = 'Alta precisión (0x51)';
Blockly.Msg['COMMUNICATION_RTC_MODULE_DS1307'] = 'v1.2 (0x68)';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TITLE'] = '[Horloge RTC %1] inicializar en %2 fecha %3';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permite inicializar el módulo de reloj Grove RTC Alta Precisión (PCF85063TP) o el módulo RTC v1.2 (DS1307), para poder leer la fecha y la hora precisas con el bloque \'Leer módulo de reloj\'. Colóquelo en el bloque \'Al inicio\'. Conecte el módulo RTC a un puerto I2C. Nota: Para funcionar, el módulo DS1307 debe tener una batería de botón.';
Blockly.Msg['DAY_MONDAY'] = 'lunes';
Blockly.Msg['DAY_TUESDAY'] = 'martes';
Blockly.Msg['DAY_WEDNESDAY'] = 'miercoles';
Blockly.Msg['DAY_THURSDAY'] = 'jueves';
Blockly.Msg['DAY_FRIDAY'] = 'viernes';
Blockly.Msg['DAY_SATURDAY'] = 'sábado';
Blockly.Msg['DAY_SUNDAY'] = 'domingo';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TITLE'] = '[Reloj RTC %1] inicializar a la hora %2 minuto %3 segundo %4';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permite inicializar el módulo de reloj Grove RTC Alta Precisión (PCF85063TP) o el módulo RTC v1.2 (DS1307), para poder leer la fecha y la hora precisas con el bloque \'Leer módulo de reloj\'. Colóquelo en el bloque \'Al inicio\'. Conecte el módulo a un puerto I2C. Nota: Para funcionar, el módulo DS1307 debe tener una batería de botón.';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TITLE'] = '[Reloj RTC %1] leer %2';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permite leer la fecha y la hora del módulo de reloj RTC de alta precisión de Grove (PCF85063TP) o el módulo RTC v1.2 (DS1307). Para obtener un resultado correcto, utilice primero los dos bloques \'Inicializar el módulo de reloj\'. Conecte el módulo a un puerto I2C. Nota: Para funcionar, el módulo DS1307 debe tener una batería de botón.';
Blockly.Msg['CLOCK_YEAR'] = 'año';
Blockly.Msg['CLOCK_MONTH'] = 'mes';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'día del mes';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'día de la semana';
Blockly.Msg['CLOCK_HOUR'] = 'hora';
Blockly.Msg['CLOCK_MINUTE'] = 'minutos';
Blockly.Msg['CLOCK_SECOND'] = 'segundo';
Blockly.Msg['COMMUNICATION_RFID_GETSTRINGCARDID_TITLE'] = '[Lector RFID] ID de insignia en pines RX %1 TX %2';
Blockly.Msg['COMMUNICATION_RFID_GETSTRINGCARDID_TOOLTIP'] = IMG_MODULE_RFID + Blockly.Tooltip.SEP + 'Le permite recuperar el identificador UID en forma de una cadena de caracteres del módulo Grove RFID de 125 kHz si el uno está disponible en los pines digitales D0 a D13.Para verificar el identificador de una tarjeta y validarla o no, simplemente compárelo con el marco de cadena deseado.';
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[Sensor SGP30] Gas %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Devuelve la cantidad de CO2 (en PPM) o TVOC (en PPB) contenida en el aire gracias al sensor SGP30.Conecte el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'Dióxido de carbono (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'Compuestos orgánicos volátiles (TCOV) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Sensor de gases multicanal] gas %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Devuelve la cantidad de gas medida en el aire (en PPM) gracias al sensor de gas de multicanal de Grove.Conecte el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Sensor de gases multicanal v2] gas %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Devuelve la cantidad de gas medida en el aire (en V) gracias al sensor de gas multicanal multicanal V2 Grove.Conecte el sensor a un puerto I2C.';
Blockly.Msg['GAS_CO'] = 'Monóxido de carbono (CO)';
Blockly.Msg['GAS_NO2'] = 'Dioxido de nitrogeno (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'Etanol (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'Dihidrógeno (H2)';
Blockly.Msg['GAS_NH3'] = 'Amoníaco (NH3)';
Blockly.Msg['GAS_CH4'] = 'Metano (CH4)';
Blockly.Msg['GAS_C3H8'] = 'Propano (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'Iso-propano (C4H10)';
Blockly.Msg['GAS_VOC'] = 'Compuestos orgánicos volátiles (COV)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Sensor de dioxígeno] O2 %1 en el pin %2';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Devuelve la concentración de dioxígeno (O2) en el aire (en %) o el voltaje de salida correspondiente gracias al sensor de Gas O2 Grove en pines analógicos A0 a A5.';
Blockly.Msg['SENSORS_O2_GAS_CONCENTRATION'] = 'concentración (%)';
Blockly.Msg['SENSORS_O2_GAS_VOUT'] = 'tensión de salida (V)';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[Sensor SCD30] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Devuelve la concentración de CO2 en el aire (en PPM), humedad (en %) o temperatura en Celsius (° C), Fahrenheit (° F) o Kelvin (K) del sensor Grove SCD30.Conecte el sensor en un puerto I2C.';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'dióxido de carbono (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = 'temperatura';
Blockly.Msg['SENSORS_SCD30_HUM'] = 'humedad (%)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[Sensor SCD30] Forzar la recalibración a %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Forzar la calibración del sensor SCD30 con el valor dado (en PPM).Colóquelo al aire libre (donde la concentración es de alrededor de 420 ppm, un aire puro), reinicie la tarjeta y luego espere 2 minutos.Consejo: use un botón externo en una entrada digital de la tarjeta Arduino para controlar el lanzamiento de la calibración.De lo contrario, al reconectar la tarjeta, el programa se lanza y hace una calibración nuevamente no necesariamente deseada.';
Blockly.Msg['SENSORS_MQ135_GETGAS_TITLE'] = '[Sensor MQ135] %1 en el pin %2';
Blockly.Msg['SENSORS_MQ135_GETGAS_TOOLTIP'] = IMG_MODULE_MQ135 + Blockly.Tooltip.SEP + 'Este bloque utiliza el sensor MQ135 para devolver la concentración del CO2 en el aire.El sensor también es sensible a otros gases como el butano y el benceno, pero da una buena aproximación del nivel de CO2.Conectarse a pines analógicos A0 a A5.';
Blockly.Msg['SENSORS_MQ135_CONCENTRATION'] = 'CO2 (ppm)';
Blockly.Msg['SENSORS_MQ135_RZERO_CALIBRATOR'] = 'resistencia a la calibración (kΩ)';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Sensor de calidad del aire] Valor en el pin %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Devuelve el valor de la calidad del aire (de 0 a 1023) a los pines analógicos A0 a A5.El sensor es Air Quality Sensor v1.3 de Seeed.';
Blockly.Msg['SENSORS_AIR_QUALITY_ONINDEXAS_TITLE'] = '[Sensor de calidad del aire] Si el aire es %1 en el pin %2, entonces';
Blockly.Msg['SENSORS_AIR_QUALITY_ONINDEXAS_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Ejecuta instrucciones de acuerdo con la calidad del aire medida por el sensor de calidad del aire Grove en pines analógicos A0 a A5.El sensor es Air Quality Sensor v1.3 de Seeed.';
Blockly.Msg['SENSORS_AIR_QUALITY_FA'] = 'sano';
Blockly.Msg['SENSORS_AIR_QUALITY_LP'] = 'poco contaminado';
Blockly.Msg['SENSORS_AIR_QUALITY_HP'] = 'contaminado';
Blockly.Msg['SENSORS_AIR_QUALITY_VHP'] = 'muy contaminado';
Blockly.Msg['SENSORS_DUST_READDATA_TITLE'] = '[Sensor de partículas] %1 en el pin %2';
Blockly.Msg['SENSORS_DUST_READDATA_TOOLTIP'] = IMG_MODULE_DUST + Blockly.Tooltip.SEP + 'Devuelve la concentración de partículas (diámetro> 1 μm) con el sensor de partículas Grove (PPD42) en los pines digitales D0 a D13.';
Blockly.Msg['SENSORS_DUST_CONCENTRATION'] = 'concentración (pcs/L)';
Blockly.Msg['SENSORS_DUST_RATIO'] = 'relación (%)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[Capteur HM330X] Concentración de partículas finas %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Detecta la densidad de partículas en el aire con el sensor HM330X.Conecte el sensor en un puerto I2C.';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
Blockly.Msg['SENSORS_MHZ19_GETDATA_TITLE'] = '[Sensor MH-Z19] %1 en los pines TX %2 RX %3';
Blockly.Msg['SENSORS_MHZ19_GETDATA_TOOLTIP'] = IMG_MODULE_MHZ19 + Blockly.Tooltip.SEP + 'Este bloque utiliza el sensor MH-Z19 para devolver la cantidad de CO2 (en PPM) al aire o la temperatura en grado Celsius (° C), Fahrenheit (° F) o Kelvin (K).Este sensor funciona en UART y, por lo tanto, se puede conectar a los pines digitales de D0 a D13.';
Blockly.Msg['SENSORS_MHZ19_CO2'] = 'CO2 (ppm)';
Blockly.Msg['SENSORS_MHZ19_TEMPERATURE'] = 'temperatura';
// Sensors - Climate
Blockly.Msg['SENSORS_TEMPERATURE'] = 'temperatura';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humedad (%)';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'en';
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[Sensor BMP280 %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grados Celsius (° C), Fahrenheit (° F) o Kelvin (K), la presión (en PA).La altitud (en m) se calcula con la presión y se inicializa en 0 al comienzo del programa.El bloque necesita el sensor Grove BMP280 (dirección: 0x77, color: azul) o el sensor HW-611 280 (dirección: 0x76, color: púrpura).Conecte el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_BMP280_TEMP'] = 'temperatura';
Blockly.Msg['SENSORS_BMP280_PRESS'] = 'presión(Pa)';
Blockly.Msg['SENSORS_BMP280_ALT'] = 'altitud (m)';
Blockly.Msg['SENSORS_DPS310_READDATA_TITLE'] = '[Sensor DPS310] %1';
Blockly.Msg['SENSORS_DPS310_READDATA_TOOLTIP'] = IMG_MODULE_DPS310 + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grado Celsius (° C), Fahrenheit (° F) o Kelvin (K) y la presión (en Pascal).Conecte el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_DPS310_TEMPERATURE'] = 'temperatura';
Blockly.Msg['SENSORS_DPS310_PRESSURE'] = 'presión (Pa)';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Sensor de humedad] Humedad del suelo en el pin %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Devuelve la humedad (de 0 a 1023) medida gracias al sensor de humedad de Grove en pines analógicos A0 a A5.';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[T ° Sensor] Temperatura en %1 en el pin %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (° C), Fahrenheit (° F) o Kelvin (k) del sensor de temperatura en los pines analógicos A0 a A5.';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = '[Sensor H.T °] Temperatura en %1 en pines A1 %2 A0 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Devuelve la temperatura del termopar en el grado de Celsius (50 a 600 ° C), Fahrenheit (° F) o Kelvin (k) gracias al sensor de bosque de alta temperatura en pasadores analógicos A0 a A5.';
Blockly.Msg['SENSORS_MAX6675_READTEMP_TITLE'] = '[Sensor MAX6675 & termopar] temperatura en %1 %2 en los pines SO %3 CS %4 CLK %5';
Blockly.Msg['SENSORS_MAX6675_READTEMP_TOOLTIP'] = IMG_MODULE_MAX6675 + Blockly.Tooltip.SEP + 'Este bloque utiliza el sensor MAX6675 para devolver la temperatura en grado Celsius (° C), Fahrenheit (° F) o Kelvin (K).Agregue un período de adquisición superior a 0.5 segundos.Las conexiones se especifican en el tutorial.';
Blockly.Msg['SENSORS_DHT_READDATA_TITLE'] = '[Sensor %1] %2 en el pin %3';
Blockly.Msg['SENSORS_DHT_READDATA_TOOLTIP'] = IMG_MODULE_DHT11_22 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grado Celsius (° C), Fahrenheit (° F) o Kelvin (K), o humedad (en %) gracias al sensor DHT11 o DHT22 Grove en los pasadores digitales de D0 a D13.';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[Sensor TH02] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grado Celsius (° C), Fahrenheit (° F) o Kelvin (K) o humedad (en %) gracias al sensor TH02.Conecte el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Sensor SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (° C), Fahrenheit (° F) o Kelvin (K) o humedad (en %) gracias al sensor SHT31.Conecte el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_MPX5700AP_GETPRESSURE_TITLE'] = '[Sensor MPX5700AP] presión (kPa) en el pin %1';
Blockly.Msg['SENSORS_MPX5700AP_GETPRESSURE_TOOLTIP'] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + 'Devuelve la presión (en KPA) medida gracias al sensor Grove MPX5700AP en los pines analógicos A0 a A5.';
Blockly.Msg['SENSORS_BME680_READDATA_TITLE'] = '[Sensor BME680] %1';
Blockly.Msg['SENSORS_BME680_READDATA_TOOLTIP'] = IMG_MODULE_BME680 + Blockly.Tooltip.SEP + 'Devuelve la temperatura ambiente en grado Celsius (° C), Fahrenheit (° F) o Kelvin (k), presión (en PA), humedad (en %) o la cantidad de gas (en ‎Ω). Conecte el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_BME680_TEMPERATURE'] = 'temperatura';
Blockly.Msg['SENSORS_BME680_PRESSURE'] = 'presión (Pa)';
Blockly.Msg['SENSORS_BME680_HUMIDITY'] = 'humedad (%)';
Blockly.Msg['SENSORS_BME680_GAS'] = 'gas (‎Ω)';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TITLE'] = '[Sensor DS18B20] temperatura en %1 en el pin %2';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + 'Devuelve la temperatura en grados Celsius (° C), Fahrenheit (° F) o Kelvin (K) con el sensor Grove DS18B20 en los pines digitales D0 a D13.Este sensor se usa para medir la temperatura del agua.Sumerja el extremo de la sonda para medir la temperatura del agua.Tenga en cuenta que para temperaturas superiores a 70 ° C, la sonda no puede medir durante mucho tiempo.';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Sensor de agua] Cantidad de agua en el huso %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Devuelve la cantidad de agua (de 0 a 1023) medida gracias al sensor de agua Grove en los pines analógicos A0 a A5.';
Blockly.Msg['SENSORS_GETGROVEWATER_I2C_TITLE'] = '[Sensor de agua I2C] cantidad de agua (%)';
Blockly.Msg['SENSORS_GETGROVEWATER_I2C_TOOLTIP'] = IMG_MODULE_WATER_I2C + Blockly.Tooltip.SEP + 'Devuelve la cantidad de agua (del 0 al 100%) medida gracias al sensor de agua I2C Grove.Conecte el módulo a un puerto I2C.';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Pluviómetro] estado en el pin %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Devuelve el estado del sensor de lluvia en los pines digitales D0 a D13.';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anemómetro] estado en el pin %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Devuelve el estado del anemómetro (dos veces el estado alto con cada rotación) en los pines digitales D0 a D13.';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Sensor de luz] brillo en el pin %1 ';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Devuelve el brillo (de 0 a 1023) del sensor de luz Grove en los pasadores analógicos A0 a A5.';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[SensorSI1145] brillo %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Devuelve el índice de luz ultravioleta, el brillo visible (en luz) o infrarrojo (en lumen) gracias al sensor de luz solar Grove o al sensor GY1145.Conecte el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_SI1145_UV'] = 'índice UV';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visible (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrarrojo (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Sensor ultravioleta] Índice UV en el pin %1 ';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Devuelve el índice de luz ultravioleta para las ondas entre 240 y 380 nm del sensor Grove en pines analógicos A0 a A5.';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Sensor de sonido] Nivel de sonido en el pin %1 ';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Devuelve el nivel de sonido (0 a 1023) con el sensor de sonido Grove en los pines analógicos de A0 a A5.';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Sensor de color] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Le permite leer el nivel de uno de los tres colores primarios con el sensor de color Grove, el nivel es entre 0 y 10240. Conecte el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_GROVECOLOR_TEMP'] = 'temperatura del color (K)';
Blockly.Msg['SENSORS_GROVECOLOR_LUX'] = 'brillo (lux)';
Blockly.Msg['SENSORS_GROVECOLOR_ONCOLORDETECTED_TITLE'] = '[Sensor de color] Si se detecta el color %1';
Blockly.Msg['SENSORS_GROVECOLOR_ONCOLORDETECTED_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Le permite leer el nivel de uno de los tres colores primarios con el sensor de color grove, este bloque prueba el valor máximo de los 3 colores conecte el sensor a un puerto I2C.';
Blockly.Msg['COLOR_LEVEL_RED'] = 'nivel rojo';
Blockly.Msg['COLOR_LEVEL_GREEN'] = 'nivel verde';
Blockly.Msg['COLOR_LEVEL_BLUE'] = 'nivel azul';
Blockly.Msg['COLOR_RED'] = 'rojo';
Blockly.Msg['COLOR_GREEN'] = 'vérte';
Blockly.Msg['COLOR_BLUE'] = 'azul';
Blockly.Msg['SENSORS_CAMERA_SNAPSHOT_TITLE'] = '[Cámara] tomar una foto en PINS RX %1 TX %2 %3 [SHIELD SD] guarde la foto en el PIN %4';
Blockly.Msg['SENSORS_CAMERA_SNAPSHOT_TOOLTIP'] = IMG_MODULE_CAMERA + Blockly.Tooltip.SEP + 'Tomar una foto y guárdarla en una tarjeta microSD conectada a un lector conectado al Arduino.El Shield Grove para la tarjeta SD con PIN CS conectado a D4.';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Sensor ultrasónico %1] %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Devuelve la distancia (en cm) o la duración del viaje de ida y vuelta (en μs) medido gracias al sensor ultrasónico en los pines digitales de D0 a D13.El sensor Grove usa un solo pin, el HC-SR04 usa 2 pines.';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distancia (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'tiempo de viaje (μs)';
Blockly.Msg['SENSORS_ULTRASONIC_1PIN'] = 'en el pin';
Blockly.Msg['SENSORS_ULTRASONIC_2PINS'] = 'en el pin';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = '[Sensor de gestos] Tipo de gesto';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Devuelve el tipo de gesto analizado (\'right\', \'left\', \'up\', \'down\', \'forward\', \'backward\', \'clockwise\', \'wave\') gracias al sensor de gestos de Grove.Conecte el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Sensor de gesto] Si el gesto %1 se detecta entonces';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Ejecuta instrucciones si el gesto seleccionado es detectado por el sensor de gestos Grove.Conecte el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'derecha';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'izquierda';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'alto';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'bajo';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'adelante';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'atrás';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'sentido horario';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'sentido antihorario';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'onda';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Sensor de línea recta] Estado en el pin %1 ';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de línea recta Grove (0 o 1) en los pines digitales D0 a D13.';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Módulo de inclinación] estado en el pin %1 ';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Devuelve el valor de la inclinación del módulo Grove (0 o 1) en los pines digitales D0 a D13.';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[Sensor de movimiento] estado en el pin %1 ';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Devuelve el valor del sensor de movimiento de movimiento de Grove PIR (0 o 1) en los pines digitales D0 a D13.';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Sensor de vibración] estado en el pin %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Devuelve el estado de la vibración (0 o 1) gracias al sensor de vibración piezoeléctrica en los pines digitales D0 a D13.';
// Sensors - Other
Blockly.Msg['SENSORS_INA219_GETDATA_TITLE'] = '[SensorINA219] %1';
Blockly.Msg['SENSORS_INA219_GETDATA_TOOLTIP'] = IMG_MODULE_INA219 + Blockly.Tooltip.SEP + 'Devuelve diferentes parámetros elegidos por el usuario como la corriente (en MA), el voltaje (en V) o la potencia (en MW) gracias al sensor AdaFruit INA219.Conecte el sensor a un puerto I2C.';
Blockly.Msg['SENSORS_INA219_BUS_VOLTAGE'] = 'voltaje de bus (V)';
Blockly.Msg['SENSORS_INA219_SHUNT_VOLTAGE'] = 'voltaje de derivación (mV)';
Blockly.Msg['SENSORS_INA219_LOAD_VOLTAGE'] = 'voltaje de carga (V)';
Blockly.Msg['SENSORS_INA219_CURRENT'] = 'corriente (mA)';
Blockly.Msg['SENSORS_INA219_POWER'] = 'potencia(mW)';
Blockly.Msg['SENSORS_FSR402_GETFORCE_TITLE'] = '[Detector de fuerza] valor en el pin %1';
Blockly.Msg['SENSORS_FSR402_GETFORCE_TOOLTIP'] = IMG_MODULE_FORCE + Blockly.Tooltip.SEP + 'Devuelve la fuerza ejercida en el detector redondo gracias al sensor FSR402 en los pines analógicos A0 a A5.';
Blockly.Msg['SENSORS_GETPULSE_TITLE'] = '[Detector de pulso] valor en el pin%1';
Blockly.Msg['SENSORS_GETPULSE_TOOLTIP'] = IMG_MODULE_PULSE + Blockly.Tooltip.SEP + 'Devuelve el pulso detectado en pines analógicos A0 a A5.';
Blockly.Msg['SENSORS_GETPULSE_BPM_TITLE'] = '[Sensor de pulso] latidos por minuto %1';
Blockly.Msg['SENSORS_GETPULSE_BPM_TOOLTIP'] = IMG_MODULE_PULSE + Blockly.Tooltip.SEP + 'Devuelve el número de latidos por minuto de los pines analógicos A0 a A5.';
Blockly.Msg['SENSORS_VOLTAGE_DIVIDER_GETDATA_TITLE'] = '[Divisor de tensión] divide la tensión %1 por %2 en el pin %3';
Blockly.Msg['SENSORS_VOLTAGE_DIVIDER_GETDATA_TOOLTIP'] = IMG_MODULE_VOLTAGE_DIVDER + Blockly.Tooltip.SEP + 'Devuelve el valor de la tensión en los pines analógicos (A0 a A5). El selector permite especificar el rango de medición: 3 para una tensión entre 0,3V y 12,9V, 10 para una tensión entre 1V y 43V.';
// Actuators
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servo motor] controlar el ángulo en %1 en el pin %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Le permite controlar el ángulo (de 0 a 180 °) de un servomotor en los pines PWM.';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Servo motor continuo] controlar la velocidad a %1 ( %) Dirección %2 en el pin %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Le permite controlar la velocidad (de 0 a 100 %) de un servomotor continuo en pines PWM.';
Blockly.Msg['ACTUATORS_SERVO_DETACH_TITLE'] = '[Servomoteur] parar el motor en el pin %1';
Blockly.Msg['ACTUATORS_SERVO_DETACH_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Le permite parar el servomotor en los pines PWM.';
Blockly.Msg['ACTUATORS_DCMOTOR_SETSPEED_TITLE'] = '[Motor CC] controlar el motor %1 dirección %2 velocidad %3 (%)';
Blockly.Msg['ACTUATORS_DCMOTOR_SETSPEED_TOOLTIP'] = IMG_MODULE_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + 'Le permite controlar la velocidad (de 0 a 100 %) de los motores de corriente continua conectados al controlador de motores.Conecte el módulo a un puerto I2C.';
Blockly.Msg['ACTUATORS_DCMOTOR_STOP_TITLE'] = '[Motor CC] parar el motor %1';
Blockly.Msg['ACTUATORS_DCMOTOR_STOP_TOOLTIP'] = IMG_MODULE_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + 'permite detener los motores de corriente continua conectados al controlador de motores.Conecte el módulo a un puerto I2C.';
Blockly.Msg['ACTUATORS_STEPPERMOTOR_RUN_TITLE'] = '[Motor paso a paso] controlar el número de pasos %1 dirección %2';
Blockly.Msg['ACTUATORS_STEPPERMOTOR_RUN_TOOLTIP'] = IMG_MODULE_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + 'Permite controlar el número de pasos (de 0 a 1024) de un motor paso a paso conectado a los pines Out 1-2-3-4.Conecte el módulo a un puerto I2C.';
Blockly.Msg['ACTUATORS_MINI_I2C_MOTOR_DRIVER_DRIVE_TITLE'] = '[Motor CC] controlar el motor %1 dirección %2 velocidad %3 ( %) para %4 (s)';
Blockly.Msg['ACTUATORS_MINI_I2C_MOTOR_DRIVER_DRIVE_TOOLTIP'] = IMG_MODULE_MINI_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + 'Permite controlar la velocidad (de 0 a 100 %) de los motores de corriente continua conectados al mini controlador de motores (V1.0).Conecte el módulo a un puerto I2C.';
Blockly.Msg['ACTUATORS_MINI_I2C_MOTOR_DRIVER_STOP_TITLE'] = '[Motor CC] parar el motor %1';
Blockly.Msg['ACTUATORS_MINI_I2C_MOTOR_DRIVER_STOP_TOOLTIP'] = IMG_MODULE_MINI_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + 'Permite detener los motores de corriente continua conectados al mini controlador de motores (V1.0).Conecte el módulo a un puerto I2C.';
Blockly.Msg['ACTUATORS_MC33926_MOTOR_SHIELD_SETSPEED_TITLE'] = '[Shield Motores MC33926] controlar el motor %1 dirección %2 velocidad %3';
Blockly.Msg['ACTUATORS_MC33926_MOTOR_SHIELD_SETSPEED_TOOLTIP'] = IMG_MODULE_MC33926_SHIELD_MOTOR + Blockly.Tooltip.SEP + 'Permite controlar la velocidad (de 0 a 400) de los motores de corriente continua conectados al Shield Motor Arduino MC33926.';
Blockly.Msg['ACTUATORS_MC33926_MOTOR_SHIELD_GETCURRENT_TITLE'] = '[Shield Moteurs MC33926] corriente (MA) del motor %1';
Blockly.Msg['ACTUATORS_MC33926_MOTOR_SHIELD_GETCURRENT_TOOLTIP'] = IMG_MODULE_MC33926_SHIELD_MOTOR + Blockly.Tooltip.SEP + 'Devuelve la corriente (en mA) cruzando los motores  de corriente continua conectados al Shield Motor Arduino MC33926.';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Motor de vibración] controlar el %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Permite activar o desactivar el motor de vibración Grove (arriba o hacia abajo) en los pines digitales D0 a D13.';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Módulo relé] controlar el estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Le permite controlar el valor del relé (alto o bajo) en los pines digitales D0 a D13.';
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TITLE'] = '[MOSFET] controlar el estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permite controlar el estado del transitor MOSFET (0 o 1) en un pin PWM.';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TITLE'] = '[MOSFET] Control de potencia a %1 (%) en el pin %2';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Le permite controlar la potencia de salida del transitor MOSFET (de 0 a 100 %) en un pin PWM.';
Blockly.Msg['ACTUATORS_GROVEBUZZER_CONTROLSTATE_TITLE'] = '[Zumbador/Parlantes] controlar el estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEBUZZER_CONTROLSTATE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'El módulo Buzzer Grove se puede conectar a una salida digital y emitirá un tono cuando la salida esté encendida.También se puede conectar a una salida PWM (señalada ~ en Arduino) para generar varias frecuencias (ver otro bloque).';
Blockly.Msg['ACTUATORS_GROVEBUZZER_PLAYNOTE_TITLE'] = '[Zumbador/Parlantes] tocar la nota %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEBUZZER_PLAYNOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Le permite jugar una nota con el módulo de timbres o altavoces en los pines digitales D0 a D13.';
Blockly.Msg['ACTUATORS_GROVEBUZZER_PLAYNOTEDURATION_TITLE'] = '[Zumbador/Parlantes] tocar la nota %1 durante %2 (s) en el pin %3';
Blockly.Msg['ACTUATORS_GROVEBUZZER_PLAYNOTEDURATION_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Le permite jugar una nota con el módulo de timbres o altavoces en los pines digitales D0 a D13.';
Blockly.Msg['ACTUATORS_TONE_TITLE'] = '[Zumbador/Parlantes] jugar la frecuencia %1 (Hz) en el pin %2';
Blockly.Msg['ACTUATORS_TONE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Este bloque le permite jugar una frecuencia dada con un módulo de altavoz o un timbre en los pines digitales D0 a D13.';
Blockly.Msg['ACTUATORS_TONE_DURATION_TITLE'] = '[Zumbador/Parlantes] jugar la frecuencia %1 (Hz) durante %2 (s) en el pin %3';
Blockly.Msg['ACTUATORS_TONE_DURATION_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Este bloque le permite jugar una frecuencia dada con un módulo de altavoz o un timbre en los pines digitales D0 a D13.';
Blockly.Msg['ACTUATORS_NOTONE_TITLE'] = '[Zumbador/Parlantes]cortar el sonido en el pin %1';
Blockly.Msg['ACTUATORS_NOTONE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permite cortar el sonido reproducido en el módulo de timbre de Grove.';
Blockly.Msg['ACTUATORS_GROVEBUZZER_PLAYMUSIC_TITLE'] = '[Zumbador/Parlantes] reproducir música %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEBUZZER_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permite tocar música con el módulo de timbres o altavoces en los pines digitales D0 a D13.';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TITLE'] = '[Atomizador de agua] controlar el estado %1 en el %2';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TOOLTIP'] = IMG_MODULE_WATER_ATOMIZER + Blockly.Tooltip.SEP + 'Permite activar o desactivar el atomizador de agua (superior o inferior) en pines digitales D0 a D13.';
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TITLE'] = '[Electroimanes] controlar el estado %1 en el pin %2';
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TOOLTIP'] = IMG_MODULE_ELECTROMAGNET + Blockly.Tooltip.SEP + 'Le permite activar o desactivar electroimanes (alto o bajo) en pines digitales D0 a D13.';

// IA Sensors
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TITLE'] = 'cargar modelo local';
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TOOLTIP'] = 'Permite cargar un modelo de IA almacenado localmente desde el navegador web.';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TITLE'] = 'cargar el modelo desde la URL %1';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TOOLTIP'] = 'Permite cargar un modelo de IA almacenado en la nube.';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TITLE'] = 'Predicción a partir de datos de sensores';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TIME_WINDOW'] = 'ventana';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TOOLTIP'] = 'Permite realizar una predicción a partir de un sensor. Ajusta la ventana de tiempo si es necesario.';
Blockly.Msg['VITTAIA_SENSOR_ACC'] = 'acelerómetro';
Blockly.Msg['VITTAIA_DETECT_CLASS_TITLE'] = 'si la clase %1 %2 es detectada entonces';
Blockly.Msg['VITTAIA_DETECT_CLASS_TOOLTIP'] = 'Permite detectar la clase de un objeto.';
Blockly.Msg['VITTAIA_IS'] = 'es';
Blockly.Msg['VITTAIA_ISNOT'] = 'no es';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TITLE'] = 'clase detectada';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TOOLTIP'] = 'Permite recuperar la clase con la mayor probabilidad.';
