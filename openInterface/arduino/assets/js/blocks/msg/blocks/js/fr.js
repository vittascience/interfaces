/**
 * @fileoverview English messages for Arduino. (EN)
 */
'use strict';
//COMMENT - Arduino
Blockly.Msg['CALL_EXPRESSION_COMMENT_TITLE'] = 'Commentaire %1';
Blockly.Msg['CALL_EXPRESSION_COMMENT_TOOLTIP'] = 'Permet d\'ajouter un commentaire dans le code.';
// Display - Arduino
Blockly.Msg['DISPLAY_CONTROL_BUILTIN_LED_TITLE'] = '[Arduino] contrôler la LED intégrée (D13) à l\'état %1';
Blockly.Msg['DISPLAY_CONTROL_BUILTIN_LED_TOOLTIP'] = 'Permet de contrôler l\'état de la LED connectée à la broche D13 sur la carte Arduino.';
// Display - Screens
Blockly.Msg['DISPLAY_LCD_SETTEXT_TITLE'] = '[LCD] adresse %1 afficher le texte %2 sur la ligne %3 position %4';
Blockly.Msg['DISPLAY_LCD_SETTEXT_TOOLTIP'] = IMG_MODULE_LCD_I2C + Blockly.Tooltip.SEP + 'Affiche du texte d\'un maximum de 16 caractères sur l\'une des deux lignes de l\'écran LCD1602 grove. Brancher le module sur un port I2C. 0x3e correspond à l\'addresse I2C du module Grove. 0x3f et 0x27 utilisent le module convertisseur I2C PCF8574.';
Blockly.Msg['DISPLAY_LCD_CLEAR_TITLE'] = '[LCD] adresse %1 effacer l\'écran';
Blockly.Msg['DISPLAY_LCD_CLEAR_TOOLTIP'] = IMG_MODULE_LCD_I2C + Blockly.Tooltip.SEP + 'Permet d\'effacer tous les caractères de l\'écran LCD. Brancher le module sur un port I2C. 0x3e correspond à l\'addresse I2C du module Grove. 0x3f et 0x27 utilisent le module convertisseur I2C PCF8574.';
Blockly.Msg['DISPLAY_LCD_SET_DISPLAY_TITLE'] = '[LCD] adresse %1 %2 l\'écran';
Blockly.Msg['DISPLAY_LCD_SET_DISPLAY_TOOLTIP'] = IMG_MODULE_LCD_I2C + Blockly.Tooltip.SEP + 'Permet d\'allumer ou éteindre le rétroéclairage de l\'écran LCD. Brancher le module sur un port I2C. 0x3e correspond à l\'addresse I2C du module Grove. 0x3f et 0x27 utilisent le module convertisseur I2C PCF8574.';
Blockly.Msg['DISPLAY_LCD_SET_DISPLAY_ON'] = 'allumer';
Blockly.Msg['DISPLAY_LCD_SET_DISPLAY_OFF'] = 'éteindre';
Blockly.Msg['DISPLAY_LCD_SETRGBCOLOR_TITLE'] = '[LCD] éclairer l’écran LCD de couleur R %1 G %2 B %3';
Blockly.Msg['DISPLAY_LCD_SETRGBCOLOR_TOOLTIP'] = IMG_MODULE_LCD_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant le rétroéclairage du module Grove LCD 16x2. Donner une valeur entre 0 et 255 pour rouge, vert et bleu. Brancher le module sur un port I2C.';
Blockly.Msg['DISPLAY_LCD_SETPALETTERGBCOLOR_TITLE'] = '[LCD] éclairer l’écran LCD de couleur %1';
Blockly.Msg['DISPLAY_LCD_SETPALETTERGBCOLOR_TOOLTIP'] = IMG_MODULE_LCD_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant le rétroéclairage du module Grove LCD 16x2. Choisir la couleur désirée dans la palette. Brancher le module sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TITLE'] = '[Ecran OLED] afficher le texte %1 à la position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_ADDTEXT_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'écrire du texte sur un écran OLED grove 128x64 px. Brancher l\'afficheur sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TITLE'] = '[Ecran OLED] afficher l\'icône %1 à la position x %2 y %3';
Blockly.Msg['DISPLAY_OLED_DRAWICON_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'afficher une icône, à la position (x,y) sur l\'écran grove OLED 128x64 px. Brancher l\'afficheur sur un port I2C.';
Blockly.Msg['DISPLAY_OLED_DRAWBITMAPLOGO_TITLE'] = '[Ecran OLED] afficher le logo %1';
Blockly.Msg['DISPLAY_OLED_DRAWBITMAPLOGO_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet d\'afficher un logo sur l\'écran grove OLED 128x64 px. Brancher l\'afficheur sur un port I2C.';
Blockly.Msg['LOGO_VITTASCIENCE'] = 'Vittascience';
Blockly.Msg['LOGO_ARDUINO'] = 'Arduino';
Blockly.Msg['LOGO_SEEED'] = 'Seeed';
Blockly.Msg['LOGO_MICROBIT'] = 'Micro:bit';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TITLE'] = '[Ecran OLED] effacer l\'écran';
Blockly.Msg['DISPLAY_OLED_CLEARSCREEN_TOOLTIP'] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + 'Permet de nettoyer l\'écran OLED. Brancher le module sur un port I2C.';
// Display - LED modules
Blockly.Msg['DISPLAY_SETGROVELED_TITLE'] = '[LED] contrôler la LED à l\'état %1 sur la broche %2';
Blockly.Msg['DISPLAY_SETGROVELED_TOOLTIP'] = IMG_MODULE_LED + Blockly.Tooltip.SEP + 'Permet d\'activer ou désactiver la LED Grove (0 ou 1) sur les broches digitales D0 à D13.';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TITLE'] = '[LED] régler la luminosité à %1 sur la broche %2';
Blockly.Msg['DISPLAY_SETLEDINTENSITY_TOOLTIP'] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 255 sur les broches PWM.';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TITLE'] = '[Variable Color LED] régler la luminosité à %1 (%) sur la broche %2';
Blockly.Msg['DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP'] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + 'Permet de régler la luminosité d\'une LED de 0 à 100 % sur les broches PWM. A la premièe utilisation, les valeurs RGB sont fixées à 0. Utiliser un tournevis pour régler les couleurs R, G et B derrière le module.';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TITLE'] = '[Chainable LED] definir %1 LED sur les broches CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Permet de paramétrer la chaîne de LED RGB en définissant le nombre de modules en série sur les broches digitales D0 à D13.';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TITLE'] = '[Chainable LED] contrôler la LED %1 à R %2 G %3 B %4 sur les broches CIN %5 DIN %6';
Blockly.Msg['DISPLAY_CHAINABLE_RGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la DEL RGB, donner une valeur entre 0 et 255 pour Rouge, Vert et Bleu.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TITLE'] = '[Chainable LED] contrôler la LED %1 à %2 sur les broches CIN %3 DIN %4';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur de la DEL RGB, choisir une couleur dans la palette.';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TITLE'] = '[Chainable LED] contrôler toutes les LED à R %1 G %2 B %3 sur les broches CIN %4 DIN %5';
Blockly.Msg['DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur des DEL RGB, donner une valeur entre 0 et 255 pour Rouge, Vert et Bleu.';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE'] = '[Chainable LED] contrôler toutes les LED à %1 sur les broches CIN %2 DIN %3';
Blockly.Msg['DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP'] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + 'Bloc contrôlant la couleur des DEL RGB, choisir une couleur dans la palette.';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TITLE'] = '[Neopixel] définir %1 LED sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_DEFINE_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de définir le nombre de LED du neopixel sur les broches digitales D0 à D13. Ce bloc doit être utilisé dans le setup.';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TITLE'] = '[Neopixel] contrôler la LED %1 à  R %2 G %3 B %4 sur la broche %5';
Blockly.Msg['DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED tel que (R,G,B) de 0 à 255 du module neopixel.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE'] = '[Neopixel] contrôler la LED %1 à %2 sur la broche %3';
Blockly.Msg['DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler la couleur de chaque LED du module neopixel. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE'] = '[Neopixel] contrôler toutes les LED à R %1 G %2 B %3 sur la broche %4';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie telle que (R,G,B) soit de 0 à 255.';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE'] = '[Neopixel] contrôler toutes les LED à %1 sur la broche %2';
Blockly.Msg['DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Permet de contrôler toutes les LED du module neopixel à la couleur choisie. Utiliser la palette pour changer la couleur.';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TITLE'] = '[Neopixel] Arc-en-ciel sur la broche %1';
Blockly.Msg['DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP'] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + 'Afficher le spectre des couleurs sur les LED RGB sur les broches digitales D0 à D13.';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TITLE'] = '[Afficheur 4-digit] afficher le nombre %1 sur les broches CLK %2 DIO %3';
Blockly.Msg['DISPLAY_4DIGIT_SETNUMBER_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher un nombre, une température ou l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales D0 à D13.';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TITLE'] = '[Afficheur 4-digit] l\'horloge sur les broches CLK %1 DIO %2';
Blockly.Msg['DISPLAY_4DIGIT_SETCLOCK_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales D0 à D13. Attention, l\'heure est récupérée lorsque le bloc est ajouté. De plus, elle continue de s\'afficher correctement seulement si la carte arduino reste allumée.';
Blockly.Msg['DISPLAY_4DIGIT_SETTEMP_TITLE'] = '[Afficheur 4-digit] afficher la temperature %1 sur les broches CLK %2 DIO %3';
Blockly.Msg['DISPLAY_4DIGIT_SETTEMP_TOOLTIP'] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + 'Permet d\'afficher l\'horloge sur l\'afficheur 4-digit grove (TM1637) avec les broches digitales D0 à D13. Attention, l\'heure est récupérée lorsque le bloc est ajouté. De plus, elle continue de s\'afficher correctement seulement si la carte arduino reste allumée.';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TITLE'] = '[Module LED Bar] afficher le niveau de %1 sur les broches DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_SET_LEVEL_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Enable to show level of input value on grove LED bar display (MY9221) on digital pins from D0 up through D13.';
Blockly.Msg['DISPLAY_MY9221_SET_GREEN_TO_RED_TITLE'] = '[Module LED Bar] afficher le niveau du %1 sur les broches DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_RED_TO_GREEN'] = 'rouge au vert';
Blockly.Msg['DISPLAY_MY9221_GREEN_TO_RED'] = 'vert au rouge';
Blockly.Msg['DISPLAY_MY9221_SET_GREEN_TO_RED_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permet de changer l\'orientation des LEDs du module bargraphe grove (MY9221), du vert au rouge ou du rouge au vert.';
Blockly.Msg['DISPLAY_MY9221_SET_LED_TITLE'] = '[Module LED Bar] état de la LED n°%1 %2 sur les broches DI %3 DCKI %4';
Blockly.Msg['DISPLAY_MY9221_SET_LED_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Permet piloter chacune des LEDs du module bargraphe grove (MY9221) sur les broches D0 à D13.';
// Input/Output - Arduino
Blockly.Msg['IO_WAIT_TITLE'] = 'attendre %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Effectue une pause dans l\'exécution du code.';
Blockly.Msg['IO_WAIT_SECOND'] = 'seconde(s)';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milliseconde(s)';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microseconde(s)';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'attendre jusqu\'à %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Arrête l\'excution du code jusqu\'à ce que la condition soit satisfaite.';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'démarrer le chronomètre';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Initialise un chronomètre à 0 (en secondes).';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'valeur du chronomètre en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Renvoie la valeur du chronomètre à partir de l\'initialisation (en secondes ou millisecondes).';
Blockly.Msg['IO_GETCHRONOMETER_SIMPLE_TITLE'] = 'valeur du chronomètre';
Blockly.Msg['IO_GETCHRONOMETER_SIMPLE_TOOLTIP'] = 'Renvoie la valeur du chronomètre à partir de l\'initialisation (en secondes).';
// Input/Output - External modules
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TITLE'] = '[Clavier numérique] chiffre sur les broches RX %1 TX %2';
Blockly.Msg['IO_GROVEKEYPAD_GETNUMBER_TOOLTIP'] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + 'Permet d\'obtenir la touche appuyée du clavier numérique grove sur les broches RX et TX. Quand vous connectez le module, s\'assurer que les broches soient \'croisées\' : RX de la carte avec TX du module et inversement.';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TITLE'] = '[Module joytsick] valeur de l\'axe %1 sur les broches X %2 Y %3';
Blockly.Msg['IO_GROVEJOYSTICK_GETAXIS_TOOLTIP'] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'axe X ou Y (de 0 à 1023) du joystick Grove sur les broches analogiques A0 à A5.';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TITLE'] = '[Potentiomètre linéaire] valeur sur la broche %1';
Blockly.Msg['IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP'] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + 'Renvoie la position (de 0 à 1023) du potentiomètre linéaire Grove sur les broches analogiques A0 à A5.';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TITLE'] = '[Potentiomètre rotatif] valeur sur la broche %1';
Blockly.Msg['IO_GETGROVEROTARYANGLE_TOOLTIP'] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + 'Renvoie l\'angle (de 0 à 1023) du potentiomètre rotatif Grove sur les broches A0 à A5.';
Blockly.Msg['IO_GETGROVETACTILE_TITLE'] = '[Capteur tactile] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVETACTILE_TOOLTIP'] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur tactile Grove (0 ou 1) sur les broches digitales D0 à D13.';
Blockly.Msg['IO_GETGROVEBUTTON_TITLE'] = '[Module bouton] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVEBUTTON_TOOLTIP'] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + 'Renvoie la valeur du bouton Grove (0 ou 1) sur les broches digitales D0 à D13.';
Blockly.Msg['IO_GETGROVESWITCH_TITLE'] = '[Module interrupteur] état sur la broche %1 ';
Blockly.Msg['IO_GETGROVESWITCH_TOOLTIP'] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'interrupteur Grove (0 ou 1) sur les broches digitales D0 à D13.';
Blockly.Msg['IO_GROVEMP3_INIT_TITLE'] = '[Module MP3 v3] initialisation sur les broches RX %1 TX %2';
Blockly.Msg['IO_GROVEMP3_INIT_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Initialise le module grove mp3 v3.0 sur les broches RX/TX';
Blockly.Msg['IO_GROVEMP3_PLAY_PAUSE_TITLE'] = '[Module MP3 v3] mettre la lecture sur play/pause';
Blockly.Msg['IO_GROVEMP3_PLAY_PAUSE_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Permet de mettre la lecture sur play/pause';
Blockly.Msg['IO_GROVEMP3_NEXT_TITLE'] = '[Module MP3 v3] passer au morceau suivant';
Blockly.Msg['IO_GROVEMP3_NEXT_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Permet de passer au morceau suivant';
Blockly.Msg['IO_GROVEMP3_PLAY_SD_SONG_TITLE'] = '[Module MP3 v3] lire le morceau %1';
Blockly.Msg['IO_GROVEMP3_PLAY_SD_SONG_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Permet de lire un morceau en indiquant le nom du fichier.';
Blockly.Msg['IO_GROVEMP3_PLAY_SD_DIRECTORY_SONG_TITLE'] = '[Module MP3 v3] lire le morceau du répertoire %1 index %2';
Blockly.Msg['IO_GROVEMP3_PLAY_SD_DIRECTORY_SONG_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Permet de lire un morceau contenu dans un répertoire en indiquant son index.';
Blockly.Msg['IO_GROVEMP3_GET_VOLUME_TITLE'] = '[Module MP3 v3] volume courant';
Blockly.Msg['IO_GROVEMP3_GET_VOLUME_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Retourne le niveau du volume courant';
Blockly.Msg['IO_GROVEMP3_SET_VOLUME_TITLE'] = '[Module MP3 v3] régler le volume %1';
Blockly.Msg['IO_GROVEMP3_SET_VOLUME_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Permet de régler le niveau du volume';
// Input/Output - Pins
Blockly.Msg['IO_LED_BUILTIN_TITLE'] = 'LED intégrée';
Blockly.Msg['IO_LED_BUILTIN_TOOLTIP'] = 'Permet de contrôler l\'état de la LED intégrée à la carte Arduino.';
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'HAUT (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAS (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Retourne une valeur booléene (HAUT ou BAS).';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'état de la broche numérique %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée digitale (0 ou 1).';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'écrire sur la broche numérique %1 l\'état %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Permet d\'écrire une valeur sur une entrée digitale (0 ou 1).';
Blockly.Msg['IO_WRITEANALOGPIN_TITLE'] = 'écrire sur la broche analogique %1 la valeur %2';
Blockly.Msg['IO_WRITEANALOGPIN_TOOLTIP'] = 'Permet d\'écrire une valeur sur une entrée analogique (0-255).';
Blockly.Msg['IO_READANALOGPIN_TITLE'] = 'lire la broche analogique %1';
Blockly.Msg['IO_READANALOGPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée analogique (0-1023).';
Blockly.Msg['IO_SETPWM_TITLE'] = 'appliquer un signal PWM de rapport cyclique %1 (%) sur la broche %2 ';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Permet d\'appliquer un signal PWM sur une broche pwm (~) en paramétrant le rapport cyclique (en %). Pour les broches D3, D9, D10 et D11, la fréquence du signal est de 490 Hz (soit 2.04 ms). Pour les broches D5 et D6, elle est de 980 Hz (soit 1.02 ms).';
Blockly.Msg['IO_READPULSEIN_TITLE'] = 'lire l\'impulsion (μs) de l\'état %1 sur la broche %2';
Blockly.Msg['IO_READPULSEIN_TOOLTIP'] = 'Renvoie la durée de l\'impulsion entrante à l\'état HAUT ou à l\'état BAS (en μs). Fonctionne pour des impulsions de 10 μs à 3 min.';
Blockly.Msg['IO_ATTACH_INTERRUPT_TITLE'] = 'si %1 détécté sur la broche %2 alors';
Blockly.Msg['IO_ATTACH_INTERRUPT_TOOLTIP'] = 'Permet de créer un évènement sur les broches 2 et 3. Ce bloc exécute des instructions à n\'importe quel instant dès qu\'un front montant/descendant ou les deux est détécté sur les broches 2 et 3.';
Blockly.Msg['IO_RISING_EDGE'] = 'front montant';
Blockly.Msg['IO_FALLING_EDGE'] = 'front descendant';
Blockly.Msg['IO_BOTH_EDGE'] = 'changement d\'état';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_BEGIN_TITLE'] = 'initialiser la communication série à %1 bauds';
Blockly.Msg['COMMUNICATION_SERIAL_BEGIN_TOOLTIP'] = 'Initialise la communication série à une vitesse donnée (en bauds).';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'écrire dans la console %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Ce bloc sert à écrire n\'importe quel type de données sur le port série. Elles s\'afficheront alors dans la console lors de l\'exécution du programme.';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'avec';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'saut(s) de ligne';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE'] = 'si une donnée est reçue du port série dans %1 alors';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si une donnée est reçue par le port série dans la variable \'serialData\'.';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'tracer le graphe';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Ce bloc permet d\'écrire des données (numériques) qui seront visibles dans le traceur. Il peut être utilisé avec un ou plusieurs blocs au format "Nom" et "Données". Pour visualiser les graphiques, cliquer sur l\'icone \'Mode Graphique\' dans la console.';
Blockly.Msg['COMMUNICATION_DATA'] = 'Donnée';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nom %1 Valeur %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Ce bloc est à utiliser avec le bloc "Tracer le graphique". Il doit lui-même contenir le nom de la valeur à afficher (texte), et la valeur en question (nombre).';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'jouer la note %1 sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Joue la note selectionnée jusqu\'à l\'exécution du bloc "Fin de la note".';
Blockly.Msg['NOTE_C'] = 'Do';
Blockly.Msg['NOTE_C_SHARP'] = 'Do#';
Blockly.Msg['NOTE_D'] = 'Ré';
Blockly.Msg['NOTE_D_SHARP'] = 'Ré#';
Blockly.Msg['NOTE_E'] = 'Mi';
Blockly.Msg['NOTE_F'] = 'Fa';
Blockly.Msg['NOTE_F_SHARP'] = 'Fa#';
Blockly.Msg['NOTE_G'] = 'Sol';
Blockly.Msg['NOTE_G_SHARP'] = 'Sol#';
Blockly.Msg['NOTE_A'] = 'La';
Blockly.Msg['NOTE_A_SHARP'] = 'La#';
Blockly.Msg['NOTE_B'] = 'Si';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'Jouer la fréquence %1 (Hz) sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Ce bloc permet de jouer une fréquence donnée sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'terminer la note sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Arrête la note en cours.';
// Communication - Data logging
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TITLE'] = '[Openlog] écrire dans la carte SD %1 baudrate %2 sur les broches RXI %3 TXO %4 %5 Données %6';
Blockly.Msg['COMMUNICATION_OPENLOG_WRITE_TOOLTIP'] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + 'Permet d\'écrire des données dans la carte micro SD avec le module Openlog. Fonctionnement en transmission UART.';
Blockly.Msg['COMMUNICATION_SDSPI_WRITE_TITLE'] = '[Module SD SPI] écrire dans la carte SD %1 sur la broche CS %2 %3 Données %4';
Blockly.Msg['COMMUNICATION_SDSPI_WRITE_TOOLTIP'] = IMG_MODULE_SD_SPIMODULE + Blockly.Tooltip.SEP + 'Ce bloc permet d\'écrire des données dans la carte SD avec un module SPI. Avec une carte Arduino UNO, la transmission SPI utilise les broches ICSP ou ISP. Il faut spécifier la broche CS (par exemple D4 pour le shield grove).';
// Communication - Wireless
Blockly.Msg['COMMUNICATION_BLUETOOTH_SETTINGS_TITLE'] = '[Bluetooth] configurer : Nom %1 Mode %2 Code pin %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SETTINGS_TOOLTIP'] = IMG_MODULE_SERIAL_BT + Blockly.Tooltip.SEP + 'Permet de configurer le module série Bluetooth en renseignant le nom, le mode (\'S\' pour esclave et \'M\' pour maitre) et le code pin.';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TITLE'] = '[Bluetooth] envoyer sur les broches RX %1 TX %2 message %3';
Blockly.Msg['COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_SERIAL_BT + Blockly.Tooltip.SEP + 'Permet d\'envoyer des données via le module série BLuetooth sur les broches digitales D0 à D13.';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[Bluetooth] si message reçu sur les broches RX %1 TX %2 dans %3 alors';
Blockly.Msg['COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_SERIAL_BT + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par un module série Bluetooth dans la variable \'bluetoothData\' sur les broches digitales D0 à D13.';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_SENDDATA_TITLE'] = '[HM10 BT] envoyer sur les broches RX %1 TX %2 message %3';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_SENDDATA_TOOLTIP'] = IMG_MODULE_HM10_BT + Blockly.Tooltip.SEP + 'Permet d\'envoyer des données via le module série BLuetooth HM10 sur les broches digitales D0 à D13.';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_ONDATARECEIVED_TITLE'] = '[HM10 BT] si message reçu sur les broches RX %1 TX %2 dans %3 alors';
Blockly.Msg['COMMUNICATION_HM10_BLUETOOTH_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_HM10_BT + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par un module série Bluetooth HM10 dans la variable \'HM10Data\' sur les broches digitales D0 à D13. Par défaut, le module s\'appelle MLT-BT05.';
Blockly.Msg['COMMUNICATION_RADIONRF24_SENDDATA_TITLE'] = '[Radio nRF24L01] envoyer à Adresse %1 Canal %2 sur les broches CE %3 CSN %4 le message %5';
Blockly.Msg['COMMUNICATION_RADIONRF24_SENDDATA_TOOLTIP'] = IMG_MODULE_NRF24L01 + Blockly.Tooltip.SEP + 'Permet d\'envoyer des données sans-fil par le module nRF24L01 à un autre module similaire. Le module fonctionne sur la bande de fréquences 2,4GHz. Avec une carte Arduino UNO, la transmission SPI utilise les broches ICSP ou ISP. Attention, ce module doit être alimenté par une tension 3.3 V.';
Blockly.Msg['COMMUNICATION_RADIONRF24_DATARECEIVER_TITLE'] = '[Radio nRF24L01] si donnée disponible Adresse %1 Canal %2 sur les broches CE %3 CSN %4 dans %5 alors';
Blockly.Msg['COMMUNICATION_RADIONRF24_DATARECEIVER_TOOLTIP'] = IMG_MODULE_NRF24L01 + Blockly.Tooltip.SEP + 'Permet de lire les données reçues par le module nRF24L01. Voir le tutoriel (clic droit sur le bloc puis Aide).';
Blockly.Msg['COMMUNICATION_GROVE_433MHZ_TRANSMITTER'] = '[Radio 315/433MHz] envoyer sur la broche %1 Message %2';
Blockly.Msg['COMMUNICATION_GROVE_433MHZ_TRANSMITTER_TOOLTIP'] = IMG_MODULE_RF433_TRANSMITTER + Blockly.Tooltip.SEP + 'Permet d\'envoyer un message radio grâce au module Grove Radio 433MHz ou 315MHz connecté sur une broche digitale.';
Blockly.Msg['COMMUNICATION_GROVE_433MHZ_RECEIVER'] = '[Radio 315/433MHz] si message reçu sur la broche %1 dans %2 alors';
Blockly.Msg['COMMUNICATION_GROVE_433MHZ_RECEIVER_TOOLTIP'] = IMG_MODULE_RF433_RECEIVER + Blockly.Tooltip.SEP + 'Permet de lire les données reçues par le module Grove Radio 433MHz ou 315MHz. Le bloc renvoie le message texte reçu, ou bien \'No message\'.';
Blockly.Msg['COMMUNICATION_IRRECEIVER_ONDATARECEIVED_TITLE'] = '[Recepteur IR] si donnée reçue sur la broche %1 dans %2 alors';
Blockly.Msg['COMMUNICATION_IRRECEIVER_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par transmission infrarouge dans la variable \'IRData\'. Connecter le récepteur infrarouge sur les broches digitales D0 à D13.';
Blockly.Msg['COMMUNICATION_REMOTECONTROL_ONCOMMANDRECEIVED_TITLE'] = '[Télécommande NEC] si la commande %1 est reçue avec les données %2 alors';
Blockly.Msg['COMMUNICATION_REMOTECONTROL_ONCOMMANDRECEIVED_TOOLTIP'] = IMG_MODULE_BASIC_BLACK_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une des commandes est reçue d\'une télécommande NEC par transmission infrarouge dans la variable \'IRData\'. Utiliser le bloc avec le récepteur infrarouge pour faire fonctionner la transmission.';
Blockly.Msg['REMOTE_NEC_BUTTON'] = 'touche ';
Blockly.Msg['REMOTE_NEC_BUTTON_UP'] = 'haut';
Blockly.Msg['REMOTE_NEC_BUTTON_DOWN'] = 'bas';
Blockly.Msg['REMOTE_NEC_BUTTON_LEFT'] = 'gauche';
Blockly.Msg['REMOTE_NEC_BUTTON_RIGHT'] = 'droit';
Blockly.Msg['REMOTE_NEC_BUTTON_BACK'] = 'Retour';
// Communication - External modules
Blockly.Msg['COMMUNICATION_GPS_ONDATARECEIVED_TITLE'] = '[GPS] si une donnée est reçue sur les broches TX %1 RX %2 dans %3 alors';
Blockly.Msg['COMMUNICATION_GPS_ONDATARECEIVED_TOOLTIP'] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + 'Permet d\'exécuter des instructions si une donnée est reçue par GPS dans la variable \'gpsData\' sur les broches RX/TX.';
Blockly.Msg['COMMUNICATION_RTC_MODULE_PCF85063TP'] = 'Haute Précision (0x51)';
Blockly.Msg['COMMUNICATION_RTC_MODULE_DS1307'] = 'v1.2 (0x68)';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TITLE'] = '[Horloge RTC %1] initialiser à %2 date %3';
Blockly.Msg['COMMUNICATION_GROVERTC_SETDATE_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet d\'initialiser le module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307), pour pouvoir lire la date et l\'heure précise avec le bloc \'Lire le module horloge\'. Placer dans le bloc \'Au démarrage\'. Brancher le module RTC sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['DAY_MONDAY'] = 'lundi';
Blockly.Msg['DAY_TUESDAY'] = 'mardi';
Blockly.Msg['DAY_WEDNESDAY'] = 'mercredi';
Blockly.Msg['DAY_THURSDAY'] = 'jeudi';
Blockly.Msg['DAY_FRIDAY'] = 'vendredi';
Blockly.Msg['DAY_SATURDAY'] = 'samedi';
Blockly.Msg['DAY_SUNDAY'] = 'dimanche';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TITLE'] = '[Horloge RTC %1] initialiser à heure %2 minute %3 seconde %4';
Blockly.Msg['COMMUNICATION_GROVERTC_SETHOUR_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet d\'initialiser le module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307), pour pouvoir lire la date et l\'heure précise avec le bloc \'Lire le module horloge\'. Placer dans le bloc \'Au démarrage\'. Brancher le module sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TITLE'] = '[Horloge RTC %1] lire %2';
Blockly.Msg['COMMUNICATION_GROVERTC_READTIME_TOOLTIP'] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + 'Permet de lire la date et l\'heure du module horloge Grove RTC Haute Précision (PCF85063TP) ou le module RTC v1.2 (DS1307). Pour avoir un résultat correct, utiliser au préalable les deux blocs \'Initialiser le module horloge\'. Brancher le module sur un port I2C. Note: Pour fonctionner, le module DS1307 doit obligatoirement avoir une pile bouton.';
Blockly.Msg['CLOCK_YEAR'] = 'année';
Blockly.Msg['CLOCK_MONTH'] = 'mois';
Blockly.Msg['CLOCK_MONTH_DAY'] = 'jour du mois';
Blockly.Msg['CLOCK_WEEK_DAY'] = 'jour de la semaine';
Blockly.Msg['CLOCK_HOUR'] = 'heure';
Blockly.Msg['CLOCK_MINUTE'] = 'minute';
Blockly.Msg['CLOCK_SECOND'] = 'seconde';
Blockly.Msg['COMMUNICATION_RFID_GETSTRINGCARDID_TITLE'] = '[Lecteur RFID] ID du badge sur les broches RX %1 TX %2';
Blockly.Msg['COMMUNICATION_RFID_GETSTRINGCARDID_TOOLTIP'] = IMG_MODULE_RFID + Blockly.Tooltip.SEP + 'Permet de récupérer l\'identifiant UID sous forme de chaîne de caractères du module Grove RFID 125 kHz si celui si est disponible sur les broches digitales D0 à D13. Afin de vérifier l\'identifiant d\'une carte et le valider ou non, il suffit simplement de le comparer avec la trame de type \'String\' désirée.';
// Sensors - Gas
Blockly.Msg['SENSORS_SGP30_READDATA_TITLE'] = '[Capteur SGP30] gaz %1';
Blockly.Msg['SENSORS_SGP30_READDATA_TOOLTIP'] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + 'Renvoie la quantité de CO2 (en ppm) ou de TVOC (en ppb) contenu dans l\'air grâce au capteur SGP30. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SGP30_CO2'] = 'Dioxyde de carbone (CO2) (ppm)';
Blockly.Msg['SENSORS_SGP30_TVOC'] = 'Composés organiques volatiles (TVOC) (ppb)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TITLE'] = '[Capteur de gaz multicanal] gaz %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNEL_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + 'Renvoie la quantité du gaz mesuré dans l\'air (en ppm) grâce au capteur de gaz multicanal grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TITLE'] = '[Capteur de gaz multicanal v2] gaz %1 (ppm)';
Blockly.Msg['SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP'] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + 'Renvoie la quantité du gaz mesuré dans l\'air (en V) grâce au capteur de gaz multicanal V2 grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['GAS_CO'] = 'Monoxyde de carbone (CO)';
Blockly.Msg['GAS_NO2'] = 'Dioxyde d\'azote (NO2)';
Blockly.Msg['GAS_C2H5OH'] = 'Ethanol (C2H5OH)';
Blockly.Msg['GAS_H2'] = 'Dihydrogène (H2)';
Blockly.Msg['GAS_NH3'] = 'Ammoniac (NH3)';
Blockly.Msg['GAS_CH4'] = 'Méthane (CH4)';
Blockly.Msg['GAS_C3H8'] = 'Propane (C3H8)';
Blockly.Msg['GAS_C4H10'] = 'Iso-propane (C4H10)';
Blockly.Msg['GAS_VOC'] = 'Composés organiques volatiles (COV)';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TITLE'] = '[Capteur de dioxygène] O2 %1 sur la broche %2';
Blockly.Msg['SENSORS_O2_GAS_READDATA_TOOLTIP'] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + 'Renvoie la concentration de dioxygène (O2) dans l\'air (en %) ou la tension de sortie correspondante grâce au capteur de gas O2 grove sur les broches analogiques A0 à A5.';
Blockly.Msg['SENSORS_O2_GAS_CONCENTRATION'] = 'concentration (%)';
Blockly.Msg['SENSORS_O2_GAS_VOUT'] = 'tension de sortie (V)';
Blockly.Msg['SENSORS_SCD30_READDATA_TITLE'] = '[Capteur SCD30] %1';
Blockly.Msg['SENSORS_SCD30_READDATA_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Renvoie la concentration de CO2 dans l\'air (en ppm), l\'humidité (en %) ou la température en Celsius (°C), Fahrenheit (°F) ou Kelvin (K) from the grove SCD30 sensor. Bancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SCD30_CO2'] = 'dioxyde de carbone (CO2) (ppm)';
Blockly.Msg['SENSORS_SCD30_TEMP'] = 'température';
Blockly.Msg['SENSORS_SCD30_HUM'] = 'humidité (%)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TITLE'] = '[Capteur SCD30] forcer la recalibration à %1 (ppm)';
Blockly.Msg['SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP'] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + 'Forcer la calibration du capteur SCD30 à la valeur donnée (en ppm). Se placer en extérieur (là où la concentration est autour de 420 ppm environ, soit un air pur), redémarrer la carte, puis attendre 2 minutes. Conseil: Utiliser un bouton externe sur une entrée digitale de la carte Arduino pour contrôler le lancement de la calibration. Sinon, en rebranchant la carte, le programme se lance et effectue de nouveau une calibration pas forcément souhaitée.';
Blockly.Msg['SENSORS_MQ135_GETGAS_TITLE'] = '[Capteur MQ135] %1 sur la broche %2';
Blockly.Msg['SENSORS_MQ135_GETGAS_TOOLTIP'] = IMG_MODULE_MQ135 + Blockly.Tooltip.SEP + 'Ce bloc utilise le capteur MQ135 pour renvoyer le CO2 dans l\'air. Le capteur est également sensible à d\'autres gas comme le Butane et le Benzène, mais donne une bonne approximation du niveau de CO2. Connecter sur les broches analogiques A0 à A5.';
Blockly.Msg['SENSORS_MQ135_CONCENTRATION'] = 'CO2 (ppm)';
Blockly.Msg['SENSORS_MQ135_RZERO_CALIBRATOR'] = 'résistance de calibration (kΩ)';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TITLE'] = '[Capteur de qualité d\'air] valeur sur la broche %1';
Blockly.Msg['SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Renvoie la valeur de la qualité de l\'air (de 0 à 1023) sur les broches analogiques A0 à A5. Le capteur est Air Quality Sensor v1.3 de Seeed.';
Blockly.Msg['SENSORS_AIR_QUALITY_ONINDEXAS_TITLE'] = '[Capteur de qualité d\'air] si l\'air est %1 sur la broche %2 alors';
Blockly.Msg['SENSORS_AIR_QUALITY_ONINDEXAS_TOOLTIP'] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + 'Exécute des instructions selon la qualité de l\'air mesurée par le capteur de qualité de l\'air grove sur les broches analogiques A0 à A5. Le capteur est Air Quality Sensor v1.3 de Seeed.';
Blockly.Msg['SENSORS_AIR_QUALITY_FA'] = 'sain';
Blockly.Msg['SENSORS_AIR_QUALITY_LP'] = 'peu pollué';
Blockly.Msg['SENSORS_AIR_QUALITY_HP'] = 'polluée';
Blockly.Msg['SENSORS_AIR_QUALITY_VHP'] = 'très polluée';
Blockly.Msg['SENSORS_DUST_READDATA_TITLE'] = '[Capteur de particules] %1 sur la broche %2';
Blockly.Msg['SENSORS_DUST_READDATA_TOOLTIP'] = IMG_MODULE_DUST + Blockly.Tooltip.SEP + 'Renvoie la concentration de particules (diamètre > 1 μm) avec le capteur de particule grove (PPD42) sur les broches digitales D0 à D13.';
Blockly.Msg['SENSORS_DUST_CONCENTRATION'] = 'concentration (pcs/L)';
Blockly.Msg['SENSORS_DUST_RATIO'] = 'ratio (%)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TITLE'] = '[Capteur HM330X] concentration de particules fines %1 (µg/m3)';
Blockly.Msg['SENSORS_HM330X_GETPARTICULE_TOOLTIP'] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + 'Détecte la densité de particules dans l\'air avec le capteur HM330X. Bancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_HM330X_ATM_PM1'] = 'PM1.0';
Blockly.Msg['SENSORS_HM330X_ATM_PM2_5'] = 'PM2.5';
Blockly.Msg['SENSORS_HM330X_ATM_PM10'] = 'PM10.0';
Blockly.Msg['SENSORS_MHZ19_GETDATA_TITLE'] = '[Capteur MH-Z19] %1 sur les broches TX %2 RX %3';
Blockly.Msg['SENSORS_MHZ19_GETDATA_TOOLTIP'] = IMG_MODULE_MHZ19 + Blockly.Tooltip.SEP + 'Ce bloc utilise le capteur MH-Z19 pour renvoyer la quantité de CO2 (en ppm) dans l\'air ou la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K). Ce capteur fonctionne en UART et peut donc être connecté aux broches digitales de D0 à D13.';
Blockly.Msg['SENSORS_MHZ19_CO2'] = 'CO2 (ppm)';
Blockly.Msg['SENSORS_MHZ19_TEMPERATURE'] = 'température';
// Sensors - Climate
Blockly.Msg['SENSORS_TEMPERATURE'] = 'température';
Blockly.Msg['SENSORS_HUMIDITY'] = 'humidité (%)';
Blockly.Msg['SENSORS_TEMPERATURE_IN'] = 'en';
Blockly.Msg['SENSORS_BMP280_READDATA_TITLE'] = '[Capteur BMP280 %1] %2';
Blockly.Msg['SENSORS_BMP280_READDATA_TOOLTIP'] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), la pression (en Pa). L\'altitude (en m) est calculée avec la pression et est initialisée à 0 au début du programme. Le bloc a besoin du capteur Grove BMP280 (addresse: 0x77, couleur: bleu) ou le capteur HW-611 280 (addresse: 0x76, couleur: violet). Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_BMP280_TEMP'] = 'température';
Blockly.Msg['SENSORS_BMP280_PRESS'] = 'pression (Pa)';
Blockly.Msg['SENSORS_BMP280_ALT'] = 'altitude (m)';
Blockly.Msg['SENSORS_DPS310_READDATA_TITLE'] = '[Capteur DPS310] %1';
Blockly.Msg['SENSORS_DPS310_READDATA_TOOLTIP'] = IMG_MODULE_DPS310 + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), et la pression (en Pascal). Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_DPS310_TEMPERATURE'] = 'température';
Blockly.Msg['SENSORS_DPS310_PRESSURE'] = 'pression (Pa)';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TITLE'] = '[Capteur d\'humidité] humidité du sol sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEMOISTURE_TOOLTIP'] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + 'Renvoie l\'humidité (de 0 à 1023) mesurée grâce au capteur d\'humidité grove sur les broches analogiques A0 à A5.';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TITLE'] = '[Capteur de T°] température en %1 sur la broche %2';
Blockly.Msg['SENSORS_GETGROVETEMPERATURE_TOOLTIP'] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) du capteur de température Grove sur les broches analogiques A0 à A5.';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TITLE'] = '[Capteur H.T°] température en %1 sur les broches A1 %2 A0 %3';
Blockly.Msg['SENSORS_GETGROVEHIGHTEMP_TOOLTIP'] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + 'Renvoie la température du thermocouple en degré Celsius (50 à 600 °C), Fahrenheit (°F) ou Kelvin (K) grâce au capteur grove de haute température sur les broches analogiques A0 à A5.';
Blockly.Msg['SENSORS_MAX6675_READTEMP_TITLE'] = '[Capteur MAX6675 & Thermocouple] température en %1 %2 sur les broches SO %3 CS %4 CLK %5';
Blockly.Msg['SENSORS_MAX6675_READTEMP_TOOLTIP'] = IMG_MODULE_MAX6675 + Blockly.Tooltip.SEP + 'Ce bloc utilise le capteur MAX6675 pour renvoyer la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K). Ajouter un délai d\'acquisition supérieur à 0,5 seconde. Les branchements sont spécifiés dans le tutoriel.';
Blockly.Msg['SENSORS_DHT_READDATA_TITLE'] = '[Capteur %1] %2 sur la broche %3';
Blockly.Msg['SENSORS_DHT_READDATA_TOOLTIP'] = IMG_MODULE_DHT11_22 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur dht11 ou dht22 grove sur les broches digitales de D0 à D13.';
Blockly.Msg['SENSORS_TH02_READDATA_TITLE'] = '[Capteur TH02] %1';
Blockly.Msg['SENSORS_TH02_READDATA_TOOLTIP'] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur TH02. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SHT31_READDATA_TITLE'] = '[Capteur SHT31] %1';
Blockly.Msg['SENSORS_SHT31_READDATA_TOOLTIP'] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), ou l\'humidité (en %) grâce au capteur SHT31. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_MPX5700AP_GETPRESSURE_TITLE'] = '[Capteur MPX5700AP] pression (kPa) sur la broche %1';
Blockly.Msg['SENSORS_MPX5700AP_GETPRESSURE_TOOLTIP'] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + 'Renvoie la pression (en kPa) mesurée grâce au capteur grove MPX5700AP sur les broches analogiques A0 à A5.';
Blockly.Msg['SENSORS_BME680_READDATA_TITLE'] = '[Capteur BME680] %1';
Blockly.Msg['SENSORS_BME680_READDATA_TOOLTIP'] = IMG_MODULE_BME680 + Blockly.Tooltip.SEP + 'Renvoie la température ambiante en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K), la pression (en Pa), l\'humidité (en %) ou la quantité de gas (en ‎Ω). Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_BME680_TEMPERATURE'] = 'température';
Blockly.Msg['SENSORS_BME680_PRESSURE'] = 'pression (Pa)';
Blockly.Msg['SENSORS_BME680_HUMIDITY'] = 'humidité (%)';
Blockly.Msg['SENSORS_BME680_GAS'] = 'gas (‎Ω)';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TITLE'] = '[Capteur DS18B20] température en %1 sur la broche %2';
Blockly.Msg['SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP'] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + 'Renvoie la température en degré Celsius (°C), Fahrenheit (°F) ou Kelvin (K) avec le capteur grove DS18B20 sur les broches digitales D0 à D13. Ce capteur est utilisé pour mesurer la température de l\'eau. Plonger l\'extrémité de la sonde afin de mesurer la température de l\'eau. Attention, pour des températures supérieures à 70°C, la sonde ne peut pas mesurer pendant une longue durée.';
Blockly.Msg['SENSORS_GETGROVEWATER_TITLE'] = '[Capteur d\'eau] quantité d\'eau sur la broche %1';
Blockly.Msg['SENSORS_GETGROVEWATER_TOOLTIP'] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + 'Renvoie la quantité d\'eau (de 0 à 1023) mesurée grâce au capteur d\'eau grove sur les broches analogiques A0 à A5.';
Blockly.Msg['SENSORS_GETGROVEWATER_I2C_TITLE'] = '[Capteur d\'eau I2C] quantité d\'eau (%)';
Blockly.Msg['SENSORS_GETGROVEWATER_I2C_TOOLTIP'] = IMG_MODULE_WATER_I2C + Blockly.Tooltip.SEP + 'Renvoie la quantité d\'eau (de 0 à 100%) mesurée grâce au capteur d\'eau I2C grove. Connecter le module sur un port I2C.';
Blockly.Msg['SENSORS_GETRAINGAUGE_TITLE'] = '[Pluviomètre] état sur la broche %1';
Blockly.Msg['SENSORS_GETRAINGAUGE_TOOLTIP'] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + 'Renvoie l\'état du capteur de pluie sur les broches digitales D0 à D13.';
Blockly.Msg['SENSORS_GETANEMOMETER_TITLE'] = '[Anémomètre] état sur la broche %1';
Blockly.Msg['SENSORS_GETANEMOMETER_TOOLTIP'] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + 'Renvoie l\'état de l\'anémomètre (deux fois état HAUT à chaque rotation) sur les broches digitales D0 à D13.';
// Sensors - Sound & Light
Blockly.Msg['SENSORS_GETGROVELIGHT_TITLE'] = '[Capteur de lumière] luminosité sur la broche %1 ';
Blockly.Msg['SENSORS_GETGROVELIGHT_TOOLTIP'] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + 'Renvoie la luminosité (de 0 à 1023) du capteur de lumière Grove sur les broches analogiques A0 à A5.';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TITLE'] = '[Capteur SI1145] luminosité %1';
Blockly.Msg['SENSORS_SI1145_GETLIGHT_TOOLTIP'] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + 'Renvoie l\'indice de lumière ultraviolette, la luminosité visible (en lumen) ou infrarouge (en lumen) grâce au capteur Grove Sunlight ou le capteur GY1145. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_SI1145_UV'] = 'indice UV';
Blockly.Msg['SENSORS_SI1145_VISIBLE'] = 'visible (lumen)';
Blockly.Msg['SENSORS_SI1145_IR'] = 'infrarouge (lumen)';
Blockly.Msg['SENSORS_GETUVINDEX_TITLE'] = '[Capteur ultraviolet] indice UV sur la broche %1 ';
Blockly.Msg['SENSORS_GETUVINDEX_TOOLTIP'] = IMG_MODULE_UV + Blockly.Tooltip.SEP + 'Renvoie l\'indice de la lumière ultraviolette pour des ondes entre 240 et 380 nm du capteur Grove sur les broches analogiques A0 à A5.';
Blockly.Msg['SENSORS_GETGROVESOUND_TITLE'] = '[Capteur de son] niveau sonore sur la broche %1 ';
Blockly.Msg['SENSORS_GETGROVESOUND_TOOLTIP'] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + 'Renvoie le niveau sonore (0 à 1023) avec le capteur de son Grove sur les broches analogiques de A0 à A5.';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TITLE'] = '[Capteur de couleurs] %1';
Blockly.Msg['SENSORS_GROVECOLOR_GETDATA_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Permet de lire le niveau d\'une des trois couleurs primaires avec le capteur de couleur grove, le niveau est compris entre 0 et 10240. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GROVECOLOR_TEMP'] = 'température de la couleur (K)';
Blockly.Msg['SENSORS_GROVECOLOR_LUX'] = 'luminosité (lux)';
Blockly.Msg['SENSORS_GROVECOLOR_ONCOLORDETECTED_TITLE'] = '[Capteur de couleurs] si la couleur %1 est détectée alors';
Blockly.Msg['SENSORS_GROVECOLOR_ONCOLORDETECTED_TOOLTIP'] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + 'Permet de lire le niveau d\'une des trois couleurs primaires avec le capteur de couleur grove, ce bloc teste la valeur maximale des 3 couleurs. Brancher le capteur sur un port I2C.';
Blockly.Msg['COLOR_LEVEL_RED'] = 'niveau de rouge';
Blockly.Msg['COLOR_LEVEL_GREEN'] = 'niveau de vert';
Blockly.Msg['COLOR_LEVEL_BLUE'] = 'niveau de bleu';
Blockly.Msg['COLOR_RED'] = 'rouge';
Blockly.Msg['COLOR_GREEN'] = 'verte';
Blockly.Msg['COLOR_BLUE'] = 'bleue';
Blockly.Msg['SENSORS_CAMERA_SNAPSHOT_TITLE'] = '[Camera] prendre une photo sur broches RX %1 TX %2 %3 [Shield SD] enregistrer la photo sur la broche %4';
Blockly.Msg['SENSORS_CAMERA_SNAPSHOT_TOOLTIP'] = IMG_MODULE_CAMERA + Blockly.Tooltip.SEP + 'Prendre une photo et l\'enregistrer sur une carte microSD branchée sur un lecteur connecté à l\'Arduino. Le shield Grove pour carte SD a la broche CS branchée sur D4.';
// Sensors - Distance & Motion
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TITLE'] = '[Capteur à ultrasons %1] %2';
Blockly.Msg['SENSORS_GETGROVEULTRASONIC_TOOLTIP'] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + 'Renvoie la distance (en cm) ou la durée de l\'aller-retour (en μs) mesurée grâce au capteur à ultrasons sur les broches digitales de D0 à D13. Le capteur Grove utilise une seule broche, le HC-SR04 utilise 2 broches.';
Blockly.Msg['SENSORS_ULTRASONIC_DISTANCE'] = 'distance (cm)';
Blockly.Msg['SENSORS_ULTRASONIC_DURATION'] = 'durée de l\'aller-retour (μs)';
Blockly.Msg['SENSORS_ULTRASONIC_1PIN'] = 'sur la broche';
Blockly.Msg['SENSORS_ULTRASONIC_2PINS'] = 'sur les broches';
Blockly.Msg['SENSORS_GETGESTURE_TITLE'] = '[Capteur de gestes] type de geste';
Blockly.Msg['SENSORS_GETGESTURE_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Renvoie le type de geste analysé (\'right\', \'left\', \'up\', \'down\', \'forward\', \'backward\', \'clockwise\', \'wave\') grâce au capteur de gestes grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TITLE'] = '[Capteur de gestes] si le geste %1 est détecté alors';
Blockly.Msg['SENSORS_ONGESTUREDETECTED_TOOLTIP'] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + 'Exécute des instructions si le geste selectionné est détecté par le capteur de gestes grove. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_GESTURE_RIGHT'] = 'droit';
Blockly.Msg['SENSORS_GESTURE_LEFT'] = 'gauche';
Blockly.Msg['SENSORS_GESTURE_UP'] = 'haut';
Blockly.Msg['SENSORS_GESTURE_DOWN'] = 'bas';
Blockly.Msg['SENSORS_GESTURE_FORWARD'] = 'avant';
Blockly.Msg['SENSORS_GESTURE_BACKWARD'] = 'arrière';
Blockly.Msg['SENSORS_GESTURE_CLOCKWISE'] = 'horaire';
Blockly.Msg['SENSORS_GESTURE_ANTICLOCKWISE'] = 'antihoraire';
Blockly.Msg['SENSORS_GESTURE_WAVE'] = 'onde';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TITLE'] = '[Capteur de ligne noire] état sur la broche %1 ';
Blockly.Msg['SENSORS_GETGROVELINEFINDER_TOOLTIP'] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur de ligne noire grove (0 ou 1) sur les broches digitales D0 à D13.';
Blockly.Msg['SENSORS_GETGROVETILT_TITLE'] = '[Module inclinaison] état sur la broche %1 ';
Blockly.Msg['SENSORS_GETGROVETILT_TOOLTIP'] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + 'Renvoie la valeur de l\'inclinaison du module Grove (0 ou 1) sur les broches digitales D0 à D13.';
Blockly.Msg['SENSORS_GETGROVEMOTION_TITLE'] = '[Capteur de mouvement] état sur la broche %1 ';
Blockly.Msg['SENSORS_GETGROVEMOTION_TOOLTIP'] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + 'Renvoie la valeur du capteur de mouvement Grove PIR Motion (0 ou 1) sur les broches digitales D0 à D13.';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TITLE'] = '[Capteur de vibrations] état sur la broche %1';
Blockly.Msg['SENSORS_GETPIEZOVIBRATION_TOOLTIP'] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + 'Renvoie l\'état de la vibration (0 ou 1) grâce au capteur de vibration piezoélectrique sur les broches digitales D0 à D13.';
// Sensors - Other
Blockly.Msg['SENSORS_INA219_GETDATA_TITLE'] = '[Capteur INA219] %1';
Blockly.Msg['SENSORS_INA219_GETDATA_TOOLTIP'] = IMG_MODULE_INA219 + Blockly.Tooltip.SEP + 'Retourne différents paramètres choisis par l\'utilisateur dont le courant (en mA), la tension (en V) ou la puissance (en mW) grâce au capteur Adafruit INA219. Brancher le capteur sur un port I2C.';
Blockly.Msg['SENSORS_INA219_BUS_VOLTAGE'] = 'bus voltage (V)';
Blockly.Msg['SENSORS_INA219_SHUNT_VOLTAGE'] = 'shunt voltage (mV)';
Blockly.Msg['SENSORS_INA219_LOAD_VOLTAGE'] = 'load voltage (V)';
Blockly.Msg['SENSORS_INA219_CURRENT'] = 'courant (mA)';
Blockly.Msg['SENSORS_INA219_POWER'] = 'puissance (mW)';
Blockly.Msg['SENSORS_FSR402_GETFORCE_TITLE'] = '[Détecteur de force] valeur sur la broche %1';
Blockly.Msg['SENSORS_FSR402_GETFORCE_TOOLTIP'] = IMG_MODULE_FORCE + Blockly.Tooltip.SEP + 'Renvoie la force exercée sur le détecteur rond grâce au capteur FSR402 sur les broches analogiques A0 à A5.';
Blockly.Msg['SENSORS_GETPULSE_TITLE'] = '[Détecteur de pouls] valeur sur la broche %1';
Blockly.Msg['SENSORS_GETPULSE_TOOLTIP'] = IMG_MODULE_PULSE + Blockly.Tooltip.SEP + 'Renvoie le pouls détecté sur les broches analogiques A0 à A5.';
Blockly.Msg['SENSORS_GETPULSE_BPM_TITLE'] = '[Détecteur de pouls] battements par minute %1';
Blockly.Msg['SENSORS_GETPULSE_BPM_TOOLTIP'] = IMG_MODULE_PULSE + Blockly.Tooltip.SEP + 'Renvoie le nombres de battements par minute les broches analogiques A0 à A5.';
Blockly.Msg['SENSORS_VOLTAGE_DIVIDER_GETDATA_TITLE'] = '[Diviseur de tension] diviser la tension  %1 par %2 sur la broche %3';
Blockly.Msg['SENSORS_VOLTAGE_DIVIDER_GETDATA_TOOLTIP'] = IMG_MODULE_VOLTAGE_DIVDER + Blockly.Tooltip.SEP + 'Retourne la valeur de la tension sur les broches analogiques (A0 à A5). Le sélecteur permet d\'indiquer la plage de mesure : 3 pour une tension entre 0,3V et 12,9V, 10 pour une tension entre 1V et 43V.';
// Actuators
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TITLE'] = '[Servomoteur] contrôler l\'angle à %1 sur la broche %2';
Blockly.Msg['ACTUATORS_SERVO_SETANGLE_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler l\'angle (de 0 à 180 °) d\'un servomoteur sur les broches PWM.';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE'] = '[Servomoteur continu] contrôler la vitesse à %1 (%) direction %2 sur la broche %3';
Blockly.Msg['ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP'] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + 'Permet de contrôler la vitesse (de 0 à 100 %) d\'un servomoteur continu sur les broches PWM.';
Blockly.Msg['ACTUATORS_SERVO_DETACH_TITLE'] = '[Servomoteur] arrêter le moteur sur la broche %1';
Blockly.Msg['ACTUATORS_SERVO_DETACH_TOOLTIP'] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + 'Permet de d\'arrêter un servomoteur sur les broches PWM.';
Blockly.Msg['ACTUATORS_DCMOTOR_SETSPEED_TITLE'] = '[Moteur CC] contrôler le moteur %1 direction %2 vitesse %3 (%)';
Blockly.Msg['ACTUATORS_DCMOTOR_SETSPEED_TOOLTIP'] = IMG_MODULE_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + 'Permet de contrôler la vitesse (de 0 à 100 %) des moteurs à courant continu branché sur le driver de moteurs. Brancher le module sur un port I2C.';
Blockly.Msg['ACTUATORS_DCMOTOR_STOP_TITLE'] = '[Moteur CC] arrêter le moteur %1';
Blockly.Msg['ACTUATORS_DCMOTOR_STOP_TOOLTIP'] = IMG_MODULE_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + 'Permet d\'arrêter les moteurs à courant continu branché sur le driver de moteurs. Brancher le module sur un port I2C.';
Blockly.Msg['ACTUATORS_STEPPERMOTOR_RUN_TITLE'] = '[Moteur pas à pas] contrôler le nombre de pas %1 direction %2';
Blockly.Msg['ACTUATORS_STEPPERMOTOR_RUN_TOOLTIP'] = IMG_MODULE_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + 'Permet de contrôler le nombre de pas (de 0 to 1024) d\'un moteur pas à pas branché sur les broches OUT 1-2-3-4. Brancher le module sur un port I2C.';
Blockly.Msg['ACTUATORS_MINI_I2C_MOTOR_DRIVER_DRIVE_TITLE'] = '[Moteur CC] contrôler le moteur %1 direction %2 vitesse %3 (%) pendant %4 (s)';
Blockly.Msg['ACTUATORS_MINI_I2C_MOTOR_DRIVER_DRIVE_TOOLTIP'] = IMG_MODULE_MINI_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + 'Permet de contrôler la vitesse (de 0 à 100 %) des moteurs à courant continu branché sur le mini driver de moteurs (v1.0). Brancher le module sur un port I2C.';
Blockly.Msg['ACTUATORS_MINI_I2C_MOTOR_DRIVER_STOP_TITLE'] = '[Moteur CC] arrêter le moteur %1';
Blockly.Msg['ACTUATORS_MINI_I2C_MOTOR_DRIVER_STOP_TOOLTIP'] = IMG_MODULE_MINI_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + 'Permet d\'arrêter les moteurs à courant continu branché sur le mini driver de moteurs (v1.0). Brancher le module sur un port I2C.';
Blockly.Msg['ACTUATORS_MC33926_MOTOR_SHIELD_SETSPEED_TITLE'] = '[Shield Moteurs MC33926] contrôler le moteur %1 direction %2 vitesse %3';
Blockly.Msg['ACTUATORS_MC33926_MOTOR_SHIELD_SETSPEED_TOOLTIP'] = IMG_MODULE_MC33926_SHIELD_MOTOR + Blockly.Tooltip.SEP + 'Permet de contrôler la vitesse (de 0 à 400) des moteurs à courant continu branchés sur le shield moteur Arduino MC33926.';
Blockly.Msg['ACTUATORS_MC33926_MOTOR_SHIELD_GETCURRENT_TITLE'] = '[Shield Moteurs MC33926] courant (mA) du moteur %1';
Blockly.Msg['ACTUATORS_MC33926_MOTOR_SHIELD_GETCURRENT_TOOLTIP'] = IMG_MODULE_MC33926_SHIELD_MOTOR + Blockly.Tooltip.SEP + 'Renvoie le courant (en mA) traversant les moteurs à courant continu branchés sur le shield moteur Arduino MC33926.';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE'] = '[Moteur à vibration] contrôler le %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP'] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver le moteur à vibration grove (HAUT ou BAS) sur les broches digitales D0 à D13.';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TITLE'] = '[Module relais] contrôler à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVERELAY_CONTROL_TOOLTIP'] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + 'Permet de contrôler la valeur du relais (HAUT ou BAS) sur les broches digitales D0 à D13.';
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TITLE'] = '[MOSFET] contrôler à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_MOSFET_SETSTATE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permet de contrôler l\'état du transitor MOSFET (0 ou 1) sur une broche PWM.';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TITLE'] = '[MOSFET] contrôler la puissance à %1 (%) sur la broche %2';
Blockly.Msg['ACTUATORS_MOSFET_SETPERCENTVALUE_TOOLTIP'] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + 'Permet de contrôler la puissance de sortie du transitor MOSFET (de 0 à 100 %) sur une broche PWM.';
Blockly.Msg['ACTUATORS_GROVEBUZZER_CONTROLSTATE_TITLE'] = '[Buzzer/Speaker] contrôler à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVEBUZZER_CONTROLSTATE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Le module Buzzer Grove peut être connecté à une sortie numérique et émettra une tonalité lorsque la sortie est ON. Il peut aussi être connecté à une sortie PWM (notée ~ sur Arduino) pour générer diverses fréquences (voir autre bloc).';
Blockly.Msg['ACTUATORS_GROVEBUZZER_PLAYNOTE_TITLE'] = '[Buzzer/Speaker] jouer la note %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVEBUZZER_PLAYNOTE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une note avec le module buzzer ou speaker grove sur les broches digitales D0 à D13.';
Blockly.Msg['ACTUATORS_GROVEBUZZER_PLAYNOTEDURATION_TITLE'] = '[Buzzer/Speaker] jouer la note %1 pendant %2 (s) sur la broche %3';
Blockly.Msg['ACTUATORS_GROVEBUZZER_PLAYNOTEDURATION_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une note avec le module buzzer ou speaker grove sur les broches digitales D0 à D13.';
Blockly.Msg['ACTUATORS_TONE_TITLE'] = '[Buzzer/Speaker] jouer la fréquence %1 (Hz) sur la broche %2';
Blockly.Msg['ACTUATORS_TONE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Ce bloc permet de jouer une fréquence donnée avec un module haut-parleur ou un buzzer sur les broches digitales D0 à D13..';
Blockly.Msg['ACTUATORS_TONE_DURATION_TITLE'] = '[Buzzer/Speaker] jouer la fréquence %1 (Hz) pendant %2 (s) sur la broche %3';
Blockly.Msg['ACTUATORS_TONE_DURATION_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Ce bloc permet de jouer une fréquence donnée avec un module haut-parleur ou un buzzer sur les broches digitales D0 à D13..';
Blockly.Msg['ACTUATORS_NOTONE_TITLE'] = '[Buzzer/Speaker] couper le son sur la broche %1';
Blockly.Msg['ACTUATORS_NOTONE_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de couper le son joué sur le module grove Buzzer.';
Blockly.Msg['ACTUATORS_GROVEBUZZER_PLAYMUSIC_TITLE'] = '[Buzzer/Speaker] jouer la musique %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVEBUZZER_PLAYMUSIC_TOOLTIP'] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + 'Permet de jouer une musique avec le module buzzer ou speaker grove sur les broches digitales D0 à D13.';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TITLE'] = '[Atomiseur d\'eau] contrôler à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TOOLTIP'] = IMG_MODULE_WATER_ATOMIZER + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver l\'atomiseur d\'eau (HAUT ou BAS) sur les broches digitales D0 à D13.';
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TITLE'] = '[Electroaimant] contrôler à l\'état %1 sur la broche %2';
Blockly.Msg['ACTUATORS_GROVEELECTROMAGNET_CONTROL_TOOLTIP'] = IMG_MODULE_ELECTROMAGNET + Blockly.Tooltip.SEP + 'Permet d\'activer ou de désactiver l\'électroaimant (HAUT ou BAS) sur les broches digitales D0 à D13.';

// VITTAIA
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TITLE'] = 'charger le modèle local';
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TOOLTIP'] = 'Permet de charger un modèle IA stocké localement depuis le navigateur web.';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TITLE'] = 'charger le modèle depuis l\'url %1';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TOOLTIP'] = 'Permet de charger un modèle IA stocké depuis le cloud.';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TITLE'] = 'Prédiction à partir des données de capteur';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TIME_WINDOW'] = 'fenêtre';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TOOLTIP'] = 'Permet de lancer une prédiction à partir d\'un capteur. Ajuster la fenêtre de temps pour obtenir une prédiction, si nécessaire.';
Blockly.Msg['VITTAIA_SENSOR_ACC'] = 'accéléromètre';
Blockly.Msg['VITTAIA_DETECT_CLASS_TITLE'] = 'si la classe %1 %2 détectée alors';
Blockly.Msg['VITTAIA_DETECT_CLASS_TOOLTIP'] = 'Permet de détecter la classe d\'un objet.';
Blockly.Msg['VITTAIA_IS'] = 'est';
Blockly.Msg['VITTAIA_ISNOT'] = 'n\'est pas';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TITLE'] = 'classe detectée';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TOOLTIP'] = 'Permet de récupérer la classe avec la plus haute probabilité.';