/**
 * @fileoverview English messages for Arduino. (EN)
 */

'use strict';
//COMMENT - Arduino
Blockly.Msg['CALL_EXPRESSION_COMMENT_TITLE'] = 'comment %1';
Blockly.Msg['CALL_EXPRESSION_COMMENT_TOOLTIP'] = 'This block allows you to add a comment to your code.';
// Display - Arduino
Blockly.Msg["DISPLAY_CONTROL_BUILTIN_LED_TITLE"] = "[Arduino] set built-in LED (D13) to state %1";
Blockly.Msg["DISPLAY_CONTROL_BUILTIN_LED_TOOLTIP"] = "Turn on the led (Pin 13) on the Arduino board. This block does not need any sensor or external LED.";
// Display - Screens
Blockly.Msg["DISPLAY_LCD_SETTEXT_TITLE"] = "[LCD] address %1 show text %2 on line %3 position %4";
Blockly.Msg["DISPLAY_LCD_SETTEXT_TOOLTIP"] = IMG_MODULE_LCD_I2C + Blockly.Tooltip.SEP + "Show text on the grove lcd 1602 display. Connect lcd on I2C port. 0x3e is the grove module I2C address. 0x3f and 0x27 use the PCF8574 I2C adapter module.";
Blockly.Msg["DISPLAY_LCD_CLEAR_TITLE"] = "[LCD] address %1 clear display";
Blockly.Msg["DISPLAY_LCD_CLEAR_TOOLTIP"] = IMG_MODULE_LCD_I2C + Blockly.Tooltip.SEP + "Enable to clear the entire lcd text. Connect lcd on I2C port. 0x3e is the grove module I2C address. 0x3f and 0x27 use the PCF8574 I2C adapter module.";
Blockly.Msg["DISPLAY_LCD_SET_DISPLAY_TITLE"] = "[LCD] address %1 set display %2";
Blockly.Msg["DISPLAY_LCD_SET_DISPLAY_TOOLTIP"] = IMG_MODULE_LCD_I2C + Blockly.Tooltip.SEP + "Enable to switch ON/OFF the display. Connect lcd on I2C port. 0x3e is the grove module I2C address. 0x3f and 0x27 use the PCF8574 I2C adapter module.";
Blockly.Msg["DISPLAY_LCD_SET_DISPLAY_ON"] = "on";
Blockly.Msg["DISPLAY_LCD_SET_DISPLAY_OFF"] = "off";
Blockly.Msg["DISPLAY_LCD_SETRGBCOLOR_TITLE"] = "[LCD] illuminate the LCD display in R %1 G %2 B %3";
Blockly.Msg["DISPLAY_LCD_SETRGBCOLOR_TOOLTIP"] = IMG_MODULE_LCD_RGB + Blockly.Tooltip.SEP + "Block controlling the backlight of the Grove LCD 16x2 characters module. Give a value between 0 and 255 for illuminate the display in red, green and blue. Connect LCD on an I2C port.";
Blockly.Msg["DISPLAY_LCD_SETPALETTERGBCOLOR_TITLE"] = "[LCD] illuminate the LCD display in %1";
Blockly.Msg["DISPLAY_LCD_SETPALETTERGBCOLOR_TOOLTIP"] = IMG_MODULE_LCD_RGB + Blockly.Tooltip.SEP + "Block controlling the backlight of the Grove LCD 16x2 characters module. Choice color in palette for illuminate the display. Connect LCD on an I2C port.";
Blockly.Msg["DISPLAY_OLED_ADDTEXT_TITLE"] = "[OLED display] show the text %1 at position x %2 y %3";
Blockly.Msg["DISPLAY_OLED_ADDTEXT_TOOLTIP"] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + "Enable write text on OLED display of size 128x64 px. Connect the OLED display on I2C port.";
Blockly.Msg["DISPLAY_OLED_DRAWICON_TITLE"] = "[OLED display] draw icon %1 at position x %2 y %3";
Blockly.Msg["DISPLAY_OLED_DRAWICON_TOOLTIP"] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + "Enable to draw icon, at position (x,y) on grove OLED display with bitmap array of size 8x8 px (like character). Connect the OLED display on I2C port.";
Blockly.Msg["DISPLAY_OLED_DRAWBITMAPLOGO_TITLE"] = "[OLED display] draw logo %1";
Blockly.Msg["DISPLAY_OLED_DRAWBITMAPLOGO_TOOLTIP"] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + "Enable to draw logo on grove OLED display with bitmap array of size 128x64 px. Connect the OLED display on I2C port.";
Blockly.Msg["LOGO_VITTASCIENCE"] = "Vittascience";
Blockly.Msg["LOGO_ARDUINO"] = "Arduino";
Blockly.Msg["LOGO_SEEED"] = "Seeed";
Blockly.Msg["LOGO_MICROBIT"] = "Micro:bit";
Blockly.Msg["DISPLAY_OLED_CLEARSCREEN_TITLE"] = "[OLED display] clear screen";
Blockly.Msg["DISPLAY_OLED_CLEARSCREEN_TOOLTIP"] = IMG_MODULE_OLED + Blockly.Tooltip.SEP + "Enable to clear the entire grove oled screen. Connect the OLED display on I2C port.";
// Display - LED modules
Blockly.Msg["DISPLAY_SETGROVELED_TITLE"] = "[LED] control LED to state %1 on pin %2";
Blockly.Msg["DISPLAY_SETGROVELED_TOOLTIP"] = IMG_MODULE_LED + Blockly.Tooltip.SEP + "Enable to switch on or switch off the LED socket kit Grove (0 or 1) on digital pins D0 up through D13.";
Blockly.Msg["DISPLAY_SETLEDINTENSITY_TITLE"] = "[LED] set LED intensity to %1 on pin %2";
Blockly.Msg["DISPLAY_SETLEDINTENSITY_TOOLTIP"] = IMG_MODULE_LED_PWM + Blockly.Tooltip.SEP + "Enable to set the LED intensity from 0 to 255 on PWM pins.";
Blockly.Msg["DISPLAY_SET_VARIABLE_COLOR_LED_TITLE"] = "[Variable Color LED] set intensity to %1 (%) on pin %2";
Blockly.Msg["DISPLAY_SET_VARIABLE_COLOR_LED_TOOLTIP"] = IMG_MODULE_LED_VARIABLE_COLOR + Blockly.Tooltip.SEP + "Enable to set the LED intensity from 0 to 100 (%) on PWM pins. When using the module for the first time, RGB are set to 0. Use a screwdriver on R, G or B behind module to control LED color.";
Blockly.Msg["DISPLAY_CHAINABLERGBLED_DEFINE_TITLE"] = "[Chainable LED] define %1 LED on pins CIN %2 DIN %3";
Blockly.Msg["DISPLAY_CHAINABLERGBLED_DEFINE_TOOLTIP"] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + "Enable to define chainable RGB LED with number of LED on digital pins D0 up through D13.";
Blockly.Msg["DISPLAY_CHAINABLE_RGBLED_TITLE"] = "[Chainable LED] set LED %1 at R %2 G %3 B %4 on pins CIN %5 DIN %6";
Blockly.Msg["DISPLAY_CHAINABLE_RGBLED_TOOLTIP"] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + "Block controlling the color of the RGB LED, give a value between 0 and 255 for Red, Green and Blue.";
Blockly.Msg["DISPLAY_CHAINABLE_PALETTERGBLED_TITLE"] = "[Chainable LED] set LED %1 at %2 on pins CIN %3 DIN %4";
Blockly.Msg["DISPLAY_CHAINABLE_PALETTERGBLED_TOOLTIP"] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + "Block controlling the color of the RGB LED, choose a colour in the given palette.";
Blockly.Msg["DISPLAY_CHAINABLE_ALLRGBLED_TITLE"] = "[Chainable LED] set all LED at R %1 G %2 B %3 on pins CIN %4 DIN %5";
Blockly.Msg["DISPLAY_CHAINABLE_ALLRGBLED_TOOLTIP"] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + "Block controlling the color of all the RGB LED, give a value between 0 and 255 for Red, Green and Blue.";
Blockly.Msg["DISPLAY_CHAINABLE_PALETTEALLRGBLED_TITLE"] = "[Chainable LED] set all the LED at %1 on pins CIN %2 DIN %3";
Blockly.Msg["DISPLAY_CHAINABLE_PALETTEALLRGBLED_TOOLTIP"] = IMG_MODULE_LED_RGB + Blockly.Tooltip.SEP + "Block controlling the color of all the LED, choose a colour in the given palette.";
Blockly.Msg["DISPLAY_NEOPIXEL_DEFINE_TITLE"] = "[Neopixel] define %1 LED on pin %2";
Blockly.Msg["DISPLAY_NEOPIXEL_DEFINE_TOOLTIP"] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Enable to define LED number of neopixelon digital pins from D0 up through D13. This block have to be used in setup.";
Blockly.Msg["DISPLAY_NEOPIXEL_LEDCONTROL_TITLE"] = "[Neopixel] set LED %1 at R %2 G %3 B %4 on pin %5";
Blockly.Msg["DISPLAY_NEOPIXEL_LEDCONTROL_TOOLTIP"] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Enable to control each LED color of neopixel as (R,G,B) from 0 to 255 on digital pins from D0 up through D13.";
Blockly.Msg["DISPLAY_NEOPIXEL_SETPALETTECOLOR_TITLE"] = "[Neopixel] set LED %1 at %2 on pin %3";
Blockly.Msg["DISPLAY_NEOPIXEL_SETPALETTECOLOR_TOOLTIP"] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Enable to control each LED color of neopixel on digital pins from D0 up through D13.";
Blockly.Msg["DISPLAY_NEOPIXEL_SETALLLEDRGB_TITLE"] = "[Neopixel] set all LED to colour R %1 G %2 B %3 on pin %4";
Blockly.Msg["DISPLAY_NEOPIXEL_SETALLLEDRGB_TOOLTIP"] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Enable to control all LED of neopixel to the choosed colour value as (R,G,B) from 0 to 255. Use P15 to set Maqueen neopixel.";
Blockly.Msg["DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TITLE"] = "[Neopixel] set all LED to colour %1 on pin %2";
Blockly.Msg["DISPLAY_NEOPIXEL_SETALLLEDCOLOR_TOOLTIP"] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Enable to control all LED of neopixel to the choosed colour value. Use P15 to set Maqueen neopixel.";
Blockly.Msg["DISPLAY_NEOPIXEL_RAINBOW_TITLE"] = "[Neopixel] set a rainbow on pin %1";
Blockly.Msg["DISPLAY_NEOPIXEL_RAINBOW_TOOLTIP"] = IMG_MODULE_NEOPIXEL + Blockly.Tooltip.SEP + "Enable to show a rainbow on neopixel module, set pin and the number of LED.";
Blockly.Msg["DISPLAY_4DIGIT_SETNUMBER_TITLE"] = "[4-Digit module] show %1 on pins CLK %2 DIO %3";
Blockly.Msg["DISPLAY_4DIGIT_SETNUMBER_TOOLTIP"] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + "Enable to show numbers or temperature on grove 4-digit display (TM1637) on digital pins from D0 up through D13.";
Blockly.Msg["DISPLAY_4DIGIT_SETCLOCK_TITLE"] = "[4-Digit module] show clock on pins CLK %1 DIO %2";
Blockly.Msg["DISPLAY_4DIGIT_SETCLOCK_TOOLTIP"] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + "Enable to show clock on grove 4-digit display (TM1637) on digital pins from D0 up through D13. Warning, getting real clock is possible only if arduino stay in power on mode.";
Blockly.Msg["DISPLAY_4DIGIT_SETTEMP_TITLE"] = "[4-Digit module] show temperature %1 on pins CLK %2 DIO %3";
Blockly.Msg["DISPLAY_4DIGIT_SETTEMP_TOOLTIP"] = IMG_MODULE_4DIGITDISPLAY + Blockly.Tooltip.SEP + "Enable to show temperature on grove 4-digit display (TM1637) on digital pins from D0 up through D13.";
Blockly.Msg["DISPLAY_MY9221_SET_LEVEL_TITLE"] = "[LED Bar module] set level of %1 on pins DI %2 DCKI %3";
Blockly.Msg["DISPLAY_MY9221_SET_LEVEL_TOOLTIP"] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + "Enable to show level of input value on grove LED bar display (MY9221) on digital pins from D0 up through D13.";
Blockly.Msg['DISPLAY_MY9221_SET_GREEN_TO_RED_TITLE'] = '[LED Bar Module] Display the level of %1 on pins DI %2 DCKI %3';
Blockly.Msg['DISPLAY_MY9221_RED_TO_GREEN'] = 'red to green';
Blockly.Msg['DISPLAY_MY9221_GREEN_TO_RED'] = 'green to red';
Blockly.Msg['DISPLAY_MY9221_SET_GREEN_TO_RED_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Allows changing the orientation of the LEDs on the Grove bargraph module (MY9221), from green to red or red to green.';
Blockly.Msg['DISPLAY_MY9221_SET_LED_TITLE'] = '[LED Bar Module] State of LED n°%1 %2 on pins DI %3 DCKI %4';
Blockly.Msg['DISPLAY_MY9221_SET_LED_TOOLTIP'] = IMG_MODULE_LED_BAR + Blockly.Tooltip.SEP + 'Allows controlling each LED on the Grove bargraph module (MY9221) on pins D0 to D13.';
// Input/Output - Arduino
Blockly.Msg["IO_WAIT_TITLE"] = "wait %1 %2";
Blockly.Msg["IO_WAIT_TOOLTIP"] = "Stop the code execution (duration in seconds or milliseconds).";
Blockly.Msg["IO_WAIT_SECOND"] = "second(s)";
Blockly.Msg["IO_WAIT_MILLISECOND"] = "millisecond(s)";
Blockly.Msg["IO_WAIT_MICROSECOND"] = "microsecond(s)";
Blockly.Msg["IO_WAIT_UNTIL_TITLE"] = "wait until %1";
Blockly.Msg["IO_WAIT_UNTIL_TOOLTIP"] = "Stop the code execution until the satisfied condition.";
Blockly.Msg["IO_INITCHRONOMETER_TITLE"] = "initialize the chronometer";
Blockly.Msg["IO_INITCHRONOMETER_TOOLTIP"] = "Allows you to initialize the chronometer (in seconds).";
Blockly.Msg["IO_GETCHRONOMETER_TITLE"] = "get chronometer in %1";
Blockly.Msg["IO_GETCHRONOMETER_TOOLTIP"] = "Returns the chronometer value from the initialization in seconds or milliseconds.";
Blockly.Msg['IO_GETCHRONOMETER_SIMPLE_TITLE'] = 'chronometer value';
Blockly.Msg['IO_GETCHRONOMETER_SIMPLE_TOOLTIP'] = 'Returns the chronometer value since initialization (in seconds).';

// Input/Output - External modules
Blockly.Msg["IO_GROVEKEYPAD_GETNUMBER_TITLE"] = "[Numeric Touch Keypad] get number on pins RX %1 TX %2";
Blockly.Msg["IO_GROVEKEYPAD_GETNUMBER_TOOLTIP"] = IMG_MODULE_KEYPAD + Blockly.Tooltip.SEP + "Enable to get touched number from keypad grove module on pins RX & TX. When you connect the device, make sure you “cross” the wires. Arduino TX pin needs to be connected with the device's RX pin, and the RX pin with the device's TX pin.";
Blockly.Msg["IO_GROVEJOYSTICK_GETAXIS_TITLE"] = "[Joystick Module] joystick axis %1 value on pins A0 %2 A1 %3";
Blockly.Msg["IO_GROVEJOYSTICK_GETAXIS_TOOLTIP"] = IMG_MODULE_JOYSTICK + Blockly.Tooltip.SEP + "Returns grove joystick axis value (from 0 to 1023) on analog pins A0 through A5.";
Blockly.Msg["IO_GETGROVESLIDEPOTENTIOMETER_TITLE"] = "[Slide Potentiometer] position value on pin %1";
Blockly.Msg["IO_GETGROVESLIDEPOTENTIOMETER_TOOLTIP"] = IMG_MODULE_SLIDE_POT + Blockly.Tooltip.SEP + "Returns grove slide potentiometer position value (from 0 to 1023) on analog pins A0 up through A5.";
Blockly.Msg["IO_GETGROVEROTARYANGLE_TITLE"] = "[Rotary Angle Module] angle on pin %1";
Blockly.Msg["IO_GETGROVEROTARYANGLE_TOOLTIP"] = IMG_MODULE_ROTARY_ANGLE + Blockly.Tooltip.SEP + "Returns grove rotary angle position (from 0 to 1023) on analog pins A0 up through A5.";
Blockly.Msg["IO_GETGROVETACTILE_TITLE"] = "[Touch Sensor] touch state on pin %1 ";
Blockly.Msg["IO_GETGROVETACTILE_TOOLTIP"] = IMG_MODULE_TOUCH + Blockly.Tooltip.SEP + "Returns grove touch sensor state (0 or 1) on digital pins D0 up through D13.";
Blockly.Msg["IO_GETGROVEBUTTON_TITLE"] = "[Button Module] button state on pin %1 ";
Blockly.Msg["IO_GETGROVEBUTTON_TOOLTIP"] = IMG_MODULE_BUTTON + Blockly.Tooltip.SEP + "Returns grove button state (0 or 1) on digital pins D0 up through D13.";
Blockly.Msg["IO_GETGROVESWITCH_TITLE"] = "[Switch Module] switch state on pin %1 ";
Blockly.Msg["IO_GETGROVESWITCH_TOOLTIP"] = IMG_MODULE_SWITCH + Blockly.Tooltip.SEP + "Returns grove switch state (0 or 1) on digital pins D0 up through D13.";
Blockly.Msg["IO_GROVEMP3_INIT_TITLE"] = "[MP3 Module v3] initialize on RX pin %1 TX pin %2";
Blockly.Msg["IO_GROVEMP3_INIT_TOOLTIP"] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + "Initializes the Grove MP3 v3.0 module on RX/TX pins";
Blockly.Msg["IO_GROVEMP3_PLAY_PAUSE_TITLE"] = "[MP3 Module v3] set play/pause";
Blockly.Msg["IO_GROVEMP3_PLAY_PAUSE_TOOLTIP"] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + "Sets the play/pause state";
Blockly.Msg["IO_GROVEMP3_NEXT_TITLE"] = "[MP3 Module v3] go to next track";
Blockly.Msg["IO_GROVEMP3_NEXT_TOOLTIP"] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + "Goes to the next track";
Blockly.Msg['IO_GROVEMP3_PLAY_SD_SONG_TITLE'] = '[MP3 Module v3] play track %1';
Blockly.Msg['IO_GROVEMP3_PLAY_SD_SONG_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Allows you to play a track by giving the file name.';
Blockly.Msg['IO_GROVEMP3_PLAY_SD_DIRECTORY_SONG_TITLE'] = '[MP3 Module v3] play the track from the folder %1 index %2';
Blockly.Msg['IO_GROVEMP3_PLAY_SD_DIRECTORY_SONG_TOOLTIP'] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + 'Allows you to play a track in a folder by specifying its index.';
Blockly.Msg["IO_GROVEMP3_GET_VOLUME_TITLE"] = "[MP3 Module v3] current volume";
Blockly.Msg["IO_GROVEMP3_GET_VOLUME_TOOLTIP"] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + "Returns the current volume level";
Blockly.Msg["IO_GROVEMP3_SET_VOLUME_TITLE"] = "[MP3 Module v3] set volume %1";
Blockly.Msg["IO_GROVEMP3_SET_VOLUME_TOOLTIP"] = IMG_MODULE_MP3 + Blockly.Tooltip.SEP + "Sets the volume level";
// Input/Output - Pins
Blockly.Msg['IO_LED_BUILTIN_TITLE'] = 'built-in LED';
Blockly.Msg['IO_LED_BUILTIN_TOOLTIP'] = 'This block allows you to control the built-in LED on the Arduino board.';
Blockly.Msg["IO_DIGITAL_SIGNAL_TITLE"] = "%1";
Blockly.Msg["IO_DIGITAL_SIGNAL_HIGH"] = "HIGH (1)";
Blockly.Msg["IO_DIGITAL_SIGNAL_LOW"] = "LOW (0)";
Blockly.Msg["IO_DIGITAL_SIGNAL_TOOLTIP"] = "Returns boolean value (HIGH ou LOW).";
Blockly.Msg["IO_READDIGITALPIN_TITLE"] = "read digital pin %1";
Blockly.Msg["IO_READDIGITALPIN_TOOLTIP"] = "This block reads one of the digital inputs and returns the value.";
Blockly.Msg["IO_WRITEDIGITALPIN_TITLE"] = "write on digital pin %1 state %2";
Blockly.Msg["IO_WRITEDIGITALPIN_TOOLTIP"] = "Enable to write state on digital pin.";
Blockly.Msg["IO_WRITEANALOGPIN_TITLE"] = "write on analog pin %1 value %2";
Blockly.Msg["IO_WRITEANALOGPIN_TOOLTIP"] = "Enable to write on analog pin the value (0-255)."
Blockly.Msg["IO_READANALOGPIN_TITLE"] = "read analog pin %1";
Blockly.Msg["IO_READANALOGPIN_TOOLTIP"] = "Enable to read the analog value of pins (0-1023).";
Blockly.Msg["IO_SETPWM_TITLE"] = "apply pwm signal with duty cycle %1 (%) on pin %2";
Blockly.Msg["IO_SETPWM_TOOLTIP"] = "Apply a PWM signal on pwm pin (~) with duty cycle setting (in %). For pins D3, D9, D10 et D11, signal frequency is 490 Hz (period 2.04 ms). For pins D5 et D6, it's 980 Hz (period 1.02 ms).";
Blockly.Msg["IO_READPULSEIN_TITLE"] = "read pulse in of state %1 on pin %2";
Blockly.Msg["IO_READPULSEIN_TOOLTIP"] = "Returns the duration of pulse in (in μs). Choice state to measure (HIGH or LOW). Works on pulses from 10 μs to 3 min in length.";
Blockly.Msg["IO_ATTACH_INTERRUPT_TITLE"] = "on %1 detected on pin %2 then";
Blockly.Msg["IO_ATTACH_INTERRUPT_TOOLTIP"] = "Enable to set event on pins 2 or 3. This bloc execute instructions at any time as soon as a rising/falling edge or both is detected on pins 2 or 3.";
Blockly.Msg["IO_RISING_EDGE"] = "rising edge";
Blockly.Msg["IO_FALLING_EDGE"] = "falling edge";
Blockly.Msg["IO_BOTH_EDGE"] = "change";

// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_BEGIN_TITLE'] = 'initialize serial communication at %1 bauds';
Blockly.Msg['COMMUNICATION_SERIAL_BEGIN_TOOLTIP'] = 'This block initializes the serial communication at a given baud rate. It must be used in the setup block.';
Blockly.Msg["COMMUNICATION_SERIAL_WRITE_TITLE"] = "write on the serial port %1";
Blockly.Msg["COMMUNICATION_SERIAL_WRITE_TOOLTIP"] = "This block is used to write any type of data on the serial port. They will be displayed in the console when the program is running.";
Blockly.Msg["COMMUNICATION_SERIAL_WRITE_WITH"] = "with";
Blockly.Msg["COMMUNICATION_SERIAL_WRITE_NEWLINES"] = "newline(s)";
Blockly.Msg["COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE"] = "on serial data received in %1 then";
Blockly.Msg["COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP"] = "Allows you to execute instructions if data is received by serial port in the 'serialData' variable.";
Blockly.Msg["COMMUNICATION_WRITEGRAPH_TITLE"] = "show on graph";
Blockly.Msg["COMMUNICATION_WRITEGRAPH_TOOLTIP"] = "This block makes it possible to write (digital) data that will be visible in the plotter. It can be used with one or more blocks in \"Name\" and \"Data\" format.";
Blockly.Msg["COMMUNICATION_DATA"] = "Data";
Blockly.Msg["COMMUNICATION_PRINT_DATAS_TITLE"] = "Name %1 Data %2";
Blockly.Msg["COMMUNICATION_PRINT_DATAS_TOOLTIP"] = "This block is to be used in the \"Write in graphic\" block. It must contain the name of the (text) value to display and the value in question.";
Blockly.Msg["COMMUNICATION_COMPUTER_PLAYNOTE_TITLE"] = "play music %1 in the serial port";
Blockly.Msg["COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP"] = "Play selected note until execution of \"Stop music\" block.";
Blockly.Msg["NOTE_C"] = "C";
Blockly.Msg["NOTE_C_SHARP"] = "C#";
Blockly.Msg["NOTE_D"] = "D";
Blockly.Msg["NOTE_D_SHARP"] = "D#";
Blockly.Msg["NOTE_E"] = "E";
Blockly.Msg["NOTE_F"] = "F";
Blockly.Msg["NOTE_F_SHARP"] = "F#";
Blockly.Msg["NOTE_G"] = "G";
Blockly.Msg["NOTE_G_SHARP"] = "G#";
Blockly.Msg["NOTE_A"] = "A";
Blockly.Msg["NOTE_A_SHARP"] = "A#";
Blockly.Msg["NOTE_B"] = "B";
Blockly.Msg["COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE"] = "play frequency %1 (Hz) on the computer";
Blockly.Msg["COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP"] = "This block allows to play a given frequency on the computer";
Blockly.Msg["COMMUNICATION_COMPUTER_STOPMUSIC_TITLE"] = "stop music of serial port";
Blockly.Msg["COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP"] = "Stop the current note of serial port.";
// Communication - Data logging
Blockly.Msg["COMMUNICATION_OPENLOG_WRITE_TITLE"] = "[Openlog] write on the SD card %1 baudrate %2 on pins RXI %3 TXO %4 %5 Datas %6";
Blockly.Msg["COMMUNICATION_OPENLOG_WRITE_TOOLTIP"] = IMG_MODULE_OPENLOG + Blockly.Tooltip.SEP + "Block enables writing data in the SD card of Openlog module.";
Blockly.Msg["COMMUNICATION_SDSPI_WRITE_TITLE"] = "[SD SPI module] write on the SD card %1 on pin %2 %3 Data %4";
Blockly.Msg["COMMUNICATION_SDSPI_WRITE_TOOLTIP"] = IMG_MODULE_SD_SPIMODULE + Blockly.Tooltip.SEP + "This block allows the data to be written on the microSD card with SPI module. SPI communication uses ICSP or ISP pins. It requires to specify the CS pin (for instance D4 on the shield).";
// Communication - Wireless
Blockly.Msg["COMMUNICATION_BLUETOOTH_SETTINGS_TITLE"] = "[Bluetooth] set name %1 mode %2 pin code %3";
Blockly.Msg["COMMUNICATION_BLUETOOTH_SETTINGS_TOOLTIP"] = IMG_MODULE_SERIAL_BT + Blockly.Tooltip.SEP + "Enable to set 3 parameters (name, mode 'S' for slave or 'M' for master, and pin code) of serial bluetooth module.";
Blockly.Msg["COMMUNICATION_BLUETOOTH_SENDDATA_TITLE"] = "[Bluetooth] send on pins RX %1 TX %2 message %3";
Blockly.Msg["COMMUNICATION_BLUETOOTH_SENDDATA_TOOLTIP"] = IMG_MODULE_SERIAL_BT + Blockly.Tooltip.SEP + "Enable to send any data by serial bluetooth module on digital pins D0 up through D13.";
Blockly.Msg["COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TITLE"] = "[Bluetooth] on message received RX %1 TX %2 in %3 then";
Blockly.Msg["COMMUNICATION_BLUETOOTH_ONDATARECEIVED_TOOLTIP"] = IMG_MODULE_SERIAL_BT + Blockly.Tooltip.SEP + "Allows you to execute instructions on data received by serial bluetooth module in the 'bluetoothData' variable on digital pins D0 up through D13.";
Blockly.Msg["COMMUNICATION_HM10_BLUETOOTH_SENDDATA_TITLE"] = "[HM10 BT] send on pins RX %1 TX %2 message %3";
Blockly.Msg["COMMUNICATION_HM10_BLUETOOTH_SENDDATA_TOOLTIP"] = IMG_MODULE_HM10_BT + Blockly.Tooltip.SEP + "Enable to send any data by serial HM10 bluetooth module on digital pins D0 up through D13.";
Blockly.Msg["COMMUNICATION_HM10_BLUETOOTH_ONDATARECEIVED_TITLE"] = "[HM10 BT] on message received RX %1 TX %2 in %3 then";
Blockly.Msg["COMMUNICATION_HM10_BLUETOOTH_ONDATARECEIVED_TOOLTIP"] = IMG_MODULE_HM10_BT + Blockly.Tooltip.SEP + "Allows you to execute instructions on data received by serial HM10 bluetooth module in the 'HM10Data' variable on digital pins D0 up through D13. As default, the module name is MLT-BT05.";
Blockly.Msg["COMMUNICATION_RADIONRF24_SENDDATA_TITLE"] = "[radio nRF24L01] send to Adress %1 Channel %2 on pins CE %3 CSN %4 the message %5";
Blockly.Msg["COMMUNICATION_RADIONRF24_SENDDATA_TOOLTIP"] = IMG_MODULE_NRF24L01 + Blockly.Tooltip.SEP + "Transmits wireless data through the nRF24L01 module to another similar module. It uses the 2.4 GHz band and it can operate with baud rates from 250 kbps up to 2 Mbps. With Arduino UNO, SPI communication uses ISCP or ISP pins. Warning, the power supply of this module have to be 3.3 V.";
Blockly.Msg["COMMUNICATION_RADIONRF24_DATARECEIVER_TITLE"] = "[radio nRF24L01] on data received Adress %1 Channel %2 on pins CS %3 CSN %4 in %5";
Blockly.Msg["COMMUNICATION_RADIONRF24_DATARECEIVER_TOOLTIP"] = IMG_MODULE_NRF24L01 + Blockly.Tooltip.SEP + "Reads the data received by the nRF24L01 module. See the tutorial (right click on the block then Help). Warning, the power supply of this module has to be 3.3 V.";
Blockly.Msg["COMMUNICATION_GROVE_433MHZ_TRANSMITTER"] = "[Radio 315/433MHz] send on pin %1 Message %2";
Blockly.Msg["COMMUNICATION_GROVE_433MHZ_TRANSMITTER_TOOLTIP"] = IMG_MODULE_RF433_TRANSMITTER + Blockly.Tooltip.SEP + "Send a radio message through the Grove Radio RF 433MHz or 315MHz module.";
Blockly.Msg["COMMUNICATION_GROVE_433MHZ_RECEIVER"] = "[Radio 315/433MHz] on data received on pin %1 in %2";
Blockly.Msg["COMMUNICATION_GROVE_433MHZ_RECEIVER_TOOLTIP"] = IMG_MODULE_RF433_RECEIVER + Blockly.Tooltip.SEP + "Reads data received by the Grove Radio 433MHz or 315MHz module. The block returns the received text message, or 'No message'.";
Blockly.Msg["COMMUNICATION_IRRECEIVER_ONDATARECEIVED_TITLE"] = "[IR Receiver] on infrared data received on pin %1 in %2 then";
Blockly.Msg["COMMUNICATION_IRRECEIVER_ONDATARECEIVED_TOOLTIP"] = IMG_MODULE_IR_RECEIVER + Blockly.Tooltip.SEP + "Allows you to execute instructions on data received by IR transmission in the 'IRData' variable. Connect IR receiver on digital pins D0 up through D13.";
Blockly.Msg["COMMUNICATION_REMOTECONTROL_ONCOMMANDRECEIVED_TITLE"] = "[NEC remote control] if command %1 received with infrared data %2 then";
Blockly.Msg["COMMUNICATION_REMOTECONTROL_ONCOMMANDRECEIVED_TOOLTIP"] = IMG_MODULE_BASIC_BLACK_REMOTE_IR_RECEIVER + Blockly.Tooltip.SEP + "Allows you to execute instructions on command received by IR transmission in 'IRData' variable from NEC remote control. Use IR receiver block to enable IR transmission.";
Blockly.Msg["REMOTE_NEC_BUTTON"] = "pad ";
Blockly.Msg["REMOTE_NEC_BUTTON_UP"] = "up";
Blockly.Msg["REMOTE_NEC_BUTTON_DOWN"] = "down";
Blockly.Msg["REMOTE_NEC_BUTTON_LEFT"] = "left";
Blockly.Msg["REMOTE_NEC_BUTTON_RIGHT"] = "right";
Blockly.Msg["REMOTE_NEC_BUTTON_BACK"] = "back";
// Communication - External modules
Blockly.Msg["COMMUNICATION_GPS_ONDATARECEIVED_TITLE"] = "[GPS module] on data received on pins TX %1 RX %2 in %3 then";
Blockly.Msg["COMMUNICATION_GPS_ONDATARECEIVED_TOOLTIP"] = IMG_MODULE_GPS + Blockly.Tooltip.SEP + "Allows you to execute instructions on data received by GPS grove module in the 'gpsData' variable on pin TX/RX.";
Blockly.Msg["COMMUNICATION_RTC_MODULE_PCF85063TP"] = "High Precision (0x51)";
Blockly.Msg["COMMUNICATION_RTC_MODULE_DS1307"] = "v1.2 (0x68)";
Blockly.Msg["COMMUNICATION_GROVERTC_SETDATE_TITLE"] = "[Clock RTC %1] initialize at %2 date %3";
Blockly.Msg["COMMUNICATION_GROVERTC_SETDATE_TOOLTIP"] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + "Allows you to initialize the Grove High Precision RTC clock module (PCF85063TP) or RTC v1.2 (DS1307) so that you can read the exact date and time using the 'Read clock module' block. Place in the 'on start' block. Connect module on I2C port. Warning: To work, the DS1307 module must have a small flat battery.";
Blockly.Msg["DAY_MONDAY"] = "monday";
Blockly.Msg["DAY_TUESDAY"] = "tuesday";
Blockly.Msg["DAY_WEDNESDAY"] = "wednesday";
Blockly.Msg["DAY_THURSDAY"] = "thursday";
Blockly.Msg["DAY_FRIDAY"] = "friday";
Blockly.Msg["DAY_SATURDAY"] = "saturday";
Blockly.Msg["DAY_SUNDAY"] = "sunday";
Blockly.Msg["COMMUNICATION_GROVERTC_SETHOUR_TITLE"] = "[Clock RTC %1] initialize at hour %2 minute %3 second %4";
Blockly.Msg["COMMUNICATION_GROVERTC_SETHOUR_TOOLTIP"] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + "Allows you to initialize the Grove High Precision RTC clock module (PCF85063TP) or RTC v1.2 (DS1307) so that you can read the exact date and time using the 'Read clock module' block. Place in the 'on start' block. Connect module on I2C port. Warning: To work, the DS1307 module must have a small flat battery.";
Blockly.Msg["COMMUNICATION_GROVERTC_READTIME_TITLE"] = "[Clock RTC %1] read %2";
Blockly.Msg["COMMUNICATION_GROVERTC_READTIME_TOOLTIP"] = IMG_MODULE_RTC + Blockly.Tooltip.SEP + "Read the date and time (choose from the drop-down menu) from Grove High Precision RTC clock module (PCF85063TP) or RTC v1.2 (DS1307). To obtain a correct result, first use the two blocks 'Initialize the clock module'. Connect module on I2C port. Warning: To work, the DS1307 module must have a small flat battery.";
Blockly.Msg["CLOCK_YEAR"] = "year";
Blockly.Msg["CLOCK_MONTH"] = "month";
Blockly.Msg["CLOCK_MONTH_DAY"] = "day of month";
Blockly.Msg["CLOCK_WEEK_DAY"] = "day of week";
Blockly.Msg["CLOCK_HOUR"] = "hour";
Blockly.Msg["CLOCK_MINUTE"] = "minute";
Blockly.Msg["CLOCK_SECOND"] = "second";
Blockly.Msg["COMMUNICATION_RFID_GETSTRINGCARDID_TITLE"] = "[RFID reader] UID card on pins RX %1 TX %2";
Blockly.Msg["COMMUNICATION_RFID_GETSTRINGCARDID_TOOLTIP"] = IMG_MODULE_RFID + Blockly.Tooltip.SEP + "Read the card UID of the Grove RFID module if it's available on digital pins D0 up to D13. In order to verify the UID card and validate it or not, it is enough simply to compare with the frame of type 'String' desired.";

// Sensors - Gas
Blockly.Msg["SENSORS_SGP30_READDATA_TITLE"] = "[SGP30 Sensor] gas %1";
Blockly.Msg["SENSORS_SGP30_READDATA_TOOLTIP"] = IMG_MODULE_SGP30 + Blockly.Tooltip.SEP + "Returns the amount of CO2 (in ppm) or TVOC (in ppb) in the air from sgp30 sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_SGP30_CO2"] = "carbon dioxide (CO2) (ppm)";
Blockly.Msg["SENSORS_SGP30_TVOC"] = "volatile organic compounds (VOC) (ppb)";
Blockly.Msg["SENSORS_MULTICHANNEL_GETGAS_TITLE"] = "[Multichannel Gas Sensor] gas %1 (ppm)";
Blockly.Msg["SENSORS_MULTICHANNEL_GETGAS_TOOLTIP"] = IMG_MODULE_MULTICHANNEL + Blockly.Tooltip.SEP + "Returns the amount of choosen gas in the air (in ppm) from grove multichannel gas sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_MULTICHANNELV2_GETGAS_TITLE"] = "[Multichannel Gas Sensor v2] gas %1 (ppm)";
Blockly.Msg["SENSORS_MULTICHANNELV2_GETGAS_TOOLTIP"] = IMG_MODULE_MULTICHANNEL_V2 + Blockly.Tooltip.SEP + "Returns the amount of choosen gas in the air (in V) from grove multichannel gas V2 sensor. Connect sensor on I2C port.";
Blockly.Msg["GAS_CO"] = "carbon monoxide (CO)";
Blockly.Msg["GAS_NO2"] = "nitrogen dioxide (NO2)";
Blockly.Msg["GAS_C2H5OH"] = "ethanol (C2H5OH)";
Blockly.Msg["GAS_H2"] = "dihydrogen (H2)";
Blockly.Msg["GAS_NH3"] = "ammonia (NH3)";
Blockly.Msg["GAS_CH4"] = "methane (CH4)";
Blockly.Msg["GAS_C3H8"] = "propane (C3H8)";
Blockly.Msg["GAS_C4H10"] = "iso-propane (C4H10)";
Blockly.Msg["GAS_VOC"] = "volatile organic compounds (VOC)";
Blockly.Msg["SENSORS_O2_GAS_READDATA_TITLE"] = "[Oxygen Gas Sensor] O2 %1 on pin %2";
Blockly.Msg["SENSORS_O2_GAS_READDATA_TOOLTIP"] = IMG_MODULE_O2 + Blockly.Tooltip.SEP + "Returns O2 concentration (in %) or voltage output (in V) from the grove O2 sensor on analog pins A0 up through A5.";
Blockly.Msg["SENSORS_O2_GAS_CONCENTRATION"] = "concentration (%)";
Blockly.Msg["SENSORS_O2_GAS_VOUT"] = "output voltage (V)";
Blockly.Msg["SENSORS_SCD30_READDATA_TITLE"] = "[SCD30 Sensor] %1";
Blockly.Msg["SENSORS_SCD30_READDATA_TOOLTIP"] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + "Returns CO2 concentration (in ppm), humidity (in %) or temperature in Celsius (°C), Fahrenheit (°F) or Kelvin (K) from the grove SCD30 sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_SCD30_CO2"] = "carbon dioxide (CO2) (ppm)";
Blockly.Msg["SENSORS_SCD30_TEMP"] = "temperature";
Blockly.Msg["SENSORS_SCD30_HUM"] = "humidity (%)";
Blockly.Msg["SENSORS_SCD30_FORCED_CALIBRATION_TITLE"] = "[Capteur SCD30] force calibration to %1 (ppm)";
Blockly.Msg["SENSORS_SCD30_FORCED_CALIBRATION_TOOLTIP"] = IMG_MODULE_SCD30 + Blockly.Tooltip.SEP + "Force the calibration of the SCD30 sensor to the given value (in ppm). Go outside (where the concentration is around approximately 420 ppm, i.e. clean air), reset the board, then wait 2 minutes. Advice: Use an external button on a digital input of the Arduino board to control the launch of the calibration. Otherwise, by reconnecting the board, the program launches and performs a calibration again that is not necessarily desired.";
Blockly.Msg["SENSORS_MQ135_GETGAS_TITLE"] = "[MQ135 Sensor] %1 on pin %2";
Blockly.Msg["SENSORS_MQ135_GETGAS_TOOLTIP"] = IMG_MODULE_MQ135 + Blockly.Tooltip.SEP + "This block uses the MQ135 sensor to get the CO2 concentration (in ppm) into the air. Connect sensor to power supply during 48h and report the return value of 'resistance for calibration (kΩ)' in the constante RESISTANCE_ZERO. The sensor is also sensitive to other gases such as Butane and Benzene, but gives a good approximation of the CO2 level.";
Blockly.Msg["SENSORS_MQ135_CONCENTRATION"] = "CO2 (ppm)";
Blockly.Msg["SENSORS_MQ135_RZERO_CALIBRATOR"] = "resistance for calibration (kΩ)";
Blockly.Msg["SENSORS_AIR_QUALITY_GETVALUE_TITLE"] = "[Air Quality Sensor] value on pin %1";
Blockly.Msg["SENSORS_AIR_QUALITY_GETVALUE_TOOLTIP"] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + "Returns value of air quality (from 0 to 1023) on analog pins A0 up through A5. Sensor is Air Quality Sensor v1.3 from Seeed.";
Blockly.Msg["SENSORS_AIR_QUALITY_ONINDEXAS_TITLE"] = "[Air Quality Sensor] if air is %1 on pin %2 then";
Blockly.Msg["SENSORS_AIR_QUALITY_ONINDEXAS_TOOLTIP"] = IMG_MODULE_AIR_QUALITY + Blockly.Tooltip.SEP + "Execute instructions based on the air quality index measured by the grove air quality sensor on analog pins A0 through A5. Sensor is Air Quality Sensor v1.3 from Seeed.";
Blockly.Msg["SENSORS_AIR_QUALITY_FA"] = "healthy";
Blockly.Msg["SENSORS_AIR_QUALITY_LP"] = "little polluted";
Blockly.Msg["SENSORS_AIR_QUALITY_HP"] = "polluted";
Blockly.Msg["SENSORS_AIR_QUALITY_VHP"] = "very polluted";
Blockly.Msg["SENSORS_DUST_READDATA_TITLE"] = "[Dust Sensor] %1 on pin %2";
Blockly.Msg["SENSORS_DUST_READDATA_TOOLTIP"] = IMG_MODULE_DUST + Blockly.Tooltip.SEP + "Returns concentration of particles (diameter > 1 μm) from the grove dust sensor (PPD42) on digital pins D0 up through D13.";
Blockly.Msg["SENSORS_DUST_CONCENTRATION"] = "concentration (pcs/L)";
Blockly.Msg["SENSORS_DUST_RATIO"] = "ratio (%)";
Blockly.Msg["SENSORS_HM330X_GETPARTICULE_TITLE"] = "[HM330X Sensor] concentration of particle matter %1 (µg/m3)";
Blockly.Msg["SENSORS_HM330X_GETPARTICULE_TOOLTIP"] = IMG_MODULE_HM330X + Blockly.Tooltip.SEP + "Detect the density of particles in the air with the HM330X sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_HM330X_ATM_PM1"] = "PM1.0";
Blockly.Msg["SENSORS_HM330X_ATM_PM2_5"] = "PM2.5";
Blockly.Msg["SENSORS_HM330X_ATM_PM10"] = "PM10.0";
Blockly.Msg["SENSORS_MHZ19_GETDATA_TITLE"] = "[MH-Z19 Sensor] %1 on pins TX %2 RX %3";
Blockly.Msg["SENSORS_MHZ19_GETDATA_TOOLTIP"] = IMG_MODULE_MHZ19 + Blockly.Tooltip.SEP + "This block uses the MH-Z19 sensor to return the amount of CO2 (in ppm) in air or temperature in Celsius (°C), Fahrenheit (°F) or Kelvin (K). It's a serial sensor and can be connected on digital pins D0 up through D13.";
Blockly.Msg["SENSORS_MHZ19_CO2"] = "CO2 (ppm)";
Blockly.Msg["SENSORS_MHZ19_TEMPERATURE"] = "temperature";
// Sensors - Climate
Blockly.Msg["SENSORS_TEMPERATURE"] = "temperature";
Blockly.Msg["SENSORS_HUMIDITY"] = "humidity (%)";
Blockly.Msg["SENSORS_TEMPERATURE_IN"] = "in";
Blockly.Msg["SENSORS_BMP280_READDATA_TITLE"] = "[BMP280 Sensor %1] %2";
Blockly.Msg["SENSORS_BMP280_READDATA_TOOLTIP"] = IMG_MODULE_BMP280 + Blockly.Tooltip.SEP + "This block uses the BMP280 sensor to return the ambient temperature in Celsius degree (°C), Fahrenheit (°F) or Kelvin (K), the pressure (in Pa), or the altitude (in m). Connect sensor on I2C port.";
Blockly.Msg["SENSORS_BMP280_TEMP"] = "temperature";
Blockly.Msg["SENSORS_BMP280_PRESS"] = "pressure (Pa)";
Blockly.Msg["SENSORS_BMP280_ALT"] = "altitude (m)";
Blockly.Msg["SENSORS_DPS310_READDATA_TITLE"] = "[DPS310 Sensor] %1";
Blockly.Msg["SENSORS_DPS310_READDATA_TOOLTIP"] = IMG_MODULE_DPS310 + Blockly.Tooltip.SEP + "Returns the ambient temperature in Celius degree (°C), Fahrenheit (°F) or Kelvin (K), and pressure (in Pa). Connect sensor on I2C port.";
Blockly.Msg["SENSORS_DPS310_TEMPERATURE"] = "temperature";
Blockly.Msg["SENSORS_DPS310_PRESSURE"] = "pressure (Pa)";
Blockly.Msg["SENSORS_GETGROVEMOISTURE_TITLE"] = "[Moisture Sensor] moisture on pin %1";
Blockly.Msg["SENSORS_GETGROVEMOISTURE_TOOLTIP"] = IMG_MODULE_MOISTURE + Blockly.Tooltip.SEP + "Returns moisture measurement (from 0 to 1023) from the grove moisture sensor on analog pins A0 up through A5.";
Blockly.Msg["SENSORS_GETGROVETEMPERATURE_TITLE"] = "[Temperature Sensor] temperature in %1 on pin %2 ";
Blockly.Msg["SENSORS_GETGROVETEMPERATURE_TOOLTIP"] = IMG_MODULE_TEMPERATURE + Blockly.Tooltip.SEP + "Returns temperature in Celsius (°C), Fahrenheit (°F) or Kelvin (K) from grove sensor on analog pins A0 up through A5.";
Blockly.Msg["SENSORS_GETGROVEHIGHTEMP_TITLE"] = "[H.T° Sensor] temperature in %1 on pins A1 %2 A0 %3";
Blockly.Msg["SENSORS_GETGROVEHIGHTEMP_TOOLTIP"] = IMG_MODULE_HIGH_TEMPERATURE + Blockly.Tooltip.SEP + "Returns thermocouple temperature in Celsius (50 to 600°C), Fahrenheit (°F) or Kelvin (K) with grove high temperature sensor. Connect sensor on analog pins A0 up through A5.";
Blockly.Msg["SENSORS_MAX6675_READTEMP_TITLE"] = "[MAX6675 Sensor & Thermocouple] temperature in %1 %2 on pins SO %3 CS %4 CLK %5";
Blockly.Msg["SENSORS_MAX6675_READTEMP_TOOLTIP"] = IMG_MODULE_MAX6675 + Blockly.Tooltip.SEP + "This block uses the MAX6675 sensor and thermocouple to return the temperature in Celsius (°C), Fahrenheit (°F) or Kelvin (K). Set an acquisition time more than 0.5 seconds.";
Blockly.Msg["SENSORS_DHT_READDATA_TITLE"] = "[%1 Sensor] %2 on pin %3";
Blockly.Msg["SENSORS_DHT_READDATA_TOOLTIP"] = IMG_MODULE_DHT11_22 + Blockly.Tooltip.SEP + "Returns temperature in Celsius degree (°C), Fahrenheit (°F) or Kelvin (K), or air humidity (in %) from dht11 or dht22 sensor on digital pins DO up through D13.";
Blockly.Msg["SENSORS_TH02_READDATA_TITLE"] = "[TH02 Sensor] %1";
Blockly.Msg["SENSORS_TH02_READDATA_TOOLTIP"] = IMG_MODULE_TH02 + Blockly.Tooltip.SEP + "Returns temperature in Celsius degree (°C), Fahrenheit (°F) or Kelvin (K), or air humidity (in %) from TH02 sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_SHT31_READDATA_TITLE"] = "[SHT31 Sensor] %1";
Blockly.Msg["SENSORS_SHT31_READDATA_TOOLTIP"] = IMG_MODULE_SHT31 + Blockly.Tooltip.SEP + "Returns temperature in Celsius degree (°C), Fahrenheit (°F) or Kelvin (K), or air humidity (in %) from SHT31 sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_MPX5700AP_GETPRESSURE_TITLE"] = "[MPX5700AP Sensor] pressure (kPa) on pin %1";
Blockly.Msg["SENSORS_MPX5700AP_GETPRESSURE_TOOLTIP"] = IMG_MODULE_MPX5700AP + Blockly.Tooltip.SEP + "Returns pressure measurement (in kPa) from the pressure sensor grove MPX5700AP on analog pins A0 up through A5.";
Blockly.Msg["SENSORS_BME680_READDATA_TITLE"] = "[BME680 Sensor] %1";
Blockly.Msg["SENSORS_BME680_READDATA_TOOLTIP"] = IMG_MODULE_BME680 + Blockly.Tooltip.SEP + "This block uses the BME680 sensor to return the ambient temperature in Celsius (°C), Fahrenheit (°F) or Kelvin (K), the pressure (in Pa), the humidity (in %) or the gas (in Ω). Connect sensor on I2C port.";
Blockly.Msg["SENSORS_BME680_TEMPERATURE"] = "temperature";
Blockly.Msg["SENSORS_BME680_PRESSURE"] = "pressure (Pa)";
Blockly.Msg["SENSORS_BME680_HUMIDITY"] = "humidity (%)";
Blockly.Msg["SENSORS_BME680_GAS"] = "gas (Ω)";
Blockly.Msg["SENSORS_DS18B20_GETTEMPERATURE_TITLE"] = "[DS18B20 Sensor] temperature in %1 on pin %2";
Blockly.Msg["SENSORS_DS18B20_GETTEMPERATURE_TOOLTIP"] = IMG_MODULE_DS18B20 + Blockly.Tooltip.SEP + "Returns the temperature in Celsius (°C), Fahrenheit (°F) or Kelvin (K) with the DS18B20 grove sensor on digital pins D0 to D13. This sensor is used to measure the water temperature. Dive exerted from the probe to measure the water temperature. Please note, for temperatures over 70°C, the probe cannot measure for a long time.";
Blockly.Msg["SENSORS_GETGROVEWATER_TITLE"] = "[Water Sensor] water amount on pin %1";
Blockly.Msg["SENSORS_GETGROVEWATER_TOOLTIP"] = IMG_MODULE_WATER + Blockly.Tooltip.SEP + "Returns water amount (from 0 to 1023) from the grove water sensor on analog pins A0 up through A5.";
Blockly.Msg["SENSORS_GETGROVEWATER_I2C_TITLE"] = "[Water Sensor I2C] water amount (%)";
Blockly.Msg["SENSORS_GETGROVEWATER_I2C_TOOLTIP"] = IMG_MODULE_WATER_I2C + Blockly.Tooltip.SEP + "Returns water amount (from 0 to 100 %) from the grove I2C water sensor. Connect sensor on I2C port";
Blockly.Msg["SENSORS_GETRAINGAUGE_TITLE"] = "[Rain Gauge Sensor] state value on pin %1 ";
Blockly.Msg["SENSORS_GETRAINGAUGE_TOOLTIP"] = IMG_MODULE_RAIN_GAUGE + Blockly.Tooltip.SEP + "Returns rain gauge grove state (1 if it's raining or 0 else) on digital pins D0 up through D13.";
Blockly.Msg["SENSORS_GETANEMOMETER_TITLE"] = "[Anemometer] state value on pin %1 ";
Blockly.Msg["SENSORS_GETANEMOMETER_TOOLTIP"] = IMG_MODULE_ANEMOMETER + Blockly.Tooltip.SEP + "Returns grove anemometer state (twice state HIGH on each rotation) on digital pins D0 up through D13.";
// Sensors - Sound & Light
Blockly.Msg["SENSORS_GETGROVELIGHT_TITLE"] = "[Light Sensor] light level on pin %1 ";
Blockly.Msg["SENSORS_GETGROVELIGHT_TOOLTIP"] = IMG_MODULE_LIGHT + Blockly.Tooltip.SEP + "Returns grove light sensor value (from 0 to 1023) on analog pins A0 to A5.";
Blockly.Msg["SENSORS_SI1145_GETLIGHT_TITLE"] = "[SI1145 Sensor] get light %1";
Blockly.Msg["SENSORS_SI1145_GETLIGHT_TOOLTIP"] = IMG_MODULE_SI1145 + Blockly.Tooltip.SEP + "Returns Ultraviolet light index, IR light (in lumen) or Visible light (in lumen) from si1145 sensor. It works with Grove Sunlight Sensor or GY1145 sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_SI1145_UV"] = "UV index";
Blockly.Msg["SENSORS_SI1145_VISIBLE"] = "visible (lumen)";
Blockly.Msg["SENSORS_SI1145_IR"] = "infrared (lumen)";
Blockly.Msg["SENSORS_GETUVINDEX_TITLE"] = "[Ultraviolet Sensor] UV index on pin %1";
Blockly.Msg["SENSORS_GETUVINDEX_TOOLTIP"] = IMG_MODULE_UV + Blockly.Tooltip.SEP + "Returns UV index, for waves between 240 nm and 380 nm, with UV grove sensor on analog pins A0 to A5.";
Blockly.Msg["SENSORS_GETGROVESOUND_TITLE"] = "[Sound Sensor] sound level (dB) on pin %1 ";
Blockly.Msg["SENSORS_GETGROVESOUND_TOOLTIP"] = IMG_MODULE_SOUND_LOUDNESS + Blockly.Tooltip.SEP + "Returns grove sound sensor value (from 0 to 1023 converted in dB) on analog pins A0 to A5.";
Blockly.Msg["SENSORS_GROVECOLOR_GETDATA_TITLE"] = "[Color Sensor] %1";
Blockly.Msg["SENSORS_GROVECOLOR_GETDATA_TOOLTIP"] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + "Lets you read the level of one of the three primary colors with the Grove color sensor, returns a level between 0 and 10240.";
Blockly.Msg["SENSORS_GROVECOLOR_TEMP"] = "color temperature (K)";
Blockly.Msg["SENSORS_GROVECOLOR_LUX"] = "luminosity (lux)";
Blockly.Msg["SENSORS_GROVECOLOR_ONCOLORDETECTED_TITLE"] = "[Color Sensor] on color %1 detected then";
Blockly.Msg["SENSORS_GROVECOLOR_ONCOLORDETECTED_TOOLTIP"] = IMG_MODULE_I2C_COLOR + Blockly.Tooltip.SEP + "Lets you read the level of one of the three primary colors with the Grove color sensor, this block test the maximum value.";
Blockly.Msg["COLOR_LEVEL_RED"] = "red level";
Blockly.Msg["COLOR_LEVEL_GREEN"] = "green level";
Blockly.Msg["COLOR_LEVEL_BLUE"] = "blue level";
Blockly.Msg["COLOR_RED"] = "red";
Blockly.Msg["COLOR_GREEN"] = "green";
Blockly.Msg["COLOR_BLUE"] = "blue";
Blockly.Msg["SENSORS_CAMERA_SNAPSHOT_TITLE"] = " [Camera module] Take a picture on pins RX %1 TX %2 %3 [SD Shield] Save to a microSD card on pin %4";
Blockly.Msg["SENSORS_CAMERA_SNAPSHOT_TOOLTIP"] = IMG_MODULE_CAMERA + Blockly.Tooltip.SEP + "Take a picture and save it to a microSD card connected to a drive connected to the Arduino. The SD Grove Shield has the pin plugged to D4.";
// Sensors - Distance & Motion
Blockly.Msg["SENSORS_GETGROVEULTRASONIC_TITLE"] = "[Ultrasonic Sensor %1] %2";
Blockly.Msg["SENSORS_GETGROVEULTRASONIC_TOOLTIP"] = IMG_MODULE_ULTRASONIC + Blockly.Tooltip.SEP + "Returns distance measurement (in cm) or the duration of round trip (in μs) from the ultrasonic ranger sensor on digital pins D0 to D13. The grove sensor uses only one pin, the HC-SR04 uses 2 pins.";
Blockly.Msg["SENSORS_ULTRASONIC_DISTANCE"] = "distance (cm)";
Blockly.Msg["SENSORS_ULTRASONIC_DURATION"] = "round-trip duration (μs)";
Blockly.Msg["SENSORS_ULTRASONIC_1PIN"] = "on pin";
Blockly.Msg["SENSORS_ULTRASONIC_2PINS"] = "on pins ";
Blockly.Msg["SENSORS_GETGESTURE_TITLE"] = "[Gesture Sensor] gesture type";
Blockly.Msg["SENSORS_GETGESTURE_TOOLTIP"] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + "Returns the gesture type ('right', 'left', 'up', 'down', 'forward', 'backward', 'clockwise', 'wave') from grove gesture sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_ONGESTUREDETECTED_TITLE"] = "[Gesture Sensor] on gesture %1 detected then";
Blockly.Msg["SENSORS_ONGESTUREDETECTED_TOOLTIP"] = IMG_MODULE_GESTURE + Blockly.Tooltip.SEP + "Execute instructions if selected gesture id detected by the grove gesture sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_GESTURE_RIGHT"] = "right";
Blockly.Msg["SENSORS_GESTURE_LEFT"] = "left";
Blockly.Msg["SENSORS_GESTURE_UP"] = "up";
Blockly.Msg["SENSORS_GESTURE_DOWN"] = "down";
Blockly.Msg["SENSORS_GESTURE_FORWARD"] = "forward";
Blockly.Msg["SENSORS_GESTURE_BACKWARD"] = "backward";
Blockly.Msg["SENSORS_GESTURE_CLOCKWISE"] = "clockwise";
Blockly.Msg["SENSORS_GESTURE_ANTICLOCKWISE"] = "anticlockwise";
Blockly.Msg["SENSORS_GESTURE_WAVE"] = "wave";
Blockly.Msg["SENSORS_GETGROVELINEFINDER_TITLE"] = "[Line Finder Sensor] line finder state on pin %1 ";
Blockly.Msg["SENSORS_GETGROVELINEFINDER_TOOLTIP"] = IMG_MODULE_LINE_FINDER + Blockly.Tooltip.SEP + "Returns grove touch sensor state (0 or 1) on digital pins D0 up through D13.";
Blockly.Msg["SENSORS_GETGROVETILT_TITLE"] = "[Tilt Module] tilt state on pin %1 ";
Blockly.Msg["SENSORS_GETGROVETILT_TOOLTIP"] = IMG_MODULE_TILT + Blockly.Tooltip.SEP + "Returns grove tilt state (0 or 1) on digital pins D0 up through D13.";
Blockly.Msg["SENSORS_GETGROVEMOTION_TITLE"] = "[PIR Motion Sensor] movement state value on pin %1 ";
Blockly.Msg["SENSORS_GETGROVEMOTION_TOOLTIP"] = IMG_MODULE_MOTION + Blockly.Tooltip.SEP + "Returns grove PIR Motion state (0 if there is movement or 1 else) on digital pins D0 up through D13.";
Blockly.Msg["SENSORS_GETPIEZOVIBRATION_TITLE"] = "[Piezo Vibration sensor] state value on pin %1 ";
Blockly.Msg["SENSORS_GETPIEZOVIBRATION_TOOLTIP"] = IMG_MODULE_VIBRATIONS + Blockly.Tooltip.SEP + "Returns vibration state (0 or 1) from piezo vibration grove sensor on digital pins D0 up through D13.";
// Sensors - Other
Blockly.Msg["SENSORS_INA219_GETDATA_TITLE"] = "[INA219 Sensor] %1";
Blockly.Msg["SENSORS_INA219_GETDATA_TOOLTIP"] = IMG_MODULE_INA219 + Blockly.Tooltip.SEP + "Returns parameter choosen by user as voltage (in V), current (in mA) or power (in mW) wih the Adafruit INA219 sensor. Connect sensor on I2C port.";
Blockly.Msg["SENSORS_INA219_BUS_VOLTAGE"] = "bus voltage (V)";
Blockly.Msg["SENSORS_INA219_SHUNT_VOLTAGE"] = "shunt voltage (mV)";
Blockly.Msg["SENSORS_INA219_LOAD_VOLTAGE"] = "load voltage (V)";
Blockly.Msg["SENSORS_INA219_CURRENT"] = "current (mA)";
Blockly.Msg["SENSORS_INA219_POWER"] = "power (mW)";
Blockly.Msg["SENSORS_FSR402_GETFORCE_TITLE"] = "[Force Sensor] value on pin %1";
Blockly.Msg["SENSORS_FSR402_GETFORCE_TOOLTIP"] = IMG_MODULE_FORCE + Blockly.Tooltip.SEP + "Returns force exerted on round detector from 0 to 1024 with the grove force sensor (FSR402) on analog pin A0 to A5.";
Blockly.Msg["SENSORS_GETPULSE_TITLE"] = "[Pulse Sensor] value on pin %1";
Blockly.Msg["SENSORS_GETPULSE_TOOLTIP"] = IMG_MODULE_PULSE + Blockly.Tooltip.SEP + "Returns pulse value from 0 to 1024 with the grove force sensor on analog pin A0 to A5.";
Blockly.Msg['SENSORS_GETPULSE_BPM_TITLE'] = '[Pulse Sensor] beats per minute %1';
Blockly.Msg['SENSORS_GETPULSE_BPM_TOOLTIP'] = IMG_MODULE_PULSE + Blockly.Tooltip.SEP + 'Returns the number of beats per minute from analog pins A0 to A5.';
Blockly.Msg['SENSORS_VOLTAGE_DIVIDER_GETDATA_TITLE'] = '[Voltage Divider] divide voltage %1 by %2 on pin %3';
Blockly.Msg['SENSORS_VOLTAGE_DIVIDER_GETDATA_TOOLTIP'] = IMG_MODULE_VOLTAGE_DIVDER + Blockly.Tooltip.SEP + 'Returns the voltage value on analog pins (A0 to A5). The selector allows specifying the measurement range: 3 for a voltage between 0.3V and 12.9V, 10 for a voltage between 1V and 43V.';
// Actuators
Blockly.Msg["ACTUATORS_SERVO_SETANGLE_TITLE"] = "[Servomotor] set angle to %1 on pin %2";
Blockly.Msg["ACTUATORS_SERVO_SETANGLE_TOOLTIP"] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + "Enable to control servo angle (from 0 to 180 °) on digital PWM pins.";
Blockly.Msg["ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TITLE"] = "[Continuous Servomotor] set speed to %1 (%) direction %2 on pin %3";
Blockly.Msg["ACTUATORS_CONTINUOUS_SERVO_SETSPEED_TOOLTIP"] = IMG_MODULE_CONTINUOUS_SERVO + Blockly.Tooltip.SEP + "Enable to control continuous servo speed (from 0 to 100 %) on PWM pins.";
Blockly.Msg["ACTUATORS_SERVO_DETACH_TITLE"] = "[Servomotor] stop the motor on pin %1";
Blockly.Msg["ACTUATORS_SERVO_DETACH_TOOLTIP"] = IMG_MODULE_SERVO + Blockly.Tooltip.SEP + "Stop servomotor on PWM pins.";
Blockly.Msg["ACTUATORS_DCMOTOR_SETSPEED_TITLE"] = "[DC Motor] control motor %1 direction %2 speed %3 (%)";
Blockly.Msg["ACTUATORS_DCMOTOR_SETSPEED_TOOLTIP"] = IMG_MODULE_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + "Enable to control speed (from 0 to 100 %) of DC motors plugged on motor driver. Connect motor driver on I2C port.";
Blockly.Msg["ACTUATORS_DCMOTOR_STOP_TITLE"] = "[DC Motor] stop motor %1";
Blockly.Msg["ACTUATORS_DCMOTOR_STOP_TOOLTIP"] = IMG_MODULE_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + "Enable to stop DC motors plugged on motor driver. Connect motor driver on I2C port.";
Blockly.Msg["ACTUATORS_STEPPERMOTOR_RUN_TITLE"] = "[Stepper Motor] control step motor %1 direction %2";
Blockly.Msg["ACTUATORS_STEPPERMOTOR_RUN_TOOLTIP"] = IMG_MODULE_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + "Enable to control step (from 0 to 1024) of stepper motors plugged on motor driver pins OUT 1-2-3-4. Connect motor driver on I2C port.";
Blockly.Msg["ACTUATORS_MINI_I2C_MOTOR_DRIVER_DRIVE_TITLE"] = "[DC Motor] control motor %1 direction %2 speed %3 (%) duration %4 (s)";
Blockly.Msg["ACTUATORS_MINI_I2C_MOTOR_DRIVER_DRIVE_TOOLTIP"] = IMG_MODULE_MINI_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + "Enable to control speed (from 0 to 100 %) of DC motors plugged on mini motor driver. Connect mini motor driver (v1.0) on I2C port.";
Blockly.Msg["ACTUATORS_MINI_I2C_MOTOR_DRIVER_STOP_TITLE"] = "[DC Motor] stop motor %1";
Blockly.Msg["ACTUATORS_MINI_I2C_MOTOR_DRIVER_STOP_TOOLTIP"] = IMG_MODULE_MINI_I2C_MOTOR_DRIVER + Blockly.Tooltip.SEP + "Enable to stop DC motors plugged on mini motor driver. Connect mini motor driver (v1.0) on I2C port.";
Blockly.Msg["ACTUATORS_MC33926_MOTOR_SHIELD_SETSPEED_TITLE"] = "[MC33926 Motor Shield] control motor %1 direction %2 speed %3";
Blockly.Msg["ACTUATORS_MC33926_MOTOR_SHIELD_SETSPEED_TOOLTIP"] = IMG_MODULE_MC33926_SHIELD_MOTOR + Blockly.Tooltip.SEP + "Enable to control speed (from 0 to 400) of DC motors plugged on Dual MC33926 Shield Motor.";
Blockly.Msg["ACTUATORS_MC33926_MOTOR_SHIELD_GETCURRENT_TITLE"] = "[MC33926 Motor Shield] get current (mA) from motor %1";
Blockly.Msg["ACTUATORS_MC33926_MOTOR_SHIELD_GETCURRENT_TOOLTIP"] = IMG_MODULE_MC33926_SHIELD_MOTOR + Blockly.Tooltip.SEP + "Enable to get current (in mA) from DC motors plugged on Dual MC33926 Shield Motor.";
Blockly.Msg["ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TITLE"] = "[Vibration motor] control state to %1 on pin %2";
Blockly.Msg["ACTUATORS_GROVEVIBRATIONMOTOR_CONTROL_TOOLTIP"] = IMG_MODULE_VIBRATION_MOTOR + Blockly.Tooltip.SEP + "Enable to control state of grove vibration motor (HIGH or LOW) on digitals pins D0 up through D13.";
Blockly.Msg["ACTUATORS_GROVERELAY_CONTROL_TITLE"] = "[Relay module] control state to %1 on pin %2";
Blockly.Msg["ACTUATORS_GROVERELAY_CONTROL_TOOLTIP"] = IMG_MODULE_RELAY + Blockly.Tooltip.SEP + "Enable to control state grove relay module (HIGH or LOW) on digitals pins D0 up through D13.";
Blockly.Msg["ACTUATORS_MOSFET_SETSTATE_TITLE"] = "[MOSFET] set state to %1 on pin %2";
Blockly.Msg["ACTUATORS_MOSFET_SETSTATE_TOOLTIP"] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + "Enable to set the state of MOSFET transistor to HIGH or LOW on the PWM pins.";
Blockly.Msg["ACTUATORS_MOSFET_SETPERCENTVALUE_TITLE"] = "[MOSFET] set value to %1 (%) on pin %2";
Blockly.Msg["ACTUATORS_MOSFET_SETPERCENTVALUE_TOOLTIP"] = IMG_MODULE_MOSFET + Blockly.Tooltip.SEP + "Enable to control the MOSFET transistor cycle time (from 0 to 100 %) on PWM pins.";
Blockly.Msg["ACTUATORS_GROVEBUZZER_CONTROLSTATE_TITLE"] = "[Buzzer/Speaker] control state to %1 on pin %2";
Blockly.Msg["ACTUATORS_GROVEBUZZER_CONTROLSTATE_TOOLTIP"] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + "The Buzzer Grove module can be connected to a digital output and will emit a tone when the output is ON. It can also be connected to a PWM output (noted ~ on Arduino) to generate various frequencies (see other block).";
Blockly.Msg["ACTUATORS_GROVEBUZZER_PLAYNOTE_TITLE"] = "[Buzzer/Speaker] play the note %1 on pin %2";
Blockly.Msg["ACTUATORS_GROVEBUZZER_PLAYNOTE_TOOLTIP"] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + "Play the selected note on digitals pins D0 up through D13.";
Blockly.Msg["ACTUATORS_GROVEBUZZER_PLAYNOTEDURATION_TITLE"] = "[Buzzer/Speaker] play the note %1 during %2 (s) on pin %3";
Blockly.Msg["ACTUATORS_GROVEBUZZER_PLAYNOTEDURATION_TOOLTIP"] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + "Play the selected note with defined duration in seconds on digitals pins D0 up through D13.";
Blockly.Msg["ACTUATORS_TONE_TITLE"] = "[Buzzer/Speaker] set the frequency %1 on pin %2";
Blockly.Msg["ACTUATORS_TONE_TOOLTIP"] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + "This block allows to play a given frequency with a loudspeaker module or a buzzer on digitals pins D0 up through D13.";
Blockly.Msg["ACTUATORS_TONE_DURATION_TITLE"] = "[Buzzer/Speaker] set the frequency %1 during %2 (s) on pin %3";
Blockly.Msg["ACTUATORS_TONE_DURATION_TOOLTIP"] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + "This block allows to play a given frequency with defined duration in seconds with a loudspeaker module or a buzzer on digitals pins D0 up through D13.";
Blockly.Msg["ACTUATORS_NOTONE_TITLE"] = "[Buzzer/Speaker] stop music on pin %1";
Blockly.Msg["ACTUATORS_NOTONE_TOOLTIP"] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + "Enable to stop the music in playing.";
Blockly.Msg["ACTUATORS_GROVEBUZZER_PLAYMUSIC_TITLE"] = "[Buzzer/Speaker] play music %1 on pin %2";
Blockly.Msg["ACTUATORS_GROVEBUZZER_PLAYMUSIC_TOOLTIP"] = IMG_MODULE_BUZZER_SPEAKER + Blockly.Tooltip.SEP + "Enable to play the choosen music on grove buzzer module on digital pins D0 up through D13.";
Blockly.Msg["ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TITLE"] = "[Water atomizer] control state to %1 on pin %2";
Blockly.Msg["ACTUATORS_GROVEWATERATOMIZATION_CONTROL_TOOLTIP"] = IMG_MODULE_WATER_ATOMIZER + Blockly.Tooltip.SEP + "Enable to control state of grove water atomizer (HIGH or LOW) on digitals pins D0 up through D13.";
Blockly.Msg["ACTUATORS_GROVEELECTROMAGNET_CONTROL_TITLE"] = "[Electromagnet] control state to %1 on pin %2";
Blockly.Msg["ACTUATORS_GROVEELECTROMAGNET_CONTROL_TOOLTIP"] = IMG_MODULE_ELECTROMAGNET + Blockly.Tooltip.SEP + "Enable to control state of grove water atomizer (HIGH or LOW) on digitals pins D0 up through D13.";

// IA SENSORS
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TITLE'] = 'load local model';
Blockly.Msg['VITTAIA_LOAD_LOCAL_MODEL_TOOLTIP'] = 'Allows loading an AI model stored locally from the web browser.';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TITLE'] = 'load the model from URL %1';
Blockly.Msg['VITTAIA_LOAD_CLOUD_MODEL_TOOLTIP'] = 'Allows loading an AI model stored from the cloud.';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TITLE'] = 'Prediction from sensor data';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TIME_WINDOW'] = 'window';
Blockly.Msg['VITTAIA_MAKE_PREDICTION_TOOLTIP'] = 'Allows making a prediction from a sensor. Adjust the time window to get a prediction if needed.';
Blockly.Msg['VITTAIA_SENSOR_ACC'] = 'accelerometer';
Blockly.Msg['VITTAIA_DETECT_CLASS_TITLE'] = 'if class %1 %2 detected then';
Blockly.Msg['VITTAIA_DETECT_CLASS_TOOLTIP'] = 'Allows detecting the class of an object.';
Blockly.Msg['VITTAIA_IS'] = 'is';
Blockly.Msg['VITTAIA_ISNOT'] = 'is not';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TITLE'] = 'detected class';
Blockly.Msg['VITTAIA_GET_HIGHEST_PROBABILITY_CLASS_TOOLTIP'] = 'Allows you to retrieve the class with the highest probability.';