/**
 * @fileoverview Spanish messages for CyberPi. (ES)
 */

'use strict';

// Display - LEDs
Blockly.Msg['CYBERPI_LED_ON_ALL_RGB_TITLE'] = '[LED] controla todos los LED a R %1 G %2 B %3';
Blockly.Msg['CYBERPI_LED_ON_ALL_RGB_TOOLTIP'] = 'Le permite encender los 5 LED RGB de la tarjeta CyberPi eligiendo los colores R, G y B (0-255).';
Blockly.Msg['CYBERPI_LED_ON_ALL_RGB_PALETTE_TITLE'] = '[LED] controla todos los LED a %1';
Blockly.Msg['CYBERPI_LED_ON_ALL_RGB_PALETTE_TOOLTIP'] = 'Le permite encender los 5 LED RGB de la placa CyberPi eligiendo un color de la paleta.';
Blockly.Msg['CYBERPI_LED_ON_RGB_TITLE'] = '[LED] controla el LED %1 a R %2 G %3 B %4';
Blockly.Msg['CYBERPI_LED_ON_RGB_TOOLTIP'] = 'Le permite controlar cada LED RGB en la placa CyberPi usando su ID (1-5) y eligiendo los colores R, G y B (0-255).';
Blockly.Msg['CYBERPI_LED_ON_RGB_PALETTE_TITLE'] = '[LED] controla el LED %1 a %2';
Blockly.Msg['CYBERPI_LED_ON_RGB_PALETTE_TOOLTIP'] = 'Le permite controlar cada LED RGB en la placa CyberPi usando su ID (1-5) y eligiendo un color de la paleta.';
Blockly.Msg['CYBERPI_LED_PLAY_TITLE'] = '[LED] reproduce la animación %1';
Blockly.Msg['CYBERPI_LED_PLAY_TOOLTIP'] = 'Le permite mostrar la animación LED especificada en CyberPi.';
Blockly.Msg['CYBERPI_ANIMATION_RAINBOW'] = 'arco iris';
Blockly.Msg['CYBERPI_ANIMATION_SPOONDRIFT'] = 'spoondrift';
Blockly.Msg['CYBERPI_ANIMATION_METEOR_BLUE'] = 'azul meteoro';
Blockly.Msg['CYBERPI_ANIMATION_METEOR_GREEN'] = 'verde meteoro';
Blockly.Msg['CYBERPI_ANIMATION_FLASH_RED'] = 'destello rojo';
Blockly.Msg['CYBERPI_ANIMATION_FLASH_ORANGE'] = 'parpadeo naranja';
Blockly.Msg['CYBERPI_ANIMATION_FIREFLY'] = 'luciérnaga';
Blockly.Msg['CYBERPI_LED_MOVE_TITLE'] = '[LED] mueve el LED en %1 paso';
Blockly.Msg['CYBERPI_LED_MOVE_TOOLTIP'] = 'Le permite hacer que los colores de los LED se desplacen de izquierda a derecha según el número de posiciones especificado (-4 - +4) en el CyberPi.';
Blockly.Msg['CYBERPI_LED_SET_BRIGHTNESS_TITLE'] = '[LED] establece el brillo en %1 (%)';
Blockly.Msg['CYBERPI_LED_SET_BRIGHTNESS_TOOLTIP'] = 'Le permite configurar el brillo de los LED de CyberPi.';
Blockly.Msg['CYBERPI_LED_GET_BRIGHTNESS_TITLE'] = '[LED] obtiene el brillo del LED (%)';
Blockly.Msg['CYBERPI_LED_GET_BRIGHTNESS_TOOLTIP'] = 'Devuelve el brillo de 0 a 100 % de los LED de CyberPi.';
// Display - Console
Blockly.Msg['CYBERPI_CONSOLE_PRINT_TITLE'] = '[Consola] imprime %1';
Blockly.Msg['CYBERPI_CONSOLE_PRINT_TOOLTIP'] = 'Le permite escribir texto en la pantalla de CyberPi.';
Blockly.Msg['CYBERPI_CONSOLE_SET_FONT_TITLE'] = '[Consola] establece el tamaño de fuente en %1';
Blockly.Msg['CYBERPI_CONSOLE_SET_FONT_TOOLTIP'] = 'Le permite cambiar el tamaño de fuente del texto en la consola de la placa CyberPi.';
// Display - Text
Blockly.Msg['CYBERPI_DISPLAY_SHOW_LABEL_TITLE'] = '[Pantalla] mostrar etiqueta %1 tamaño de fuente %2 posición %3';
Blockly.Msg['CYBERPI_DISPLAY_SHOW_LABEL_TOOLTIP'] = 'Le permite mostrar texto en la posición especificada en la pantalla de CyberPi. El tamaño de fuente se puede configurar como 16, 24 o 32.';
Blockly.Msg['CYBERPI_POSITION_TOP_MID'] = 'superior medio';
Blockly.Msg['CYBERPI_POSITION_TOP_LEFT'] = 'arriba a la izquierda';
Blockly.Msg['CYBERPI_POSITION_TOP_RIGHT'] = 'arriba a la derecha';
Blockly.Msg['CYBERPI_POSITION_CENTER'] = 'centro';
Blockly.Msg['CYBERPI_POSITION_MID_LEFT'] = 'centro izquierda';
Blockly.Msg['CYBERPI_POSITION_MID_RIGHT'] = 'medio derecho';
Blockly.Msg['CYBERPI_POSITION_BOTTOM_MID'] = 'abajo a la mitad';
Blockly.Msg['CYBERPI_POSITION_BOTTOM_LEFT'] = 'abajo a la izquierda';
Blockly.Msg['CYBERPI_POSITION_BOTTOM_RIGHT'] = 'abajo a la derecha';
Blockly.Msg['CYBERPI_DISPLAY_SHOW_LABEL_XY_TITLE'] = '[Pantalla] mostrar etiqueta %1 tamaño de fuente %2 x %3 y %4';
Blockly.Msg['CYBERPI_DISPLAY_SHOW_LABEL_XY_TOOLTIP'] = 'Le permite mostrar texto en la posición especificada x (0-128) e y (0-128) en la pantalla de CyberPi. El tamaño de fuente se puede configurar como 16, 24 o 32';
// Display - Linechart
Blockly.Msg['CYBERPI_LINECHART_ADD_TITLE'] = '[Pantalla] línea: agregar valor %1';
Blockly.Msg['CYBERPI_LINECHART_ADD_TOOLTIP'] = 'Le permite agregar un valor a la curva en la pantalla de CyberPi.\nConsejo:\n - El valor debe estar entre 0 y 100. Use la "[Pantalla] para ajustar la X definida entre MIN y MAX" para ajustarlo entre 0 y 100.\n - La curva puede contener un máximo de 128 valores en horizontal si están separados por 1. Utilice el bloque "[Pantalla] para definir los valores de separación de el gráfico a X" para cambiar el paso.\n - Use el bloque "[Pantalla] use el gráfico de color R G B" agregue o seleccione una nueva curva.';
Blockly.Msg['CYBERPI_LINECHART_SET_STEP_TITLE'] = '[Pantalla] línea: establece el paso de los valores en %1';
Blockly.Msg['CYBERPI_LINECHART_SET_STEP_TOOLTIP'] = 'Permite establecer la brecha entre los valores contenidos en el gráfico. Este contendrá 64 si están separados por 2. La cantidad de datos que puede contener el gráfico es tal que: N = int(128 / desviación)';
Blockly.Msg['CYBERPI_BARCHART_ADD_TITLE'] = '[Pantalla] histograma: cambia el valor a %1';
Blockly.Msg['CYBERPI_BARCHART_ADD_TOOLTIP'] = 'Le permite cambiar el valor del histograma en la pantalla de CyberPi.\nConsejo:\n - El valor debe estar entre 0 y 100. Use la "[Pantalla] para ajustar la X definida entre MIN y MAX" para ajustarlo entre 0 y 100.\n - Utilice el bloque "[Pantalla] use color graph R G B" para agregar o seleccionar una barra. Al agregar un nuevo color, por lo tanto, se define una nueva barra en el histograma. ';
Blockly.Msg['CYBERPI_TABLE_ADD_TITLE'] = '[Pantalla] tabla: agregar %1 en la posición x %2 y %3';
Blockly.Msg['CYBERPI_TABLE_ADD_TOOLTIP'] = 'Le permite agregar un valor numérico o textual a la tabla en la pantalla CyberPi.';
Blockly.Msg['CYBERPI_CHART_MAP_TITLE'] = '[Pantalla] ajustar %1 establecido entre %2 y %3';
Blockly.Msg['CYBERPI_CHART_MAP_TOOLTIP'] = 'Permite ajustar el dato definido entre un mínimo y un máximo para que quede contenido entre 0 y 100 en la curva o en el histograma.';
Blockly.Msg['CYBERPI_CHART_SET_BRUSH_TITLE'] = '[Pantalla] usar gráfico de colores R %1 G %2 B %3';
Blockly.Msg['CYBERPI_CHART_SET_BRUSH_TOOLTIP'] = 'Permite agregar/seleccionar una nueva curva o barra horizontal en el histograma con un nuevo conjunto de colores con R, G y B (0-255).';
Blockly.Msg['CYBERPI_CHART_SET_BRUSH_PALETTE_TITLE'] = '[Pantalla] usar tabla de colores %1';
Blockly.Msg['CYBERPI_CHART_SET_BRUSH_PALETTE_TOOLTIP'] = 'Le permite agregar/seleccionar una nueva curva o barra horizontal en el histograma con un nuevo color elegido de la paleta.';
// IO - Time
Blockly.Msg['IO_WAIT_TITLE'] = 'espera %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Pausa en la ejecución del código';
Blockly.Msg['IO_WAIT_SECOND'] = 'segundo(s)';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milisegundo(s)';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microsegundo(s)';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'espera hasta %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Detiene la ejecución del código hasta que se cumpla la condición';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'iniciar el temporizador';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Inicializar un temporizador a 0 (en segundos)';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'valor del cronómetro en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Devuelve el valor del temporizador de la inicialización (en segundos o milisegundos)';
// IO - Buttons
Blockly.Msg['IO_CONTROLLER_IS_BUTTON_PRESSED_TITLE'] = 'botón %1 presionado';
Blockly.Msg['IO_CONTROLLER_IS_BUTTON_PRESSED_TOOLTIP'] = 'Devuelve \'True\' si se presiona el botón seleccionado y \'False\' en caso contrario.';
Blockly.Msg['IO_CONTROLLER_ON_BUTTON_PRESSED_TITLE'] = 'si se presiona el botón %1 entonces';
Blockly.Msg['IO_CONTROLLER_ON_BUTTON_PRESSED_TOOLTIP'] = 'Ejecuta instrucciones si se presiona el botón seleccionado.';
Blockly.Msg['IO_CONTROLLER_BUTTONS_GET_COUNT_TITLE'] = 'número de clics de botón %1';
Blockly.Msg['IO_CONTROLLER_BUTTONS_GET_COUNT_TOOLTIP'] = 'Devuelve el número de veces que se presionó el botón seleccionado.';
Blockly.Msg['IO_CONTROLLER_BUTTONS_RESET_COUNT_TITLE'] = 'restablecer el recuento de clics en %1';
Blockly.Msg['IO_CONTROLLER_BUTTONS_RESET_COUNT_TOOLTIP'] = 'Restablece la cuenta de la cantidad de veces que se presiona el botón especificado o se mueve el joystick en la dirección especificada.';
// IO -Events
Blockly.Msg['IO_EVENT_START_TITLE'] = 'cuando se inicia el programa, entonces';
Blockly.Msg['IO_EVENT_START_TOOLTIP'] = 'Permite ejecutar instrucciones cuando se inicia el programa. Nota: Este es un bloque de programación controlado por eventos, antes de usarlo, deshabilite los bloques "Repetir para siempre" contenidos en su programa.';
Blockly.Msg['IO_EVENT_IS_PRESS_TITLE'] = 'cuando se presiona el botón %1, entonces';
Blockly.Msg['IO_EVENT_IS_PRESS_TOOLTIP'] = 'Permite ejecutar instrucciones cuando se presiona el botón seleccionado. Nota: Este es un bloque de programación controlado por eventos, antes de usarlo, deshabilite los bloques "Repetir para siempre" contenidos en su programa.';
Blockly.Msg['IO_CYBERPI_BROADCAST_TITLE'] = 'mensaje de emisión %1';
Blockly.Msg['IO_CYBERPI_BROADCAST_TOOLTIP'] = 'Permite emitir un mensaje durante la ejecución de un programa, este activará el evento vinculado al mensaje.';
Blockly.Msg['IO_EVENT_RECEIVE_TITLE'] = 'cuando se recibe el mensaje %1, entonces';
Blockly.Msg['IO_EVENT_RECEIVE_TOOLTIP'] = 'Permite ejecutar instrucciones cuando se recibe un mensaje de difusión. Nota: Este es un bloque de programación basado en eventos, antes de usarlo, deshabilite el contenido de los bloques "Repetir para siempre" en su programa. ';
// IO - Pines
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'ALTO (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAJO (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Devuelve un valor booleano (1 si es HIGH o 0 si es LOW)';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'leer pin digital %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Leer el valor de una entrada digital (0 o 1)';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'escribe el estado %1 en el pin digital %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Escribir un valor en una entrada digital (0 o 1)';
// Blockly.Msg["IO_READANALOGPIN_TITLE"] = "read analog pin %1";
// Blockly.Msg["IO_READANALOGPIN_TOOLTIP"] = "Reads the value of an analog input (0-1023), which corresponds to a voltage between 0 and 3.6V.";
Blockly.Msg['IO_WRITEPWMPIN_TITLE'] = 'escribe el valor %1 en el pin PWM %2';
Blockly.Msg['IO_WRITEPWMPIN_TOOLTIP'] = 'Permite aplicar una señal PWM con una frecuencia fija de 10kH y cambiando el ciclo de 0 a 1023. El valor 512 corresponderá al 50% del ciclo, es decir, a unos 1,66V';
// Blockly.Msg["IO_WRITEANALOGPIN_TITLE"] = "write value %1 to analog pin %2 (DAC)";
// Blockly.Msg["IO_WRITEANALOGPIN_TOOLTIP"] = "Allows to apply an analog voltage on the DAC pins p25 and p26 (from 0 to 255). The Esp32 uses a Digital-Analog Converter (DAC) to apply a voltage including between 0 and 3.3V.";
Blockly.Msg['IO_SETPWM_TITLE'] = 'aplicar una señal de onda cuadrada de frecuencia %1 (Hz) al pin %2';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Aplicar una señal de onda cuadrada (PWM) con un ciclo fijo del 50% a un pin. Este bloque permite cambiar la frecuencia de la señal';
Blockly.Msg['IO_STOPPWM_TITLE'] = 'detener la señal PWM del pin %1';
Blockly.Msg['IO_STOPPWM_TOOLTIP'] = 'Detener la señal PWM aplicada a un pin';
Blockly.Msg['IO_GETVOLTAGE_TITLE'] = 'convertir %1 en %2 en voltaje';
Blockly.Msg['IO_GETVOLTAGE_TOOLTIP'] = 'Convierte un valor analógico a voltaje eligiendo la resolución (10 bits: 1024, 12 bits: 4096, 9 bits: 512, 11 bits: 2048) y un máximo de 3,6V';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'escribir en la consola %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Permite escribir datos en el puerto serie';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'con';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'avance de línea(s)';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE then'] = 'on serial data received in %1 then';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permite ejecutar instrucciones si se reciben datos del puerto serie en la variable \'serialData\'';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'reproduce la nota %1 en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Toca la nota seleccionada hasta que se ejecuta el bloque "Fin de nota".';
Blockly.Msg['NOTE_C'] = 'Do';
Blockly.Msg['NOTE_C_SHARP'] = 'Do#';
Blockly.Msg['NOTE_D'] = 'D';
Blockly.Msg['NOTE_D_SHARP'] = 'D#';
Blockly.Msg['NOTE_E'] = 'E';
Blockly.Msg['NOTE_F'] = 'F';
Blockly.Msg['NOTE_F_SHARP'] = 'F#';
Blockly.Msg['NOTE_G'] = 'G';
Blockly.Msg['NOTE_G_SHARP'] = 'G#';
Blockly.Msg['NOTE_A'] = 'A';
Blockly.Msg['NOTE_A_SHARP'] = 'A#';
Blockly.Msg['NOTE_B'] = 'Si';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'reproduce la frecuencia %1 (Hz) en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Este bloque reproduce una frecuencia determinada en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'terminar la nota en el ordenador';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Detener la nota actual';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'trazar gráfico';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Este bloque permite escribir datos (numéricos) que serán visibles en el trazador. Puede utilizarse con uno o varios bloques con formato "Nom" y "Datos". Para ver los gráficos, haga clic en el icono "Modo gráfico" de la consola';
Blockly.Msg['COMMUNICATION_DATA'] = 'Datos';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nombre %1 Valor %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Este bloque debe utilizarse junto con el bloque "Plot Graph". Debe contener a su vez el nombre del valor a mostrar (texto), y el valor en cuestión (número)';
// Sensors - CyberPi
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TITLE'] = 'leer sensor de pasillo';
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TOOLTIP'] = 'Devuelve el valor del sensor Hall de la placa.';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TITLE'] = 'leer la temperatura del procesador en %1';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TOOLTIP'] = 'Devuelve la temperatura del procesador ESP32 de CyberPi.';
Blockly.Msg['SENSORS_CYBERPI_GET_BRIGHTNESS_TITLE'] = 'luminosidad ambiental (%)';
Blockly.Msg['SENSORS_CYBERPI_GET_BRIGHTNESS_TOOLTIP'] = 'Devuelve el brillo ambiental de 0 a 100 % detectado por el sensor CyberPi integrado.';
Blockly.Msg['SENSORS_CYBERPI_GET_LOUDNESS_TITLE'] = 'intensidad del ambiente (%)';
Blockly.Msg['SENSORS_CYBERPI_GET_LOUDNESS_TOOLTIP'] = 'Devuelve la sonoridad ambiental de 0 a 100 % detectada por el sensor CyberPi integrado.';
// Acutuators - audio
Blockly.Msg['ACTUATORS_AUDIO_PLAY_TITLE'] = '[audio] reproducir %1';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_TOOLTIP'] = 'Reproduzca el texto seleccionado con el altavoz integrado de CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_HI'] = 'hola';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_BYE'] = 'adiós';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_YEAH'] = 'sí';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_WOW'] = 'wow';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_LAUGH'] = 'risa';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_HUM'] = 'vacilación';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_SAD'] = 'triste';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_SIGH'] = 'suspiro';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_ANNOYED'] = 'molesto';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_ANGRY'] = 'enojado';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_SURPRISED'] = 'sorprendido';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_YUMMY'] = 'delicioso';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_CURIOUS'] = 'curioso';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_EMBARRASSED'] = 'avergonzado';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_READY'] = 'listo';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_SPRINT'] = 'sprint';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_NOTE_TITLE'] = '[audio] reproducir nota %1 para %2 (s)';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_NOTE_TOOLTIP'] = 'Reproduzca la nota elegida (0-132) con el altavoz integrado en la placa CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_TONE_TITLE'] = '[audio] frecuencia de reproducción %1';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_TONE_TOOLTIP'] = 'Reproduzca una frecuencia (en Hz) con el altavoz integrado en la placa CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_TONE_DURATION'] = 'durante';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_DRUM_TITLE'] = '[audio] reproducir sonido %1 para %2 (s)';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_DRUM_TOOLTIP'] = 'Reproduzca un sonido de batería con el altavoz integrado en la placa CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_SNARE'] = 'caja';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_BASS_DRUM'] = 'bombo';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_SIDE_STICK'] = 'rimshot';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_CRASH_SYMBAL'] = 'platillo de choque';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_OPEN_HI_HAT'] = 'abrir charles';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_CLOSED_HI_HAT'] = 'charles cerrado';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_TAMOURINE'] = 'tamourine';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_HAND_CLAP'] = 'aplauso';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_CLAVES'] = 'claves';
Blockly.Msg['ACTUATORS_AUDIO_START_RECORDING_TITLE'] = '[audio] comenzar a grabar';
Blockly.Msg['ACTUATORS_AUDIO_START_RECORDING_TOOLTIP'] = 'Comience a grabar audio con el altavoz integrado en la placa CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_STOP_RECORDING_TITLE'] = '[audio] detener la grabación';
Blockly.Msg['ACTUATORS_AUDIO_STOP_RECORDING_TOOLTIP'] = 'Detener la grabación de audio con el altavoz integrado de CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_RECORDING_TITLE'] = '[audio] reproduciendo grabación';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_RECORDING_TOOLTIP'] = 'Reproduzca la grabación de audio con el altavoz integrado de CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_ADD_TEMPO_TITLE'] = '[audio] aumentar el tempo en %1 (%)';
Blockly.Msg['ACTUATORS_AUDIO_ADD_TEMPO_TOOLTIP'] = 'Le permite aumentar el tempo del audio en un cierto porcentaje.';
Blockly.Msg['ACTUATORS_AUDIO_SET_TEMPO_TITLE'] = '[audio] establece el tempo en %1 (%)';
Blockly.Msg['ACTUATORS_AUDIO_SET_TEMPO_TOOLTIP'] = 'Le permite configurar el tempo del audio de 0 a 100%.';
Blockly.Msg['ACTUATORS_AUDIO_GET_TEMPO_TITLE'] = '[audio] tempo (%)';
Blockly.Msg['ACTUATORS_AUDIO_GET_TEMPO_TOOLTIP'] = 'Devuelve el tempo del audio (en %).';
Blockly.Msg['ACTUATORS_AUDIO_ADD_VOLUME_TITLE'] = '[audio] aumentar el volumen en %1 (%)';
Blockly.Msg['ACTUATORS_AUDIO_ADD_VOLUME_TOOLTIP'] = 'Le permite aumentar el volumen del audio en un cierto porcentaje.';
Blockly.Msg['ACTUATORS_AUDIO_SET_VOLUME_TITLE'] = '[audio] establece el volumen en %1 (%)';
Blockly.Msg['ACTUATORS_AUDIO_SET_VOLUME_TOOLTIP'] = 'Le permite configurar el volumen de audio de 0 a 100 %.';
Blockly.Msg['ACTUATORS_AUDIO_GET_VOLUME_TITLE'] = '[audio] volumen (%)';
Blockly.Msg['ACTUATORS_AUDIO_GET_VOLUME_TOOLTIP'] = 'Devuelve el volumen de audio (en %).';
Blockly.Msg['ACTUATORS_AUDIO_STOP_TITLE'] = '[audio] detener sonidos';
Blockly.Msg['ACTUATORS_AUDIO_STOP_TOOLTIP'] = 'Le permite detener la reproducción de sonidos a través del altavoz integrado de CyberPi.';
// Robots - Motor M1 & M2
Blockly.Msg['MBOT2_MOTORS_SET_POWER_TITLE'] = '[Motor.es %1] establece la potencia en %2 (%)';
Blockly.Msg['MBOT2_MOTORS_SET_POWER_TOOLTIP'] = 'Le permite controlar la potencia de los motores M1 y M2. Estos motores se conectan directamente al robot mBot2.';
Blockly.Msg['MBOT2_MOTORS_ADD_POWER_TITLE'] = '[Motor.es %1] aumenta la potencia en %2 (%)';
Blockly.Msg['MBOT2_MOTORS_ADD_POWER_TOOLTIP'] = 'Le permite aumentar la potencia de los motores M1 y M2. Estos motores se conectan directamente al robot mBot2.';
Blockly.Msg['MBOT2_MOTORS_GET_POWER_TITLE'] = '[Motor.es %1] potencia (%)';
Blockly.Msg['MBOT2_MOTORS_GET_POWER_TOOLTIP'] = 'Devuelve la potencia del motor M1 o M2. Estos motores se conectan directamente al robot mBot2.';
Blockly.Msg['MBOT2_MOTORS_STOP_TITLE'] = '[Motor.es %1] stop';
Blockly.Msg['MBOT2_MOTORS_STOP_TOOLTIP'] = 'Le permite detener los motores M1 y/o M2. Estos motores se conectan directamente al robot mBot2.';
// Robots - Servos
Blockly.Msg['MBOT2_SERVOS_SET_ANGLE_TITLE'] = '[Servo.s %1] está controlando el ángulo en %2 (°)';
Blockly.Msg['MBOT2_SERVOS_SET_ANGLE_TOOLTIP'] = 'Le permite controlar el ángulo (en °) de los servos S1, S2, S3 o S4 de 0 a 360°. Estos servos se conectan directamente al robot mBot2.';
Blockly.Msg['MBOT2_SERVOS_ADD_ANGLE_TITLE'] = '[Servo.s %1] aumenta el ángulo en %2 (°)';
Blockly.Msg['MBOT2_SERVOS_ADD_ANGLE_TOOLTIP'] = 'Le permite aumentar el ángulo (en °) del servo S1, S2, S3 o S4 de 0 a 360°. Estos servos se conectan directamente al robot mBot2.';
Blockly.Msg['MBOT2_SERVOS_GET_ANGLE_TITLE'] = '[Servo.s %1] ángulo del servo (°)';
Blockly.Msg['MBOT2_SERVOS_GET_ANGLE_TOOLTIP'] = 'Devuelve el ángulo del servo S1, S2, S3 o S4. Estos servos se conectan directamente al robot mBot2.';
Blockly.Msg['MBOT2_SERVOS_RESET_TITLE'] = '[Servo.s %1] detener motor.es';
Blockly.Msg['MBOT2_SERVOS_RESET_TOOLTIP'] = 'Le permite detener el servomotor S1, S2, S3 o S4. Estos servos se conectan directamente al robot mBot2.';
// Robots - mBot2
Blockly.Msg['ROBOTS_MBOT2_MOTOR_LEFT'] = 'izquierda (EM1)';
Blockly.Msg['ROBOTS_MBOT2_MOTOR_RIGHT'] = 'derecha (EM2)';
Blockly.Msg['ROBOTS_MBOT2_MOTOR_SPEED'] = 'velocidad (RPM)';
Blockly.Msg['ROBOTS_MBOT2_MOTOR_POWER'] = 'potencia (%)';
Blockly.Msg['ROBOTS_MBOT2_MOTOR_ANGLE'] = 'posición angular (°)';
Blockly.Msg['ROBOTS_MBOT2_BOTH_MOTORS'] = 'derecha (EM2) e izquierda (EM1)';
Blockly.Msg['ROBOTS_MBOT2_MOVE_FORWARD'] = 'adelante';
Blockly.Msg['ROBOTS_MBOT2_MOVE_REVERSE'] = 'retroceder';
Blockly.Msg['ROBOTS_MBOT2_MOVE_TITLE'] = '[mBot2] %1 velocidad %2 (RPM)';
Blockly.Msg['ROBOTS_MBOT2_MOVE_DURATION'] = 'durante';
Blockly.Msg['ROBOTS_MBOT2_MOVE_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Permite controlar la marcha (HACIA ADELANTE/HACIA ATRÁS) así como la velocidad (de 0 a 207 RPM) del robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_MOVE_BY_TITLE'] = '[mBot2] %1 de %2 %3';
Blockly.Msg['ROBOTS_MBOT2_MOVE_BY_CM'] = 'cm';
Blockly.Msg['ROBOTS_MBOT2_MOVE_BY_INCHS'] = 'pulgadas';
Blockly.Msg['ROBOTS_MBOT2_MOVE_BY_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Permite que mBot2 avance o retroceda cierta distancia (en cm o pulgadas).';
Blockly.Msg['ROBOTS_MBOT2_TURN_TITLE'] = '[mBot2] gira %1 de %2 (°)';
Blockly.Msg['ROBOTS_MBOT2_TURN_RIGHT'] = 'derecha';
Blockly.Msg['ROBOTS_MBOT2_TURN_LEFT'] = 'izquierda';
Blockly.Msg['ROBOTS_MBOT2_TURN_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Le permite girar a la izquierda o a la derecha en un cierto ángulo (en °) con el robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_CONTROL_MOTOR_TITLE'] = '[mBot2] controla motor.es %1 dirección %2 con %3 desde %4';
Blockly.Msg['ROBOTS_MBOT2_CONTROL_MOTOR_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Le permite controlar cada uno de los motores codificadores EM1 o EM2 con la potencia (en %) o la velocidad (en rpm) del robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_TURN_MOTOR_TITLE'] = '[mBot2] girar motor.es %1 dirección %2 ángulo %3 (°) a velocidad %4 (RPM)';
Blockly.Msg['ROBOTS_MBOT2_TURN_MOTOR_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Permite controlar la rotación de cada uno de los motores codificadores EM1 o EM2 en un cierto ángulo (en °) con la velocidad (en rpm) del mBot2.';
Blockly.Msg['ROBOTS_MBOT2_STOP_MOTOR_TITLE'] = '[mBot2] detener motor.es %1';
Blockly.Msg['ROBOTS_MBOT2_STOP_MOTOR_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Le permite detener los motores codificadores EM1 o EM2 del robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_GET_MOTOR_ENCODING_TITLE'] = '[mBot2] %1 del motor codificador %2';
Blockly.Msg['ROBOTS_MBOT2_GET_MOTOR_ENCODING_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Devuelve la velocidad de giro (en rpm) o la potencia (en %) o la posición angular (en °) del motor codificador EM1 o EM2 del mBot2.';
Blockly.Msg['ROBOTS_MBOT2_RESET_MOTOR_ANGULAR_POSITION_TITLE'] = '[mBot2] restablece el ángulo (°) del motor %1';
Blockly.Msg['ROBOTS_MBOT2_RESET_MOTOR_ANGULAR_POSITION_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Le permite restablecer la posición angular a 0° de los motores codificadores EM1 y/o EM2 del robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_CONTROL_MOTOR_LOCKING_TITLE'] = '[mBot2] bloqueo automático del motor de control de %1 a %2';
Blockly.Msg['ROBOTS_MBOT2_CONTROL_MOTOR_LOCKING_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Permite controlar el bloqueo automático de los motores codificadores EM1 y/o EM2 del robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_CONTROL_MOTOR_LOCKING_ENABLE'] = 'habilitar';
Blockly.Msg['ROBOTS_MBOT2_CONTROL_MOTOR_LOCKING_DISABLE'] = 'deshabilitar';
// Robots - Ultrasonic sensors
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_GET_DISTANCE_TITLE'] = '[Sensor ultrasónico %1] distancia (cm)';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_GET_DISTANCE_TOOLTIP'] = IMG_MBUILD_ULTRASONIC_SENSOR + Blockly.Tooltip.SEP + 'Devuelve la distancia de 3 a 300 cm entre el robot y el obstáculo medida con el sensor ultrasónico del robot mBot2. Es posible conectar en serie hasta 8 sensores ultrasónicos, use el parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_SET_BRIGHTNESS_TITLE'] = '[Sensor ultrasónico %1] establece el brillo del LED %2 en %3 (%)';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_SET_BRIGHTNESS_TOOLTIP'] = IMG_MBUILD_ULTRASONIC_SENSOR + Blockly.Tooltip.SEP + 'Le permite configurar el brillo (0-100)% de cada uno de los 8 LED azules integrados en un sensor ultrasónico.';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_GET_BRIGHTNESS_TITLE'] = '[Sensor ultrasónico %1] brillo (%) del LED %2';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_GET_BRIGHTNESS_TOOLTIP'] = IMG_MBUILD_ULTRASONIC_SENSOR + Blockly.Tooltip.SEP + 'Devuelve el brillo ambiental del LED azul seleccionado con id (1-8) e integrado con el sensor ultrasónico.';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_STOP_LED_TITLE'] = '[Sensor ultrasónico %1] apaga el LED %2';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_STOP_LED_TOOLTIP'] = IMG_MBUILD_ULTRASONIC_SENSOR + Blockly.Tooltip.SEP + 'Permite apagar el LED azul seleccionado con el id (1-8) e integrado en el sensor ultrasónico.';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_PLAY_LED_TITLE'] = '[Sensor ultrasónico %1] reproducir emoción %2';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_PLAY_LED_TOOLTIP'] = IMG_MBUILD_ULTRASONIC_SENSOR + Blockly.Tooltip.SEP + 'Reproduce una emoción con los LED azules del sensor ultrasónico. Esto dura alrededor de 1-2 segundos.';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_EMOTION_SLEEPY'] = 'dormir';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_EMOTION_HAPPPY'] = 'feliz';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_EMOTION_DIZZY'] = 'mareado';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_EMOTION_WINK'] = 'levantar las cejas';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_EMOTION_THINKING'] = 'pensando';
// Robots - Quad RGB sensors
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_LINE'] = 'línea';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_GROUND'] = 'fondo';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_WHITE'] = 'blanco';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_RED'] = 'rojo';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_YELLOW'] = 'amarillo';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_GREEN'] = 'verde';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_CYAN'] = 'cian';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_BLUE'] = 'azul';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_PURPLE'] = 'púrpura';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_BLACK'] = 'negro';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_CUSTOM'] = 'predefinido';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_L1_R1_DETECTION_IS_TITLE'] = '[Sensor RGB cuádruple %1] detectado %2 por L1 y R1 es %3';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_L1_R1_DETECTION_IS_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Devuelve \'Verdadero\' si se comprueba el estado de detección de los sensores centrales L1 y R1 (bajo el robot) según el modo de detección, devuelve \'Falso\' de lo contrario. \n\nEs posible conectar hasta 8 sensores RGB cuádruples en paralelo. Utilice el parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_L1_R1_DETECTION_TITLE'] = '[Sensor RGB cuádruple %1] estados de detección de %2 por L1 y R1';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_L1_R1_DETECTION_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Devuelve el estado de los sensores centrales L1 y R1 (debajo del robot) de 0 a 3 dependiendo del modo de detección elegido.\nEs posible conectar hasta 8 sensores RGB cuádruples en paralelo. utilice el parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DETECTION_IS_TITLE'] = '[Sensor RGB cuádruple %1] detectando %2 es %3';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DETECTION_IS_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Devuelve \'Verdadero\' si se comprueba el estado de detección de los 4 sensores L1, L2 y R1, R2 (debajo del robot) según el modo de detección, de lo contrario, devuelve \'Falso\'.\nEs posible conectar hasta 8 sensores RGB cuádruples en paralelo. Utilice el parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_DETECTION_TITLE'] = '[Sensor RGB cuádruple %1] estados de detección de %2';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_DETECTION_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Devuelve el estado de los 4 sensores L1, L2 y R1, R2 (debajo del robot) de 0 a 15 dependiendo del modo de detección elegido. nIt es posible conectar hasta 8 sensores RGB cuádruples en paralelo. Utilice el parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_IS_COLOR_DETECTED_TITLE'] = '[Sensor RGB cuádruple %1] sonda %2 detecta %3';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_IS_COLOR_DETECTED_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Devuelve \'Verdadero\' si la sonda elegida (L1, L2, R1, R2) detecta la línea o el color seleccionado; de lo contrario, \'Falso\'.\nEs es posible conectar hasta 8 sensores RGB cuádruples en paralelo. Utilice el parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_PROBE_DATA_TITLE'] = '[Sensor RGB cuádruple %1] %2 medido con la sonda %3';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_PROBE_DATA_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Devuelve \'Verdadero\' si la sonda elegida (L1, L2, R1, R2) detecta la línea o el color seleccionado; de lo contrario, \'Falso\'.\nEs es posible conectar hasta 8 sensores RGB cuádruples en paralelo. Utilice el parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DATA_R'] = 'nivel rojo';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DATA_G'] = 'nivel verde';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DATA_B'] = 'nivel azul';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DATA_GRAY_LEVEL'] = 'nivel de gris';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DATA_LIGHT'] = 'intensidad de luz';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DATA_COLOR'] = 'color';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_OFFSET_TRACK_TITLE'] = '[Sensor RGB cuádruple %1] desviación de la línea';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_OFFSET_TRACK_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Devuelve la desviación del robot con la línea de -100 a 100 mm. Un valor negativo significa una desviación hacia la izquierda. Por el contrario, un valor positivo significa una desviación hacia la derecha. \n\nEs posible bifurcarse en paralelo hacia arriba a 8 sensores RGB cuádruples. utilice el parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DEFINE_COLOR_TITLE'] = '[Sensor RGB cuádruple %1] establece el color en %2';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DEFINE_COLOR_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Le permite configurar el color de las luces del sensor cuádruple RGB en rojo, verde o azul. \n\nEs posible conectar en paralelo hasta 8 sensores RGB cuádruples. utilice el parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_LIST_TITLE'] = '[Sensor RGB cuádruple %1] LED de control en %2';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_LIST_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Le permite configurar el color de las luces del sensor cuádruple RGB eligiendo un color de la lista. \n\nEs posible conectar en paralelo hasta 8 sensores RGB cuádruples. utilice el parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_RGB_TITLE'] = '[Sensor RGB cuádruple %1] control LED en R %2 G %3 B %4';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_RGB_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Le permite configurar el color de las luces del sensor cuádruple RGB configurando RGB de 0 a 255. \n\nEs posible conectar en paralelo hasta 8 sensores RGB cuádruples. utilice el parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_PALETTE_TITLE'] = '[Sensor RGB cuádruple %1] control LED en %2';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_PALETTE_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Le permite configurar el color de las luces del sensor cuádruple RGB eligiendo un color de la paleta. \n\nEs posible conectar en paralelo hasta 8 sensores RGB cuádruples. utilice el parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_TOLERANCE'] = 'tolerancia';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_CLOSE_LED_TITLE'] = '[Sensor RGB cuádruple %1] apaga los LED';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_CLOSE_LED_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Le permite apagar los LED del sensor RGB cuádruple. \n\nSe pueden conectar hasta 8 sensores RGB cuádruples en paralelo. Use el parámetro (1- 8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_CALIBRATE_TITLE'] = '[Sensor RGB cuádruple %1] calibrar';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_CALIBRATE_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Permite la calibración de sensores de línea/color. \n\nSe pueden conectar hasta 8 sensores RGB cuádruples en paralelo. El parámetro (1-8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_COLOR_MODE_TITLE'] = '[Sensor RGB cuádruple] establezca el modo de detección en %1';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_COLOR_MODE_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Permite definir el modo de detección de color. \n\nEs posible conectar hasta 8 sensores RGB cuádruples en paralelo. Utilice el parámetro ( 1- 8) para recuperar el valor deseado.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DETECTION_MODE_STANDARD'] = 'estándar';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DETECTION_MODE_ENHANCE'] = 'mejora de color';
// Red - Wi-Fi
Blockly.Msg['CYBERPI_WIFI_CONNECT_TITLE'] = '[WiFi] conecta el CyberPi a la red: nombre %1 contraseña %2';
Blockly.Msg['CYBERPI_WIFI_CONNECT_TOOLTIP'] = 'Le permite conectar la tarjeta CyberPi a una red WiFi.';
Blockly.Msg['CYBERPI_WIFI_IS_CONNECT_TITLE'] = '[WiFi] ¿CyberPi está conectado?';
Blockly.Msg['CYBERPI_WIFI_IS_CONNECT_TOOLTIP'] = 'Comprueba si la tarjeta CyberPi está conectada a una red WiFi.';
Blockly.Msg['CYBERPI_WIFI_DISCONNECT_TITLE'] = '[WiFi] %1 el CyberPi';
Blockly.Msg['CYBERPI_WIFI_DISCONNECT_ACTION'] = "desconectar";
Blockly.Msg['CYBERPI_WIFI_RECONNECT_ACTION'] = "reconectar";
Blockly.Msg['CYBERPI_WIFI_DISCONNECT_TOOLTIP'] = 'Le permite desconectar o reconectar la tarjeta CyberPi a la red WiFi.';
// Red - LAN
Blockly.Msg['CYBERPI_WIFI_BROADCAST_SET_TITLE'] = '[LAN] transmite el mensaje %1 valor %2';
Blockly.Msg['CYBERPI_WIFI_BROADCAST_SET_TOOLTIP'] = 'Le permite enviar un mensaje que contiene un valor en una red WiFi. Todas las tarjetas CyberPi conectadas a una red deben utilizar el mismo canal de comunicación. Sin conexión al enrutador, las tarjetas CyberPi utilizan el mismo canal por defecto y, por lo tanto, pueden comunicarse entre sí en la LAN; Cuando la tarjeta CyberPi está conectada a un enrutador, su canal depende de la configuración del enrutador, que puede ser diferente del canal predeterminado y, por lo tanto, es posible que no pueda comunicarse con otra tarjeta CyberPi que no esté conectada al enrutador. Por lo tanto, para garantizar una buena comunicación, si utiliza un enrutador, conecte todas las tarjetas CyberPi a la misma red local.';
Blockly.Msg['CYBERPI_WIFI_BROADCAST_GET_TITLE'] = 'Valor del mensaje de transmisión [LAN] %1';
Blockly.Msg['CYBERPI_WIFI_BROADCAST_GET_TOOLTIP'] = 'Permite recibir el valor del mensaje transmitido en una red WiFi. No es obligatorio conectarse a una red WiFi existente para enviar un mensaje. En este caso, CyberPi ha creado una LAN local.';