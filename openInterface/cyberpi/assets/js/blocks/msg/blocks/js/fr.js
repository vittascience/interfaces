/**
 * @fileoverview French messages for CyberPi. (FR)
 */

'use strict';

// Display - LEDs
Blockly.Msg['CYBERPI_LED_ON_ALL_RGB_TITLE'] = '[LED] contrôler toutes les LED à R %1 G %2 B %3';
Blockly.Msg['CYBERPI_LED_ON_ALL_RGB_TOOLTIP'] = 'Permet d\'allumer les 5 LED RGB de la carte CyberPi en choisissant les couleurs R, G et B (0-255).';
Blockly.Msg['CYBERPI_LED_ON_ALL_RGB_PALETTE_TITLE'] = '[LED] contrôler toutes les LED à %1';
Blockly.Msg['CYBERPI_LED_ON_ALL_RGB_PALETTE_TOOLTIP'] = 'Permet d\'allumer les 5 LED RGB de la carte CyberPi en choisissant une couleur dans la palette.';
Blockly.Msg['CYBERPI_LED_ON_RGB_TITLE'] = '[LED] contrôler la LED %1 à R %2 G %3 B %4';
Blockly.Msg['CYBERPI_LED_ON_RGB_TOOLTIP'] = 'Permet de contrôler chaque LED RGB de la carte CyberPi en utilisant son ID (1-5) et en choisissant les couleurs R, G et B (0-255).';
Blockly.Msg['CYBERPI_LED_ON_RGB_PALETTE_TITLE'] = '[LED] contrôler la LED %1 à %2';
Blockly.Msg['CYBERPI_LED_ON_RGB_PALETTE_TOOLTIP'] = 'Permet de contrôler chaque LED RGB de la carte CyberPi en utilisant son ID (1-5) et en choisissant une couleur dans la palette.';
Blockly.Msg['CYBERPI_LED_PLAY_TITLE'] = '[LED] afficher l\'animation %1';
Blockly.Msg['CYBERPI_LED_PLAY_TOOLTIP'] = 'Permet d\'afficher l\'animation choisie sur les LED RGB de la carte CyberPi.';
Blockly.Msg['CYBERPI_ANIMATION_RAINBOW'] = 'arc-en-ciel';
Blockly.Msg['CYBERPI_ANIMATION_SPOONDRIFT'] = 'à la cuillère';
Blockly.Msg['CYBERPI_ANIMATION_METEOR_BLUE'] = 'bleu météore';
Blockly.Msg['CYBERPI_ANIMATION_METEOR_GREEN'] = 'vert météore';
Blockly.Msg['CYBERPI_ANIMATION_FLASH_RED'] = 'flash rouge';
Blockly.Msg['CYBERPI_ANIMATION_FLASH_ORANGE'] = 'flash orange';
Blockly.Msg['CYBERPI_ANIMATION_FIREFLY'] = 'luciole';
Blockly.Msg['CYBERPI_LED_MOVE_TITLE'] = '[LED] décaler les LED de %1';
Blockly.Msg['CYBERPI_LED_MOVE_TOOLTIP'] = 'Permet de décaler les LED RGB d\'un certain nombre de pas (-4 - +4) de la carte CyberPi.';
Blockly.Msg['CYBERPI_LED_SET_BRIGHTNESS_TITLE'] = '[LED] définir la luminosité à %1 (%)';
Blockly.Msg['CYBERPI_LED_SET_BRIGHTNESS_TOOLTIP'] = 'Permet de régler la luminosité (0-100) % des LED RGB de la carte CyberPi.';
Blockly.Msg['CYBERPI_LED_GET_BRIGHTNESS_TITLE'] = '[LED] luminosité des LED (%)';
Blockly.Msg['CYBERPI_LED_GET_BRIGHTNESS_TOOLTIP'] = 'Retourne la luminosité de 0 à 100 % des LED RGB de la carte CyberPi.';
// Display - Console
Blockly.Msg['CYBERPI_CONSOLE_PRINT_TITLE'] = '[Console] écrire dans la console %1';
Blockly.Msg['CYBERPI_CONSOLE_PRINT_TOOLTIP'] = 'Permet d\'afficher du texte dans la console de la carte CyberPi.';
Blockly.Msg['CYBERPI_CONSOLE_SET_FONT_TITLE'] = '[Console] définir taille de police à %1';
Blockly.Msg['CYBERPI_CONSOLE_SET_FONT_TOOLTIP'] = 'Permet de changer la taille de police du texte dans la console de la carte CyberPi.';
// Display - Text
Blockly.Msg['CYBERPI_DISPLAY_SHOW_LABEL_TITLE'] = '[Ecran] afficher l\'étiquette %1 taille %2 position %3';
Blockly.Msg['CYBERPI_DISPLAY_SHOW_LABEL_TOOLTIP'] = 'Permet d\'afficher l\'étiquette à la position indiquée sur l\'écran de la carte CyberPi. La taille de police peut être définie comme 16, 24 ou 32.';
Blockly.Msg['CYBERPI_POSITION_TOP_MID'] = 'en haut milieu';
Blockly.Msg['CYBERPI_POSITION_TOP_LEFT'] = 'en haut gauche';
Blockly.Msg['CYBERPI_POSITION_TOP_RIGHT'] = 'en haut droit';
Blockly.Msg['CYBERPI_POSITION_CENTER'] = 'centré';
Blockly.Msg['CYBERPI_POSITION_MID_LEFT'] = 'milieu gauche';
Blockly.Msg['CYBERPI_POSITION_MID_RIGHT'] = 'milieu droit';
Blockly.Msg['CYBERPI_POSITION_BOTTOM_MID'] = 'en bas milieu';
Blockly.Msg['CYBERPI_POSITION_BOTTOM_LEFT'] = 'en bas gauche';
Blockly.Msg['CYBERPI_POSITION_BOTTOM_RIGHT'] = 'en bas droit';
Blockly.Msg['CYBERPI_DISPLAY_SHOW_LABEL_XY_TITLE'] = '[Ecran] afficher l\'étiquette %1 taille %2 x %3 y %4';
Blockly.Msg['CYBERPI_DISPLAY_SHOW_LABEL_XY_TOOLTIP'] = 'Permet d\'afficher l\'étiquette à la position x (0-128) et y (0-128) sur l\'écran de la carte CyberPi. La taille de police peut être définie comme 16, 24 ou 32.';
// Display - Linechart
Blockly.Msg['CYBERPI_LINECHART_ADD_TITLE'] = '[Ecran] courbe linéaire: ajouter la valeur %1';
Blockly.Msg['CYBERPI_LINECHART_ADD_TOOLTIP'] = 'Permet d\'ajouter une valeur à la courbe sur l\'écran de la CyberPi.\nAstuce:\n - La valeur doit être comprise entre 0 et 100. Utiliser le bloc "[Ecran] ajuster X définie entre MIN et MAX" pour l\'ajuster entre 0 et 100.\n - La courbe peut contenir au maximum 128 valeurs horizontalement si elles sont espacées de 1. Utiliser le bloc "[Ecran] définir l\'écart des valeurs du graphe à X" pour changer le pas.\n - Utiliser le bloc "[Ecran] utiliser le graphique couleur R G B" ajouter ou sélectionner une nouvelle courbe.';
Blockly.Msg['CYBERPI_LINECHART_SET_STEP_TITLE'] = '[Ecran] courbe linéaire: def. écart des valeurs à %1';
Blockly.Msg['CYBERPI_LINECHART_SET_STEP_TOOLTIP'] = 'Permet de paramétrer l\'écart entre les valeurs contenues dans la courbe. Celle-ci en contiendra 64 si elles sont espacées de 2. La quantité de données que peut contenir le graphe est tel que: N = int(128 / écart)';
Blockly.Msg['CYBERPI_BARCHART_ADD_TITLE'] = '[Ecran] histogramme: changer la valeur à %1';
Blockly.Msg['CYBERPI_BARCHART_ADD_TOOLTIP'] = 'Permet de changer la valeur de l\'histogramme sur l\'écran de la CyberPi.\nAstuce:\n - La valeur doit être comprise entre 0 et 100. Utiliser le bloc "[Ecran] ajuster X définie entre MIN et MAX" pour l\'ajuster entre 0 et 100.\n - Utiliser le bloc "[Ecran] utiliser le graphique couleur R G B" pour ajouter ou sélectionner une barre. Ajouter une nouvelle couleur définit donc une nouvelle barre dans l\'histogramme.';
Blockly.Msg['CYBERPI_TABLE_ADD_TITLE'] = '[Ecran] tableau: ajouter %1 à la position x %2 y %3';
Blockly.Msg['CYBERPI_TABLE_ADD_TOOLTIP'] = 'Permet d\'ajouter une valeur numérique ou textuelle dans le tableau sur l\'écran de la CyberPi.';
Blockly.Msg['CYBERPI_CHART_MAP_TITLE'] = '[Ecran] ajuster %1 définie entre %2 et %3';
Blockly.Msg['CYBERPI_CHART_MAP_TOOLTIP'] = 'Permet d\'ajuster la donnée définie entre un minimum et un maximum pour qu\'elle soit contenue entre 0 et 100 sur la courbe ou dans l\'histogramme.';
Blockly.Msg['CYBERPI_CHART_SET_BRUSH_TITLE'] = '[Ecran] utiliser graphe de couleur R %1 G %2 B %3';
Blockly.Msg['CYBERPI_CHART_SET_BRUSH_TOOLTIP'] = 'Permet d\'ajouter/sélectionner une nouvelle courbe horizontale ou une barre dans l\'histogramme avec une nouvelle couleur définie avec R, G et B (0-255).';
Blockly.Msg['CYBERPI_CHART_SET_BRUSH_PALETTE_TITLE'] = '[Ecran] utiliser graphe de couleur %1';
Blockly.Msg['CYBERPI_CHART_SET_BRUSH_PALETTE_TOOLTIP'] = 'Permet d\'ajouter/sélectionner une nouvelle courbe horizontale ou une barre dans l\'histogramme avec une nouvelle couleur choisie dans la palette.';
// IO - Time
Blockly.Msg['IO_WAIT_TITLE'] = 'attendre %1 %2';
Blockly.Msg['IO_WAIT_TOOLTIP'] = 'Effectue une pause dans l\'exécution du code.';
Blockly.Msg['IO_WAIT_SECOND'] = 'seconde(s)';
Blockly.Msg['IO_WAIT_MILLISECOND'] = 'milliseconde(s)';
Blockly.Msg['IO_WAIT_MICROSECOND'] = 'microseconde(s)';
Blockly.Msg['IO_WAIT_UNTIL_TITLE'] = 'attendre jusqu\'à %1';
Blockly.Msg['IO_WAIT_UNTIL_TOOLTIP'] = 'Arrête l\'excution du code jusqu\'à ce que la condition soit satisfaite.';
Blockly.Msg['IO_INITCHRONOMETER_TITLE'] = 'démarrer le chronomètre';
Blockly.Msg['IO_INITCHRONOMETER_TOOLTIP'] = 'Initialise un chronomètre à 0 (en secondes).';
Blockly.Msg['IO_GETCHRONOMETER_TITLE'] = 'valeur du chronomètre en %1';
Blockly.Msg['IO_GETCHRONOMETER_TOOLTIP'] = 'Renvoie la valeur du chronomètre à partir de l\'initialisation (en secondes ou millisecondes).';
// IO - Buttons
Blockly.Msg['IO_CONTROLLER_IS_BUTTON_PRESSED_TITLE'] = 'bouton %1 est appuyé';
Blockly.Msg['IO_CONTROLLER_IS_BUTTON_PRESSED_TOOLTIP'] = 'Retourne \'True\' si le bouton sélectionné est appuyé, et \'False\' sinon.';
Blockly.Msg['IO_CONTROLLER_ON_BUTTON_PRESSED_TITLE'] = 'si le bouton %1 est appuyé alors';
Blockly.Msg['IO_CONTROLLER_ON_BUTTON_PRESSED_TOOLTIP'] = 'Exécute des instructions si le bouton sélectionné est appuyé ou que le joystick est déplacé.';
Blockly.Msg['IO_CONTROLLER_BUTTONS_GET_COUNT_TITLE'] = 'nombre de clics du bouton %1';
Blockly.Msg['IO_CONTROLLER_BUTTONS_GET_COUNT_TOOLTIP'] = 'Retourne le nombre de fois qu\'a été appuyé le bouton sélectionné ou la direction du joystick sélectionné.';
Blockly.Msg['IO_CONTROLLER_BUTTONS_RESET_COUNT_TITLE'] = 'réinitialiser le comptage des clics de %1';
Blockly.Msg['IO_CONTROLLER_BUTTONS_RESET_COUNT_TOOLTIP'] = 'Permet de réinitialiser le comptage du nombre de fois où le bouton spécifié est appuyé ou que le joystick est déplacé dans la direction spécifiée.';
// IO -Events
Blockly.Msg['IO_EVENT_START_TITLE'] = 'Quand le programme démarre, alors';
Blockly.Msg['IO_EVENT_START_TOOLTIP'] = 'Permet d\'exécuter des instructions lorsque le programme démarre. Note: Ceci est un bloc de programmation événementielle, avant de l\'utiliser, désactiver les blocs "Répéter indéfiniment" contenu dans votre programme.';
Blockly.Msg['IO_EVENT_IS_PRESS_TITLE'] = 'Quand le bouton %1 est appuyé, alors';
Blockly.Msg['IO_EVENT_IS_PRESS_TOOLTIP'] = 'Permet d\'exécuter des instructions lorsque le bouton sélectionné est appuyé. Note: Ceci est un bloc de programmation événementielle, avant de l\'utiliser, désactiver les blocs "Répéter indéfiniment" contenu dans votre programme.';
Blockly.Msg['IO_CYBERPI_BROADCAST_TITLE'] = 'émettre le message %1';
Blockly.Msg['IO_CYBERPI_BROADCAST_TOOLTIP'] = 'Permet d\'émettre un message durant l\'exécution d\'un programme, celui-ci déclenchera l\'évènement relié au message.';
Blockly.Msg['IO_EVENT_RECEIVE_TITLE'] = 'Quand le message %1 est reçu, alors';
Blockly.Msg['IO_EVENT_RECEIVE_TOOLTIP'] = 'Permet d\'exécuter des instructions lorsqu\'un message diffusé est reçu. Note: Ceci est un bloc de programmation événementielle, avant de l\'utiliser, désactiver les blocs "Répéter indéfiniment" contenu dans votre programme.';
// IO - Pines
Blockly.Msg['IO_DIGITAL_SIGNAL_TITLE'] = '%1';
Blockly.Msg['IO_DIGITAL_SIGNAL_HIGH'] = 'HAUT (1)';
Blockly.Msg['IO_DIGITAL_SIGNAL_LOW'] = 'BAS (0)';
Blockly.Msg['IO_DIGITAL_SIGNAL_TOOLTIP'] = 'Retourne une valeur booléenne (1 si HAUT ou 0 si BAS).';
Blockly.Msg['IO_READDIGITALPIN_TITLE'] = 'état de la broche numérique %1';
Blockly.Msg['IO_READDIGITALPIN_TOOLTIP'] = 'Permet de lire la valeur d\'une entrée digitale (0 ou 1).';
Blockly.Msg['IO_WRITEDIGITALPIN_TITLE'] = 'écrire l\'état %1 sur la broche numérique %2';
Blockly.Msg['IO_WRITEDIGITALPIN_TOOLTIP'] = 'Permet d\'écrire une valeur sur une entrée digitale (0 ou 1).';
// Blockly.Msg["IO_READANALOGPIN_TITLE"] = "read analog pin %1";
// Blockly.Msg["IO_READANALOGPIN_TOOLTIP"] = "Reads the value of an analog input (0-1023), which corresponds to a voltage between 0 and 3.6V.";
Blockly.Msg['IO_WRITEPWMPIN_TITLE'] = 'écrire la valeur %1 sur la broche PWM %2';
Blockly.Msg['IO_WRITEPWMPIN_TOOLTIP'] = 'Permet d\'appliquer un signal PWM avec une fréquence fixée à 10kH et en changeant le cycle de 0 à 1023. La valeur 512 correspondra à 50% du cycle, donc environ 1.66V.';
// Blockly.Msg["IO_WRITEANALOGPIN_TITLE"] = "write value %1 to analog pin %2 (DAC)";
// Blockly.Msg["IO_WRITEANALOGPIN_TOOLTIP"] = "Allows to apply an analog voltage on the DAC pins p25 and p26 (from 0 to 255). The Esp32 uses a Digital-Analog Converter (DAC) to apply a voltage including between 0 and 3.3V.";
Blockly.Msg['IO_SETPWM_TITLE'] = 'appliquer un signal carré de fréquence %1 (Hz) sur la broche %2';
Blockly.Msg['IO_SETPWM_TOOLTIP'] = 'Permet d\'appliquer un signal carré (PWM) avec un cycle fixé à 50% sur une broche. Ce bloc permet de changer la fréquence du signal.';
Blockly.Msg['IO_STOPPWM_TITLE'] = 'arrêter le signal PWM de la broche %1';
Blockly.Msg['IO_STOPPWM_TOOLTIP'] = 'Permet d\'arrêter le signal PWM appliqué sur une broche.';
Blockly.Msg['IO_GETVOLTAGE_TITLE'] = 'convertir %1 sur %2 en tension';
Blockly.Msg['IO_GETVOLTAGE_TOOLTIP'] = 'Permet de convertir une valeur analogique en tension en choisissant la résolution (10-bit: 1024, 12-bit: 4096, 9-bit: 512, 11-bit: 2048) et un maximum de 3.6V.';
// Communication - Serial connection
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TITLE'] = 'écrire dans la console %1';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_TOOLTIP'] = 'Permet d\'écrire des données dans le port série.';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_WITH'] = 'avec';
Blockly.Msg['COMMUNICATION_SERIAL_WRITE_NEWLINES'] = 'saut(s) de ligne';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TITLE then'] = 'on serial data received in %1 then';
Blockly.Msg['COMMUNICATION_SERIAL_ONDATARECEIVED_TOOLTIP'] = 'Permet d\'exécuter des instructions si une donnée est reçue par le port série dans la variable \'serialData\'.';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TITLE'] = 'jouer la note %1 sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_PLAYNOTE_TOOLTIP'] = 'Joue la note selectionnée jusqu\'à l\'exécution du bloc "Fin de la note".';
Blockly.Msg['NOTE_C'] = 'Do';
Blockly.Msg['NOTE_C_SHARP'] = 'Do#';
Blockly.Msg['NOTE_D'] = 'Ré';
Blockly.Msg['NOTE_D_SHARP'] = 'Ré#';
Blockly.Msg['NOTE_E'] = 'Mi';
Blockly.Msg['NOTE_F'] = 'Fa';
Blockly.Msg['NOTE_F_SHARP'] = 'Fa#';
Blockly.Msg['NOTE_G'] = 'Sol';
Blockly.Msg['NOTE_G_SHARP'] = 'Sol#';
Blockly.Msg['NOTE_A'] = 'La';
Blockly.Msg['NOTE_A_SHARP'] = 'La#';
Blockly.Msg['NOTE_B'] = 'Si';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TITLE'] = 'jouer la fréquence %1 (Hz) sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_SETFREQUENCY_TOOLTIP'] = 'Ce bloc permet de jouer une fréquence donnée sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TITLE'] = 'terminer la note sur l\'ordinateur';
Blockly.Msg['COMMUNICATION_COMPUTER_STOPMUSIC_TOOLTIP'] = 'Arrête la note en cours.';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TITLE'] = 'tracer le graphe';
Blockly.Msg['COMMUNICATION_WRITEGRAPH_TOOLTIP'] = 'Ce bloc permet d\'écrire des données (numériques) qui seront visibles dans le traceur. Il peut être utilisé avec un ou plusieurs blocs au format "Nom" et "Données". Pour visualiser les graphiques, cliquer sur l\'icone \'Mode Graphique\' dans la console.';
Blockly.Msg['COMMUNICATION_DATA'] = 'Donnée';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TITLE'] = 'Nom %1 Valeur %2';
Blockly.Msg['COMMUNICATION_PRINT_DATAS_TOOLTIP'] = 'Ce bloc est à utiliser avec le bloc "Tracer le graphique". Il doit lui-même contenir le nom de la valeur à afficher (texte), et la valeur en question (nombre).';
// Sensors - CyberPi
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TITLE'] = 'lire le capteur à effet Hall';
Blockly.Msg['SENSORS_READ_HALL_SENSOR_TOOLTIP'] = 'Renvoie la valeur du capteur à effet Hall de la carte.';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TITLE'] = 'température du processeur en %1';
Blockly.Msg['SENSORS_READ_PROCESSOR_TEMP_TOOLTIP'] = 'Retourne la température du processeur.';
Blockly.Msg['SENSORS_CYBERPI_GET_BRIGHTNESS_TITLE'] = 'ambient brightness (%)';
Blockly.Msg['SENSORS_CYBERPI_GET_BRIGHTNESS_TOOLTIP'] = 'Returns ambient brightness from 0 to 100% with CyberPi\'s built-in sensor.';
Blockly.Msg['SENSORS_CYBERPI_GET_LOUDNESS_TITLE'] = 'ambient loudness (%)';
Blockly.Msg['SENSORS_CYBERPI_GET_LOUDNESS_TOOLTIP'] = 'Returns ambient sound intensity from 0 to 100% with CyberPi\'s built-in sensor.';
// Acutuators - audio
Blockly.Msg['ACTUATORS_AUDIO_PLAY_TITLE'] = '[audio] lire %1';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_TOOLTIP'] = 'Lire le texte choisit avec le haut-parleur intégré à la carte CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_HI'] = 'salut';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_BYE'] = 'au revoir';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_YEAH'] = 'yeah';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_WOW'] = 'wow';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_LAUGH'] = 'rire';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_HUM'] = 'hésitation';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_SAD'] = 'triste';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_SIGH'] = 'soupir';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_ANNOYED'] = 'ennuyé';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_ANGRY'] = 'en colère';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_SURPRISED'] = 'surpris';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_YUMMY'] = 'délicieux';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_CURIOUS'] = 'curieux';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_EMBARRASSED'] = 'embarrassé';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_READY'] = 'prêt';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_SPRINT'] = 'sprint';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_NOTE_TITLE'] = '[audio] jouer la note %1 pendant %2 (s)';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_NOTE_TOOLTIP'] = 'Lire la note choisie (0-132) avec le haut-parleur intégré à la carte CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_TONE_TITLE'] = '[audio] jouer la fréquence %1';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_TONE_TOOLTIP'] = 'Jouer une fréquence (en Hz) avec le haut-parleur intégré à la carte CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_TONE_DURATION'] = 'pendant';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_DRUM_TITLE'] = '[audio] jouer le son %1 pendant %2 (s)';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_DRUM_TOOLTIP'] = 'Jouer un son de percussion avec le haut-parleur intégré à la carte CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_SNARE'] = 'caisse claire';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_BASS_DRUM'] = 'grosse caisse';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_SIDE_STICK'] = 'rimshot';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_CRASH_SYMBAL'] = 'cymbale crash';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_OPEN_HI_HAT'] = 'charley ouverte';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_CLOSED_HI_HAT'] = 'charley fermée';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_TAMOURINE'] = 'tamourin';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_HAND_CLAP'] = 'clap de main';
Blockly.Msg['ACTUATORS_AUDIO_DRUM_CLAVES'] = 'claves';
Blockly.Msg['ACTUATORS_AUDIO_START_RECORDING_TITLE'] = '[audio] démarrer l\'enregistrement';
Blockly.Msg['ACTUATORS_AUDIO_START_RECORDING_TOOLTIP'] = 'Démarrer un enregisrement audio avec le haut-parleur intégré à la carte CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_STOP_RECORDING_TITLE'] = '[audio] arrêter l\'enregistrement';
Blockly.Msg['ACTUATORS_AUDIO_STOP_RECORDING_TOOLTIP'] = 'Arrêter l\'enregisrement audio avec le haut-parleur intégré à la carte CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_RECORDING_TITLE'] = '[audio] lire l\'enregistrement';
Blockly.Msg['ACTUATORS_AUDIO_PLAY_RECORDING_TOOLTIP'] = 'Lire l\'enregisrement audio avec le haut-parleur intégré à la carte CyberPi.';
Blockly.Msg['ACTUATORS_AUDIO_ADD_TEMPO_TITLE'] = '[audio] augmenter le tempo de %1 (%)';
Blockly.Msg['ACTUATORS_AUDIO_ADD_TEMPO_TOOLTIP'] = 'Permet d\'augmenter le tempo audio d\'un certain pourcentage.';
Blockly.Msg['ACTUATORS_AUDIO_SET_TEMPO_TITLE'] = '[audio] définir le tempo à %1 (%)';
Blockly.Msg['ACTUATORS_AUDIO_SET_TEMPO_TOOLTIP'] = 'Permet de définir le tempo audio de 0 à 100 %.';
Blockly.Msg['ACTUATORS_AUDIO_GET_TEMPO_TITLE'] = '[audio] tempo (%)';
Blockly.Msg['ACTUATORS_AUDIO_GET_TEMPO_TOOLTIP'] = 'Retourne le tempo audio (en %).';
Blockly.Msg['ACTUATORS_AUDIO_ADD_VOLUME_TITLE'] = '[audio] augmenter le volume de %1 (%)';
Blockly.Msg['ACTUATORS_AUDIO_ADD_VOLUME_TOOLTIP'] = 'Permet d\'augmenter le volume audio d\'un certain pourcentage.';
Blockly.Msg['ACTUATORS_AUDIO_SET_VOLUME_TITLE'] = '[audio] définir le volume à %1 (%)';
Blockly.Msg['ACTUATORS_AUDIO_SET_VOLUME_TOOLTIP'] = 'Permet de définir le volume audio de 0 à 100 %.';
Blockly.Msg['ACTUATORS_AUDIO_GET_VOLUME_TITLE'] = '[audio] volume (%)';
Blockly.Msg['ACTUATORS_AUDIO_GET_VOLUME_TOOLTIP'] = 'Retourne le volume audio (en %).';
Blockly.Msg['ACTUATORS_AUDIO_STOP_TITLE'] = '[audio] arrêter les sons';
Blockly.Msg['ACTUATORS_AUDIO_STOP_TOOLTIP'] = 'Permet d\'arrêter les sons joués par le haut-parleur intégré à la CyberPi.';
// Robots - Motor M1 & M2
Blockly.Msg['MBOT2_MOTORS_SET_POWER_TITLE'] = '[Moteur.s %1] contrôler la puissance à %2 (%)';
Blockly.Msg['MBOT2_MOTORS_SET_POWER_TOOLTIP'] = 'Permet de contrôler la puissance des moteurs M1 et M2. Ces moteurs se branchent directement sur le robot mBot2.';
Blockly.Msg['MBOT2_MOTORS_ADD_POWER_TITLE'] = '[Moteur.s %1] augmenter la puissance de %2 (%)';
Blockly.Msg['MBOT2_MOTORS_ADD_POWER_TOOLTIP'] = 'Permet d\'augmenter la puissance des moteurs M1 et M2. Ces moteurs se branchent directement sur le robot mBot2.';
Blockly.Msg['MBOT2_MOTORS_GET_POWER_TITLE'] = '[Moteur.s %1] puissance (%)';
Blockly.Msg['MBOT2_MOTORS_GET_POWER_TOOLTIP'] = 'Retourne la puissance du moteur M1 ou M2. Ces moteurs se branchent directement sur le robot mBot2.';
Blockly.Msg['MBOT2_MOTORS_STOP_TITLE'] = '[Moteur.s %1] arrêter';
Blockly.Msg['MBOT2_MOTORS_STOP_TOOLTIP'] = 'Permet d\'arrêter les moteurs M1 et/ou M2. Ces moteurs se branchent directement sur le robot mBot2.';
// Robots - Servos
Blockly.Msg['MBOT2_SERVOS_SET_ANGLE_TITLE'] = '[Servo.s %1] contrôler l\'angle à %2 (°)';
Blockly.Msg['MBOT2_SERVOS_SET_ANGLE_TOOLTIP'] = 'Permet de contrôler l\'angle (en °) des servomoteurs S1, S2, S3 ou S4 de 0 à 360°. Ces servos se branchent directement sur le robot mBot2.';
Blockly.Msg['MBOT2_SERVOS_ADD_ANGLE_TITLE'] = '[Servo.s %1] augmenter l\'angle de %2 (°)';
Blockly.Msg['MBOT2_SERVOS_ADD_ANGLE_TOOLTIP'] = 'Permet d\'augmenter l\'angle (en °) du servomoteur S1, S2, S3 ou S4 de 0 à 360°. Ces servos se branchent directement sur le robot mBot2.';
Blockly.Msg['MBOT2_SERVOS_GET_ANGLE_TITLE'] = '[Servo.s %1] angle (°) du servomoteur';
Blockly.Msg['MBOT2_SERVOS_GET_ANGLE_TOOLTIP'] = 'Retourne l\'angle du servomoteur S1, S2, S3 ou S4. Ces servos se branchent directement sur le robot mBot2.';
Blockly.Msg['MBOT2_SERVOS_RESET_TITLE'] = '[Servo.s %1] arrêter le.s moteur.s';
Blockly.Msg['MBOT2_SERVOS_RESET_TOOLTIP'] = 'Permet d\'arrêter le servomoteur S1, S2, S3 ou S4. Ces servos se branchent directement sur le robot mBot2.';
// Robots - mBot2
Blockly.Msg['ROBOTS_MBOT2_MOTOR_LEFT'] = 'gauche (EM1)';
Blockly.Msg['ROBOTS_MBOT2_MOTOR_RIGHT'] = 'droit (EM2)';
Blockly.Msg['ROBOTS_MBOT2_MOTOR_SPEED'] = 'vitesse (tr/min)';
Blockly.Msg['ROBOTS_MBOT2_MOTOR_POWER'] = 'puissance (%)';
Blockly.Msg['ROBOTS_MBOT2_MOTOR_ANGLE'] = 'position angulaire (°)';
Blockly.Msg['ROBOTS_MBOT2_BOTH_MOTORS'] = 'droit (EM2) & gauche (EM1)';
Blockly.Msg['ROBOTS_MBOT2_MOVE_FORWARD'] = 'avancer';
Blockly.Msg['ROBOTS_MBOT2_MOVE_REVERSE'] = 'reculer';
Blockly.Msg['ROBOTS_MBOT2_MOVE_TITLE'] = '[mBot2] %1 vitesse %2 (tr/min)';
Blockly.Msg['ROBOTS_MBOT2_MOVE_DURATION'] = 'pendant';
Blockly.Msg['ROBOTS_MBOT2_MOVE_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Permet de contrôler la marche (AVANT/ARRIERE) ainsi que la vitesse (de 0 à 207 tr/min) du robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_MOVE_BY_TITLE'] = '[mBot2] %1 de %2 %3';
Blockly.Msg['ROBOTS_MBOT2_MOVE_BY_CM'] = 'cm';
Blockly.Msg['ROBOTS_MBOT2_MOVE_BY_INCHS'] = 'pouce.s';
Blockly.Msg['ROBOTS_MBOT2_MOVE_BY_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Permet d\'avancer ou de reculer d\'une certaine distance (en cm ou en pouce) avec le robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_TURN_TITLE'] = '[mBot2] pivoter vers la %1 de %2 °';
Blockly.Msg['ROBOTS_MBOT2_TURN_RIGHT'] = 'droite';
Blockly.Msg['ROBOTS_MBOT2_TURN_LEFT'] = 'gauche';
Blockly.Msg['ROBOTS_MBOT2_TURN_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Permet de pivoter à gauche ou à droite d\'un certain angle (en °) avec le robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_CONTROL_MOTOR_TITLE'] = '[mBot2] contrôler le.s moteur.s %1 direction %2 avec %3 de %4';
Blockly.Msg['ROBOTS_MBOT2_CONTROL_MOTOR_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Permet de contrôler chacun des moteurs encodeur EM1 ou EM2 avec la puissance (en %) ou la vitesse (en tr/min) du robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_TURN_MOTOR_TITLE'] = '[mBot2] pivoter le.s moteur.s %1 direction %2 angle %3 ° à la vitesse %4 (tr/min)';
Blockly.Msg['ROBOTS_MBOT2_TURN_MOTOR_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Permet de contrôler la rotation de chacun des moteurs encodeur EM1 ou EM2 d\'un certain angle (en °) avec la vitesse (en tr/min) du robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_STOP_MOTOR_TITLE'] = '[mBot2] arrêter le.s moteur.s %1';
Blockly.Msg['ROBOTS_MBOT2_STOP_MOTOR_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Permet d\'arrêter les moteurs encodeur EM1 ou EM2 du robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_GET_MOTOR_ENCODING_TITLE'] = '[mBot2] %1 du moteur encodeur %2';
Blockly.Msg['ROBOTS_MBOT2_GET_MOTOR_ENCODING_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Retourne la vitesse de rotation (en tr/min) ou la puissance (en %) ou la position angulaire (en °) du moteur encodeur EM1 ou EM2 du robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_RESET_MOTOR_ANGULAR_POSITION_TITLE'] = '[mBot2] réinitialiser l\'angle (°) du moteur %1';
Blockly.Msg['ROBOTS_MBOT2_RESET_MOTOR_ANGULAR_POSITION_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Permet de réinitialiser la position angulaire à 0° des moteurs encodeurs EM1 et/ou EM2 du robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_CONTROL_MOTOR_LOCKING_TITLE'] = '[mBot2] contrôler le verrouillage auto. du moteur %1 à %2';
Blockly.Msg['ROBOTS_MBOT2_CONTROL_MOTOR_LOCKING_TOOLTIP'] = IMG_ROBOT_MBOT2 + Blockly.Tooltip.SEP + 'Permet de contrôler le verrouillage automatique des moteurs encodeurs EM1 et/ou EM2 du robot mBot2.';
Blockly.Msg['ROBOTS_MBOT2_CONTROL_MOTOR_LOCKING_ENABLE'] = 'activer';
Blockly.Msg['ROBOTS_MBOT2_CONTROL_MOTOR_LOCKING_DISABLE'] = 'desactiver';
// Robots - Ultrasonic sensors
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_GET_DISTANCE_TITLE'] = '[Capteur à ultrasons %1] distance (cm)';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_GET_DISTANCE_TOOLTIP'] = IMG_MBUILD_ULTRASONIC_SENSOR + Blockly.Tooltip.SEP + 'Retourne la distance de 3 à 300 cm entre le robot et l\'obstacle mesurée avec le capteur à ultrasons du robot mBot2. Il est possible de brancher en parallèle jusqu\'à 8 capteurs à ultrasons. Utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_SET_BRIGHTNESS_TITLE'] = '[Capteur à ultrasons %1] régler la luminosité de la LED %2 à %3 (%)';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_SET_BRIGHTNESS_TOOLTIP'] = IMG_MBUILD_ULTRASONIC_SENSOR + Blockly.Tooltip.SEP + 'Permet de régler la luminosité (0-100) % de chacune des 8 LED bleues intégrées à un capteur à ultrasons.';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_GET_BRIGHTNESS_TITLE'] = '[Capteur à ultrasons %1] luminosité (%) de la LED %2';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_GET_BRIGHTNESS_TOOLTIP'] = IMG_MBUILD_ULTRASONIC_SENSOR + Blockly.Tooltip.SEP + 'Retourne la luminosité ambiante de la LED bleue sélectionnée avec l\'id (1-8) et intégrée au capteur à ultrasons.';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_STOP_LED_TITLE'] = '[Capteur à ultrasons %1] éteindre la LED %2';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_STOP_LED_TOOLTIP'] = IMG_MBUILD_ULTRASONIC_SENSOR + Blockly.Tooltip.SEP + 'Permet d\'éteindre la LED bleue sélectionnée avec l\'id (1-8) et intégrée au capteur à ultrasons.';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_PLAY_LED_TITLE'] = '[Capteur à ultrasons %1] afficher l\'émotion %2';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_PLAY_LED_TOOLTIP'] = IMG_MBUILD_ULTRASONIC_SENSOR + Blockly.Tooltip.SEP + 'Permet d\'afficher une émotion avec les LED bleues du capteur à ultrasons. Celle-ci dure environ 1 à 2 secondes.';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_EMOTION_SLEEPY'] = 'en veille';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_EMOTION_HAPPPY'] = 'heureux';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_EMOTION_DIZZY'] = 'étourdi';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_EMOTION_WINK'] = 'lever les sourcils';
Blockly.Msg['MBUILD_SENSORS_ULTRASONIC_EMOTION_THINKING'] = 'pensif';
// Robots - Quad RGB sensors
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_LINE'] = 'ligne';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_GROUND'] = 'arrière-plan';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_WHITE'] = 'blanc';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_RED'] = 'rouge';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_YELLOW'] = 'jaune';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_GREEN'] = 'vert';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_CYAN'] = 'cyan';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_BLUE'] = 'bleu';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_PURPLE'] = 'violet';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_BLACK'] = 'noir';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_MODE_CUSTOM'] = 'prédéfinie';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_L1_R1_DETECTION_IS_TITLE'] = '[Capteur RGB quad. %1] détection de %2 par L1 et R1 est %3';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_L1_R1_DETECTION_IS_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Retournes \'True\' si l\'état de détection des capteurs centraux L1 et R1 (sous le robot) en fonction du mode de détection est vérifié, retourne \'False\' sinon. \n\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_L1_R1_DETECTION_TITLE'] = '[Capteur RGB quad. %1] états de détection de %2 par L1 et R1';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_L1_R1_DETECTION_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Retournes l\'état des capteurs centraux L1 et R1 (sous le robot) de 0 à 3 en fonction du mode de détection choisit.\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DETECTION_IS_TITLE'] = '[Capteur RGB quad. %1] détection de %2 est %3';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DETECTION_IS_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Retournes \'True\' si l\'état de détection des 4 capteurs L1, L2 et R1, R2 (sous le robot) en fonction du mode de détection est vérifié, retourne \'False\' sinon.\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_DETECTION_TITLE'] = '[Capteur RGB quad. %1] états de détection de %2';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_DETECTION_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Retournes l\'état des 4 capteurs L1, L2 et R1, R2 (sous le robot) de 0 à 15 en fonction du mode de détection choisit.\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_IS_COLOR_DETECTED_TITLE'] = '[Capteur RGB quad. %1] la sonde %2 détecte %3';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_IS_COLOR_DETECTED_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Retournes \'True\' si la sonde choisie (L1, L2, R1, R2) détecte la ligne ou la couleur sélectionnée, sinon \'False\'.\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_PROBE_DATA_TITLE'] = '[Capteur RGB quad. %1] %2 mesuré.e avec la sonde %3';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_PROBE_DATA_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Retournes \'True\' si la sonde choisie (L1, L2, R1, R2) détecte la ligne ou la couleur sélectionnée, sinon \'False\'.\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DATA_R'] = 'niveau de rouge';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DATA_G'] = 'niveau de vert';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DATA_B'] = 'niveau de bleu';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DATA_GRAY_LEVEL'] = 'niveau de gris';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DATA_LIGHT'] = 'intensité luminseuse';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DATA_COLOR'] = 'couleur';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_OFFSET_TRACK_TITLE'] = '[Capteur RGB quad. %1] déviation avec la ligne';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_GET_OFFSET_TRACK_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Retourne la déviation du robot avec la ligne de -100 à 100 mm. Une valeur négative signifie une déviaion vers la gauche. A l\'inverse, une valeur positive signifie une déviation vers la droite. \n\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DEFINE_COLOR_TITLE'] = '[Capteur RGB quad. %1] définir la couleur à %2';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DEFINE_COLOR_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Permet de définir la couleur des lumières du capteur RGB quadruple en rouge, en vert ou en bleu. \n\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_LIST_TITLE'] = '[Capteur RGB quad. %1] contrôler les LED à %2';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_LIST_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Permet de définir la couleur des lumières du capteur RGB quadruple en choisissant une couleur dans la liste. \n\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_RGB_TITLE'] = '[Capteur RGB quad. %1] contrôler les LED à R %2 G %3 B %4';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_RGB_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Permet de définir la couleur des lumières du capteur RGB quadruple en paramétrant RGB de 0 à 255. \n\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_PALETTE_TITLE'] = '[Capteur RGB quad. %1] contrôler les LED à %2';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_PALETTE_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Permet de définir la couleur des lumières du capteur RGB quadruple en choisissant une couleur dans la palette. \n\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_SET_COLOR_TOLERANCE'] = 'tolérance';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_CLOSE_LED_TITLE'] = '[Capteur RGB quad. %1] éteindre les LED';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_CLOSE_LED_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Permet d\'éteindre les LED du capteur RGB quadruple. \n\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_CALIBRATE_TITLE'] = '[Capteur RGB quad. %1] calibrer';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_CALIBRATE_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Permet d\'effectuer une calibration des capteurs de ligne/couleur. \n\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_COLOR_MODE_TITLE'] = '[Capteur RGB quad.] définir le mode de détection à %1';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_COLOR_MODE_TOOLTIP'] = IMG_MBUILD_SENSORS_QUAD_RGB_SENSOR + Blockly.Tooltip.SEP + 'Permet de définir le mode de détection des couleurs. \n\nIl est possible de brancher en parallèle jusqu\'à 8 capteurs RGB quadruple. utiliser le paramètre (1-8) pour récupérer la valeur souhaitée.';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DETECTION_MODE_STANDARD'] = 'standard';
Blockly.Msg['MBUILD_SENSORS_QUAD_RGB_DETECTION_MODE_ENHANCE'] = 'amélioration des couleurs';
// Network - WiFi
Blockly.Msg['CYBERPI_WIFI_CONNECT_TITLE'] = '[WiFi] connecter la CyberPi au réseau: nom %1 mot de passe %2';
Blockly.Msg['CYBERPI_WIFI_CONNECT_TOOLTIP'] = 'Permet de connecter la carte CyberPi à un réseau WiFi.';
Blockly.Msg['CYBERPI_WIFI_IS_CONNECT_TITLE'] = '[WiFi] CyberPi est connectée ?';
Blockly.Msg['CYBERPI_WIFI_IS_CONNECT_TOOLTIP'] = 'Vérifie si la carte CyberPi est connectée à un réseau WiFi.';
Blockly.Msg['CYBERPI_WIFI_DISCONNECT_TITLE'] = '[WiFi] %1 la CyberPi';
Blockly.Msg['CYBERPI_WIFI_DISCONNECT_ACTION'] = "déconnecter";
Blockly.Msg['CYBERPI_WIFI_RECONNECT_ACTION'] = "reconnecter";
Blockly.Msg['CYBERPI_WIFI_DISCONNECT_TOOLTIP'] = 'Permet de déconnecter ou reconnecter la carte CyberPi au réseau WiFi.';
// Network - LAN
Blockly.Msg['CYBERPI_WIFI_BROADCAST_SET_TITLE'] = '[LAN] diffuser le message %1 valeur %2';
Blockly.Msg['CYBERPI_WIFI_BROADCAST_SET_TOOLTIP'] = 'Permet d\'envoyer un message contenant une valeur sur un réseau WiFi. Toutes les cartes CyberPi connectées à un réseau doivent utiliser le même canal de communication. Sans connexion au routeur, les cartes CyberPi utilisent le même canal par défaut et peuvent ainsi communiquer entre elles sur le LAN ; lorsque la carte CyberPi est connectée à un routeur, son canal dépend du réglage du routeur, qui peut être différent du canal par défaut, et il peut donc ne pas parvenir à communiquer avec une autre carte CyberPi qui n\'est pas connecté au routeur. Par conséquent, pour garantir une bonne communication, si vous utilisez un routeur, connectez toutes les cartes CyberPi sur le même réseau local.';
Blockly.Msg['CYBERPI_WIFI_BROADCAST_GET_TITLE'] = '[LAN] valeur du message diffusé %1';
Blockly.Msg['CYBERPI_WIFI_BROADCAST_GET_TOOLTIP'] = 'Permet de recevoir la valeur du message diffusé sur un réseau WiFi. Il n\'est pas obligatoire de se connecter à un réseau WiFi existant pour envoyer un message. Dans ce cas, la CyberPi créé un réseau local LAN.';
